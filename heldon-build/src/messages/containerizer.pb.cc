// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: containerizer.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "containerizer.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {
namespace slave {

namespace {

const ::google::protobuf::Descriptor* ContainerLimitation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerLimitation_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerState_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerRecoverInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerRecoverInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerConfig_Docker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerConfig_Docker_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerConfig_Appc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerConfig_Appc_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerLaunchInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerLaunchInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerTermination_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerTermination_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ContainerClass_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_containerizer_2eproto() {
  protobuf_AddDesc_containerizer_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "containerizer.proto");
  GOOGLE_CHECK(file != NULL);
  ContainerLimitation_descriptor_ = file->message_type(0);
  static const int ContainerLimitation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLimitation, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLimitation, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLimitation, reason_),
  };
  ContainerLimitation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerLimitation_descriptor_,
      ContainerLimitation::default_instance_,
      ContainerLimitation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLimitation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLimitation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerLimitation));
  ContainerState_descriptor_ = file->message_type(1);
  static const int ContainerState_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerState, executor_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerState, container_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerState, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerState, directory_),
  };
  ContainerState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerState_descriptor_,
      ContainerState::default_instance_,
      ContainerState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerState));
  ContainerRecoverInfo_descriptor_ = file->message_type(2);
  static const int ContainerRecoverInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerRecoverInfo, checkpointed_container_states_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerRecoverInfo, orphan_container_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerRecoverInfo, known_container_ids_),
  };
  ContainerRecoverInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerRecoverInfo_descriptor_,
      ContainerRecoverInfo::default_instance_,
      ContainerRecoverInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerRecoverInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerRecoverInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerRecoverInfo));
  ContainerConfig_descriptor_ = file->message_type(3);
  static const int ContainerConfig_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, executor_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, task_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, command_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, container_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, container_class_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, directory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, rootfs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, docker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, appc_),
  };
  ContainerConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerConfig_descriptor_,
      ContainerConfig::default_instance_,
      ContainerConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerConfig));
  ContainerConfig_Docker_descriptor_ = ContainerConfig_descriptor_->nested_type(0);
  static const int ContainerConfig_Docker_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig_Docker, manifest_),
  };
  ContainerConfig_Docker_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerConfig_Docker_descriptor_,
      ContainerConfig_Docker::default_instance_,
      ContainerConfig_Docker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig_Docker, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig_Docker, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerConfig_Docker));
  ContainerConfig_Appc_descriptor_ = ContainerConfig_descriptor_->nested_type(1);
  static const int ContainerConfig_Appc_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig_Appc, manifest_),
  };
  ContainerConfig_Appc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerConfig_Appc_descriptor_,
      ContainerConfig_Appc::default_instance_,
      ContainerConfig_Appc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig_Appc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerConfig_Appc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerConfig_Appc));
  ContainerLaunchInfo_descriptor_ = file->message_type(4);
  static const int ContainerLaunchInfo_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, pre_exec_commands_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, environment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, rootfs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, enter_namespaces_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, clone_namespaces_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, working_directory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, capabilities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, rlimits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, tty_slave_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, task_environment_),
  };
  ContainerLaunchInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerLaunchInfo_descriptor_,
      ContainerLaunchInfo::default_instance_,
      ContainerLaunchInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerLaunchInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerLaunchInfo));
  ContainerTermination_descriptor_ = file->message_type(5);
  static const int ContainerTermination_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerTermination, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerTermination, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerTermination, reasons_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerTermination, message_),
  };
  ContainerTermination_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerTermination_descriptor_,
      ContainerTermination::default_instance_,
      ContainerTermination_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerTermination, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerTermination, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerTermination));
  ContainerClass_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_containerizer_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerLimitation_descriptor_, &ContainerLimitation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerState_descriptor_, &ContainerState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerRecoverInfo_descriptor_, &ContainerRecoverInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerConfig_descriptor_, &ContainerConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerConfig_Docker_descriptor_, &ContainerConfig_Docker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerConfig_Appc_descriptor_, &ContainerConfig_Appc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerLaunchInfo_descriptor_, &ContainerLaunchInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerTermination_descriptor_, &ContainerTermination::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_containerizer_2eproto() {
  delete ContainerLimitation::default_instance_;
  delete ContainerLimitation_reflection_;
  delete ContainerState::default_instance_;
  delete ContainerState_reflection_;
  delete ContainerRecoverInfo::default_instance_;
  delete ContainerRecoverInfo_reflection_;
  delete ContainerConfig::default_instance_;
  delete ContainerConfig_reflection_;
  delete ContainerConfig_Docker::default_instance_;
  delete ContainerConfig_Docker_reflection_;
  delete ContainerConfig_Appc::default_instance_;
  delete ContainerConfig_Appc_reflection_;
  delete ContainerLaunchInfo::default_instance_;
  delete ContainerLaunchInfo_reflection_;
  delete ContainerTermination::default_instance_;
  delete ContainerTermination_reflection_;
}

void protobuf_AddDesc_containerizer_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2eproto();
  ::appc::spec::protobuf_AddDesc_spec_2eproto();
  ::docker::spec::v1::protobuf_AddDesc_v1_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023containerizer.proto\022\013mesos.slave\032\013meso"
    "s.proto\032\nspec.proto\032\010v1.proto\"t\n\023Contain"
    "erLimitation\022\"\n\tresources\030\001 \003(\0132\017.mesos."
    "Resource\022\017\n\007message\030\002 \001(\t\022(\n\006reason\030\003 \001("
    "\0162\030.mesos.TaskStatus.Reason\"\206\001\n\016Containe"
    "rState\022*\n\rexecutor_info\030\001 \001(\0132\023.mesos.Ex"
    "ecutorInfo\022(\n\014container_id\030\002 \002(\0132\022.mesos"
    ".ContainerID\022\013\n\003pid\030\003 \002(\004\022\021\n\tdirectory\030\004"
    " \002(\t\"\275\001\n\024ContainerRecoverInfo\022B\n\035checkpo"
    "inted_container_states\030\001 \003(\0132\033.mesos.sla"
    "ve.ContainerState\0220\n\024orphan_container_id"
    "s\030\002 \003(\0132\022.mesos.ContainerID\022/\n\023known_con"
    "tainer_ids\030\003 \003(\0132\022.mesos.ContainerID\"\231\004\n"
    "\017ContainerConfig\022*\n\rexecutor_info\030\010 \001(\0132"
    "\023.mesos.ExecutorInfo\022\"\n\ttask_info\030\t \001(\0132"
    "\017.mesos.TaskInfo\022(\n\014command_info\030\013 \002(\0132\022"
    ".mesos.CommandInfo\022,\n\016container_info\030\014 \001"
    "(\0132\024.mesos.ContainerInfo\022\"\n\tresources\030\r "
    "\003(\0132\017.mesos.Resource\0224\n\017container_class\030"
    "\016 \001(\0162\033.mesos.slave.ContainerClass\022\021\n\tdi"
    "rectory\030\003 \002(\t\022\014\n\004user\030\004 \001(\t\022\016\n\006rootfs\030\005 "
    "\001(\t\0223\n\006docker\030\007 \001(\0132#.mesos.slave.Contai"
    "nerConfig.Docker\022/\n\004appc\030\n \001(\0132!.mesos.s"
    "lave.ContainerConfig.Appc\0329\n\006Docker\022/\n\010m"
    "anifest\030\001 \001(\0132\035.docker.spec.v1.ImageMani"
    "fest\0322\n\004Appc\022*\n\010manifest\030\001 \001(\0132\030.appc.sp"
    "ec.ImageManifest\"\226\003\n\023ContainerLaunchInfo"
    "\022-\n\021pre_exec_commands\030\001 \003(\0132\022.mesos.Comm"
    "andInfo\022\'\n\013environment\030\002 \001(\0132\022.mesos.Env"
    "ironment\022\016\n\006rootfs\030\003 \001(\t\022\030\n\020enter_namesp"
    "aces\030\t \003(\005\022\030\n\020clone_namespaces\030\004 \003(\005\022\014\n\004"
    "user\030\n \001(\t\022#\n\007command\030\005 \001(\0132\022.mesos.Comm"
    "andInfo\022\031\n\021working_directory\030\006 \001(\t\022+\n\014ca"
    "pabilities\030\007 \001(\0132\025.mesos.CapabilityInfo\022"
    "\"\n\007rlimits\030\010 \001(\0132\021.mesos.RLimitInfo\022\026\n\016t"
    "ty_slave_path\030\016 \001(\t\022,\n\020task_environment\030"
    "\017 \001(\0132\022.mesos.Environment\"\203\001\n\024ContainerT"
    "ermination\022\016\n\006status\030\003 \001(\005\022\037\n\005state\030\004 \001("
    "\0162\020.mesos.TaskState\022)\n\007reasons\030\005 \003(\0162\030.m"
    "esos.TaskStatus.Reason\022\017\n\007message\030\002 \001(\t*"
    "(\n\016ContainerClass\022\013\n\007DEFAULT\020\001\022\t\n\005DEBUG\020"
    "\002", 1641);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "containerizer.proto", &protobuf_RegisterTypes);
  ContainerLimitation::default_instance_ = new ContainerLimitation();
  ContainerState::default_instance_ = new ContainerState();
  ContainerRecoverInfo::default_instance_ = new ContainerRecoverInfo();
  ContainerConfig::default_instance_ = new ContainerConfig();
  ContainerConfig_Docker::default_instance_ = new ContainerConfig_Docker();
  ContainerConfig_Appc::default_instance_ = new ContainerConfig_Appc();
  ContainerLaunchInfo::default_instance_ = new ContainerLaunchInfo();
  ContainerTermination::default_instance_ = new ContainerTermination();
  ContainerLimitation::default_instance_->InitAsDefaultInstance();
  ContainerState::default_instance_->InitAsDefaultInstance();
  ContainerRecoverInfo::default_instance_->InitAsDefaultInstance();
  ContainerConfig::default_instance_->InitAsDefaultInstance();
  ContainerConfig_Docker::default_instance_->InitAsDefaultInstance();
  ContainerConfig_Appc::default_instance_->InitAsDefaultInstance();
  ContainerLaunchInfo::default_instance_->InitAsDefaultInstance();
  ContainerTermination::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_containerizer_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_containerizer_2eproto {
  StaticDescriptorInitializer_containerizer_2eproto() {
    protobuf_AddDesc_containerizer_2eproto();
  }
} static_descriptor_initializer_containerizer_2eproto_;
const ::google::protobuf::EnumDescriptor* ContainerClass_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerClass_descriptor_;
}
bool ContainerClass_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerLimitation::kResourcesFieldNumber;
const int ContainerLimitation::kMessageFieldNumber;
const int ContainerLimitation::kReasonFieldNumber;
#endif  // !_MSC_VER

ContainerLimitation::ContainerLimitation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerLimitation)
}

void ContainerLimitation::InitAsDefaultInstance() {
}

ContainerLimitation::ContainerLimitation(const ContainerLimitation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerLimitation)
}

void ContainerLimitation::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reason_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerLimitation::~ContainerLimitation() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerLimitation)
  SharedDtor();
}

void ContainerLimitation::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void ContainerLimitation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerLimitation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerLimitation_descriptor_;
}

const ContainerLimitation& ContainerLimitation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerLimitation* ContainerLimitation::default_instance_ = NULL;

ContainerLimitation* ContainerLimitation::New() const {
  return new ContainerLimitation;
}

void ContainerLimitation::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    reason_ = 0;
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerLimitation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerLimitation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (tag == 10) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_resources;
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // optional string message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_reason;
        break;
      }

      // optional .mesos.TaskStatus.Reason reason = 3;
      case 3: {
        if (tag == 24) {
         parse_reason:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskStatus_Reason_IsValid(value)) {
            set_reason(static_cast< ::mesos::TaskStatus_Reason >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerLimitation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerLimitation)
  return false;
#undef DO_
}

void ContainerLimitation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerLimitation)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  // optional string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message(), output);
  }

  // optional .mesos.TaskStatus.Reason reason = 3;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->reason(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerLimitation)
}

::google::protobuf::uint8* ContainerLimitation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerLimitation)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->resources(i), target);
  }

  // optional string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  // optional .mesos.TaskStatus.Reason reason = 3;
  if (has_reason()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->reason(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerLimitation)
  return target;
}

int ContainerLimitation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .mesos.TaskStatus.Reason reason = 3;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reason());
    }

  }
  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerLimitation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerLimitation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerLimitation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerLimitation::MergeFrom(const ContainerLimitation& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerLimitation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerLimitation::CopyFrom(const ContainerLimitation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerLimitation::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void ContainerLimitation::Swap(ContainerLimitation* other) {
  if (other != this) {
    resources_.Swap(&other->resources_);
    std::swap(message_, other->message_);
    std::swap(reason_, other->reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerLimitation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerLimitation_descriptor_;
  metadata.reflection = ContainerLimitation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerState::kExecutorInfoFieldNumber;
const int ContainerState::kContainerIdFieldNumber;
const int ContainerState::kPidFieldNumber;
const int ContainerState::kDirectoryFieldNumber;
#endif  // !_MSC_VER

ContainerState::ContainerState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerState)
}

void ContainerState::InitAsDefaultInstance() {
  executor_info_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  container_id_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
}

ContainerState::ContainerState(const ContainerState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerState)
}

void ContainerState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  executor_info_ = NULL;
  container_id_ = NULL;
  pid_ = GOOGLE_ULONGLONG(0);
  directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerState::~ContainerState() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerState)
  SharedDtor();
}

void ContainerState::SharedDtor() {
  if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete directory_;
  }
  if (this != default_instance_) {
    delete executor_info_;
    delete container_id_;
  }
}

void ContainerState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerState_descriptor_;
}

const ContainerState& ContainerState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerState* ContainerState::default_instance_ = NULL;

ContainerState* ContainerState::New() const {
  return new ContainerState;
}

void ContainerState::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_executor_info()) {
      if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
    }
    if (has_container_id()) {
      if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
    }
    pid_ = GOOGLE_ULONGLONG(0);
    if (has_directory()) {
      if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        directory_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.ExecutorInfo executor_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_container_id;
        break;
      }

      // required .mesos.ContainerID container_id = 2;
      case 2: {
        if (tag == 18) {
         parse_container_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_pid;
        break;
      }

      // required uint64 pid = 3;
      case 3: {
        if (tag == 24) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_directory;
        break;
      }

      // required string directory = 4;
      case 4: {
        if (tag == 34) {
         parse_directory:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_directory()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->directory().data(), this->directory().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "directory");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerState)
  return false;
#undef DO_
}

void ContainerState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerState)
  // optional .mesos.ExecutorInfo executor_info = 1;
  if (has_executor_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_info(), output);
  }

  // required .mesos.ContainerID container_id = 2;
  if (has_container_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->container_id(), output);
  }

  // required uint64 pid = 3;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->pid(), output);
  }

  // required string directory = 4;
  if (has_directory()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->directory().data(), this->directory().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "directory");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->directory(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerState)
}

::google::protobuf::uint8* ContainerState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerState)
  // optional .mesos.ExecutorInfo executor_info = 1;
  if (has_executor_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_info(), target);
  }

  // required .mesos.ContainerID container_id = 2;
  if (has_container_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->container_id(), target);
  }

  // required uint64 pid = 3;
  if (has_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->pid(), target);
  }

  // required string directory = 4;
  if (has_directory()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->directory().data(), this->directory().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "directory");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->directory(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerState)
  return target;
}

int ContainerState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ExecutorInfo executor_info = 1;
    if (has_executor_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_info());
    }

    // required .mesos.ContainerID container_id = 2;
    if (has_container_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container_id());
    }

    // required uint64 pid = 3;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pid());
    }

    // required string directory = 4;
    if (has_directory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->directory());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerState::MergeFrom(const ContainerState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_info()) {
      mutable_executor_info()->::mesos::ExecutorInfo::MergeFrom(from.executor_info());
    }
    if (from.has_container_id()) {
      mutable_container_id()->::mesos::ContainerID::MergeFrom(from.container_id());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_directory()) {
      set_directory(from.directory());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerState::CopyFrom(const ContainerState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerState::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_executor_info()) {
    if (!this->executor_info().IsInitialized()) return false;
  }
  if (has_container_id()) {
    if (!this->container_id().IsInitialized()) return false;
  }
  return true;
}

void ContainerState::Swap(ContainerState* other) {
  if (other != this) {
    std::swap(executor_info_, other->executor_info_);
    std::swap(container_id_, other->container_id_);
    std::swap(pid_, other->pid_);
    std::swap(directory_, other->directory_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerState_descriptor_;
  metadata.reflection = ContainerState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerRecoverInfo::kCheckpointedContainerStatesFieldNumber;
const int ContainerRecoverInfo::kOrphanContainerIdsFieldNumber;
const int ContainerRecoverInfo::kKnownContainerIdsFieldNumber;
#endif  // !_MSC_VER

ContainerRecoverInfo::ContainerRecoverInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerRecoverInfo)
}

void ContainerRecoverInfo::InitAsDefaultInstance() {
}

ContainerRecoverInfo::ContainerRecoverInfo(const ContainerRecoverInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerRecoverInfo)
}

void ContainerRecoverInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerRecoverInfo::~ContainerRecoverInfo() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerRecoverInfo)
  SharedDtor();
}

void ContainerRecoverInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ContainerRecoverInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerRecoverInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerRecoverInfo_descriptor_;
}

const ContainerRecoverInfo& ContainerRecoverInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerRecoverInfo* ContainerRecoverInfo::default_instance_ = NULL;

ContainerRecoverInfo* ContainerRecoverInfo::New() const {
  return new ContainerRecoverInfo;
}

void ContainerRecoverInfo::Clear() {
  checkpointed_container_states_.Clear();
  orphan_container_ids_.Clear();
  known_container_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerRecoverInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerRecoverInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
      case 1: {
        if (tag == 10) {
         parse_checkpointed_container_states:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_checkpointed_container_states()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_checkpointed_container_states;
        if (input->ExpectTag(18)) goto parse_orphan_container_ids;
        break;
      }

      // repeated .mesos.ContainerID orphan_container_ids = 2;
      case 2: {
        if (tag == 18) {
         parse_orphan_container_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_orphan_container_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orphan_container_ids;
        if (input->ExpectTag(26)) goto parse_known_container_ids;
        break;
      }

      // repeated .mesos.ContainerID known_container_ids = 3;
      case 3: {
        if (tag == 26) {
         parse_known_container_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_known_container_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_known_container_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerRecoverInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerRecoverInfo)
  return false;
#undef DO_
}

void ContainerRecoverInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerRecoverInfo)
  // repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
  for (int i = 0; i < this->checkpointed_container_states_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->checkpointed_container_states(i), output);
  }

  // repeated .mesos.ContainerID orphan_container_ids = 2;
  for (int i = 0; i < this->orphan_container_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->orphan_container_ids(i), output);
  }

  // repeated .mesos.ContainerID known_container_ids = 3;
  for (int i = 0; i < this->known_container_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->known_container_ids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerRecoverInfo)
}

::google::protobuf::uint8* ContainerRecoverInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerRecoverInfo)
  // repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
  for (int i = 0; i < this->checkpointed_container_states_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->checkpointed_container_states(i), target);
  }

  // repeated .mesos.ContainerID orphan_container_ids = 2;
  for (int i = 0; i < this->orphan_container_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->orphan_container_ids(i), target);
  }

  // repeated .mesos.ContainerID known_container_ids = 3;
  for (int i = 0; i < this->known_container_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->known_container_ids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerRecoverInfo)
  return target;
}

int ContainerRecoverInfo::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
  total_size += 1 * this->checkpointed_container_states_size();
  for (int i = 0; i < this->checkpointed_container_states_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->checkpointed_container_states(i));
  }

  // repeated .mesos.ContainerID orphan_container_ids = 2;
  total_size += 1 * this->orphan_container_ids_size();
  for (int i = 0; i < this->orphan_container_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->orphan_container_ids(i));
  }

  // repeated .mesos.ContainerID known_container_ids = 3;
  total_size += 1 * this->known_container_ids_size();
  for (int i = 0; i < this->known_container_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->known_container_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerRecoverInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerRecoverInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerRecoverInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerRecoverInfo::MergeFrom(const ContainerRecoverInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  checkpointed_container_states_.MergeFrom(from.checkpointed_container_states_);
  orphan_container_ids_.MergeFrom(from.orphan_container_ids_);
  known_container_ids_.MergeFrom(from.known_container_ids_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerRecoverInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerRecoverInfo::CopyFrom(const ContainerRecoverInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerRecoverInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->checkpointed_container_states())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->orphan_container_ids())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->known_container_ids())) return false;
  return true;
}

void ContainerRecoverInfo::Swap(ContainerRecoverInfo* other) {
  if (other != this) {
    checkpointed_container_states_.Swap(&other->checkpointed_container_states_);
    orphan_container_ids_.Swap(&other->orphan_container_ids_);
    known_container_ids_.Swap(&other->known_container_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerRecoverInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerRecoverInfo_descriptor_;
  metadata.reflection = ContainerRecoverInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerConfig_Docker::kManifestFieldNumber;
#endif  // !_MSC_VER

ContainerConfig_Docker::ContainerConfig_Docker()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerConfig.Docker)
}

void ContainerConfig_Docker::InitAsDefaultInstance() {
  manifest_ = const_cast< ::docker::spec::v1::ImageManifest*>(&::docker::spec::v1::ImageManifest::default_instance());
}

ContainerConfig_Docker::ContainerConfig_Docker(const ContainerConfig_Docker& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerConfig.Docker)
}

void ContainerConfig_Docker::SharedCtor() {
  _cached_size_ = 0;
  manifest_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerConfig_Docker::~ContainerConfig_Docker() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerConfig.Docker)
  SharedDtor();
}

void ContainerConfig_Docker::SharedDtor() {
  if (this != default_instance_) {
    delete manifest_;
  }
}

void ContainerConfig_Docker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerConfig_Docker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerConfig_Docker_descriptor_;
}

const ContainerConfig_Docker& ContainerConfig_Docker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerConfig_Docker* ContainerConfig_Docker::default_instance_ = NULL;

ContainerConfig_Docker* ContainerConfig_Docker::New() const {
  return new ContainerConfig_Docker;
}

void ContainerConfig_Docker::Clear() {
  if (has_manifest()) {
    if (manifest_ != NULL) manifest_->::docker::spec::v1::ImageManifest::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerConfig_Docker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerConfig.Docker)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .docker.spec.v1.ImageManifest manifest = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_manifest()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerConfig.Docker)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerConfig.Docker)
  return false;
#undef DO_
}

void ContainerConfig_Docker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerConfig.Docker)
  // optional .docker.spec.v1.ImageManifest manifest = 1;
  if (has_manifest()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->manifest(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerConfig.Docker)
}

::google::protobuf::uint8* ContainerConfig_Docker::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerConfig.Docker)
  // optional .docker.spec.v1.ImageManifest manifest = 1;
  if (has_manifest()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->manifest(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerConfig.Docker)
  return target;
}

int ContainerConfig_Docker::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .docker.spec.v1.ImageManifest manifest = 1;
    if (has_manifest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->manifest());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerConfig_Docker::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerConfig_Docker* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerConfig_Docker*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerConfig_Docker::MergeFrom(const ContainerConfig_Docker& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_manifest()) {
      mutable_manifest()->::docker::spec::v1::ImageManifest::MergeFrom(from.manifest());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerConfig_Docker::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerConfig_Docker::CopyFrom(const ContainerConfig_Docker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerConfig_Docker::IsInitialized() const {

  return true;
}

void ContainerConfig_Docker::Swap(ContainerConfig_Docker* other) {
  if (other != this) {
    std::swap(manifest_, other->manifest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerConfig_Docker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerConfig_Docker_descriptor_;
  metadata.reflection = ContainerConfig_Docker_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ContainerConfig_Appc::kManifestFieldNumber;
#endif  // !_MSC_VER

ContainerConfig_Appc::ContainerConfig_Appc()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerConfig.Appc)
}

void ContainerConfig_Appc::InitAsDefaultInstance() {
  manifest_ = const_cast< ::appc::spec::ImageManifest*>(&::appc::spec::ImageManifest::default_instance());
}

ContainerConfig_Appc::ContainerConfig_Appc(const ContainerConfig_Appc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerConfig.Appc)
}

void ContainerConfig_Appc::SharedCtor() {
  _cached_size_ = 0;
  manifest_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerConfig_Appc::~ContainerConfig_Appc() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerConfig.Appc)
  SharedDtor();
}

void ContainerConfig_Appc::SharedDtor() {
  if (this != default_instance_) {
    delete manifest_;
  }
}

void ContainerConfig_Appc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerConfig_Appc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerConfig_Appc_descriptor_;
}

const ContainerConfig_Appc& ContainerConfig_Appc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerConfig_Appc* ContainerConfig_Appc::default_instance_ = NULL;

ContainerConfig_Appc* ContainerConfig_Appc::New() const {
  return new ContainerConfig_Appc;
}

void ContainerConfig_Appc::Clear() {
  if (has_manifest()) {
    if (manifest_ != NULL) manifest_->::appc::spec::ImageManifest::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerConfig_Appc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerConfig.Appc)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .appc.spec.ImageManifest manifest = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_manifest()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerConfig.Appc)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerConfig.Appc)
  return false;
#undef DO_
}

void ContainerConfig_Appc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerConfig.Appc)
  // optional .appc.spec.ImageManifest manifest = 1;
  if (has_manifest()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->manifest(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerConfig.Appc)
}

::google::protobuf::uint8* ContainerConfig_Appc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerConfig.Appc)
  // optional .appc.spec.ImageManifest manifest = 1;
  if (has_manifest()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->manifest(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerConfig.Appc)
  return target;
}

int ContainerConfig_Appc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .appc.spec.ImageManifest manifest = 1;
    if (has_manifest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->manifest());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerConfig_Appc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerConfig_Appc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerConfig_Appc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerConfig_Appc::MergeFrom(const ContainerConfig_Appc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_manifest()) {
      mutable_manifest()->::appc::spec::ImageManifest::MergeFrom(from.manifest());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerConfig_Appc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerConfig_Appc::CopyFrom(const ContainerConfig_Appc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerConfig_Appc::IsInitialized() const {

  if (has_manifest()) {
    if (!this->manifest().IsInitialized()) return false;
  }
  return true;
}

void ContainerConfig_Appc::Swap(ContainerConfig_Appc* other) {
  if (other != this) {
    std::swap(manifest_, other->manifest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerConfig_Appc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerConfig_Appc_descriptor_;
  metadata.reflection = ContainerConfig_Appc_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ContainerConfig::kExecutorInfoFieldNumber;
const int ContainerConfig::kTaskInfoFieldNumber;
const int ContainerConfig::kCommandInfoFieldNumber;
const int ContainerConfig::kContainerInfoFieldNumber;
const int ContainerConfig::kResourcesFieldNumber;
const int ContainerConfig::kContainerClassFieldNumber;
const int ContainerConfig::kDirectoryFieldNumber;
const int ContainerConfig::kUserFieldNumber;
const int ContainerConfig::kRootfsFieldNumber;
const int ContainerConfig::kDockerFieldNumber;
const int ContainerConfig::kAppcFieldNumber;
#endif  // !_MSC_VER

ContainerConfig::ContainerConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerConfig)
}

void ContainerConfig::InitAsDefaultInstance() {
  executor_info_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  task_info_ = const_cast< ::mesos::TaskInfo*>(&::mesos::TaskInfo::default_instance());
  command_info_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  container_info_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
  docker_ = const_cast< ::mesos::slave::ContainerConfig_Docker*>(&::mesos::slave::ContainerConfig_Docker::default_instance());
  appc_ = const_cast< ::mesos::slave::ContainerConfig_Appc*>(&::mesos::slave::ContainerConfig_Appc::default_instance());
}

ContainerConfig::ContainerConfig(const ContainerConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerConfig)
}

void ContainerConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  executor_info_ = NULL;
  task_info_ = NULL;
  command_info_ = NULL;
  container_info_ = NULL;
  container_class_ = 1;
  directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rootfs_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  docker_ = NULL;
  appc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerConfig::~ContainerConfig() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerConfig)
  SharedDtor();
}

void ContainerConfig::SharedDtor() {
  if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete directory_;
  }
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rootfs_;
  }
  if (this != default_instance_) {
    delete executor_info_;
    delete task_info_;
    delete command_info_;
    delete container_info_;
    delete docker_;
    delete appc_;
  }
}

void ContainerConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerConfig_descriptor_;
}

const ContainerConfig& ContainerConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerConfig* ContainerConfig::default_instance_ = NULL;

ContainerConfig* ContainerConfig::New() const {
  return new ContainerConfig;
}

void ContainerConfig::Clear() {
  if (_has_bits_[0 / 32] & 239) {
    if (has_executor_info()) {
      if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
    }
    if (has_task_info()) {
      if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
    }
    if (has_command_info()) {
      if (command_info_ != NULL) command_info_->::mesos::CommandInfo::Clear();
    }
    if (has_container_info()) {
      if (container_info_ != NULL) container_info_->::mesos::ContainerInfo::Clear();
    }
    container_class_ = 1;
    if (has_directory()) {
      if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        directory_->clear();
      }
    }
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 1792) {
    if (has_rootfs()) {
      if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        rootfs_->clear();
      }
    }
    if (has_docker()) {
      if (docker_ != NULL) docker_->::mesos::slave::ContainerConfig_Docker::Clear();
    }
    if (has_appc()) {
      if (appc_ != NULL) appc_->::mesos::slave::ContainerConfig_Appc::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string directory = 3;
      case 3: {
        if (tag == 26) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_directory()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->directory().data(), this->directory().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "directory");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user;
        break;
      }

      // optional string user = 4;
      case 4: {
        if (tag == 34) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_rootfs;
        break;
      }

      // optional string rootfs = 5;
      case 5: {
        if (tag == 42) {
         parse_rootfs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rootfs()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->rootfs().data(), this->rootfs().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "rootfs");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_docker;
        break;
      }

      // optional .mesos.slave.ContainerConfig.Docker docker = 7;
      case 7: {
        if (tag == 58) {
         parse_docker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_executor_info;
        break;
      }

      // optional .mesos.ExecutorInfo executor_info = 8;
      case 8: {
        if (tag == 66) {
         parse_executor_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_task_info;
        break;
      }

      // optional .mesos.TaskInfo task_info = 9;
      case 9: {
        if (tag == 74) {
         parse_task_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_appc;
        break;
      }

      // optional .mesos.slave.ContainerConfig.Appc appc = 10;
      case 10: {
        if (tag == 82) {
         parse_appc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_appc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_command_info;
        break;
      }

      // required .mesos.CommandInfo command_info = 11;
      case 11: {
        if (tag == 90) {
         parse_command_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_container_info;
        break;
      }

      // optional .mesos.ContainerInfo container_info = 12;
      case 12: {
        if (tag == 98) {
         parse_container_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 13;
      case 13: {
        if (tag == 106) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_resources;
        if (input->ExpectTag(112)) goto parse_container_class;
        break;
      }

      // optional .mesos.slave.ContainerClass container_class = 14;
      case 14: {
        if (tag == 112) {
         parse_container_class:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::slave::ContainerClass_IsValid(value)) {
            set_container_class(static_cast< ::mesos::slave::ContainerClass >(value));
          } else {
            mutable_unknown_fields()->AddVarint(14, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerConfig)
  return false;
#undef DO_
}

void ContainerConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerConfig)
  // required string directory = 3;
  if (has_directory()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->directory().data(), this->directory().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "directory");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->directory(), output);
  }

  // optional string user = 4;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->user(), output);
  }

  // optional string rootfs = 5;
  if (has_rootfs()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rootfs().data(), this->rootfs().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rootfs");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->rootfs(), output);
  }

  // optional .mesos.slave.ContainerConfig.Docker docker = 7;
  if (has_docker()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->docker(), output);
  }

  // optional .mesos.ExecutorInfo executor_info = 8;
  if (has_executor_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->executor_info(), output);
  }

  // optional .mesos.TaskInfo task_info = 9;
  if (has_task_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->task_info(), output);
  }

  // optional .mesos.slave.ContainerConfig.Appc appc = 10;
  if (has_appc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->appc(), output);
  }

  // required .mesos.CommandInfo command_info = 11;
  if (has_command_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->command_info(), output);
  }

  // optional .mesos.ContainerInfo container_info = 12;
  if (has_container_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->container_info(), output);
  }

  // repeated .mesos.Resource resources = 13;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->resources(i), output);
  }

  // optional .mesos.slave.ContainerClass container_class = 14;
  if (has_container_class()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      14, this->container_class(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerConfig)
}

::google::protobuf::uint8* ContainerConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerConfig)
  // required string directory = 3;
  if (has_directory()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->directory().data(), this->directory().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "directory");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->directory(), target);
  }

  // optional string user = 4;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->user(), target);
  }

  // optional string rootfs = 5;
  if (has_rootfs()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rootfs().data(), this->rootfs().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rootfs");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->rootfs(), target);
  }

  // optional .mesos.slave.ContainerConfig.Docker docker = 7;
  if (has_docker()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->docker(), target);
  }

  // optional .mesos.ExecutorInfo executor_info = 8;
  if (has_executor_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->executor_info(), target);
  }

  // optional .mesos.TaskInfo task_info = 9;
  if (has_task_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->task_info(), target);
  }

  // optional .mesos.slave.ContainerConfig.Appc appc = 10;
  if (has_appc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->appc(), target);
  }

  // required .mesos.CommandInfo command_info = 11;
  if (has_command_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->command_info(), target);
  }

  // optional .mesos.ContainerInfo container_info = 12;
  if (has_container_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->container_info(), target);
  }

  // repeated .mesos.Resource resources = 13;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->resources(i), target);
  }

  // optional .mesos.slave.ContainerClass container_class = 14;
  if (has_container_class()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      14, this->container_class(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerConfig)
  return target;
}

int ContainerConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ExecutorInfo executor_info = 8;
    if (has_executor_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_info());
    }

    // optional .mesos.TaskInfo task_info = 9;
    if (has_task_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_info());
    }

    // required .mesos.CommandInfo command_info = 11;
    if (has_command_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command_info());
    }

    // optional .mesos.ContainerInfo container_info = 12;
    if (has_container_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container_info());
    }

    // optional .mesos.slave.ContainerClass container_class = 14;
    if (has_container_class()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->container_class());
    }

    // required string directory = 3;
    if (has_directory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->directory());
    }

    // optional string user = 4;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string rootfs = 5;
    if (has_rootfs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rootfs());
    }

    // optional .mesos.slave.ContainerConfig.Docker docker = 7;
    if (has_docker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->docker());
    }

    // optional .mesos.slave.ContainerConfig.Appc appc = 10;
    if (has_appc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->appc());
    }

  }
  // repeated .mesos.Resource resources = 13;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerConfig::MergeFrom(const ContainerConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_info()) {
      mutable_executor_info()->::mesos::ExecutorInfo::MergeFrom(from.executor_info());
    }
    if (from.has_task_info()) {
      mutable_task_info()->::mesos::TaskInfo::MergeFrom(from.task_info());
    }
    if (from.has_command_info()) {
      mutable_command_info()->::mesos::CommandInfo::MergeFrom(from.command_info());
    }
    if (from.has_container_info()) {
      mutable_container_info()->::mesos::ContainerInfo::MergeFrom(from.container_info());
    }
    if (from.has_container_class()) {
      set_container_class(from.container_class());
    }
    if (from.has_directory()) {
      set_directory(from.directory());
    }
    if (from.has_user()) {
      set_user(from.user());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_rootfs()) {
      set_rootfs(from.rootfs());
    }
    if (from.has_docker()) {
      mutable_docker()->::mesos::slave::ContainerConfig_Docker::MergeFrom(from.docker());
    }
    if (from.has_appc()) {
      mutable_appc()->::mesos::slave::ContainerConfig_Appc::MergeFrom(from.appc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerConfig::CopyFrom(const ContainerConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerConfig::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000044) != 0x00000044) return false;

  if (has_executor_info()) {
    if (!this->executor_info().IsInitialized()) return false;
  }
  if (has_task_info()) {
    if (!this->task_info().IsInitialized()) return false;
  }
  if (has_command_info()) {
    if (!this->command_info().IsInitialized()) return false;
  }
  if (has_container_info()) {
    if (!this->container_info().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_appc()) {
    if (!this->appc().IsInitialized()) return false;
  }
  return true;
}

void ContainerConfig::Swap(ContainerConfig* other) {
  if (other != this) {
    std::swap(executor_info_, other->executor_info_);
    std::swap(task_info_, other->task_info_);
    std::swap(command_info_, other->command_info_);
    std::swap(container_info_, other->container_info_);
    resources_.Swap(&other->resources_);
    std::swap(container_class_, other->container_class_);
    std::swap(directory_, other->directory_);
    std::swap(user_, other->user_);
    std::swap(rootfs_, other->rootfs_);
    std::swap(docker_, other->docker_);
    std::swap(appc_, other->appc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerConfig_descriptor_;
  metadata.reflection = ContainerConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerLaunchInfo::kPreExecCommandsFieldNumber;
const int ContainerLaunchInfo::kEnvironmentFieldNumber;
const int ContainerLaunchInfo::kRootfsFieldNumber;
const int ContainerLaunchInfo::kEnterNamespacesFieldNumber;
const int ContainerLaunchInfo::kCloneNamespacesFieldNumber;
const int ContainerLaunchInfo::kUserFieldNumber;
const int ContainerLaunchInfo::kCommandFieldNumber;
const int ContainerLaunchInfo::kWorkingDirectoryFieldNumber;
const int ContainerLaunchInfo::kCapabilitiesFieldNumber;
const int ContainerLaunchInfo::kRlimitsFieldNumber;
const int ContainerLaunchInfo::kTtySlavePathFieldNumber;
const int ContainerLaunchInfo::kTaskEnvironmentFieldNumber;
#endif  // !_MSC_VER

ContainerLaunchInfo::ContainerLaunchInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerLaunchInfo)
}

void ContainerLaunchInfo::InitAsDefaultInstance() {
  environment_ = const_cast< ::mesos::Environment*>(&::mesos::Environment::default_instance());
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  capabilities_ = const_cast< ::mesos::CapabilityInfo*>(&::mesos::CapabilityInfo::default_instance());
  rlimits_ = const_cast< ::mesos::RLimitInfo*>(&::mesos::RLimitInfo::default_instance());
  task_environment_ = const_cast< ::mesos::Environment*>(&::mesos::Environment::default_instance());
}

ContainerLaunchInfo::ContainerLaunchInfo(const ContainerLaunchInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerLaunchInfo)
}

void ContainerLaunchInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  environment_ = NULL;
  rootfs_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  command_ = NULL;
  working_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  capabilities_ = NULL;
  rlimits_ = NULL;
  tty_slave_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_environment_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerLaunchInfo::~ContainerLaunchInfo() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerLaunchInfo)
  SharedDtor();
}

void ContainerLaunchInfo::SharedDtor() {
  if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rootfs_;
  }
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (working_directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete working_directory_;
  }
  if (tty_slave_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tty_slave_path_;
  }
  if (this != default_instance_) {
    delete environment_;
    delete command_;
    delete capabilities_;
    delete rlimits_;
    delete task_environment_;
  }
}

void ContainerLaunchInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerLaunchInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerLaunchInfo_descriptor_;
}

const ContainerLaunchInfo& ContainerLaunchInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerLaunchInfo* ContainerLaunchInfo::default_instance_ = NULL;

ContainerLaunchInfo* ContainerLaunchInfo::New() const {
  return new ContainerLaunchInfo;
}

void ContainerLaunchInfo::Clear() {
  if (_has_bits_[0 / 32] & 230) {
    if (has_environment()) {
      if (environment_ != NULL) environment_->::mesos::Environment::Clear();
    }
    if (has_rootfs()) {
      if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        rootfs_->clear();
      }
    }
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_->clear();
      }
    }
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_working_directory()) {
      if (working_directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        working_directory_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 3840) {
    if (has_capabilities()) {
      if (capabilities_ != NULL) capabilities_->::mesos::CapabilityInfo::Clear();
    }
    if (has_rlimits()) {
      if (rlimits_ != NULL) rlimits_->::mesos::RLimitInfo::Clear();
    }
    if (has_tty_slave_path()) {
      if (tty_slave_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tty_slave_path_->clear();
      }
    }
    if (has_task_environment()) {
      if (task_environment_ != NULL) task_environment_->::mesos::Environment::Clear();
    }
  }
  pre_exec_commands_.Clear();
  enter_namespaces_.Clear();
  clone_namespaces_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerLaunchInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerLaunchInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.CommandInfo pre_exec_commands = 1;
      case 1: {
        if (tag == 10) {
         parse_pre_exec_commands:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pre_exec_commands()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_pre_exec_commands;
        if (input->ExpectTag(18)) goto parse_environment;
        break;
      }

      // optional .mesos.Environment environment = 2;
      case 2: {
        if (tag == 18) {
         parse_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_environment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_rootfs;
        break;
      }

      // optional string rootfs = 3;
      case 3: {
        if (tag == 26) {
         parse_rootfs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rootfs()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->rootfs().data(), this->rootfs().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "rootfs");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_clone_namespaces;
        break;
      }

      // repeated int32 clone_namespaces = 4;
      case 4: {
        if (tag == 32) {
         parse_clone_namespaces:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_clone_namespaces())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_clone_namespaces())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_clone_namespaces;
        if (input->ExpectTag(42)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 5;
      case 5: {
        if (tag == 42) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_working_directory;
        break;
      }

      // optional string working_directory = 6;
      case 6: {
        if (tag == 50) {
         parse_working_directory:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_working_directory()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->working_directory().data(), this->working_directory().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "working_directory");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_capabilities;
        break;
      }

      // optional .mesos.CapabilityInfo capabilities = 7;
      case 7: {
        if (tag == 58) {
         parse_capabilities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_capabilities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_rlimits;
        break;
      }

      // optional .mesos.RLimitInfo rlimits = 8;
      case 8: {
        if (tag == 66) {
         parse_rlimits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rlimits()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_enter_namespaces;
        break;
      }

      // repeated int32 enter_namespaces = 9;
      case 9: {
        if (tag == 72) {
         parse_enter_namespaces:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 72, input, this->mutable_enter_namespaces())));
        } else if (tag == 74) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_enter_namespaces())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_enter_namespaces;
        if (input->ExpectTag(82)) goto parse_user;
        break;
      }

      // optional string user = 10;
      case 10: {
        if (tag == 82) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_tty_slave_path;
        break;
      }

      // optional string tty_slave_path = 14;
      case 14: {
        if (tag == 114) {
         parse_tty_slave_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tty_slave_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->tty_slave_path().data(), this->tty_slave_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tty_slave_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_task_environment;
        break;
      }

      // optional .mesos.Environment task_environment = 15;
      case 15: {
        if (tag == 122) {
         parse_task_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_environment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerLaunchInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerLaunchInfo)
  return false;
#undef DO_
}

void ContainerLaunchInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerLaunchInfo)
  // repeated .mesos.CommandInfo pre_exec_commands = 1;
  for (int i = 0; i < this->pre_exec_commands_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pre_exec_commands(i), output);
  }

  // optional .mesos.Environment environment = 2;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->environment(), output);
  }

  // optional string rootfs = 3;
  if (has_rootfs()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rootfs().data(), this->rootfs().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rootfs");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->rootfs(), output);
  }

  // repeated int32 clone_namespaces = 4;
  for (int i = 0; i < this->clone_namespaces_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->clone_namespaces(i), output);
  }

  // optional .mesos.CommandInfo command = 5;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->command(), output);
  }

  // optional string working_directory = 6;
  if (has_working_directory()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->working_directory().data(), this->working_directory().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "working_directory");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->working_directory(), output);
  }

  // optional .mesos.CapabilityInfo capabilities = 7;
  if (has_capabilities()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->capabilities(), output);
  }

  // optional .mesos.RLimitInfo rlimits = 8;
  if (has_rlimits()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->rlimits(), output);
  }

  // repeated int32 enter_namespaces = 9;
  for (int i = 0; i < this->enter_namespaces_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      9, this->enter_namespaces(i), output);
  }

  // optional string user = 10;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->user(), output);
  }

  // optional string tty_slave_path = 14;
  if (has_tty_slave_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tty_slave_path().data(), this->tty_slave_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tty_slave_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->tty_slave_path(), output);
  }

  // optional .mesos.Environment task_environment = 15;
  if (has_task_environment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->task_environment(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerLaunchInfo)
}

::google::protobuf::uint8* ContainerLaunchInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerLaunchInfo)
  // repeated .mesos.CommandInfo pre_exec_commands = 1;
  for (int i = 0; i < this->pre_exec_commands_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pre_exec_commands(i), target);
  }

  // optional .mesos.Environment environment = 2;
  if (has_environment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->environment(), target);
  }

  // optional string rootfs = 3;
  if (has_rootfs()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rootfs().data(), this->rootfs().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rootfs");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->rootfs(), target);
  }

  // repeated int32 clone_namespaces = 4;
  for (int i = 0; i < this->clone_namespaces_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->clone_namespaces(i), target);
  }

  // optional .mesos.CommandInfo command = 5;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->command(), target);
  }

  // optional string working_directory = 6;
  if (has_working_directory()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->working_directory().data(), this->working_directory().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "working_directory");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->working_directory(), target);
  }

  // optional .mesos.CapabilityInfo capabilities = 7;
  if (has_capabilities()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->capabilities(), target);
  }

  // optional .mesos.RLimitInfo rlimits = 8;
  if (has_rlimits()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->rlimits(), target);
  }

  // repeated int32 enter_namespaces = 9;
  for (int i = 0; i < this->enter_namespaces_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(9, this->enter_namespaces(i), target);
  }

  // optional string user = 10;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->user(), target);
  }

  // optional string tty_slave_path = 14;
  if (has_tty_slave_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tty_slave_path().data(), this->tty_slave_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tty_slave_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->tty_slave_path(), target);
  }

  // optional .mesos.Environment task_environment = 15;
  if (has_task_environment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->task_environment(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerLaunchInfo)
  return target;
}

int ContainerLaunchInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .mesos.Environment environment = 2;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->environment());
    }

    // optional string rootfs = 3;
    if (has_rootfs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rootfs());
    }

    // optional string user = 10;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

    // optional .mesos.CommandInfo command = 5;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional string working_directory = 6;
    if (has_working_directory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->working_directory());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.CapabilityInfo capabilities = 7;
    if (has_capabilities()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->capabilities());
    }

    // optional .mesos.RLimitInfo rlimits = 8;
    if (has_rlimits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rlimits());
    }

    // optional string tty_slave_path = 14;
    if (has_tty_slave_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tty_slave_path());
    }

    // optional .mesos.Environment task_environment = 15;
    if (has_task_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_environment());
    }

  }
  // repeated .mesos.CommandInfo pre_exec_commands = 1;
  total_size += 1 * this->pre_exec_commands_size();
  for (int i = 0; i < this->pre_exec_commands_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pre_exec_commands(i));
  }

  // repeated int32 enter_namespaces = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->enter_namespaces_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->enter_namespaces(i));
    }
    total_size += 1 * this->enter_namespaces_size() + data_size;
  }

  // repeated int32 clone_namespaces = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->clone_namespaces_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->clone_namespaces(i));
    }
    total_size += 1 * this->clone_namespaces_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerLaunchInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerLaunchInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerLaunchInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerLaunchInfo::MergeFrom(const ContainerLaunchInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  pre_exec_commands_.MergeFrom(from.pre_exec_commands_);
  enter_namespaces_.MergeFrom(from.enter_namespaces_);
  clone_namespaces_.MergeFrom(from.clone_namespaces_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_environment()) {
      mutable_environment()->::mesos::Environment::MergeFrom(from.environment());
    }
    if (from.has_rootfs()) {
      set_rootfs(from.rootfs());
    }
    if (from.has_user()) {
      set_user(from.user());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_working_directory()) {
      set_working_directory(from.working_directory());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_capabilities()) {
      mutable_capabilities()->::mesos::CapabilityInfo::MergeFrom(from.capabilities());
    }
    if (from.has_rlimits()) {
      mutable_rlimits()->::mesos::RLimitInfo::MergeFrom(from.rlimits());
    }
    if (from.has_tty_slave_path()) {
      set_tty_slave_path(from.tty_slave_path());
    }
    if (from.has_task_environment()) {
      mutable_task_environment()->::mesos::Environment::MergeFrom(from.task_environment());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerLaunchInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerLaunchInfo::CopyFrom(const ContainerLaunchInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerLaunchInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->pre_exec_commands())) return false;
  if (has_environment()) {
    if (!this->environment().IsInitialized()) return false;
  }
  if (has_command()) {
    if (!this->command().IsInitialized()) return false;
  }
  if (has_task_environment()) {
    if (!this->task_environment().IsInitialized()) return false;
  }
  return true;
}

void ContainerLaunchInfo::Swap(ContainerLaunchInfo* other) {
  if (other != this) {
    pre_exec_commands_.Swap(&other->pre_exec_commands_);
    std::swap(environment_, other->environment_);
    std::swap(rootfs_, other->rootfs_);
    enter_namespaces_.Swap(&other->enter_namespaces_);
    clone_namespaces_.Swap(&other->clone_namespaces_);
    std::swap(user_, other->user_);
    std::swap(command_, other->command_);
    std::swap(working_directory_, other->working_directory_);
    std::swap(capabilities_, other->capabilities_);
    std::swap(rlimits_, other->rlimits_);
    std::swap(tty_slave_path_, other->tty_slave_path_);
    std::swap(task_environment_, other->task_environment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerLaunchInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerLaunchInfo_descriptor_;
  metadata.reflection = ContainerLaunchInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerTermination::kStatusFieldNumber;
const int ContainerTermination::kStateFieldNumber;
const int ContainerTermination::kReasonsFieldNumber;
const int ContainerTermination::kMessageFieldNumber;
#endif  // !_MSC_VER

ContainerTermination::ContainerTermination()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.slave.ContainerTermination)
}

void ContainerTermination::InitAsDefaultInstance() {
}

ContainerTermination::ContainerTermination(const ContainerTermination& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.slave.ContainerTermination)
}

void ContainerTermination::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  status_ = 0;
  state_ = 6;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerTermination::~ContainerTermination() {
  // @@protoc_insertion_point(destructor:mesos.slave.ContainerTermination)
  SharedDtor();
}

void ContainerTermination::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void ContainerTermination::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerTermination::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerTermination_descriptor_;
}

const ContainerTermination& ContainerTermination::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_containerizer_2eproto();
  return *default_instance_;
}

ContainerTermination* ContainerTermination::default_instance_ = NULL;

ContainerTermination* ContainerTermination::New() const {
  return new ContainerTermination;
}

void ContainerTermination::Clear() {
  if (_has_bits_[0 / 32] & 11) {
    status_ = 0;
    state_ = 6;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
  }
  reasons_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerTermination::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.slave.ContainerTermination)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // optional int32 status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_state;
        break;
      }

      // optional .mesos.TaskState state = 4;
      case 4: {
        if (tag == 32) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reasons;
        break;
      }

      // repeated .mesos.TaskStatus.Reason reasons = 5;
      case 5: {
        if (tag == 40) {
         parse_reasons:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskStatus_Reason_IsValid(value)) {
            add_reasons(static_cast< ::mesos::TaskStatus_Reason >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::mesos::TaskStatus_Reason_IsValid,
                 this->mutable_reasons())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reasons;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.slave.ContainerTermination)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.slave.ContainerTermination)
  return false;
#undef DO_
}

void ContainerTermination::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.slave.ContainerTermination)
  // optional string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message(), output);
  }

  // optional int32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->status(), output);
  }

  // optional .mesos.TaskState state = 4;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->state(), output);
  }

  // repeated .mesos.TaskStatus.Reason reasons = 5;
  for (int i = 0; i < this->reasons_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->reasons(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.slave.ContainerTermination)
}

::google::protobuf::uint8* ContainerTermination::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.slave.ContainerTermination)
  // optional string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  // optional int32 status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->status(), target);
  }

  // optional .mesos.TaskState state = 4;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->state(), target);
  }

  // repeated .mesos.TaskStatus.Reason reasons = 5;
  for (int i = 0; i < this->reasons_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->reasons(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.slave.ContainerTermination)
  return target;
}

int ContainerTermination::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // optional .mesos.TaskState state = 4;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  // repeated .mesos.TaskStatus.Reason reasons = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->reasons_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->reasons(i));
    }
    total_size += 1 * this->reasons_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerTermination::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerTermination* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerTermination*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerTermination::MergeFrom(const ContainerTermination& from) {
  GOOGLE_CHECK_NE(&from, this);
  reasons_.MergeFrom(from.reasons_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerTermination::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerTermination::CopyFrom(const ContainerTermination& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerTermination::IsInitialized() const {

  return true;
}

void ContainerTermination::Swap(ContainerTermination* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(state_, other->state_);
    reasons_.Swap(&other->reasons_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerTermination::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerTermination_descriptor_;
  metadata.reflection = ContainerTermination_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace slave
}  // namespace mesos

// @@protoc_insertion_point(global_scope)
