// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: containerizer.proto

#ifndef PROTOBUF_containerizer_2eproto__INCLUDED
#define PROTOBUF_containerizer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos.pb.h"
#include "spec.pb.h"
#include "v1.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace slave {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_containerizer_2eproto();
void protobuf_AssignDesc_containerizer_2eproto();
void protobuf_ShutdownFile_containerizer_2eproto();

class ContainerLimitation;
class ContainerState;
class ContainerRecoverInfo;
class ContainerConfig;
class ContainerConfig_Docker;
class ContainerConfig_Appc;
class ContainerLaunchInfo;
class ContainerTermination;

enum ContainerClass {
  DEFAULT = 1,
  DEBUG = 2
};
bool ContainerClass_IsValid(int value);
const ContainerClass ContainerClass_MIN = DEFAULT;
const ContainerClass ContainerClass_MAX = DEBUG;
const int ContainerClass_ARRAYSIZE = ContainerClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerClass_descriptor();
inline const ::std::string& ContainerClass_Name(ContainerClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerClass_descriptor(), value);
}
inline bool ContainerClass_Parse(
    const ::std::string& name, ContainerClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerClass>(
    ContainerClass_descriptor(), name, value);
}
// ===================================================================

class ContainerLimitation : public ::google::protobuf::Message {
 public:
  ContainerLimitation();
  virtual ~ContainerLimitation();

  ContainerLimitation(const ContainerLimitation& from);

  inline ContainerLimitation& operator=(const ContainerLimitation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerLimitation& default_instance();

  void Swap(ContainerLimitation* other);

  // implements Message ----------------------------------------------

  ContainerLimitation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerLimitation& from);
  void MergeFrom(const ContainerLimitation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .mesos.TaskStatus.Reason reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline ::mesos::TaskStatus_Reason reason() const;
  inline void set_reason(::mesos::TaskStatus_Reason value);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerLimitation)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::std::string* message_;
  int reason_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerLimitation* default_instance_;
};
// -------------------------------------------------------------------

class ContainerState : public ::google::protobuf::Message {
 public:
  ContainerState();
  virtual ~ContainerState();

  ContainerState(const ContainerState& from);

  inline ContainerState& operator=(const ContainerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerState& default_instance();

  void Swap(ContainerState* other);

  // implements Message ----------------------------------------------

  ContainerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerState& from);
  void MergeFrom(const ContainerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.ExecutorInfo executor_info = 1;
  inline bool has_executor_info() const;
  inline void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 1;
  inline const ::mesos::ExecutorInfo& executor_info() const;
  inline ::mesos::ExecutorInfo* mutable_executor_info();
  inline ::mesos::ExecutorInfo* release_executor_info();
  inline void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // required .mesos.ContainerID container_id = 2;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  inline const ::mesos::ContainerID& container_id() const;
  inline ::mesos::ContainerID* mutable_container_id();
  inline ::mesos::ContainerID* release_container_id();
  inline void set_allocated_container_id(::mesos::ContainerID* container_id);

  // required uint64 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // required string directory = 4;
  inline bool has_directory() const;
  inline void clear_directory();
  static const int kDirectoryFieldNumber = 4;
  inline const ::std::string& directory() const;
  inline void set_directory(const ::std::string& value);
  inline void set_directory(const char* value);
  inline void set_directory(const char* value, size_t size);
  inline ::std::string* mutable_directory();
  inline ::std::string* release_directory();
  inline void set_allocated_directory(::std::string* directory);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerState)
 private:
  inline void set_has_executor_info();
  inline void clear_has_executor_info();
  inline void set_has_container_id();
  inline void clear_has_container_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_directory();
  inline void clear_has_directory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::uint64 pid_;
  ::std::string* directory_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerState* default_instance_;
};
// -------------------------------------------------------------------

class ContainerRecoverInfo : public ::google::protobuf::Message {
 public:
  ContainerRecoverInfo();
  virtual ~ContainerRecoverInfo();

  ContainerRecoverInfo(const ContainerRecoverInfo& from);

  inline ContainerRecoverInfo& operator=(const ContainerRecoverInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerRecoverInfo& default_instance();

  void Swap(ContainerRecoverInfo* other);

  // implements Message ----------------------------------------------

  ContainerRecoverInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerRecoverInfo& from);
  void MergeFrom(const ContainerRecoverInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
  inline int checkpointed_container_states_size() const;
  inline void clear_checkpointed_container_states();
  static const int kCheckpointedContainerStatesFieldNumber = 1;
  inline const ::mesos::slave::ContainerState& checkpointed_container_states(int index) const;
  inline ::mesos::slave::ContainerState* mutable_checkpointed_container_states(int index);
  inline ::mesos::slave::ContainerState* add_checkpointed_container_states();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >&
      checkpointed_container_states() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >*
      mutable_checkpointed_container_states();

  // repeated .mesos.ContainerID orphan_container_ids = 2;
  inline int orphan_container_ids_size() const;
  inline void clear_orphan_container_ids();
  static const int kOrphanContainerIdsFieldNumber = 2;
  inline const ::mesos::ContainerID& orphan_container_ids(int index) const;
  inline ::mesos::ContainerID* mutable_orphan_container_ids(int index);
  inline ::mesos::ContainerID* add_orphan_container_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
      orphan_container_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
      mutable_orphan_container_ids();

  // repeated .mesos.ContainerID known_container_ids = 3;
  inline int known_container_ids_size() const;
  inline void clear_known_container_ids();
  static const int kKnownContainerIdsFieldNumber = 3;
  inline const ::mesos::ContainerID& known_container_ids(int index) const;
  inline ::mesos::ContainerID* mutable_known_container_ids(int index);
  inline ::mesos::ContainerID* add_known_container_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
      known_container_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
      mutable_known_container_ids();

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerRecoverInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState > checkpointed_container_states_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID > orphan_container_ids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID > known_container_ids_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerRecoverInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerConfig_Docker : public ::google::protobuf::Message {
 public:
  ContainerConfig_Docker();
  virtual ~ContainerConfig_Docker();

  ContainerConfig_Docker(const ContainerConfig_Docker& from);

  inline ContainerConfig_Docker& operator=(const ContainerConfig_Docker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig_Docker& default_instance();

  void Swap(ContainerConfig_Docker* other);

  // implements Message ----------------------------------------------

  ContainerConfig_Docker* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerConfig_Docker& from);
  void MergeFrom(const ContainerConfig_Docker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .docker.spec.v1.ImageManifest manifest = 1;
  inline bool has_manifest() const;
  inline void clear_manifest();
  static const int kManifestFieldNumber = 1;
  inline const ::docker::spec::v1::ImageManifest& manifest() const;
  inline ::docker::spec::v1::ImageManifest* mutable_manifest();
  inline ::docker::spec::v1::ImageManifest* release_manifest();
  inline void set_allocated_manifest(::docker::spec::v1::ImageManifest* manifest);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerConfig.Docker)
 private:
  inline void set_has_manifest();
  inline void clear_has_manifest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::docker::spec::v1::ImageManifest* manifest_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerConfig_Docker* default_instance_;
};
// -------------------------------------------------------------------

class ContainerConfig_Appc : public ::google::protobuf::Message {
 public:
  ContainerConfig_Appc();
  virtual ~ContainerConfig_Appc();

  ContainerConfig_Appc(const ContainerConfig_Appc& from);

  inline ContainerConfig_Appc& operator=(const ContainerConfig_Appc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig_Appc& default_instance();

  void Swap(ContainerConfig_Appc* other);

  // implements Message ----------------------------------------------

  ContainerConfig_Appc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerConfig_Appc& from);
  void MergeFrom(const ContainerConfig_Appc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .appc.spec.ImageManifest manifest = 1;
  inline bool has_manifest() const;
  inline void clear_manifest();
  static const int kManifestFieldNumber = 1;
  inline const ::appc::spec::ImageManifest& manifest() const;
  inline ::appc::spec::ImageManifest* mutable_manifest();
  inline ::appc::spec::ImageManifest* release_manifest();
  inline void set_allocated_manifest(::appc::spec::ImageManifest* manifest);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerConfig.Appc)
 private:
  inline void set_has_manifest();
  inline void clear_has_manifest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::appc::spec::ImageManifest* manifest_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerConfig_Appc* default_instance_;
};
// -------------------------------------------------------------------

class ContainerConfig : public ::google::protobuf::Message {
 public:
  ContainerConfig();
  virtual ~ContainerConfig();

  ContainerConfig(const ContainerConfig& from);

  inline ContainerConfig& operator=(const ContainerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerConfig& default_instance();

  void Swap(ContainerConfig* other);

  // implements Message ----------------------------------------------

  ContainerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerConfig& from);
  void MergeFrom(const ContainerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContainerConfig_Docker Docker;
  typedef ContainerConfig_Appc Appc;

  // accessors -------------------------------------------------------

  // optional .mesos.ExecutorInfo executor_info = 8;
  inline bool has_executor_info() const;
  inline void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 8;
  inline const ::mesos::ExecutorInfo& executor_info() const;
  inline ::mesos::ExecutorInfo* mutable_executor_info();
  inline ::mesos::ExecutorInfo* release_executor_info();
  inline void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // optional .mesos.TaskInfo task_info = 9;
  inline bool has_task_info() const;
  inline void clear_task_info();
  static const int kTaskInfoFieldNumber = 9;
  inline const ::mesos::TaskInfo& task_info() const;
  inline ::mesos::TaskInfo* mutable_task_info();
  inline ::mesos::TaskInfo* release_task_info();
  inline void set_allocated_task_info(::mesos::TaskInfo* task_info);

  // required .mesos.CommandInfo command_info = 11;
  inline bool has_command_info() const;
  inline void clear_command_info();
  static const int kCommandInfoFieldNumber = 11;
  inline const ::mesos::CommandInfo& command_info() const;
  inline ::mesos::CommandInfo* mutable_command_info();
  inline ::mesos::CommandInfo* release_command_info();
  inline void set_allocated_command_info(::mesos::CommandInfo* command_info);

  // optional .mesos.ContainerInfo container_info = 12;
  inline bool has_container_info() const;
  inline void clear_container_info();
  static const int kContainerInfoFieldNumber = 12;
  inline const ::mesos::ContainerInfo& container_info() const;
  inline ::mesos::ContainerInfo* mutable_container_info();
  inline ::mesos::ContainerInfo* release_container_info();
  inline void set_allocated_container_info(::mesos::ContainerInfo* container_info);

  // repeated .mesos.Resource resources = 13;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 13;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional .mesos.slave.ContainerClass container_class = 14;
  inline bool has_container_class() const;
  inline void clear_container_class();
  static const int kContainerClassFieldNumber = 14;
  inline ::mesos::slave::ContainerClass container_class() const;
  inline void set_container_class(::mesos::slave::ContainerClass value);

  // required string directory = 3;
  inline bool has_directory() const;
  inline void clear_directory();
  static const int kDirectoryFieldNumber = 3;
  inline const ::std::string& directory() const;
  inline void set_directory(const ::std::string& value);
  inline void set_directory(const char* value);
  inline void set_directory(const char* value, size_t size);
  inline ::std::string* mutable_directory();
  inline ::std::string* release_directory();
  inline void set_allocated_directory(::std::string* directory);

  // optional string user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string rootfs = 5;
  inline bool has_rootfs() const;
  inline void clear_rootfs();
  static const int kRootfsFieldNumber = 5;
  inline const ::std::string& rootfs() const;
  inline void set_rootfs(const ::std::string& value);
  inline void set_rootfs(const char* value);
  inline void set_rootfs(const char* value, size_t size);
  inline ::std::string* mutable_rootfs();
  inline ::std::string* release_rootfs();
  inline void set_allocated_rootfs(::std::string* rootfs);

  // optional .mesos.slave.ContainerConfig.Docker docker = 7;
  inline bool has_docker() const;
  inline void clear_docker();
  static const int kDockerFieldNumber = 7;
  inline const ::mesos::slave::ContainerConfig_Docker& docker() const;
  inline ::mesos::slave::ContainerConfig_Docker* mutable_docker();
  inline ::mesos::slave::ContainerConfig_Docker* release_docker();
  inline void set_allocated_docker(::mesos::slave::ContainerConfig_Docker* docker);

  // optional .mesos.slave.ContainerConfig.Appc appc = 10;
  inline bool has_appc() const;
  inline void clear_appc();
  static const int kAppcFieldNumber = 10;
  inline const ::mesos::slave::ContainerConfig_Appc& appc() const;
  inline ::mesos::slave::ContainerConfig_Appc* mutable_appc();
  inline ::mesos::slave::ContainerConfig_Appc* release_appc();
  inline void set_allocated_appc(::mesos::slave::ContainerConfig_Appc* appc);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerConfig)
 private:
  inline void set_has_executor_info();
  inline void clear_has_executor_info();
  inline void set_has_task_info();
  inline void clear_has_task_info();
  inline void set_has_command_info();
  inline void clear_has_command_info();
  inline void set_has_container_info();
  inline void clear_has_container_info();
  inline void set_has_container_class();
  inline void clear_has_container_class();
  inline void set_has_directory();
  inline void clear_has_directory();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_rootfs();
  inline void clear_has_rootfs();
  inline void set_has_docker();
  inline void clear_has_docker();
  inline void set_has_appc();
  inline void clear_has_appc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_info_;
  ::mesos::TaskInfo* task_info_;
  ::mesos::CommandInfo* command_info_;
  ::mesos::ContainerInfo* container_info_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::std::string* directory_;
  ::std::string* user_;
  ::std::string* rootfs_;
  ::mesos::slave::ContainerConfig_Docker* docker_;
  ::mesos::slave::ContainerConfig_Appc* appc_;
  int container_class_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerConfig* default_instance_;
};
// -------------------------------------------------------------------

class ContainerLaunchInfo : public ::google::protobuf::Message {
 public:
  ContainerLaunchInfo();
  virtual ~ContainerLaunchInfo();

  ContainerLaunchInfo(const ContainerLaunchInfo& from);

  inline ContainerLaunchInfo& operator=(const ContainerLaunchInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerLaunchInfo& default_instance();

  void Swap(ContainerLaunchInfo* other);

  // implements Message ----------------------------------------------

  ContainerLaunchInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerLaunchInfo& from);
  void MergeFrom(const ContainerLaunchInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.CommandInfo pre_exec_commands = 1;
  inline int pre_exec_commands_size() const;
  inline void clear_pre_exec_commands();
  static const int kPreExecCommandsFieldNumber = 1;
  inline const ::mesos::CommandInfo& pre_exec_commands(int index) const;
  inline ::mesos::CommandInfo* mutable_pre_exec_commands(int index);
  inline ::mesos::CommandInfo* add_pre_exec_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >&
      pre_exec_commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >*
      mutable_pre_exec_commands();

  // optional .mesos.Environment environment = 2;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  inline const ::mesos::Environment& environment() const;
  inline ::mesos::Environment* mutable_environment();
  inline ::mesos::Environment* release_environment();
  inline void set_allocated_environment(::mesos::Environment* environment);

  // optional string rootfs = 3;
  inline bool has_rootfs() const;
  inline void clear_rootfs();
  static const int kRootfsFieldNumber = 3;
  inline const ::std::string& rootfs() const;
  inline void set_rootfs(const ::std::string& value);
  inline void set_rootfs(const char* value);
  inline void set_rootfs(const char* value, size_t size);
  inline ::std::string* mutable_rootfs();
  inline ::std::string* release_rootfs();
  inline void set_allocated_rootfs(::std::string* rootfs);

  // repeated int32 enter_namespaces = 9;
  inline int enter_namespaces_size() const;
  inline void clear_enter_namespaces();
  static const int kEnterNamespacesFieldNumber = 9;
  inline ::google::protobuf::int32 enter_namespaces(int index) const;
  inline void set_enter_namespaces(int index, ::google::protobuf::int32 value);
  inline void add_enter_namespaces(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      enter_namespaces() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_enter_namespaces();

  // repeated int32 clone_namespaces = 4;
  inline int clone_namespaces_size() const;
  inline void clear_clone_namespaces();
  static const int kCloneNamespacesFieldNumber = 4;
  inline ::google::protobuf::int32 clone_namespaces(int index) const;
  inline void set_clone_namespaces(int index, ::google::protobuf::int32 value);
  inline void add_clone_namespaces(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      clone_namespaces() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_clone_namespaces();

  // optional string user = 10;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 10;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional .mesos.CommandInfo command = 5;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 5;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional string working_directory = 6;
  inline bool has_working_directory() const;
  inline void clear_working_directory();
  static const int kWorkingDirectoryFieldNumber = 6;
  inline const ::std::string& working_directory() const;
  inline void set_working_directory(const ::std::string& value);
  inline void set_working_directory(const char* value);
  inline void set_working_directory(const char* value, size_t size);
  inline ::std::string* mutable_working_directory();
  inline ::std::string* release_working_directory();
  inline void set_allocated_working_directory(::std::string* working_directory);

  // optional .mesos.CapabilityInfo capabilities = 7;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 7;
  inline const ::mesos::CapabilityInfo& capabilities() const;
  inline ::mesos::CapabilityInfo* mutable_capabilities();
  inline ::mesos::CapabilityInfo* release_capabilities();
  inline void set_allocated_capabilities(::mesos::CapabilityInfo* capabilities);

  // optional .mesos.RLimitInfo rlimits = 8;
  inline bool has_rlimits() const;
  inline void clear_rlimits();
  static const int kRlimitsFieldNumber = 8;
  inline const ::mesos::RLimitInfo& rlimits() const;
  inline ::mesos::RLimitInfo* mutable_rlimits();
  inline ::mesos::RLimitInfo* release_rlimits();
  inline void set_allocated_rlimits(::mesos::RLimitInfo* rlimits);

  // optional string tty_slave_path = 14;
  inline bool has_tty_slave_path() const;
  inline void clear_tty_slave_path();
  static const int kTtySlavePathFieldNumber = 14;
  inline const ::std::string& tty_slave_path() const;
  inline void set_tty_slave_path(const ::std::string& value);
  inline void set_tty_slave_path(const char* value);
  inline void set_tty_slave_path(const char* value, size_t size);
  inline ::std::string* mutable_tty_slave_path();
  inline ::std::string* release_tty_slave_path();
  inline void set_allocated_tty_slave_path(::std::string* tty_slave_path);

  // optional .mesos.Environment task_environment = 15;
  inline bool has_task_environment() const;
  inline void clear_task_environment();
  static const int kTaskEnvironmentFieldNumber = 15;
  inline const ::mesos::Environment& task_environment() const;
  inline ::mesos::Environment* mutable_task_environment();
  inline ::mesos::Environment* release_task_environment();
  inline void set_allocated_task_environment(::mesos::Environment* task_environment);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerLaunchInfo)
 private:
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_rootfs();
  inline void clear_has_rootfs();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_working_directory();
  inline void clear_has_working_directory();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_rlimits();
  inline void clear_has_rlimits();
  inline void set_has_tty_slave_path();
  inline void clear_has_tty_slave_path();
  inline void set_has_task_environment();
  inline void clear_has_task_environment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo > pre_exec_commands_;
  ::mesos::Environment* environment_;
  ::std::string* rootfs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > enter_namespaces_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > clone_namespaces_;
  ::std::string* user_;
  ::mesos::CommandInfo* command_;
  ::std::string* working_directory_;
  ::mesos::CapabilityInfo* capabilities_;
  ::mesos::RLimitInfo* rlimits_;
  ::std::string* tty_slave_path_;
  ::mesos::Environment* task_environment_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerLaunchInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerTermination : public ::google::protobuf::Message {
 public:
  ContainerTermination();
  virtual ~ContainerTermination();

  ContainerTermination(const ContainerTermination& from);

  inline ContainerTermination& operator=(const ContainerTermination& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerTermination& default_instance();

  void Swap(ContainerTermination* other);

  // implements Message ----------------------------------------------

  ContainerTermination* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerTermination& from);
  void MergeFrom(const ContainerTermination& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional .mesos.TaskState state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::mesos::TaskState state() const;
  inline void set_state(::mesos::TaskState value);

  // repeated .mesos.TaskStatus.Reason reasons = 5;
  inline int reasons_size() const;
  inline void clear_reasons();
  static const int kReasonsFieldNumber = 5;
  inline ::mesos::TaskStatus_Reason reasons(int index) const;
  inline void set_reasons(int index, ::mesos::TaskStatus_Reason value);
  inline void add_reasons(::mesos::TaskStatus_Reason value);
  inline const ::google::protobuf::RepeatedField<int>& reasons() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_reasons();

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mesos.slave.ContainerTermination)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 status_;
  int state_;
  ::google::protobuf::RepeatedField<int> reasons_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_containerizer_2eproto();
  friend void protobuf_AssignDesc_containerizer_2eproto();
  friend void protobuf_ShutdownFile_containerizer_2eproto();

  void InitAsDefaultInstance();
  static ContainerTermination* default_instance_;
};
// ===================================================================


// ===================================================================

// ContainerLimitation

// repeated .mesos.Resource resources = 1;
inline int ContainerLimitation::resources_size() const {
  return resources_.size();
}
inline void ContainerLimitation::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ContainerLimitation::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLimitation.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ContainerLimitation::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLimitation.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ContainerLimitation::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLimitation.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ContainerLimitation::resources() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLimitation.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ContainerLimitation::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLimitation.resources)
  return &resources_;
}

// optional string message = 2;
inline bool ContainerLimitation::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerLimitation::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerLimitation::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerLimitation::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ContainerLimitation::message() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLimitation.message)
  return *message_;
}
inline void ContainerLimitation::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLimitation.message)
}
inline void ContainerLimitation::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLimitation.message)
}
inline void ContainerLimitation::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLimitation.message)
}
inline ::std::string* ContainerLimitation::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLimitation.message)
  return message_;
}
inline ::std::string* ContainerLimitation::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLimitation::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLimitation.message)
}

// optional .mesos.TaskStatus.Reason reason = 3;
inline bool ContainerLimitation::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerLimitation::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerLimitation::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerLimitation::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason ContainerLimitation::reason() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLimitation.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void ContainerLimitation::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLimitation.reason)
}

// -------------------------------------------------------------------

// ContainerState

// optional .mesos.ExecutorInfo executor_info = 1;
inline bool ContainerState::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerState::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerState::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerState::clear_executor_info() {
  if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
  clear_has_executor_info();
}
inline const ::mesos::ExecutorInfo& ContainerState::executor_info() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.executor_info)
  return executor_info_ != NULL ? *executor_info_ : *default_instance_->executor_info_;
}
inline ::mesos::ExecutorInfo* ContainerState::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) executor_info_ = new ::mesos::ExecutorInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerState.executor_info)
  return executor_info_;
}
inline ::mesos::ExecutorInfo* ContainerState::release_executor_info() {
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline void ContainerState::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  delete executor_info_;
  executor_info_ = executor_info;
  if (executor_info) {
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerState.executor_info)
}

// required .mesos.ContainerID container_id = 2;
inline bool ContainerState::has_container_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerState::set_has_container_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerState::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerState::clear_container_id() {
  if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
  clear_has_container_id();
}
inline const ::mesos::ContainerID& ContainerState::container_id() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.container_id)
  return container_id_ != NULL ? *container_id_ : *default_instance_->container_id_;
}
inline ::mesos::ContainerID* ContainerState::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) container_id_ = new ::mesos::ContainerID;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerState.container_id)
  return container_id_;
}
inline ::mesos::ContainerID* ContainerState::release_container_id() {
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline void ContainerState::set_allocated_container_id(::mesos::ContainerID* container_id) {
  delete container_id_;
  container_id_ = container_id;
  if (container_id) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerState.container_id)
}

// required uint64 pid = 3;
inline bool ContainerState::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerState::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerState::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerState::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 ContainerState::pid() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.pid)
  return pid_;
}
inline void ContainerState::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerState.pid)
}

// required string directory = 4;
inline bool ContainerState::has_directory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerState::set_has_directory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerState::clear_has_directory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerState::clear_directory() {
  if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_->clear();
  }
  clear_has_directory();
}
inline const ::std::string& ContainerState::directory() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerState.directory)
  return *directory_;
}
inline void ContainerState::set_directory(const ::std::string& value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerState.directory)
}
inline void ContainerState::set_directory(const char* value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerState.directory)
}
inline void ContainerState::set_directory(const char* value, size_t size) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  directory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerState.directory)
}
inline ::std::string* ContainerState::mutable_directory() {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerState.directory)
  return directory_;
}
inline ::std::string* ContainerState::release_directory() {
  clear_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = directory_;
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerState::set_allocated_directory(::std::string* directory) {
  if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete directory_;
  }
  if (directory) {
    set_has_directory();
    directory_ = directory;
  } else {
    clear_has_directory();
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerState.directory)
}

// -------------------------------------------------------------------

// ContainerRecoverInfo

// repeated .mesos.slave.ContainerState checkpointed_container_states = 1;
inline int ContainerRecoverInfo::checkpointed_container_states_size() const {
  return checkpointed_container_states_.size();
}
inline void ContainerRecoverInfo::clear_checkpointed_container_states() {
  checkpointed_container_states_.Clear();
}
inline const ::mesos::slave::ContainerState& ContainerRecoverInfo::checkpointed_container_states(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_.Get(index);
}
inline ::mesos::slave::ContainerState* ContainerRecoverInfo::mutable_checkpointed_container_states(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_.Mutable(index);
}
inline ::mesos::slave::ContainerState* ContainerRecoverInfo::add_checkpointed_container_states() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >&
ContainerRecoverInfo::checkpointed_container_states() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return checkpointed_container_states_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::slave::ContainerState >*
ContainerRecoverInfo::mutable_checkpointed_container_states() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerRecoverInfo.checkpointed_container_states)
  return &checkpointed_container_states_;
}

// repeated .mesos.ContainerID orphan_container_ids = 2;
inline int ContainerRecoverInfo::orphan_container_ids_size() const {
  return orphan_container_ids_.size();
}
inline void ContainerRecoverInfo::clear_orphan_container_ids() {
  orphan_container_ids_.Clear();
}
inline const ::mesos::ContainerID& ContainerRecoverInfo::orphan_container_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_.Get(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::mutable_orphan_container_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_.Mutable(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::add_orphan_container_ids() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
ContainerRecoverInfo::orphan_container_ids() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return orphan_container_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
ContainerRecoverInfo::mutable_orphan_container_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerRecoverInfo.orphan_container_ids)
  return &orphan_container_ids_;
}

// repeated .mesos.ContainerID known_container_ids = 3;
inline int ContainerRecoverInfo::known_container_ids_size() const {
  return known_container_ids_.size();
}
inline void ContainerRecoverInfo::clear_known_container_ids() {
  known_container_ids_.Clear();
}
inline const ::mesos::ContainerID& ContainerRecoverInfo::known_container_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_.Get(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::mutable_known_container_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_.Mutable(index);
}
inline ::mesos::ContainerID* ContainerRecoverInfo::add_known_container_ids() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >&
ContainerRecoverInfo::known_container_ids() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return known_container_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerID >*
ContainerRecoverInfo::mutable_known_container_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerRecoverInfo.known_container_ids)
  return &known_container_ids_;
}

// -------------------------------------------------------------------

// ContainerConfig_Docker

// optional .docker.spec.v1.ImageManifest manifest = 1;
inline bool ContainerConfig_Docker::has_manifest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerConfig_Docker::set_has_manifest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerConfig_Docker::clear_has_manifest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerConfig_Docker::clear_manifest() {
  if (manifest_ != NULL) manifest_->::docker::spec::v1::ImageManifest::Clear();
  clear_has_manifest();
}
inline const ::docker::spec::v1::ImageManifest& ContainerConfig_Docker::manifest() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.Docker.manifest)
  return manifest_ != NULL ? *manifest_ : *default_instance_->manifest_;
}
inline ::docker::spec::v1::ImageManifest* ContainerConfig_Docker::mutable_manifest() {
  set_has_manifest();
  if (manifest_ == NULL) manifest_ = new ::docker::spec::v1::ImageManifest;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.Docker.manifest)
  return manifest_;
}
inline ::docker::spec::v1::ImageManifest* ContainerConfig_Docker::release_manifest() {
  clear_has_manifest();
  ::docker::spec::v1::ImageManifest* temp = manifest_;
  manifest_ = NULL;
  return temp;
}
inline void ContainerConfig_Docker::set_allocated_manifest(::docker::spec::v1::ImageManifest* manifest) {
  delete manifest_;
  manifest_ = manifest;
  if (manifest) {
    set_has_manifest();
  } else {
    clear_has_manifest();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.Docker.manifest)
}

// -------------------------------------------------------------------

// ContainerConfig_Appc

// optional .appc.spec.ImageManifest manifest = 1;
inline bool ContainerConfig_Appc::has_manifest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerConfig_Appc::set_has_manifest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerConfig_Appc::clear_has_manifest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerConfig_Appc::clear_manifest() {
  if (manifest_ != NULL) manifest_->::appc::spec::ImageManifest::Clear();
  clear_has_manifest();
}
inline const ::appc::spec::ImageManifest& ContainerConfig_Appc::manifest() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.Appc.manifest)
  return manifest_ != NULL ? *manifest_ : *default_instance_->manifest_;
}
inline ::appc::spec::ImageManifest* ContainerConfig_Appc::mutable_manifest() {
  set_has_manifest();
  if (manifest_ == NULL) manifest_ = new ::appc::spec::ImageManifest;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.Appc.manifest)
  return manifest_;
}
inline ::appc::spec::ImageManifest* ContainerConfig_Appc::release_manifest() {
  clear_has_manifest();
  ::appc::spec::ImageManifest* temp = manifest_;
  manifest_ = NULL;
  return temp;
}
inline void ContainerConfig_Appc::set_allocated_manifest(::appc::spec::ImageManifest* manifest) {
  delete manifest_;
  manifest_ = manifest;
  if (manifest) {
    set_has_manifest();
  } else {
    clear_has_manifest();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.Appc.manifest)
}

// -------------------------------------------------------------------

// ContainerConfig

// optional .mesos.ExecutorInfo executor_info = 8;
inline bool ContainerConfig::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerConfig::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerConfig::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerConfig::clear_executor_info() {
  if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
  clear_has_executor_info();
}
inline const ::mesos::ExecutorInfo& ContainerConfig::executor_info() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.executor_info)
  return executor_info_ != NULL ? *executor_info_ : *default_instance_->executor_info_;
}
inline ::mesos::ExecutorInfo* ContainerConfig::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) executor_info_ = new ::mesos::ExecutorInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.executor_info)
  return executor_info_;
}
inline ::mesos::ExecutorInfo* ContainerConfig::release_executor_info() {
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline void ContainerConfig::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  delete executor_info_;
  executor_info_ = executor_info;
  if (executor_info) {
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.executor_info)
}

// optional .mesos.TaskInfo task_info = 9;
inline bool ContainerConfig::has_task_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerConfig::set_has_task_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerConfig::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerConfig::clear_task_info() {
  if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
  clear_has_task_info();
}
inline const ::mesos::TaskInfo& ContainerConfig::task_info() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.task_info)
  return task_info_ != NULL ? *task_info_ : *default_instance_->task_info_;
}
inline ::mesos::TaskInfo* ContainerConfig::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) task_info_ = new ::mesos::TaskInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.task_info)
  return task_info_;
}
inline ::mesos::TaskInfo* ContainerConfig::release_task_info() {
  clear_has_task_info();
  ::mesos::TaskInfo* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline void ContainerConfig::set_allocated_task_info(::mesos::TaskInfo* task_info) {
  delete task_info_;
  task_info_ = task_info;
  if (task_info) {
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.task_info)
}

// required .mesos.CommandInfo command_info = 11;
inline bool ContainerConfig::has_command_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerConfig::set_has_command_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerConfig::clear_has_command_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerConfig::clear_command_info() {
  if (command_info_ != NULL) command_info_->::mesos::CommandInfo::Clear();
  clear_has_command_info();
}
inline const ::mesos::CommandInfo& ContainerConfig::command_info() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.command_info)
  return command_info_ != NULL ? *command_info_ : *default_instance_->command_info_;
}
inline ::mesos::CommandInfo* ContainerConfig::mutable_command_info() {
  set_has_command_info();
  if (command_info_ == NULL) command_info_ = new ::mesos::CommandInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.command_info)
  return command_info_;
}
inline ::mesos::CommandInfo* ContainerConfig::release_command_info() {
  clear_has_command_info();
  ::mesos::CommandInfo* temp = command_info_;
  command_info_ = NULL;
  return temp;
}
inline void ContainerConfig::set_allocated_command_info(::mesos::CommandInfo* command_info) {
  delete command_info_;
  command_info_ = command_info;
  if (command_info) {
    set_has_command_info();
  } else {
    clear_has_command_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.command_info)
}

// optional .mesos.ContainerInfo container_info = 12;
inline bool ContainerConfig::has_container_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerConfig::set_has_container_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerConfig::clear_has_container_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerConfig::clear_container_info() {
  if (container_info_ != NULL) container_info_->::mesos::ContainerInfo::Clear();
  clear_has_container_info();
}
inline const ::mesos::ContainerInfo& ContainerConfig::container_info() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.container_info)
  return container_info_ != NULL ? *container_info_ : *default_instance_->container_info_;
}
inline ::mesos::ContainerInfo* ContainerConfig::mutable_container_info() {
  set_has_container_info();
  if (container_info_ == NULL) container_info_ = new ::mesos::ContainerInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.container_info)
  return container_info_;
}
inline ::mesos::ContainerInfo* ContainerConfig::release_container_info() {
  clear_has_container_info();
  ::mesos::ContainerInfo* temp = container_info_;
  container_info_ = NULL;
  return temp;
}
inline void ContainerConfig::set_allocated_container_info(::mesos::ContainerInfo* container_info) {
  delete container_info_;
  container_info_ = container_info;
  if (container_info) {
    set_has_container_info();
  } else {
    clear_has_container_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.container_info)
}

// repeated .mesos.Resource resources = 13;
inline int ContainerConfig::resources_size() const {
  return resources_.size();
}
inline void ContainerConfig::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ContainerConfig::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ContainerConfig::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ContainerConfig::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerConfig.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ContainerConfig::resources() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerConfig.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ContainerConfig::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerConfig.resources)
  return &resources_;
}

// optional .mesos.slave.ContainerClass container_class = 14;
inline bool ContainerConfig::has_container_class() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerConfig::set_has_container_class() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerConfig::clear_has_container_class() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContainerConfig::clear_container_class() {
  container_class_ = 1;
  clear_has_container_class();
}
inline ::mesos::slave::ContainerClass ContainerConfig::container_class() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.container_class)
  return static_cast< ::mesos::slave::ContainerClass >(container_class_);
}
inline void ContainerConfig::set_container_class(::mesos::slave::ContainerClass value) {
  assert(::mesos::slave::ContainerClass_IsValid(value));
  set_has_container_class();
  container_class_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.container_class)
}

// required string directory = 3;
inline bool ContainerConfig::has_directory() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerConfig::set_has_directory() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerConfig::clear_has_directory() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerConfig::clear_directory() {
  if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_->clear();
  }
  clear_has_directory();
}
inline const ::std::string& ContainerConfig::directory() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.directory)
  return *directory_;
}
inline void ContainerConfig::set_directory(const ::std::string& value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.directory)
}
inline void ContainerConfig::set_directory(const char* value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerConfig.directory)
}
inline void ContainerConfig::set_directory(const char* value, size_t size) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  directory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerConfig.directory)
}
inline ::std::string* ContainerConfig::mutable_directory() {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    directory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.directory)
  return directory_;
}
inline ::std::string* ContainerConfig::release_directory() {
  clear_has_directory();
  if (directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = directory_;
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerConfig::set_allocated_directory(::std::string* directory) {
  if (directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete directory_;
  }
  if (directory) {
    set_has_directory();
    directory_ = directory;
  } else {
    clear_has_directory();
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.directory)
}

// optional string user = 4;
inline bool ContainerConfig::has_user() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContainerConfig::set_has_user() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContainerConfig::clear_has_user() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContainerConfig::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& ContainerConfig::user() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.user)
  return *user_;
}
inline void ContainerConfig::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.user)
}
inline void ContainerConfig::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerConfig.user)
}
inline void ContainerConfig::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerConfig.user)
}
inline ::std::string* ContainerConfig::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.user)
  return user_;
}
inline ::std::string* ContainerConfig::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerConfig::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.user)
}

// optional string rootfs = 5;
inline bool ContainerConfig::has_rootfs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContainerConfig::set_has_rootfs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContainerConfig::clear_has_rootfs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContainerConfig::clear_rootfs() {
  if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_->clear();
  }
  clear_has_rootfs();
}
inline const ::std::string& ContainerConfig::rootfs() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.rootfs)
  return *rootfs_;
}
inline void ContainerConfig::set_rootfs(const ::std::string& value) {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  rootfs_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerConfig.rootfs)
}
inline void ContainerConfig::set_rootfs(const char* value) {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  rootfs_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerConfig.rootfs)
}
inline void ContainerConfig::set_rootfs(const char* value, size_t size) {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  rootfs_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerConfig.rootfs)
}
inline ::std::string* ContainerConfig::mutable_rootfs() {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.rootfs)
  return rootfs_;
}
inline ::std::string* ContainerConfig::release_rootfs() {
  clear_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rootfs_;
    rootfs_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerConfig::set_allocated_rootfs(::std::string* rootfs) {
  if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rootfs_;
  }
  if (rootfs) {
    set_has_rootfs();
    rootfs_ = rootfs;
  } else {
    clear_has_rootfs();
    rootfs_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.rootfs)
}

// optional .mesos.slave.ContainerConfig.Docker docker = 7;
inline bool ContainerConfig::has_docker() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContainerConfig::set_has_docker() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContainerConfig::clear_has_docker() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContainerConfig::clear_docker() {
  if (docker_ != NULL) docker_->::mesos::slave::ContainerConfig_Docker::Clear();
  clear_has_docker();
}
inline const ::mesos::slave::ContainerConfig_Docker& ContainerConfig::docker() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.docker)
  return docker_ != NULL ? *docker_ : *default_instance_->docker_;
}
inline ::mesos::slave::ContainerConfig_Docker* ContainerConfig::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) docker_ = new ::mesos::slave::ContainerConfig_Docker;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.docker)
  return docker_;
}
inline ::mesos::slave::ContainerConfig_Docker* ContainerConfig::release_docker() {
  clear_has_docker();
  ::mesos::slave::ContainerConfig_Docker* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline void ContainerConfig::set_allocated_docker(::mesos::slave::ContainerConfig_Docker* docker) {
  delete docker_;
  docker_ = docker;
  if (docker) {
    set_has_docker();
  } else {
    clear_has_docker();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.docker)
}

// optional .mesos.slave.ContainerConfig.Appc appc = 10;
inline bool ContainerConfig::has_appc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ContainerConfig::set_has_appc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ContainerConfig::clear_has_appc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ContainerConfig::clear_appc() {
  if (appc_ != NULL) appc_->::mesos::slave::ContainerConfig_Appc::Clear();
  clear_has_appc();
}
inline const ::mesos::slave::ContainerConfig_Appc& ContainerConfig::appc() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerConfig.appc)
  return appc_ != NULL ? *appc_ : *default_instance_->appc_;
}
inline ::mesos::slave::ContainerConfig_Appc* ContainerConfig::mutable_appc() {
  set_has_appc();
  if (appc_ == NULL) appc_ = new ::mesos::slave::ContainerConfig_Appc;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerConfig.appc)
  return appc_;
}
inline ::mesos::slave::ContainerConfig_Appc* ContainerConfig::release_appc() {
  clear_has_appc();
  ::mesos::slave::ContainerConfig_Appc* temp = appc_;
  appc_ = NULL;
  return temp;
}
inline void ContainerConfig::set_allocated_appc(::mesos::slave::ContainerConfig_Appc* appc) {
  delete appc_;
  appc_ = appc;
  if (appc) {
    set_has_appc();
  } else {
    clear_has_appc();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerConfig.appc)
}

// -------------------------------------------------------------------

// ContainerLaunchInfo

// repeated .mesos.CommandInfo pre_exec_commands = 1;
inline int ContainerLaunchInfo::pre_exec_commands_size() const {
  return pre_exec_commands_.size();
}
inline void ContainerLaunchInfo::clear_pre_exec_commands() {
  pre_exec_commands_.Clear();
}
inline const ::mesos::CommandInfo& ContainerLaunchInfo::pre_exec_commands(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_.Get(index);
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::mutable_pre_exec_commands(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_.Mutable(index);
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::add_pre_exec_commands() {
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >&
ContainerLaunchInfo::pre_exec_commands() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return pre_exec_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo >*
ContainerLaunchInfo::mutable_pre_exec_commands() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.pre_exec_commands)
  return &pre_exec_commands_;
}

// optional .mesos.Environment environment = 2;
inline bool ContainerLaunchInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerLaunchInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerLaunchInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerLaunchInfo::clear_environment() {
  if (environment_ != NULL) environment_->::mesos::Environment::Clear();
  clear_has_environment();
}
inline const ::mesos::Environment& ContainerLaunchInfo::environment() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.environment)
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::mesos::Environment* ContainerLaunchInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::mesos::Environment;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.environment)
  return environment_;
}
inline ::mesos::Environment* ContainerLaunchInfo::release_environment() {
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void ContainerLaunchInfo::set_allocated_environment(::mesos::Environment* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.environment)
}

// optional string rootfs = 3;
inline bool ContainerLaunchInfo::has_rootfs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerLaunchInfo::set_has_rootfs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerLaunchInfo::clear_has_rootfs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerLaunchInfo::clear_rootfs() {
  if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_->clear();
  }
  clear_has_rootfs();
}
inline const ::std::string& ContainerLaunchInfo::rootfs() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.rootfs)
  return *rootfs_;
}
inline void ContainerLaunchInfo::set_rootfs(const ::std::string& value) {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  rootfs_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.rootfs)
}
inline void ContainerLaunchInfo::set_rootfs(const char* value) {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  rootfs_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.rootfs)
}
inline void ContainerLaunchInfo::set_rootfs(const char* value, size_t size) {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  rootfs_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.rootfs)
}
inline ::std::string* ContainerLaunchInfo::mutable_rootfs() {
  set_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rootfs_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.rootfs)
  return rootfs_;
}
inline ::std::string* ContainerLaunchInfo::release_rootfs() {
  clear_has_rootfs();
  if (rootfs_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rootfs_;
    rootfs_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLaunchInfo::set_allocated_rootfs(::std::string* rootfs) {
  if (rootfs_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rootfs_;
  }
  if (rootfs) {
    set_has_rootfs();
    rootfs_ = rootfs;
  } else {
    clear_has_rootfs();
    rootfs_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.rootfs)
}

// repeated int32 enter_namespaces = 9;
inline int ContainerLaunchInfo::enter_namespaces_size() const {
  return enter_namespaces_.size();
}
inline void ContainerLaunchInfo::clear_enter_namespaces() {
  enter_namespaces_.Clear();
}
inline ::google::protobuf::int32 ContainerLaunchInfo::enter_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.enter_namespaces)
  return enter_namespaces_.Get(index);
}
inline void ContainerLaunchInfo::set_enter_namespaces(int index, ::google::protobuf::int32 value) {
  enter_namespaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.enter_namespaces)
}
inline void ContainerLaunchInfo::add_enter_namespaces(::google::protobuf::int32 value) {
  enter_namespaces_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.enter_namespaces)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ContainerLaunchInfo::enter_namespaces() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.enter_namespaces)
  return enter_namespaces_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ContainerLaunchInfo::mutable_enter_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.enter_namespaces)
  return &enter_namespaces_;
}

// repeated int32 clone_namespaces = 4;
inline int ContainerLaunchInfo::clone_namespaces_size() const {
  return clone_namespaces_.size();
}
inline void ContainerLaunchInfo::clear_clone_namespaces() {
  clone_namespaces_.Clear();
}
inline ::google::protobuf::int32 ContainerLaunchInfo::clone_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.clone_namespaces)
  return clone_namespaces_.Get(index);
}
inline void ContainerLaunchInfo::set_clone_namespaces(int index, ::google::protobuf::int32 value) {
  clone_namespaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.clone_namespaces)
}
inline void ContainerLaunchInfo::add_clone_namespaces(::google::protobuf::int32 value) {
  clone_namespaces_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerLaunchInfo.clone_namespaces)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ContainerLaunchInfo::clone_namespaces() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerLaunchInfo.clone_namespaces)
  return clone_namespaces_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ContainerLaunchInfo::mutable_clone_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerLaunchInfo.clone_namespaces)
  return &clone_namespaces_;
}

// optional string user = 10;
inline bool ContainerLaunchInfo::has_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerLaunchInfo::set_has_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerLaunchInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContainerLaunchInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& ContainerLaunchInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.user)
  return *user_;
}
inline void ContainerLaunchInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.user)
}
inline void ContainerLaunchInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.user)
}
inline void ContainerLaunchInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.user)
}
inline ::std::string* ContainerLaunchInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.user)
  return user_;
}
inline ::std::string* ContainerLaunchInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLaunchInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.user)
}

// optional .mesos.CommandInfo command = 5;
inline bool ContainerLaunchInfo::has_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerLaunchInfo::set_has_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerLaunchInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerLaunchInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& ContainerLaunchInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.command)
  return command_;
}
inline ::mesos::CommandInfo* ContainerLaunchInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ContainerLaunchInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.command)
}

// optional string working_directory = 6;
inline bool ContainerLaunchInfo::has_working_directory() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContainerLaunchInfo::set_has_working_directory() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContainerLaunchInfo::clear_has_working_directory() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContainerLaunchInfo::clear_working_directory() {
  if (working_directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_directory_->clear();
  }
  clear_has_working_directory();
}
inline const ::std::string& ContainerLaunchInfo::working_directory() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.working_directory)
  return *working_directory_;
}
inline void ContainerLaunchInfo::set_working_directory(const ::std::string& value) {
  set_has_working_directory();
  if (working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_directory_ = new ::std::string;
  }
  working_directory_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.working_directory)
}
inline void ContainerLaunchInfo::set_working_directory(const char* value) {
  set_has_working_directory();
  if (working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_directory_ = new ::std::string;
  }
  working_directory_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.working_directory)
}
inline void ContainerLaunchInfo::set_working_directory(const char* value, size_t size) {
  set_has_working_directory();
  if (working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_directory_ = new ::std::string;
  }
  working_directory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.working_directory)
}
inline ::std::string* ContainerLaunchInfo::mutable_working_directory() {
  set_has_working_directory();
  if (working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    working_directory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.working_directory)
  return working_directory_;
}
inline ::std::string* ContainerLaunchInfo::release_working_directory() {
  clear_has_working_directory();
  if (working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = working_directory_;
    working_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLaunchInfo::set_allocated_working_directory(::std::string* working_directory) {
  if (working_directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete working_directory_;
  }
  if (working_directory) {
    set_has_working_directory();
    working_directory_ = working_directory;
  } else {
    clear_has_working_directory();
    working_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.working_directory)
}

// optional .mesos.CapabilityInfo capabilities = 7;
inline bool ContainerLaunchInfo::has_capabilities() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContainerLaunchInfo::set_has_capabilities() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContainerLaunchInfo::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContainerLaunchInfo::clear_capabilities() {
  if (capabilities_ != NULL) capabilities_->::mesos::CapabilityInfo::Clear();
  clear_has_capabilities();
}
inline const ::mesos::CapabilityInfo& ContainerLaunchInfo::capabilities() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.capabilities)
  return capabilities_ != NULL ? *capabilities_ : *default_instance_->capabilities_;
}
inline ::mesos::CapabilityInfo* ContainerLaunchInfo::mutable_capabilities() {
  set_has_capabilities();
  if (capabilities_ == NULL) capabilities_ = new ::mesos::CapabilityInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.capabilities)
  return capabilities_;
}
inline ::mesos::CapabilityInfo* ContainerLaunchInfo::release_capabilities() {
  clear_has_capabilities();
  ::mesos::CapabilityInfo* temp = capabilities_;
  capabilities_ = NULL;
  return temp;
}
inline void ContainerLaunchInfo::set_allocated_capabilities(::mesos::CapabilityInfo* capabilities) {
  delete capabilities_;
  capabilities_ = capabilities;
  if (capabilities) {
    set_has_capabilities();
  } else {
    clear_has_capabilities();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.capabilities)
}

// optional .mesos.RLimitInfo rlimits = 8;
inline bool ContainerLaunchInfo::has_rlimits() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContainerLaunchInfo::set_has_rlimits() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContainerLaunchInfo::clear_has_rlimits() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContainerLaunchInfo::clear_rlimits() {
  if (rlimits_ != NULL) rlimits_->::mesos::RLimitInfo::Clear();
  clear_has_rlimits();
}
inline const ::mesos::RLimitInfo& ContainerLaunchInfo::rlimits() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.rlimits)
  return rlimits_ != NULL ? *rlimits_ : *default_instance_->rlimits_;
}
inline ::mesos::RLimitInfo* ContainerLaunchInfo::mutable_rlimits() {
  set_has_rlimits();
  if (rlimits_ == NULL) rlimits_ = new ::mesos::RLimitInfo;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.rlimits)
  return rlimits_;
}
inline ::mesos::RLimitInfo* ContainerLaunchInfo::release_rlimits() {
  clear_has_rlimits();
  ::mesos::RLimitInfo* temp = rlimits_;
  rlimits_ = NULL;
  return temp;
}
inline void ContainerLaunchInfo::set_allocated_rlimits(::mesos::RLimitInfo* rlimits) {
  delete rlimits_;
  rlimits_ = rlimits;
  if (rlimits) {
    set_has_rlimits();
  } else {
    clear_has_rlimits();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.rlimits)
}

// optional string tty_slave_path = 14;
inline bool ContainerLaunchInfo::has_tty_slave_path() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ContainerLaunchInfo::set_has_tty_slave_path() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ContainerLaunchInfo::clear_has_tty_slave_path() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ContainerLaunchInfo::clear_tty_slave_path() {
  if (tty_slave_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tty_slave_path_->clear();
  }
  clear_has_tty_slave_path();
}
inline const ::std::string& ContainerLaunchInfo::tty_slave_path() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.tty_slave_path)
  return *tty_slave_path_;
}
inline void ContainerLaunchInfo::set_tty_slave_path(const ::std::string& value) {
  set_has_tty_slave_path();
  if (tty_slave_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tty_slave_path_ = new ::std::string;
  }
  tty_slave_path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
inline void ContainerLaunchInfo::set_tty_slave_path(const char* value) {
  set_has_tty_slave_path();
  if (tty_slave_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tty_slave_path_ = new ::std::string;
  }
  tty_slave_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
inline void ContainerLaunchInfo::set_tty_slave_path(const char* value, size_t size) {
  set_has_tty_slave_path();
  if (tty_slave_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tty_slave_path_ = new ::std::string;
  }
  tty_slave_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}
inline ::std::string* ContainerLaunchInfo::mutable_tty_slave_path() {
  set_has_tty_slave_path();
  if (tty_slave_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tty_slave_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.tty_slave_path)
  return tty_slave_path_;
}
inline ::std::string* ContainerLaunchInfo::release_tty_slave_path() {
  clear_has_tty_slave_path();
  if (tty_slave_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tty_slave_path_;
    tty_slave_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerLaunchInfo::set_allocated_tty_slave_path(::std::string* tty_slave_path) {
  if (tty_slave_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tty_slave_path_;
  }
  if (tty_slave_path) {
    set_has_tty_slave_path();
    tty_slave_path_ = tty_slave_path;
  } else {
    clear_has_tty_slave_path();
    tty_slave_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.tty_slave_path)
}

// optional .mesos.Environment task_environment = 15;
inline bool ContainerLaunchInfo::has_task_environment() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ContainerLaunchInfo::set_has_task_environment() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ContainerLaunchInfo::clear_has_task_environment() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ContainerLaunchInfo::clear_task_environment() {
  if (task_environment_ != NULL) task_environment_->::mesos::Environment::Clear();
  clear_has_task_environment();
}
inline const ::mesos::Environment& ContainerLaunchInfo::task_environment() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerLaunchInfo.task_environment)
  return task_environment_ != NULL ? *task_environment_ : *default_instance_->task_environment_;
}
inline ::mesos::Environment* ContainerLaunchInfo::mutable_task_environment() {
  set_has_task_environment();
  if (task_environment_ == NULL) task_environment_ = new ::mesos::Environment;
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerLaunchInfo.task_environment)
  return task_environment_;
}
inline ::mesos::Environment* ContainerLaunchInfo::release_task_environment() {
  clear_has_task_environment();
  ::mesos::Environment* temp = task_environment_;
  task_environment_ = NULL;
  return temp;
}
inline void ContainerLaunchInfo::set_allocated_task_environment(::mesos::Environment* task_environment) {
  delete task_environment_;
  task_environment_ = task_environment;
  if (task_environment) {
    set_has_task_environment();
  } else {
    clear_has_task_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerLaunchInfo.task_environment)
}

// -------------------------------------------------------------------

// ContainerTermination

// optional int32 status = 3;
inline bool ContainerTermination::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerTermination::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerTermination::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerTermination::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ContainerTermination::status() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.status)
  return status_;
}
inline void ContainerTermination::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.status)
}

// optional .mesos.TaskState state = 4;
inline bool ContainerTermination::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerTermination::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerTermination::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerTermination::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState ContainerTermination::state() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void ContainerTermination::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.state)
}

// repeated .mesos.TaskStatus.Reason reasons = 5;
inline int ContainerTermination::reasons_size() const {
  return reasons_.size();
}
inline void ContainerTermination::clear_reasons() {
  reasons_.Clear();
}
inline ::mesos::TaskStatus_Reason ContainerTermination::reasons(int index) const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.reasons)
  return static_cast< ::mesos::TaskStatus_Reason >(reasons_.Get(index));
}
inline void ContainerTermination::set_reasons(int index, ::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  reasons_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.reasons)
}
inline void ContainerTermination::add_reasons(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  reasons_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.slave.ContainerTermination.reasons)
}
inline const ::google::protobuf::RepeatedField<int>&
ContainerTermination::reasons() const {
  // @@protoc_insertion_point(field_list:mesos.slave.ContainerTermination.reasons)
  return reasons_;
}
inline ::google::protobuf::RepeatedField<int>*
ContainerTermination::mutable_reasons() {
  // @@protoc_insertion_point(field_mutable_list:mesos.slave.ContainerTermination.reasons)
  return &reasons_;
}

// optional string message = 2;
inline bool ContainerTermination::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerTermination::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerTermination::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerTermination::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ContainerTermination::message() const {
  // @@protoc_insertion_point(field_get:mesos.slave.ContainerTermination.message)
  return *message_;
}
inline void ContainerTermination::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.slave.ContainerTermination.message)
}
inline void ContainerTermination::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.slave.ContainerTermination.message)
}
inline void ContainerTermination::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.slave.ContainerTermination.message)
}
inline ::std::string* ContainerTermination::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.slave.ContainerTermination.message)
  return message_;
}
inline ::std::string* ContainerTermination::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerTermination::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.slave.ContainerTermination.message)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace slave
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::slave::ContainerClass> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::slave::ContainerClass>() {
  return ::mesos::slave::ContainerClass_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_containerizer_2eproto__INCLUDED
