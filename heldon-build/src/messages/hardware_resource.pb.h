// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hardware_resource.proto

#ifndef PROTOBUF_hardware_5fresource_2eproto__INCLUDED
#define PROTOBUF_hardware_5fresource_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_hardware_5fresource_2eproto();
void protobuf_AssignDesc_hardware_5fresource_2eproto();
void protobuf_ShutdownFile_hardware_5fresource_2eproto();

class HardwareResourcesMessage;
class CPUCollection;
class CPUInfo;
class TLBCollection;
class TLBInfo;
class MemoryCollection;
class MemInfo;
class GPUCollection;
class GPUInfo;
class DiskCollection;
class DiskInfo;
class PortCollection;
class PortInfo;

enum DiskInfo_DiskType {
  DiskInfo_DiskType_SSD = 0,
  DiskInfo_DiskType_HDD = 1
};
bool DiskInfo_DiskType_IsValid(int value);
const DiskInfo_DiskType DiskInfo_DiskType_DiskType_MIN = DiskInfo_DiskType_SSD;
const DiskInfo_DiskType DiskInfo_DiskType_DiskType_MAX = DiskInfo_DiskType_HDD;
const int DiskInfo_DiskType_DiskType_ARRAYSIZE = DiskInfo_DiskType_DiskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiskInfo_DiskType_descriptor();
inline const ::std::string& DiskInfo_DiskType_Name(DiskInfo_DiskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiskInfo_DiskType_descriptor(), value);
}
inline bool DiskInfo_DiskType_Parse(
    const ::std::string& name, DiskInfo_DiskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiskInfo_DiskType>(
    DiskInfo_DiskType_descriptor(), name, value);
}
// ===================================================================

class HardwareResourcesMessage : public ::google::protobuf::Message {
 public:
  HardwareResourcesMessage();
  virtual ~HardwareResourcesMessage();

  HardwareResourcesMessage(const HardwareResourcesMessage& from);

  inline HardwareResourcesMessage& operator=(const HardwareResourcesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HardwareResourcesMessage& default_instance();

  void Swap(HardwareResourcesMessage* other);

  // implements Message ----------------------------------------------

  HardwareResourcesMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HardwareResourcesMessage& from);
  void MergeFrom(const HardwareResourcesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::std::string& slave_id() const;
  inline void set_slave_id(const ::std::string& value);
  inline void set_slave_id(const char* value);
  inline void set_slave_id(const char* value, size_t size);
  inline ::std::string* mutable_slave_id();
  inline ::std::string* release_slave_id();
  inline void set_allocated_slave_id(::std::string* slave_id);

  // required string slave_uuid = 8;
  inline bool has_slave_uuid() const;
  inline void clear_slave_uuid();
  static const int kSlaveUuidFieldNumber = 8;
  inline const ::std::string& slave_uuid() const;
  inline void set_slave_uuid(const ::std::string& value);
  inline void set_slave_uuid(const char* value);
  inline void set_slave_uuid(const char* value, size_t size);
  inline ::std::string* mutable_slave_uuid();
  inline ::std::string* release_slave_uuid();
  inline void set_allocated_slave_uuid(::std::string* slave_uuid);

  // required string slave_hostname = 9;
  inline bool has_slave_hostname() const;
  inline void clear_slave_hostname();
  static const int kSlaveHostnameFieldNumber = 9;
  inline const ::std::string& slave_hostname() const;
  inline void set_slave_hostname(const ::std::string& value);
  inline void set_slave_hostname(const char* value);
  inline void set_slave_hostname(const char* value, size_t size);
  inline ::std::string* mutable_slave_hostname();
  inline ::std::string* release_slave_hostname();
  inline void set_allocated_slave_hostname(::std::string* slave_hostname);

  // required .CPUCollection cpu_collection = 2;
  inline bool has_cpu_collection() const;
  inline void clear_cpu_collection();
  static const int kCpuCollectionFieldNumber = 2;
  inline const ::CPUCollection& cpu_collection() const;
  inline ::CPUCollection* mutable_cpu_collection();
  inline ::CPUCollection* release_cpu_collection();
  inline void set_allocated_cpu_collection(::CPUCollection* cpu_collection);

  // required .MemoryCollection mem_collection = 3;
  inline bool has_mem_collection() const;
  inline void clear_mem_collection();
  static const int kMemCollectionFieldNumber = 3;
  inline const ::MemoryCollection& mem_collection() const;
  inline ::MemoryCollection* mutable_mem_collection();
  inline ::MemoryCollection* release_mem_collection();
  inline void set_allocated_mem_collection(::MemoryCollection* mem_collection);

  // required .GPUCollection gpu_collection = 4;
  inline bool has_gpu_collection() const;
  inline void clear_gpu_collection();
  static const int kGpuCollectionFieldNumber = 4;
  inline const ::GPUCollection& gpu_collection() const;
  inline ::GPUCollection* mutable_gpu_collection();
  inline ::GPUCollection* release_gpu_collection();
  inline void set_allocated_gpu_collection(::GPUCollection* gpu_collection);

  // required .DiskCollection disk_collection = 5;
  inline bool has_disk_collection() const;
  inline void clear_disk_collection();
  static const int kDiskCollectionFieldNumber = 5;
  inline const ::DiskCollection& disk_collection() const;
  inline ::DiskCollection* mutable_disk_collection();
  inline ::DiskCollection* release_disk_collection();
  inline void set_allocated_disk_collection(::DiskCollection* disk_collection);

  // required .PortCollection port_collection = 6;
  inline bool has_port_collection() const;
  inline void clear_port_collection();
  static const int kPortCollectionFieldNumber = 6;
  inline const ::PortCollection& port_collection() const;
  inline ::PortCollection* mutable_port_collection();
  inline ::PortCollection* release_port_collection();
  inline void set_allocated_port_collection(::PortCollection* port_collection);

  // required .TLBCollection tlb_collection = 7;
  inline bool has_tlb_collection() const;
  inline void clear_tlb_collection();
  static const int kTlbCollectionFieldNumber = 7;
  inline const ::TLBCollection& tlb_collection() const;
  inline ::TLBCollection* mutable_tlb_collection();
  inline ::TLBCollection* release_tlb_collection();
  inline void set_allocated_tlb_collection(::TLBCollection* tlb_collection);

  // @@protoc_insertion_point(class_scope:HardwareResourcesMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_slave_uuid();
  inline void clear_has_slave_uuid();
  inline void set_has_slave_hostname();
  inline void clear_has_slave_hostname();
  inline void set_has_cpu_collection();
  inline void clear_has_cpu_collection();
  inline void set_has_mem_collection();
  inline void clear_has_mem_collection();
  inline void set_has_gpu_collection();
  inline void clear_has_gpu_collection();
  inline void set_has_disk_collection();
  inline void clear_has_disk_collection();
  inline void set_has_port_collection();
  inline void clear_has_port_collection();
  inline void set_has_tlb_collection();
  inline void clear_has_tlb_collection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* slave_id_;
  ::std::string* slave_uuid_;
  ::std::string* slave_hostname_;
  ::CPUCollection* cpu_collection_;
  ::MemoryCollection* mem_collection_;
  ::GPUCollection* gpu_collection_;
  ::DiskCollection* disk_collection_;
  ::PortCollection* port_collection_;
  ::TLBCollection* tlb_collection_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static HardwareResourcesMessage* default_instance_;
};
// -------------------------------------------------------------------

class CPUCollection : public ::google::protobuf::Message {
 public:
  CPUCollection();
  virtual ~CPUCollection();

  CPUCollection(const CPUCollection& from);

  inline CPUCollection& operator=(const CPUCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPUCollection& default_instance();

  void Swap(CPUCollection* other);

  // implements Message ----------------------------------------------

  CPUCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPUCollection& from);
  void MergeFrom(const CPUCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CPUInfo cpu_infos = 1;
  inline int cpu_infos_size() const;
  inline void clear_cpu_infos();
  static const int kCpuInfosFieldNumber = 1;
  inline const ::CPUInfo& cpu_infos(int index) const;
  inline ::CPUInfo* mutable_cpu_infos(int index);
  inline ::CPUInfo* add_cpu_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::CPUInfo >&
      cpu_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::CPUInfo >*
      mutable_cpu_infos();

  // required int32 cpu_quantity = 2;
  inline bool has_cpu_quantity() const;
  inline void clear_cpu_quantity();
  static const int kCpuQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 cpu_quantity() const;
  inline void set_cpu_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CPUCollection)
 private:
  inline void set_has_cpu_quantity();
  inline void clear_has_cpu_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CPUInfo > cpu_infos_;
  ::google::protobuf::int32 cpu_quantity_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static CPUCollection* default_instance_;
};
// -------------------------------------------------------------------

class CPUInfo : public ::google::protobuf::Message {
 public:
  CPUInfo();
  virtual ~CPUInfo();

  CPUInfo(const CPUInfo& from);

  inline CPUInfo& operator=(const CPUInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPUInfo& default_instance();

  void Swap(CPUInfo* other);

  // implements Message ----------------------------------------------

  CPUInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPUInfo& from);
  void MergeFrom(const CPUInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cpuID = 1;
  inline bool has_cpuid() const;
  inline void clear_cpuid();
  static const int kCpuIDFieldNumber = 1;
  inline ::google::protobuf::int32 cpuid() const;
  inline void set_cpuid(::google::protobuf::int32 value);

  // optional int32 coreID = 2;
  inline bool has_coreid() const;
  inline void clear_coreid();
  static const int kCoreIDFieldNumber = 2;
  inline ::google::protobuf::int32 coreid() const;
  inline void set_coreid(::google::protobuf::int32 value);

  // optional int32 physicalID = 3;
  inline bool has_physicalid() const;
  inline void clear_physicalid();
  static const int kPhysicalIDFieldNumber = 3;
  inline ::google::protobuf::int32 physicalid() const;
  inline void set_physicalid(::google::protobuf::int32 value);

  // optional int32 cpucores = 4;
  inline bool has_cpucores() const;
  inline void clear_cpucores();
  static const int kCpucoresFieldNumber = 4;
  inline ::google::protobuf::int32 cpucores() const;
  inline void set_cpucores(::google::protobuf::int32 value);

  // optional string modelname = 5;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelnameFieldNumber = 5;
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // optional double cpuMHz = 6;
  inline bool has_cpumhz() const;
  inline void clear_cpumhz();
  static const int kCpuMHzFieldNumber = 6;
  inline double cpumhz() const;
  inline void set_cpumhz(double value);

  // optional double cpumaxMhz = 7;
  inline bool has_cpumaxmhz() const;
  inline void clear_cpumaxmhz();
  static const int kCpumaxMhzFieldNumber = 7;
  inline double cpumaxmhz() const;
  inline void set_cpumaxmhz(double value);

  // optional double cpuminMHz = 8;
  inline bool has_cpuminmhz() const;
  inline void clear_cpuminmhz();
  static const int kCpuminMHzFieldNumber = 8;
  inline double cpuminmhz() const;
  inline void set_cpuminmhz(double value);

  // optional string l1dcache = 9;
  inline bool has_l1dcache() const;
  inline void clear_l1dcache();
  static const int kL1DcacheFieldNumber = 9;
  inline const ::std::string& l1dcache() const;
  inline void set_l1dcache(const ::std::string& value);
  inline void set_l1dcache(const char* value);
  inline void set_l1dcache(const char* value, size_t size);
  inline ::std::string* mutable_l1dcache();
  inline ::std::string* release_l1dcache();
  inline void set_allocated_l1dcache(::std::string* l1dcache);

  // optional string l1icache = 10;
  inline bool has_l1icache() const;
  inline void clear_l1icache();
  static const int kL1IcacheFieldNumber = 10;
  inline const ::std::string& l1icache() const;
  inline void set_l1icache(const ::std::string& value);
  inline void set_l1icache(const char* value);
  inline void set_l1icache(const char* value, size_t size);
  inline ::std::string* mutable_l1icache();
  inline ::std::string* release_l1icache();
  inline void set_allocated_l1icache(::std::string* l1icache);

  // optional string l2cache = 11;
  inline bool has_l2cache() const;
  inline void clear_l2cache();
  static const int kL2CacheFieldNumber = 11;
  inline const ::std::string& l2cache() const;
  inline void set_l2cache(const ::std::string& value);
  inline void set_l2cache(const char* value);
  inline void set_l2cache(const char* value, size_t size);
  inline ::std::string* mutable_l2cache();
  inline ::std::string* release_l2cache();
  inline void set_allocated_l2cache(::std::string* l2cache);

  // optional string l3cache = 12;
  inline bool has_l3cache() const;
  inline void clear_l3cache();
  static const int kL3CacheFieldNumber = 12;
  inline const ::std::string& l3cache() const;
  inline void set_l3cache(const ::std::string& value);
  inline void set_l3cache(const char* value);
  inline void set_l3cache(const char* value, size_t size);
  inline ::std::string* mutable_l3cache();
  inline ::std::string* release_l3cache();
  inline void set_allocated_l3cache(::std::string* l3cache);

  // @@protoc_insertion_point(class_scope:CPUInfo)
 private:
  inline void set_has_cpuid();
  inline void clear_has_cpuid();
  inline void set_has_coreid();
  inline void clear_has_coreid();
  inline void set_has_physicalid();
  inline void clear_has_physicalid();
  inline void set_has_cpucores();
  inline void clear_has_cpucores();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_cpumhz();
  inline void clear_has_cpumhz();
  inline void set_has_cpumaxmhz();
  inline void clear_has_cpumaxmhz();
  inline void set_has_cpuminmhz();
  inline void clear_has_cpuminmhz();
  inline void set_has_l1dcache();
  inline void clear_has_l1dcache();
  inline void set_has_l1icache();
  inline void clear_has_l1icache();
  inline void set_has_l2cache();
  inline void clear_has_l2cache();
  inline void set_has_l3cache();
  inline void clear_has_l3cache();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 cpuid_;
  ::google::protobuf::int32 coreid_;
  ::google::protobuf::int32 physicalid_;
  ::google::protobuf::int32 cpucores_;
  ::std::string* modelname_;
  double cpumhz_;
  double cpumaxmhz_;
  double cpuminmhz_;
  ::std::string* l1dcache_;
  ::std::string* l1icache_;
  ::std::string* l2cache_;
  ::std::string* l3cache_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static CPUInfo* default_instance_;
};
// -------------------------------------------------------------------

class TLBCollection : public ::google::protobuf::Message {
 public:
  TLBCollection();
  virtual ~TLBCollection();

  TLBCollection(const TLBCollection& from);

  inline TLBCollection& operator=(const TLBCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLBCollection& default_instance();

  void Swap(TLBCollection* other);

  // implements Message ----------------------------------------------

  TLBCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLBCollection& from);
  void MergeFrom(const TLBCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TLBInfo tlb_infos = 1;
  inline int tlb_infos_size() const;
  inline void clear_tlb_infos();
  static const int kTlbInfosFieldNumber = 1;
  inline const ::TLBInfo& tlb_infos(int index) const;
  inline ::TLBInfo* mutable_tlb_infos(int index);
  inline ::TLBInfo* add_tlb_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TLBInfo >&
      tlb_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TLBInfo >*
      mutable_tlb_infos();

  // @@protoc_insertion_point(class_scope:TLBCollection)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TLBInfo > tlb_infos_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static TLBCollection* default_instance_;
};
// -------------------------------------------------------------------

class TLBInfo : public ::google::protobuf::Message {
 public:
  TLBInfo();
  virtual ~TLBInfo();

  TLBInfo(const TLBInfo& from);

  inline TLBInfo& operator=(const TLBInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TLBInfo& default_instance();

  void Swap(TLBInfo* other);

  // implements Message ----------------------------------------------

  TLBInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TLBInfo& from);
  void MergeFrom(const TLBInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string l1_data_tlb = 1;
  inline int l1_data_tlb_size() const;
  inline void clear_l1_data_tlb();
  static const int kL1DataTlbFieldNumber = 1;
  inline const ::std::string& l1_data_tlb(int index) const;
  inline ::std::string* mutable_l1_data_tlb(int index);
  inline void set_l1_data_tlb(int index, const ::std::string& value);
  inline void set_l1_data_tlb(int index, const char* value);
  inline void set_l1_data_tlb(int index, const char* value, size_t size);
  inline ::std::string* add_l1_data_tlb();
  inline void add_l1_data_tlb(const ::std::string& value);
  inline void add_l1_data_tlb(const char* value);
  inline void add_l1_data_tlb(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l1_data_tlb() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l1_data_tlb();

  // repeated string l1_instruction_tlb = 2;
  inline int l1_instruction_tlb_size() const;
  inline void clear_l1_instruction_tlb();
  static const int kL1InstructionTlbFieldNumber = 2;
  inline const ::std::string& l1_instruction_tlb(int index) const;
  inline ::std::string* mutable_l1_instruction_tlb(int index);
  inline void set_l1_instruction_tlb(int index, const ::std::string& value);
  inline void set_l1_instruction_tlb(int index, const char* value);
  inline void set_l1_instruction_tlb(int index, const char* value, size_t size);
  inline ::std::string* add_l1_instruction_tlb();
  inline void add_l1_instruction_tlb(const ::std::string& value);
  inline void add_l1_instruction_tlb(const char* value);
  inline void add_l1_instruction_tlb(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& l1_instruction_tlb() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_l1_instruction_tlb();

  // optional string l2_tlb = 3;
  inline bool has_l2_tlb() const;
  inline void clear_l2_tlb();
  static const int kL2TlbFieldNumber = 3;
  inline const ::std::string& l2_tlb() const;
  inline void set_l2_tlb(const ::std::string& value);
  inline void set_l2_tlb(const char* value);
  inline void set_l2_tlb(const char* value, size_t size);
  inline ::std::string* mutable_l2_tlb();
  inline ::std::string* release_l2_tlb();
  inline void set_allocated_l2_tlb(::std::string* l2_tlb);

  // @@protoc_insertion_point(class_scope:TLBInfo)
 private:
  inline void set_has_l2_tlb();
  inline void clear_has_l2_tlb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l1_data_tlb_;
  ::google::protobuf::RepeatedPtrField< ::std::string> l1_instruction_tlb_;
  ::std::string* l2_tlb_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static TLBInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemoryCollection : public ::google::protobuf::Message {
 public:
  MemoryCollection();
  virtual ~MemoryCollection();

  MemoryCollection(const MemoryCollection& from);

  inline MemoryCollection& operator=(const MemoryCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemoryCollection& default_instance();

  void Swap(MemoryCollection* other);

  // implements Message ----------------------------------------------

  MemoryCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemoryCollection& from);
  void MergeFrom(const MemoryCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string max_size = 1;
  inline bool has_max_size() const;
  inline void clear_max_size();
  static const int kMaxSizeFieldNumber = 1;
  inline const ::std::string& max_size() const;
  inline void set_max_size(const ::std::string& value);
  inline void set_max_size(const char* value);
  inline void set_max_size(const char* value, size_t size);
  inline ::std::string* mutable_max_size();
  inline ::std::string* release_max_size();
  inline void set_allocated_max_size(::std::string* max_size);

  // required int32 device_quantity = 2;
  inline bool has_device_quantity() const;
  inline void clear_device_quantity();
  static const int kDeviceQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 device_quantity() const;
  inline void set_device_quantity(::google::protobuf::int32 value);

  // repeated .MemInfo mem_infos = 3;
  inline int mem_infos_size() const;
  inline void clear_mem_infos();
  static const int kMemInfosFieldNumber = 3;
  inline const ::MemInfo& mem_infos(int index) const;
  inline ::MemInfo* mutable_mem_infos(int index);
  inline ::MemInfo* add_mem_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::MemInfo >&
      mem_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::MemInfo >*
      mutable_mem_infos();

  // @@protoc_insertion_point(class_scope:MemoryCollection)
 private:
  inline void set_has_max_size();
  inline void clear_has_max_size();
  inline void set_has_device_quantity();
  inline void clear_has_device_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* max_size_;
  ::google::protobuf::RepeatedPtrField< ::MemInfo > mem_infos_;
  ::google::protobuf::int32 device_quantity_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static MemoryCollection* default_instance_;
};
// -------------------------------------------------------------------

class MemInfo : public ::google::protobuf::Message {
 public:
  MemInfo();
  virtual ~MemInfo();

  MemInfo(const MemInfo& from);

  inline MemInfo& operator=(const MemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemInfo& default_instance();

  void Swap(MemInfo* other);

  // implements Message ----------------------------------------------

  MemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemInfo& from);
  void MergeFrom(const MemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline const ::std::string& size() const;
  inline void set_size(const ::std::string& value);
  inline void set_size(const char* value);
  inline void set_size(const char* value, size_t size);
  inline ::std::string* mutable_size();
  inline ::std::string* release_size();
  inline void set_allocated_size(::std::string* size);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline const ::std::string& speed() const;
  inline void set_speed(const ::std::string& value);
  inline void set_speed(const char* value);
  inline void set_speed(const char* value, size_t size);
  inline ::std::string* mutable_speed();
  inline ::std::string* release_speed();
  inline void set_allocated_speed(::std::string* speed);

  // @@protoc_insertion_point(class_scope:MemInfo)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* size_;
  ::std::string* type_;
  ::std::string* speed_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static MemInfo* default_instance_;
};
// -------------------------------------------------------------------

class GPUCollection : public ::google::protobuf::Message {
 public:
  GPUCollection();
  virtual ~GPUCollection();

  GPUCollection(const GPUCollection& from);

  inline GPUCollection& operator=(const GPUCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUCollection& default_instance();

  void Swap(GPUCollection* other);

  // implements Message ----------------------------------------------

  GPUCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUCollection& from);
  void MergeFrom(const GPUCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GPUInfo gpu_infos = 1;
  inline int gpu_infos_size() const;
  inline void clear_gpu_infos();
  static const int kGpuInfosFieldNumber = 1;
  inline const ::GPUInfo& gpu_infos(int index) const;
  inline ::GPUInfo* mutable_gpu_infos(int index);
  inline ::GPUInfo* add_gpu_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::GPUInfo >&
      gpu_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::GPUInfo >*
      mutable_gpu_infos();

  // required int32 gpu_quantity = 2;
  inline bool has_gpu_quantity() const;
  inline void clear_gpu_quantity();
  static const int kGpuQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 gpu_quantity() const;
  inline void set_gpu_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GPUCollection)
 private:
  inline void set_has_gpu_quantity();
  inline void clear_has_gpu_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GPUInfo > gpu_infos_;
  ::google::protobuf::int32 gpu_quantity_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static GPUCollection* default_instance_;
};
// -------------------------------------------------------------------

class GPUInfo : public ::google::protobuf::Message {
 public:
  GPUInfo();
  virtual ~GPUInfo();

  GPUInfo(const GPUInfo& from);

  inline GPUInfo& operator=(const GPUInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPUInfo& default_instance();

  void Swap(GPUInfo* other);

  // implements Message ----------------------------------------------

  GPUInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPUInfo& from);
  void MergeFrom(const GPUInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required string product = 3;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 3;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // required string vendor = 4;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 4;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // optional int32 physical_id = 5;
  inline bool has_physical_id() const;
  inline void clear_physical_id();
  static const int kPhysicalIdFieldNumber = 5;
  inline ::google::protobuf::int32 physical_id() const;
  inline void set_physical_id(::google::protobuf::int32 value);

  // optional string bus_info = 6;
  inline bool has_bus_info() const;
  inline void clear_bus_info();
  static const int kBusInfoFieldNumber = 6;
  inline const ::std::string& bus_info() const;
  inline void set_bus_info(const ::std::string& value);
  inline void set_bus_info(const char* value);
  inline void set_bus_info(const char* value, size_t size);
  inline ::std::string* mutable_bus_info();
  inline ::std::string* release_bus_info();
  inline void set_allocated_bus_info(::std::string* bus_info);

  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 width = 8;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 8;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 clock = 9;
  inline bool has_clock() const;
  inline void clear_clock();
  static const int kClockFieldNumber = 9;
  inline ::google::protobuf::int32 clock() const;
  inline void set_clock(::google::protobuf::int32 value);

  // optional string capabilities = 10;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 10;
  inline const ::std::string& capabilities() const;
  inline void set_capabilities(const ::std::string& value);
  inline void set_capabilities(const char* value);
  inline void set_capabilities(const char* value, size_t size);
  inline ::std::string* mutable_capabilities();
  inline ::std::string* release_capabilities();
  inline void set_allocated_capabilities(::std::string* capabilities);

  // optional string configuration = 11;
  inline bool has_configuration() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 11;
  inline const ::std::string& configuration() const;
  inline void set_configuration(const ::std::string& value);
  inline void set_configuration(const char* value);
  inline void set_configuration(const char* value, size_t size);
  inline ::std::string* mutable_configuration();
  inline ::std::string* release_configuration();
  inline void set_allocated_configuration(::std::string* configuration);

  // optional string resources = 12;
  inline bool has_resources() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 12;
  inline const ::std::string& resources() const;
  inline void set_resources(const ::std::string& value);
  inline void set_resources(const char* value);
  inline void set_resources(const char* value, size_t size);
  inline ::std::string* mutable_resources();
  inline ::std::string* release_resources();
  inline void set_allocated_resources(::std::string* resources);

  // @@protoc_insertion_point(class_scope:GPUInfo)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_physical_id();
  inline void clear_has_physical_id();
  inline void set_has_bus_info();
  inline void clear_has_bus_info();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_clock();
  inline void clear_has_clock();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_configuration();
  inline void clear_has_configuration();
  inline void set_has_resources();
  inline void clear_has_resources();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* description_;
  ::std::string* product_;
  ::std::string* vendor_;
  ::std::string* bus_info_;
  ::google::protobuf::int32 physical_id_;
  ::google::protobuf::int32 width_;
  ::std::string* version_;
  ::std::string* capabilities_;
  ::std::string* configuration_;
  ::std::string* resources_;
  ::google::protobuf::int32 clock_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static GPUInfo* default_instance_;
};
// -------------------------------------------------------------------

class DiskCollection : public ::google::protobuf::Message {
 public:
  DiskCollection();
  virtual ~DiskCollection();

  DiskCollection(const DiskCollection& from);

  inline DiskCollection& operator=(const DiskCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskCollection& default_instance();

  void Swap(DiskCollection* other);

  // implements Message ----------------------------------------------

  DiskCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskCollection& from);
  void MergeFrom(const DiskCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DiskInfo disk_infos = 1;
  inline int disk_infos_size() const;
  inline void clear_disk_infos();
  static const int kDiskInfosFieldNumber = 1;
  inline const ::DiskInfo& disk_infos(int index) const;
  inline ::DiskInfo* mutable_disk_infos(int index);
  inline ::DiskInfo* add_disk_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::DiskInfo >&
      disk_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::DiskInfo >*
      mutable_disk_infos();

  // required int32 disk_quantity = 2;
  inline bool has_disk_quantity() const;
  inline void clear_disk_quantity();
  static const int kDiskQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 disk_quantity() const;
  inline void set_disk_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DiskCollection)
 private:
  inline void set_has_disk_quantity();
  inline void clear_has_disk_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DiskInfo > disk_infos_;
  ::google::protobuf::int32 disk_quantity_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static DiskCollection* default_instance_;
};
// -------------------------------------------------------------------

class DiskInfo : public ::google::protobuf::Message {
 public:
  DiskInfo();
  virtual ~DiskInfo();

  DiskInfo(const DiskInfo& from);

  inline DiskInfo& operator=(const DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskInfo& default_instance();

  void Swap(DiskInfo* other);

  // implements Message ----------------------------------------------

  DiskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskInfo& from);
  void MergeFrom(const DiskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DiskInfo_DiskType DiskType;
  static const DiskType SSD = DiskInfo_DiskType_SSD;
  static const DiskType HDD = DiskInfo_DiskType_HDD;
  static inline bool DiskType_IsValid(int value) {
    return DiskInfo_DiskType_IsValid(value);
  }
  static const DiskType DiskType_MIN =
    DiskInfo_DiskType_DiskType_MIN;
  static const DiskType DiskType_MAX =
    DiskInfo_DiskType_DiskType_MAX;
  static const int DiskType_ARRAYSIZE =
    DiskInfo_DiskType_DiskType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DiskType_descriptor() {
    return DiskInfo_DiskType_descriptor();
  }
  static inline const ::std::string& DiskType_Name(DiskType value) {
    return DiskInfo_DiskType_Name(value);
  }
  static inline bool DiskType_Parse(const ::std::string& name,
      DiskType* value) {
    return DiskInfo_DiskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::std::string& size() const;
  inline void set_size(const ::std::string& value);
  inline void set_size(const char* value);
  inline void set_size(const char* value, size_t size);
  inline ::std::string* mutable_size();
  inline ::std::string* release_size();
  inline void set_allocated_size(::std::string* size);

  // required .DiskInfo.DiskType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::DiskInfo_DiskType type() const;
  inline void set_type(::DiskInfo_DiskType value);

  // required string disk_speed = 4;
  inline bool has_disk_speed() const;
  inline void clear_disk_speed();
  static const int kDiskSpeedFieldNumber = 4;
  inline const ::std::string& disk_speed() const;
  inline void set_disk_speed(const ::std::string& value);
  inline void set_disk_speed(const char* value);
  inline void set_disk_speed(const char* value, size_t size);
  inline ::std::string* mutable_disk_speed();
  inline ::std::string* release_disk_speed();
  inline void set_allocated_disk_speed(::std::string* disk_speed);

  // @@protoc_insertion_point(class_scope:DiskInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_disk_speed();
  inline void clear_has_disk_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* size_;
  ::std::string* disk_speed_;
  int type_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static DiskInfo* default_instance_;
};
// -------------------------------------------------------------------

class PortCollection : public ::google::protobuf::Message {
 public:
  PortCollection();
  virtual ~PortCollection();

  PortCollection(const PortCollection& from);

  inline PortCollection& operator=(const PortCollection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortCollection& default_instance();

  void Swap(PortCollection* other);

  // implements Message ----------------------------------------------

  PortCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortCollection& from);
  void MergeFrom(const PortCollection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PortInfo port_infos = 1;
  inline int port_infos_size() const;
  inline void clear_port_infos();
  static const int kPortInfosFieldNumber = 1;
  inline const ::PortInfo& port_infos(int index) const;
  inline ::PortInfo* mutable_port_infos(int index);
  inline ::PortInfo* add_port_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::PortInfo >&
      port_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::PortInfo >*
      mutable_port_infos();

  // required int32 port_quantity = 2;
  inline bool has_port_quantity() const;
  inline void clear_port_quantity();
  static const int kPortQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 port_quantity() const;
  inline void set_port_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PortCollection)
 private:
  inline void set_has_port_quantity();
  inline void clear_has_port_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PortInfo > port_infos_;
  ::google::protobuf::int32 port_quantity_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static PortCollection* default_instance_;
};
// -------------------------------------------------------------------

class PortInfo : public ::google::protobuf::Message {
 public:
  PortInfo();
  virtual ~PortInfo();

  PortInfo(const PortInfo& from);

  inline PortInfo& operator=(const PortInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortInfo& default_instance();

  void Swap(PortInfo* other);

  // implements Message ----------------------------------------------

  PortInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortInfo& from);
  void MergeFrom(const PortInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string firstport = 1;
  inline bool has_firstport() const;
  inline void clear_firstport();
  static const int kFirstportFieldNumber = 1;
  inline const ::std::string& firstport() const;
  inline void set_firstport(const ::std::string& value);
  inline void set_firstport(const char* value);
  inline void set_firstport(const char* value, size_t size);
  inline ::std::string* mutable_firstport();
  inline ::std::string* release_firstport();
  inline void set_allocated_firstport(::std::string* firstport);

  // optional string lastport = 2;
  inline bool has_lastport() const;
  inline void clear_lastport();
  static const int kLastportFieldNumber = 2;
  inline const ::std::string& lastport() const;
  inline void set_lastport(const ::std::string& value);
  inline void set_lastport(const char* value);
  inline void set_lastport(const char* value, size_t size);
  inline ::std::string* mutable_lastport();
  inline ::std::string* release_lastport();
  inline void set_allocated_lastport(::std::string* lastport);

  // @@protoc_insertion_point(class_scope:PortInfo)
 private:
  inline void set_has_firstport();
  inline void clear_has_firstport();
  inline void set_has_lastport();
  inline void clear_has_lastport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* firstport_;
  ::std::string* lastport_;
  friend void  protobuf_AddDesc_hardware_5fresource_2eproto();
  friend void protobuf_AssignDesc_hardware_5fresource_2eproto();
  friend void protobuf_ShutdownFile_hardware_5fresource_2eproto();

  void InitAsDefaultInstance();
  static PortInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// HardwareResourcesMessage

// required string slave_id = 1;
inline bool HardwareResourcesMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HardwareResourcesMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HardwareResourcesMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HardwareResourcesMessage::clear_slave_id() {
  if (slave_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_->clear();
  }
  clear_has_slave_id();
}
inline const ::std::string& HardwareResourcesMessage::slave_id() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.slave_id)
  return *slave_id_;
}
inline void HardwareResourcesMessage::set_slave_id(const ::std::string& value) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(value);
  // @@protoc_insertion_point(field_set:HardwareResourcesMessage.slave_id)
}
inline void HardwareResourcesMessage::set_slave_id(const char* value) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:HardwareResourcesMessage.slave_id)
}
inline void HardwareResourcesMessage::set_slave_id(const char* value, size_t size) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HardwareResourcesMessage.slave_id)
}
inline ::std::string* HardwareResourcesMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.slave_id)
  return slave_id_;
}
inline ::std::string* HardwareResourcesMessage::release_slave_id() {
  clear_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_id_;
    slave_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HardwareResourcesMessage::set_allocated_slave_id(::std::string* slave_id) {
  if (slave_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_id_;
  }
  if (slave_id) {
    set_has_slave_id();
    slave_id_ = slave_id;
  } else {
    clear_has_slave_id();
    slave_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.slave_id)
}

// required string slave_uuid = 8;
inline bool HardwareResourcesMessage::has_slave_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HardwareResourcesMessage::set_has_slave_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HardwareResourcesMessage::clear_has_slave_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HardwareResourcesMessage::clear_slave_uuid() {
  if (slave_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_->clear();
  }
  clear_has_slave_uuid();
}
inline const ::std::string& HardwareResourcesMessage::slave_uuid() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.slave_uuid)
  return *slave_uuid_;
}
inline void HardwareResourcesMessage::set_slave_uuid(const ::std::string& value) {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  slave_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:HardwareResourcesMessage.slave_uuid)
}
inline void HardwareResourcesMessage::set_slave_uuid(const char* value) {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  slave_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:HardwareResourcesMessage.slave_uuid)
}
inline void HardwareResourcesMessage::set_slave_uuid(const char* value, size_t size) {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  slave_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HardwareResourcesMessage.slave_uuid)
}
inline ::std::string* HardwareResourcesMessage::mutable_slave_uuid() {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.slave_uuid)
  return slave_uuid_;
}
inline ::std::string* HardwareResourcesMessage::release_slave_uuid() {
  clear_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_uuid_;
    slave_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HardwareResourcesMessage::set_allocated_slave_uuid(::std::string* slave_uuid) {
  if (slave_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_uuid_;
  }
  if (slave_uuid) {
    set_has_slave_uuid();
    slave_uuid_ = slave_uuid;
  } else {
    clear_has_slave_uuid();
    slave_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.slave_uuid)
}

// required string slave_hostname = 9;
inline bool HardwareResourcesMessage::has_slave_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HardwareResourcesMessage::set_has_slave_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HardwareResourcesMessage::clear_has_slave_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HardwareResourcesMessage::clear_slave_hostname() {
  if (slave_hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_hostname_->clear();
  }
  clear_has_slave_hostname();
}
inline const ::std::string& HardwareResourcesMessage::slave_hostname() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.slave_hostname)
  return *slave_hostname_;
}
inline void HardwareResourcesMessage::set_slave_hostname(const ::std::string& value) {
  set_has_slave_hostname();
  if (slave_hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_hostname_ = new ::std::string;
  }
  slave_hostname_->assign(value);
  // @@protoc_insertion_point(field_set:HardwareResourcesMessage.slave_hostname)
}
inline void HardwareResourcesMessage::set_slave_hostname(const char* value) {
  set_has_slave_hostname();
  if (slave_hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_hostname_ = new ::std::string;
  }
  slave_hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:HardwareResourcesMessage.slave_hostname)
}
inline void HardwareResourcesMessage::set_slave_hostname(const char* value, size_t size) {
  set_has_slave_hostname();
  if (slave_hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_hostname_ = new ::std::string;
  }
  slave_hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HardwareResourcesMessage.slave_hostname)
}
inline ::std::string* HardwareResourcesMessage::mutable_slave_hostname() {
  set_has_slave_hostname();
  if (slave_hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.slave_hostname)
  return slave_hostname_;
}
inline ::std::string* HardwareResourcesMessage::release_slave_hostname() {
  clear_has_slave_hostname();
  if (slave_hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_hostname_;
    slave_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HardwareResourcesMessage::set_allocated_slave_hostname(::std::string* slave_hostname) {
  if (slave_hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_hostname_;
  }
  if (slave_hostname) {
    set_has_slave_hostname();
    slave_hostname_ = slave_hostname;
  } else {
    clear_has_slave_hostname();
    slave_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.slave_hostname)
}

// required .CPUCollection cpu_collection = 2;
inline bool HardwareResourcesMessage::has_cpu_collection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HardwareResourcesMessage::set_has_cpu_collection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HardwareResourcesMessage::clear_has_cpu_collection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HardwareResourcesMessage::clear_cpu_collection() {
  if (cpu_collection_ != NULL) cpu_collection_->::CPUCollection::Clear();
  clear_has_cpu_collection();
}
inline const ::CPUCollection& HardwareResourcesMessage::cpu_collection() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.cpu_collection)
  return cpu_collection_ != NULL ? *cpu_collection_ : *default_instance_->cpu_collection_;
}
inline ::CPUCollection* HardwareResourcesMessage::mutable_cpu_collection() {
  set_has_cpu_collection();
  if (cpu_collection_ == NULL) cpu_collection_ = new ::CPUCollection;
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.cpu_collection)
  return cpu_collection_;
}
inline ::CPUCollection* HardwareResourcesMessage::release_cpu_collection() {
  clear_has_cpu_collection();
  ::CPUCollection* temp = cpu_collection_;
  cpu_collection_ = NULL;
  return temp;
}
inline void HardwareResourcesMessage::set_allocated_cpu_collection(::CPUCollection* cpu_collection) {
  delete cpu_collection_;
  cpu_collection_ = cpu_collection;
  if (cpu_collection) {
    set_has_cpu_collection();
  } else {
    clear_has_cpu_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.cpu_collection)
}

// required .MemoryCollection mem_collection = 3;
inline bool HardwareResourcesMessage::has_mem_collection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HardwareResourcesMessage::set_has_mem_collection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HardwareResourcesMessage::clear_has_mem_collection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HardwareResourcesMessage::clear_mem_collection() {
  if (mem_collection_ != NULL) mem_collection_->::MemoryCollection::Clear();
  clear_has_mem_collection();
}
inline const ::MemoryCollection& HardwareResourcesMessage::mem_collection() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.mem_collection)
  return mem_collection_ != NULL ? *mem_collection_ : *default_instance_->mem_collection_;
}
inline ::MemoryCollection* HardwareResourcesMessage::mutable_mem_collection() {
  set_has_mem_collection();
  if (mem_collection_ == NULL) mem_collection_ = new ::MemoryCollection;
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.mem_collection)
  return mem_collection_;
}
inline ::MemoryCollection* HardwareResourcesMessage::release_mem_collection() {
  clear_has_mem_collection();
  ::MemoryCollection* temp = mem_collection_;
  mem_collection_ = NULL;
  return temp;
}
inline void HardwareResourcesMessage::set_allocated_mem_collection(::MemoryCollection* mem_collection) {
  delete mem_collection_;
  mem_collection_ = mem_collection;
  if (mem_collection) {
    set_has_mem_collection();
  } else {
    clear_has_mem_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.mem_collection)
}

// required .GPUCollection gpu_collection = 4;
inline bool HardwareResourcesMessage::has_gpu_collection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HardwareResourcesMessage::set_has_gpu_collection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HardwareResourcesMessage::clear_has_gpu_collection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HardwareResourcesMessage::clear_gpu_collection() {
  if (gpu_collection_ != NULL) gpu_collection_->::GPUCollection::Clear();
  clear_has_gpu_collection();
}
inline const ::GPUCollection& HardwareResourcesMessage::gpu_collection() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.gpu_collection)
  return gpu_collection_ != NULL ? *gpu_collection_ : *default_instance_->gpu_collection_;
}
inline ::GPUCollection* HardwareResourcesMessage::mutable_gpu_collection() {
  set_has_gpu_collection();
  if (gpu_collection_ == NULL) gpu_collection_ = new ::GPUCollection;
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.gpu_collection)
  return gpu_collection_;
}
inline ::GPUCollection* HardwareResourcesMessage::release_gpu_collection() {
  clear_has_gpu_collection();
  ::GPUCollection* temp = gpu_collection_;
  gpu_collection_ = NULL;
  return temp;
}
inline void HardwareResourcesMessage::set_allocated_gpu_collection(::GPUCollection* gpu_collection) {
  delete gpu_collection_;
  gpu_collection_ = gpu_collection;
  if (gpu_collection) {
    set_has_gpu_collection();
  } else {
    clear_has_gpu_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.gpu_collection)
}

// required .DiskCollection disk_collection = 5;
inline bool HardwareResourcesMessage::has_disk_collection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HardwareResourcesMessage::set_has_disk_collection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HardwareResourcesMessage::clear_has_disk_collection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HardwareResourcesMessage::clear_disk_collection() {
  if (disk_collection_ != NULL) disk_collection_->::DiskCollection::Clear();
  clear_has_disk_collection();
}
inline const ::DiskCollection& HardwareResourcesMessage::disk_collection() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.disk_collection)
  return disk_collection_ != NULL ? *disk_collection_ : *default_instance_->disk_collection_;
}
inline ::DiskCollection* HardwareResourcesMessage::mutable_disk_collection() {
  set_has_disk_collection();
  if (disk_collection_ == NULL) disk_collection_ = new ::DiskCollection;
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.disk_collection)
  return disk_collection_;
}
inline ::DiskCollection* HardwareResourcesMessage::release_disk_collection() {
  clear_has_disk_collection();
  ::DiskCollection* temp = disk_collection_;
  disk_collection_ = NULL;
  return temp;
}
inline void HardwareResourcesMessage::set_allocated_disk_collection(::DiskCollection* disk_collection) {
  delete disk_collection_;
  disk_collection_ = disk_collection;
  if (disk_collection) {
    set_has_disk_collection();
  } else {
    clear_has_disk_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.disk_collection)
}

// required .PortCollection port_collection = 6;
inline bool HardwareResourcesMessage::has_port_collection() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HardwareResourcesMessage::set_has_port_collection() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HardwareResourcesMessage::clear_has_port_collection() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HardwareResourcesMessage::clear_port_collection() {
  if (port_collection_ != NULL) port_collection_->::PortCollection::Clear();
  clear_has_port_collection();
}
inline const ::PortCollection& HardwareResourcesMessage::port_collection() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.port_collection)
  return port_collection_ != NULL ? *port_collection_ : *default_instance_->port_collection_;
}
inline ::PortCollection* HardwareResourcesMessage::mutable_port_collection() {
  set_has_port_collection();
  if (port_collection_ == NULL) port_collection_ = new ::PortCollection;
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.port_collection)
  return port_collection_;
}
inline ::PortCollection* HardwareResourcesMessage::release_port_collection() {
  clear_has_port_collection();
  ::PortCollection* temp = port_collection_;
  port_collection_ = NULL;
  return temp;
}
inline void HardwareResourcesMessage::set_allocated_port_collection(::PortCollection* port_collection) {
  delete port_collection_;
  port_collection_ = port_collection;
  if (port_collection) {
    set_has_port_collection();
  } else {
    clear_has_port_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.port_collection)
}

// required .TLBCollection tlb_collection = 7;
inline bool HardwareResourcesMessage::has_tlb_collection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HardwareResourcesMessage::set_has_tlb_collection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HardwareResourcesMessage::clear_has_tlb_collection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HardwareResourcesMessage::clear_tlb_collection() {
  if (tlb_collection_ != NULL) tlb_collection_->::TLBCollection::Clear();
  clear_has_tlb_collection();
}
inline const ::TLBCollection& HardwareResourcesMessage::tlb_collection() const {
  // @@protoc_insertion_point(field_get:HardwareResourcesMessage.tlb_collection)
  return tlb_collection_ != NULL ? *tlb_collection_ : *default_instance_->tlb_collection_;
}
inline ::TLBCollection* HardwareResourcesMessage::mutable_tlb_collection() {
  set_has_tlb_collection();
  if (tlb_collection_ == NULL) tlb_collection_ = new ::TLBCollection;
  // @@protoc_insertion_point(field_mutable:HardwareResourcesMessage.tlb_collection)
  return tlb_collection_;
}
inline ::TLBCollection* HardwareResourcesMessage::release_tlb_collection() {
  clear_has_tlb_collection();
  ::TLBCollection* temp = tlb_collection_;
  tlb_collection_ = NULL;
  return temp;
}
inline void HardwareResourcesMessage::set_allocated_tlb_collection(::TLBCollection* tlb_collection) {
  delete tlb_collection_;
  tlb_collection_ = tlb_collection;
  if (tlb_collection) {
    set_has_tlb_collection();
  } else {
    clear_has_tlb_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:HardwareResourcesMessage.tlb_collection)
}

// -------------------------------------------------------------------

// CPUCollection

// repeated .CPUInfo cpu_infos = 1;
inline int CPUCollection::cpu_infos_size() const {
  return cpu_infos_.size();
}
inline void CPUCollection::clear_cpu_infos() {
  cpu_infos_.Clear();
}
inline const ::CPUInfo& CPUCollection::cpu_infos(int index) const {
  // @@protoc_insertion_point(field_get:CPUCollection.cpu_infos)
  return cpu_infos_.Get(index);
}
inline ::CPUInfo* CPUCollection::mutable_cpu_infos(int index) {
  // @@protoc_insertion_point(field_mutable:CPUCollection.cpu_infos)
  return cpu_infos_.Mutable(index);
}
inline ::CPUInfo* CPUCollection::add_cpu_infos() {
  // @@protoc_insertion_point(field_add:CPUCollection.cpu_infos)
  return cpu_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CPUInfo >&
CPUCollection::cpu_infos() const {
  // @@protoc_insertion_point(field_list:CPUCollection.cpu_infos)
  return cpu_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::CPUInfo >*
CPUCollection::mutable_cpu_infos() {
  // @@protoc_insertion_point(field_mutable_list:CPUCollection.cpu_infos)
  return &cpu_infos_;
}

// required int32 cpu_quantity = 2;
inline bool CPUCollection::has_cpu_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPUCollection::set_has_cpu_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPUCollection::clear_has_cpu_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPUCollection::clear_cpu_quantity() {
  cpu_quantity_ = 0;
  clear_has_cpu_quantity();
}
inline ::google::protobuf::int32 CPUCollection::cpu_quantity() const {
  // @@protoc_insertion_point(field_get:CPUCollection.cpu_quantity)
  return cpu_quantity_;
}
inline void CPUCollection::set_cpu_quantity(::google::protobuf::int32 value) {
  set_has_cpu_quantity();
  cpu_quantity_ = value;
  // @@protoc_insertion_point(field_set:CPUCollection.cpu_quantity)
}

// -------------------------------------------------------------------

// CPUInfo

// required int32 cpuID = 1;
inline bool CPUInfo::has_cpuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPUInfo::set_has_cpuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPUInfo::clear_has_cpuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPUInfo::clear_cpuid() {
  cpuid_ = 0;
  clear_has_cpuid();
}
inline ::google::protobuf::int32 CPUInfo::cpuid() const {
  // @@protoc_insertion_point(field_get:CPUInfo.cpuID)
  return cpuid_;
}
inline void CPUInfo::set_cpuid(::google::protobuf::int32 value) {
  set_has_cpuid();
  cpuid_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.cpuID)
}

// optional int32 coreID = 2;
inline bool CPUInfo::has_coreid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPUInfo::set_has_coreid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPUInfo::clear_has_coreid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPUInfo::clear_coreid() {
  coreid_ = 0;
  clear_has_coreid();
}
inline ::google::protobuf::int32 CPUInfo::coreid() const {
  // @@protoc_insertion_point(field_get:CPUInfo.coreID)
  return coreid_;
}
inline void CPUInfo::set_coreid(::google::protobuf::int32 value) {
  set_has_coreid();
  coreid_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.coreID)
}

// optional int32 physicalID = 3;
inline bool CPUInfo::has_physicalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPUInfo::set_has_physicalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPUInfo::clear_has_physicalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPUInfo::clear_physicalid() {
  physicalid_ = 0;
  clear_has_physicalid();
}
inline ::google::protobuf::int32 CPUInfo::physicalid() const {
  // @@protoc_insertion_point(field_get:CPUInfo.physicalID)
  return physicalid_;
}
inline void CPUInfo::set_physicalid(::google::protobuf::int32 value) {
  set_has_physicalid();
  physicalid_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.physicalID)
}

// optional int32 cpucores = 4;
inline bool CPUInfo::has_cpucores() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CPUInfo::set_has_cpucores() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CPUInfo::clear_has_cpucores() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CPUInfo::clear_cpucores() {
  cpucores_ = 0;
  clear_has_cpucores();
}
inline ::google::protobuf::int32 CPUInfo::cpucores() const {
  // @@protoc_insertion_point(field_get:CPUInfo.cpucores)
  return cpucores_;
}
inline void CPUInfo::set_cpucores(::google::protobuf::int32 value) {
  set_has_cpucores();
  cpucores_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.cpucores)
}

// optional string modelname = 5;
inline bool CPUInfo::has_modelname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CPUInfo::set_has_modelname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CPUInfo::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CPUInfo::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& CPUInfo::modelname() const {
  // @@protoc_insertion_point(field_get:CPUInfo.modelname)
  return *modelname_;
}
inline void CPUInfo::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set:CPUInfo.modelname)
}
inline void CPUInfo::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:CPUInfo.modelname)
}
inline void CPUInfo::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CPUInfo.modelname)
}
inline ::std::string* CPUInfo::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CPUInfo.modelname)
  return modelname_;
}
inline ::std::string* CPUInfo::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CPUInfo::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CPUInfo.modelname)
}

// optional double cpuMHz = 6;
inline bool CPUInfo::has_cpumhz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CPUInfo::set_has_cpumhz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CPUInfo::clear_has_cpumhz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CPUInfo::clear_cpumhz() {
  cpumhz_ = 0;
  clear_has_cpumhz();
}
inline double CPUInfo::cpumhz() const {
  // @@protoc_insertion_point(field_get:CPUInfo.cpuMHz)
  return cpumhz_;
}
inline void CPUInfo::set_cpumhz(double value) {
  set_has_cpumhz();
  cpumhz_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.cpuMHz)
}

// optional double cpumaxMhz = 7;
inline bool CPUInfo::has_cpumaxmhz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CPUInfo::set_has_cpumaxmhz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CPUInfo::clear_has_cpumaxmhz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CPUInfo::clear_cpumaxmhz() {
  cpumaxmhz_ = 0;
  clear_has_cpumaxmhz();
}
inline double CPUInfo::cpumaxmhz() const {
  // @@protoc_insertion_point(field_get:CPUInfo.cpumaxMhz)
  return cpumaxmhz_;
}
inline void CPUInfo::set_cpumaxmhz(double value) {
  set_has_cpumaxmhz();
  cpumaxmhz_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.cpumaxMhz)
}

// optional double cpuminMHz = 8;
inline bool CPUInfo::has_cpuminmhz() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CPUInfo::set_has_cpuminmhz() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CPUInfo::clear_has_cpuminmhz() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CPUInfo::clear_cpuminmhz() {
  cpuminmhz_ = 0;
  clear_has_cpuminmhz();
}
inline double CPUInfo::cpuminmhz() const {
  // @@protoc_insertion_point(field_get:CPUInfo.cpuminMHz)
  return cpuminmhz_;
}
inline void CPUInfo::set_cpuminmhz(double value) {
  set_has_cpuminmhz();
  cpuminmhz_ = value;
  // @@protoc_insertion_point(field_set:CPUInfo.cpuminMHz)
}

// optional string l1dcache = 9;
inline bool CPUInfo::has_l1dcache() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CPUInfo::set_has_l1dcache() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CPUInfo::clear_has_l1dcache() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CPUInfo::clear_l1dcache() {
  if (l1dcache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1dcache_->clear();
  }
  clear_has_l1dcache();
}
inline const ::std::string& CPUInfo::l1dcache() const {
  // @@protoc_insertion_point(field_get:CPUInfo.l1dcache)
  return *l1dcache_;
}
inline void CPUInfo::set_l1dcache(const ::std::string& value) {
  set_has_l1dcache();
  if (l1dcache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1dcache_ = new ::std::string;
  }
  l1dcache_->assign(value);
  // @@protoc_insertion_point(field_set:CPUInfo.l1dcache)
}
inline void CPUInfo::set_l1dcache(const char* value) {
  set_has_l1dcache();
  if (l1dcache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1dcache_ = new ::std::string;
  }
  l1dcache_->assign(value);
  // @@protoc_insertion_point(field_set_char:CPUInfo.l1dcache)
}
inline void CPUInfo::set_l1dcache(const char* value, size_t size) {
  set_has_l1dcache();
  if (l1dcache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1dcache_ = new ::std::string;
  }
  l1dcache_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CPUInfo.l1dcache)
}
inline ::std::string* CPUInfo::mutable_l1dcache() {
  set_has_l1dcache();
  if (l1dcache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1dcache_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CPUInfo.l1dcache)
  return l1dcache_;
}
inline ::std::string* CPUInfo::release_l1dcache() {
  clear_has_l1dcache();
  if (l1dcache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l1dcache_;
    l1dcache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CPUInfo::set_allocated_l1dcache(::std::string* l1dcache) {
  if (l1dcache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l1dcache_;
  }
  if (l1dcache) {
    set_has_l1dcache();
    l1dcache_ = l1dcache;
  } else {
    clear_has_l1dcache();
    l1dcache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CPUInfo.l1dcache)
}

// optional string l1icache = 10;
inline bool CPUInfo::has_l1icache() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CPUInfo::set_has_l1icache() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CPUInfo::clear_has_l1icache() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CPUInfo::clear_l1icache() {
  if (l1icache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1icache_->clear();
  }
  clear_has_l1icache();
}
inline const ::std::string& CPUInfo::l1icache() const {
  // @@protoc_insertion_point(field_get:CPUInfo.l1icache)
  return *l1icache_;
}
inline void CPUInfo::set_l1icache(const ::std::string& value) {
  set_has_l1icache();
  if (l1icache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1icache_ = new ::std::string;
  }
  l1icache_->assign(value);
  // @@protoc_insertion_point(field_set:CPUInfo.l1icache)
}
inline void CPUInfo::set_l1icache(const char* value) {
  set_has_l1icache();
  if (l1icache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1icache_ = new ::std::string;
  }
  l1icache_->assign(value);
  // @@protoc_insertion_point(field_set_char:CPUInfo.l1icache)
}
inline void CPUInfo::set_l1icache(const char* value, size_t size) {
  set_has_l1icache();
  if (l1icache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1icache_ = new ::std::string;
  }
  l1icache_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CPUInfo.l1icache)
}
inline ::std::string* CPUInfo::mutable_l1icache() {
  set_has_l1icache();
  if (l1icache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l1icache_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CPUInfo.l1icache)
  return l1icache_;
}
inline ::std::string* CPUInfo::release_l1icache() {
  clear_has_l1icache();
  if (l1icache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l1icache_;
    l1icache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CPUInfo::set_allocated_l1icache(::std::string* l1icache) {
  if (l1icache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l1icache_;
  }
  if (l1icache) {
    set_has_l1icache();
    l1icache_ = l1icache;
  } else {
    clear_has_l1icache();
    l1icache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CPUInfo.l1icache)
}

// optional string l2cache = 11;
inline bool CPUInfo::has_l2cache() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CPUInfo::set_has_l2cache() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CPUInfo::clear_has_l2cache() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CPUInfo::clear_l2cache() {
  if (l2cache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2cache_->clear();
  }
  clear_has_l2cache();
}
inline const ::std::string& CPUInfo::l2cache() const {
  // @@protoc_insertion_point(field_get:CPUInfo.l2cache)
  return *l2cache_;
}
inline void CPUInfo::set_l2cache(const ::std::string& value) {
  set_has_l2cache();
  if (l2cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2cache_ = new ::std::string;
  }
  l2cache_->assign(value);
  // @@protoc_insertion_point(field_set:CPUInfo.l2cache)
}
inline void CPUInfo::set_l2cache(const char* value) {
  set_has_l2cache();
  if (l2cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2cache_ = new ::std::string;
  }
  l2cache_->assign(value);
  // @@protoc_insertion_point(field_set_char:CPUInfo.l2cache)
}
inline void CPUInfo::set_l2cache(const char* value, size_t size) {
  set_has_l2cache();
  if (l2cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2cache_ = new ::std::string;
  }
  l2cache_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CPUInfo.l2cache)
}
inline ::std::string* CPUInfo::mutable_l2cache() {
  set_has_l2cache();
  if (l2cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2cache_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CPUInfo.l2cache)
  return l2cache_;
}
inline ::std::string* CPUInfo::release_l2cache() {
  clear_has_l2cache();
  if (l2cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l2cache_;
    l2cache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CPUInfo::set_allocated_l2cache(::std::string* l2cache) {
  if (l2cache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l2cache_;
  }
  if (l2cache) {
    set_has_l2cache();
    l2cache_ = l2cache;
  } else {
    clear_has_l2cache();
    l2cache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CPUInfo.l2cache)
}

// optional string l3cache = 12;
inline bool CPUInfo::has_l3cache() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CPUInfo::set_has_l3cache() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CPUInfo::clear_has_l3cache() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CPUInfo::clear_l3cache() {
  if (l3cache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l3cache_->clear();
  }
  clear_has_l3cache();
}
inline const ::std::string& CPUInfo::l3cache() const {
  // @@protoc_insertion_point(field_get:CPUInfo.l3cache)
  return *l3cache_;
}
inline void CPUInfo::set_l3cache(const ::std::string& value) {
  set_has_l3cache();
  if (l3cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l3cache_ = new ::std::string;
  }
  l3cache_->assign(value);
  // @@protoc_insertion_point(field_set:CPUInfo.l3cache)
}
inline void CPUInfo::set_l3cache(const char* value) {
  set_has_l3cache();
  if (l3cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l3cache_ = new ::std::string;
  }
  l3cache_->assign(value);
  // @@protoc_insertion_point(field_set_char:CPUInfo.l3cache)
}
inline void CPUInfo::set_l3cache(const char* value, size_t size) {
  set_has_l3cache();
  if (l3cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l3cache_ = new ::std::string;
  }
  l3cache_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CPUInfo.l3cache)
}
inline ::std::string* CPUInfo::mutable_l3cache() {
  set_has_l3cache();
  if (l3cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l3cache_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CPUInfo.l3cache)
  return l3cache_;
}
inline ::std::string* CPUInfo::release_l3cache() {
  clear_has_l3cache();
  if (l3cache_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l3cache_;
    l3cache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CPUInfo::set_allocated_l3cache(::std::string* l3cache) {
  if (l3cache_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l3cache_;
  }
  if (l3cache) {
    set_has_l3cache();
    l3cache_ = l3cache;
  } else {
    clear_has_l3cache();
    l3cache_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CPUInfo.l3cache)
}

// -------------------------------------------------------------------

// TLBCollection

// repeated .TLBInfo tlb_infos = 1;
inline int TLBCollection::tlb_infos_size() const {
  return tlb_infos_.size();
}
inline void TLBCollection::clear_tlb_infos() {
  tlb_infos_.Clear();
}
inline const ::TLBInfo& TLBCollection::tlb_infos(int index) const {
  // @@protoc_insertion_point(field_get:TLBCollection.tlb_infos)
  return tlb_infos_.Get(index);
}
inline ::TLBInfo* TLBCollection::mutable_tlb_infos(int index) {
  // @@protoc_insertion_point(field_mutable:TLBCollection.tlb_infos)
  return tlb_infos_.Mutable(index);
}
inline ::TLBInfo* TLBCollection::add_tlb_infos() {
  // @@protoc_insertion_point(field_add:TLBCollection.tlb_infos)
  return tlb_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TLBInfo >&
TLBCollection::tlb_infos() const {
  // @@protoc_insertion_point(field_list:TLBCollection.tlb_infos)
  return tlb_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TLBInfo >*
TLBCollection::mutable_tlb_infos() {
  // @@protoc_insertion_point(field_mutable_list:TLBCollection.tlb_infos)
  return &tlb_infos_;
}

// -------------------------------------------------------------------

// TLBInfo

// repeated string l1_data_tlb = 1;
inline int TLBInfo::l1_data_tlb_size() const {
  return l1_data_tlb_.size();
}
inline void TLBInfo::clear_l1_data_tlb() {
  l1_data_tlb_.Clear();
}
inline const ::std::string& TLBInfo::l1_data_tlb(int index) const {
  // @@protoc_insertion_point(field_get:TLBInfo.l1_data_tlb)
  return l1_data_tlb_.Get(index);
}
inline ::std::string* TLBInfo::mutable_l1_data_tlb(int index) {
  // @@protoc_insertion_point(field_mutable:TLBInfo.l1_data_tlb)
  return l1_data_tlb_.Mutable(index);
}
inline void TLBInfo::set_l1_data_tlb(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TLBInfo.l1_data_tlb)
  l1_data_tlb_.Mutable(index)->assign(value);
}
inline void TLBInfo::set_l1_data_tlb(int index, const char* value) {
  l1_data_tlb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TLBInfo.l1_data_tlb)
}
inline void TLBInfo::set_l1_data_tlb(int index, const char* value, size_t size) {
  l1_data_tlb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TLBInfo.l1_data_tlb)
}
inline ::std::string* TLBInfo::add_l1_data_tlb() {
  return l1_data_tlb_.Add();
}
inline void TLBInfo::add_l1_data_tlb(const ::std::string& value) {
  l1_data_tlb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TLBInfo.l1_data_tlb)
}
inline void TLBInfo::add_l1_data_tlb(const char* value) {
  l1_data_tlb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TLBInfo.l1_data_tlb)
}
inline void TLBInfo::add_l1_data_tlb(const char* value, size_t size) {
  l1_data_tlb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TLBInfo.l1_data_tlb)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TLBInfo::l1_data_tlb() const {
  // @@protoc_insertion_point(field_list:TLBInfo.l1_data_tlb)
  return l1_data_tlb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TLBInfo::mutable_l1_data_tlb() {
  // @@protoc_insertion_point(field_mutable_list:TLBInfo.l1_data_tlb)
  return &l1_data_tlb_;
}

// repeated string l1_instruction_tlb = 2;
inline int TLBInfo::l1_instruction_tlb_size() const {
  return l1_instruction_tlb_.size();
}
inline void TLBInfo::clear_l1_instruction_tlb() {
  l1_instruction_tlb_.Clear();
}
inline const ::std::string& TLBInfo::l1_instruction_tlb(int index) const {
  // @@protoc_insertion_point(field_get:TLBInfo.l1_instruction_tlb)
  return l1_instruction_tlb_.Get(index);
}
inline ::std::string* TLBInfo::mutable_l1_instruction_tlb(int index) {
  // @@protoc_insertion_point(field_mutable:TLBInfo.l1_instruction_tlb)
  return l1_instruction_tlb_.Mutable(index);
}
inline void TLBInfo::set_l1_instruction_tlb(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TLBInfo.l1_instruction_tlb)
  l1_instruction_tlb_.Mutable(index)->assign(value);
}
inline void TLBInfo::set_l1_instruction_tlb(int index, const char* value) {
  l1_instruction_tlb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TLBInfo.l1_instruction_tlb)
}
inline void TLBInfo::set_l1_instruction_tlb(int index, const char* value, size_t size) {
  l1_instruction_tlb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TLBInfo.l1_instruction_tlb)
}
inline ::std::string* TLBInfo::add_l1_instruction_tlb() {
  return l1_instruction_tlb_.Add();
}
inline void TLBInfo::add_l1_instruction_tlb(const ::std::string& value) {
  l1_instruction_tlb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TLBInfo.l1_instruction_tlb)
}
inline void TLBInfo::add_l1_instruction_tlb(const char* value) {
  l1_instruction_tlb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TLBInfo.l1_instruction_tlb)
}
inline void TLBInfo::add_l1_instruction_tlb(const char* value, size_t size) {
  l1_instruction_tlb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TLBInfo.l1_instruction_tlb)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TLBInfo::l1_instruction_tlb() const {
  // @@protoc_insertion_point(field_list:TLBInfo.l1_instruction_tlb)
  return l1_instruction_tlb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TLBInfo::mutable_l1_instruction_tlb() {
  // @@protoc_insertion_point(field_mutable_list:TLBInfo.l1_instruction_tlb)
  return &l1_instruction_tlb_;
}

// optional string l2_tlb = 3;
inline bool TLBInfo::has_l2_tlb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TLBInfo::set_has_l2_tlb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TLBInfo::clear_has_l2_tlb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TLBInfo::clear_l2_tlb() {
  if (l2_tlb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2_tlb_->clear();
  }
  clear_has_l2_tlb();
}
inline const ::std::string& TLBInfo::l2_tlb() const {
  // @@protoc_insertion_point(field_get:TLBInfo.l2_tlb)
  return *l2_tlb_;
}
inline void TLBInfo::set_l2_tlb(const ::std::string& value) {
  set_has_l2_tlb();
  if (l2_tlb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2_tlb_ = new ::std::string;
  }
  l2_tlb_->assign(value);
  // @@protoc_insertion_point(field_set:TLBInfo.l2_tlb)
}
inline void TLBInfo::set_l2_tlb(const char* value) {
  set_has_l2_tlb();
  if (l2_tlb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2_tlb_ = new ::std::string;
  }
  l2_tlb_->assign(value);
  // @@protoc_insertion_point(field_set_char:TLBInfo.l2_tlb)
}
inline void TLBInfo::set_l2_tlb(const char* value, size_t size) {
  set_has_l2_tlb();
  if (l2_tlb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2_tlb_ = new ::std::string;
  }
  l2_tlb_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TLBInfo.l2_tlb)
}
inline ::std::string* TLBInfo::mutable_l2_tlb() {
  set_has_l2_tlb();
  if (l2_tlb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l2_tlb_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TLBInfo.l2_tlb)
  return l2_tlb_;
}
inline ::std::string* TLBInfo::release_l2_tlb() {
  clear_has_l2_tlb();
  if (l2_tlb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l2_tlb_;
    l2_tlb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TLBInfo::set_allocated_l2_tlb(::std::string* l2_tlb) {
  if (l2_tlb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l2_tlb_;
  }
  if (l2_tlb) {
    set_has_l2_tlb();
    l2_tlb_ = l2_tlb;
  } else {
    clear_has_l2_tlb();
    l2_tlb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TLBInfo.l2_tlb)
}

// -------------------------------------------------------------------

// MemoryCollection

// required string max_size = 1;
inline bool MemoryCollection::has_max_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemoryCollection::set_has_max_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemoryCollection::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemoryCollection::clear_max_size() {
  if (max_size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    max_size_->clear();
  }
  clear_has_max_size();
}
inline const ::std::string& MemoryCollection::max_size() const {
  // @@protoc_insertion_point(field_get:MemoryCollection.max_size)
  return *max_size_;
}
inline void MemoryCollection::set_max_size(const ::std::string& value) {
  set_has_max_size();
  if (max_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    max_size_ = new ::std::string;
  }
  max_size_->assign(value);
  // @@protoc_insertion_point(field_set:MemoryCollection.max_size)
}
inline void MemoryCollection::set_max_size(const char* value) {
  set_has_max_size();
  if (max_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    max_size_ = new ::std::string;
  }
  max_size_->assign(value);
  // @@protoc_insertion_point(field_set_char:MemoryCollection.max_size)
}
inline void MemoryCollection::set_max_size(const char* value, size_t size) {
  set_has_max_size();
  if (max_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    max_size_ = new ::std::string;
  }
  max_size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MemoryCollection.max_size)
}
inline ::std::string* MemoryCollection::mutable_max_size() {
  set_has_max_size();
  if (max_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    max_size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MemoryCollection.max_size)
  return max_size_;
}
inline ::std::string* MemoryCollection::release_max_size() {
  clear_has_max_size();
  if (max_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = max_size_;
    max_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemoryCollection::set_allocated_max_size(::std::string* max_size) {
  if (max_size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete max_size_;
  }
  if (max_size) {
    set_has_max_size();
    max_size_ = max_size;
  } else {
    clear_has_max_size();
    max_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MemoryCollection.max_size)
}

// required int32 device_quantity = 2;
inline bool MemoryCollection::has_device_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryCollection::set_has_device_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryCollection::clear_has_device_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryCollection::clear_device_quantity() {
  device_quantity_ = 0;
  clear_has_device_quantity();
}
inline ::google::protobuf::int32 MemoryCollection::device_quantity() const {
  // @@protoc_insertion_point(field_get:MemoryCollection.device_quantity)
  return device_quantity_;
}
inline void MemoryCollection::set_device_quantity(::google::protobuf::int32 value) {
  set_has_device_quantity();
  device_quantity_ = value;
  // @@protoc_insertion_point(field_set:MemoryCollection.device_quantity)
}

// repeated .MemInfo mem_infos = 3;
inline int MemoryCollection::mem_infos_size() const {
  return mem_infos_.size();
}
inline void MemoryCollection::clear_mem_infos() {
  mem_infos_.Clear();
}
inline const ::MemInfo& MemoryCollection::mem_infos(int index) const {
  // @@protoc_insertion_point(field_get:MemoryCollection.mem_infos)
  return mem_infos_.Get(index);
}
inline ::MemInfo* MemoryCollection::mutable_mem_infos(int index) {
  // @@protoc_insertion_point(field_mutable:MemoryCollection.mem_infos)
  return mem_infos_.Mutable(index);
}
inline ::MemInfo* MemoryCollection::add_mem_infos() {
  // @@protoc_insertion_point(field_add:MemoryCollection.mem_infos)
  return mem_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MemInfo >&
MemoryCollection::mem_infos() const {
  // @@protoc_insertion_point(field_list:MemoryCollection.mem_infos)
  return mem_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::MemInfo >*
MemoryCollection::mutable_mem_infos() {
  // @@protoc_insertion_point(field_mutable_list:MemoryCollection.mem_infos)
  return &mem_infos_;
}

// -------------------------------------------------------------------

// MemInfo

// required string size = 1;
inline bool MemInfo::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemInfo::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemInfo::clear_size() {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_->clear();
  }
  clear_has_size();
}
inline const ::std::string& MemInfo::size() const {
  // @@protoc_insertion_point(field_get:MemInfo.size)
  return *size_;
}
inline void MemInfo::set_size(const ::std::string& value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set:MemInfo.size)
}
inline void MemInfo::set_size(const char* value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set_char:MemInfo.size)
}
inline void MemInfo::set_size(const char* value, size_t size) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MemInfo.size)
}
inline ::std::string* MemInfo::mutable_size() {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MemInfo.size)
  return size_;
}
inline ::std::string* MemInfo::release_size() {
  clear_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = size_;
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemInfo::set_allocated_size(::std::string* size) {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete size_;
  }
  if (size) {
    set_has_size();
    size_ = size;
  } else {
    clear_has_size();
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MemInfo.size)
}

// required string type = 2;
inline bool MemInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MemInfo::type() const {
  // @@protoc_insertion_point(field_get:MemInfo.type)
  return *type_;
}
inline void MemInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:MemInfo.type)
}
inline void MemInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:MemInfo.type)
}
inline void MemInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MemInfo.type)
}
inline ::std::string* MemInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MemInfo.type)
  return type_;
}
inline ::std::string* MemInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MemInfo.type)
}

// required string speed = 3;
inline bool MemInfo::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemInfo::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemInfo::clear_speed() {
  if (speed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    speed_->clear();
  }
  clear_has_speed();
}
inline const ::std::string& MemInfo::speed() const {
  // @@protoc_insertion_point(field_get:MemInfo.speed)
  return *speed_;
}
inline void MemInfo::set_speed(const ::std::string& value) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    speed_ = new ::std::string;
  }
  speed_->assign(value);
  // @@protoc_insertion_point(field_set:MemInfo.speed)
}
inline void MemInfo::set_speed(const char* value) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    speed_ = new ::std::string;
  }
  speed_->assign(value);
  // @@protoc_insertion_point(field_set_char:MemInfo.speed)
}
inline void MemInfo::set_speed(const char* value, size_t size) {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    speed_ = new ::std::string;
  }
  speed_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MemInfo.speed)
}
inline ::std::string* MemInfo::mutable_speed() {
  set_has_speed();
  if (speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    speed_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MemInfo.speed)
  return speed_;
}
inline ::std::string* MemInfo::release_speed() {
  clear_has_speed();
  if (speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = speed_;
    speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MemInfo::set_allocated_speed(::std::string* speed) {
  if (speed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete speed_;
  }
  if (speed) {
    set_has_speed();
    speed_ = speed;
  } else {
    clear_has_speed();
    speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MemInfo.speed)
}

// -------------------------------------------------------------------

// GPUCollection

// repeated .GPUInfo gpu_infos = 1;
inline int GPUCollection::gpu_infos_size() const {
  return gpu_infos_.size();
}
inline void GPUCollection::clear_gpu_infos() {
  gpu_infos_.Clear();
}
inline const ::GPUInfo& GPUCollection::gpu_infos(int index) const {
  // @@protoc_insertion_point(field_get:GPUCollection.gpu_infos)
  return gpu_infos_.Get(index);
}
inline ::GPUInfo* GPUCollection::mutable_gpu_infos(int index) {
  // @@protoc_insertion_point(field_mutable:GPUCollection.gpu_infos)
  return gpu_infos_.Mutable(index);
}
inline ::GPUInfo* GPUCollection::add_gpu_infos() {
  // @@protoc_insertion_point(field_add:GPUCollection.gpu_infos)
  return gpu_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GPUInfo >&
GPUCollection::gpu_infos() const {
  // @@protoc_insertion_point(field_list:GPUCollection.gpu_infos)
  return gpu_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::GPUInfo >*
GPUCollection::mutable_gpu_infos() {
  // @@protoc_insertion_point(field_mutable_list:GPUCollection.gpu_infos)
  return &gpu_infos_;
}

// required int32 gpu_quantity = 2;
inline bool GPUCollection::has_gpu_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUCollection::set_has_gpu_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUCollection::clear_has_gpu_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUCollection::clear_gpu_quantity() {
  gpu_quantity_ = 0;
  clear_has_gpu_quantity();
}
inline ::google::protobuf::int32 GPUCollection::gpu_quantity() const {
  // @@protoc_insertion_point(field_get:GPUCollection.gpu_quantity)
  return gpu_quantity_;
}
inline void GPUCollection::set_gpu_quantity(::google::protobuf::int32 value) {
  set_has_gpu_quantity();
  gpu_quantity_ = value;
  // @@protoc_insertion_point(field_set:GPUCollection.gpu_quantity)
}

// -------------------------------------------------------------------

// GPUInfo

// required string description = 2;
inline bool GPUInfo::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUInfo::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& GPUInfo::description() const {
  // @@protoc_insertion_point(field_get:GPUInfo.description)
  return *description_;
}
inline void GPUInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.description)
}
inline void GPUInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.description)
}
inline void GPUInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.description)
}
inline ::std::string* GPUInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.description)
  return description_;
}
inline ::std::string* GPUInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.description)
}

// required string product = 3;
inline bool GPUInfo::has_product() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPUInfo::set_has_product() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPUInfo::clear_has_product() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPUInfo::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& GPUInfo::product() const {
  // @@protoc_insertion_point(field_get:GPUInfo.product)
  return *product_;
}
inline void GPUInfo::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.product)
}
inline void GPUInfo::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.product)
}
inline void GPUInfo::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.product)
}
inline ::std::string* GPUInfo::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.product)
  return product_;
}
inline ::std::string* GPUInfo::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.product)
}

// required string vendor = 4;
inline bool GPUInfo::has_vendor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPUInfo::set_has_vendor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPUInfo::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPUInfo::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& GPUInfo::vendor() const {
  // @@protoc_insertion_point(field_get:GPUInfo.vendor)
  return *vendor_;
}
inline void GPUInfo::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.vendor)
}
inline void GPUInfo::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.vendor)
}
inline void GPUInfo::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.vendor)
}
inline ::std::string* GPUInfo::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.vendor)
  return vendor_;
}
inline ::std::string* GPUInfo::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.vendor)
}

// optional int32 physical_id = 5;
inline bool GPUInfo::has_physical_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPUInfo::set_has_physical_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPUInfo::clear_has_physical_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPUInfo::clear_physical_id() {
  physical_id_ = 0;
  clear_has_physical_id();
}
inline ::google::protobuf::int32 GPUInfo::physical_id() const {
  // @@protoc_insertion_point(field_get:GPUInfo.physical_id)
  return physical_id_;
}
inline void GPUInfo::set_physical_id(::google::protobuf::int32 value) {
  set_has_physical_id();
  physical_id_ = value;
  // @@protoc_insertion_point(field_set:GPUInfo.physical_id)
}

// optional string bus_info = 6;
inline bool GPUInfo::has_bus_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPUInfo::set_has_bus_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPUInfo::clear_has_bus_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPUInfo::clear_bus_info() {
  if (bus_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bus_info_->clear();
  }
  clear_has_bus_info();
}
inline const ::std::string& GPUInfo::bus_info() const {
  // @@protoc_insertion_point(field_get:GPUInfo.bus_info)
  return *bus_info_;
}
inline void GPUInfo::set_bus_info(const ::std::string& value) {
  set_has_bus_info();
  if (bus_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bus_info_ = new ::std::string;
  }
  bus_info_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.bus_info)
}
inline void GPUInfo::set_bus_info(const char* value) {
  set_has_bus_info();
  if (bus_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bus_info_ = new ::std::string;
  }
  bus_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.bus_info)
}
inline void GPUInfo::set_bus_info(const char* value, size_t size) {
  set_has_bus_info();
  if (bus_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bus_info_ = new ::std::string;
  }
  bus_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.bus_info)
}
inline ::std::string* GPUInfo::mutable_bus_info() {
  set_has_bus_info();
  if (bus_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bus_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.bus_info)
  return bus_info_;
}
inline ::std::string* GPUInfo::release_bus_info() {
  clear_has_bus_info();
  if (bus_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bus_info_;
    bus_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_bus_info(::std::string* bus_info) {
  if (bus_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bus_info_;
  }
  if (bus_info) {
    set_has_bus_info();
    bus_info_ = bus_info;
  } else {
    clear_has_bus_info();
    bus_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.bus_info)
}

// optional string version = 7;
inline bool GPUInfo::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPUInfo::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPUInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPUInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GPUInfo::version() const {
  // @@protoc_insertion_point(field_get:GPUInfo.version)
  return *version_;
}
inline void GPUInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.version)
}
inline void GPUInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.version)
}
inline void GPUInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.version)
}
inline ::std::string* GPUInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.version)
  return version_;
}
inline ::std::string* GPUInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.version)
}

// optional int32 width = 8;
inline bool GPUInfo::has_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPUInfo::set_has_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPUInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPUInfo::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 GPUInfo::width() const {
  // @@protoc_insertion_point(field_get:GPUInfo.width)
  return width_;
}
inline void GPUInfo::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:GPUInfo.width)
}

// optional int32 clock = 9;
inline bool GPUInfo::has_clock() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPUInfo::set_has_clock() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPUInfo::clear_has_clock() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPUInfo::clear_clock() {
  clock_ = 0;
  clear_has_clock();
}
inline ::google::protobuf::int32 GPUInfo::clock() const {
  // @@protoc_insertion_point(field_get:GPUInfo.clock)
  return clock_;
}
inline void GPUInfo::set_clock(::google::protobuf::int32 value) {
  set_has_clock();
  clock_ = value;
  // @@protoc_insertion_point(field_set:GPUInfo.clock)
}

// optional string capabilities = 10;
inline bool GPUInfo::has_capabilities() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPUInfo::set_has_capabilities() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPUInfo::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPUInfo::clear_capabilities() {
  if (capabilities_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    capabilities_->clear();
  }
  clear_has_capabilities();
}
inline const ::std::string& GPUInfo::capabilities() const {
  // @@protoc_insertion_point(field_get:GPUInfo.capabilities)
  return *capabilities_;
}
inline void GPUInfo::set_capabilities(const ::std::string& value) {
  set_has_capabilities();
  if (capabilities_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    capabilities_ = new ::std::string;
  }
  capabilities_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.capabilities)
}
inline void GPUInfo::set_capabilities(const char* value) {
  set_has_capabilities();
  if (capabilities_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    capabilities_ = new ::std::string;
  }
  capabilities_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.capabilities)
}
inline void GPUInfo::set_capabilities(const char* value, size_t size) {
  set_has_capabilities();
  if (capabilities_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    capabilities_ = new ::std::string;
  }
  capabilities_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.capabilities)
}
inline ::std::string* GPUInfo::mutable_capabilities() {
  set_has_capabilities();
  if (capabilities_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    capabilities_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.capabilities)
  return capabilities_;
}
inline ::std::string* GPUInfo::release_capabilities() {
  clear_has_capabilities();
  if (capabilities_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = capabilities_;
    capabilities_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_capabilities(::std::string* capabilities) {
  if (capabilities_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete capabilities_;
  }
  if (capabilities) {
    set_has_capabilities();
    capabilities_ = capabilities;
  } else {
    clear_has_capabilities();
    capabilities_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.capabilities)
}

// optional string configuration = 11;
inline bool GPUInfo::has_configuration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GPUInfo::set_has_configuration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GPUInfo::clear_has_configuration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GPUInfo::clear_configuration() {
  if (configuration_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    configuration_->clear();
  }
  clear_has_configuration();
}
inline const ::std::string& GPUInfo::configuration() const {
  // @@protoc_insertion_point(field_get:GPUInfo.configuration)
  return *configuration_;
}
inline void GPUInfo::set_configuration(const ::std::string& value) {
  set_has_configuration();
  if (configuration_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    configuration_ = new ::std::string;
  }
  configuration_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.configuration)
}
inline void GPUInfo::set_configuration(const char* value) {
  set_has_configuration();
  if (configuration_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    configuration_ = new ::std::string;
  }
  configuration_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.configuration)
}
inline void GPUInfo::set_configuration(const char* value, size_t size) {
  set_has_configuration();
  if (configuration_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    configuration_ = new ::std::string;
  }
  configuration_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.configuration)
}
inline ::std::string* GPUInfo::mutable_configuration() {
  set_has_configuration();
  if (configuration_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    configuration_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.configuration)
  return configuration_;
}
inline ::std::string* GPUInfo::release_configuration() {
  clear_has_configuration();
  if (configuration_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = configuration_;
    configuration_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_configuration(::std::string* configuration) {
  if (configuration_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete configuration_;
  }
  if (configuration) {
    set_has_configuration();
    configuration_ = configuration;
  } else {
    clear_has_configuration();
    configuration_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.configuration)
}

// optional string resources = 12;
inline bool GPUInfo::has_resources() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GPUInfo::set_has_resources() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GPUInfo::clear_has_resources() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GPUInfo::clear_resources() {
  if (resources_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resources_->clear();
  }
  clear_has_resources();
}
inline const ::std::string& GPUInfo::resources() const {
  // @@protoc_insertion_point(field_get:GPUInfo.resources)
  return *resources_;
}
inline void GPUInfo::set_resources(const ::std::string& value) {
  set_has_resources();
  if (resources_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resources_ = new ::std::string;
  }
  resources_->assign(value);
  // @@protoc_insertion_point(field_set:GPUInfo.resources)
}
inline void GPUInfo::set_resources(const char* value) {
  set_has_resources();
  if (resources_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resources_ = new ::std::string;
  }
  resources_->assign(value);
  // @@protoc_insertion_point(field_set_char:GPUInfo.resources)
}
inline void GPUInfo::set_resources(const char* value, size_t size) {
  set_has_resources();
  if (resources_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resources_ = new ::std::string;
  }
  resources_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GPUInfo.resources)
}
inline ::std::string* GPUInfo::mutable_resources() {
  set_has_resources();
  if (resources_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resources_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GPUInfo.resources)
  return resources_;
}
inline ::std::string* GPUInfo::release_resources() {
  clear_has_resources();
  if (resources_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resources_;
    resources_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GPUInfo::set_allocated_resources(::std::string* resources) {
  if (resources_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resources_;
  }
  if (resources) {
    set_has_resources();
    resources_ = resources;
  } else {
    clear_has_resources();
    resources_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GPUInfo.resources)
}

// -------------------------------------------------------------------

// DiskCollection

// repeated .DiskInfo disk_infos = 1;
inline int DiskCollection::disk_infos_size() const {
  return disk_infos_.size();
}
inline void DiskCollection::clear_disk_infos() {
  disk_infos_.Clear();
}
inline const ::DiskInfo& DiskCollection::disk_infos(int index) const {
  // @@protoc_insertion_point(field_get:DiskCollection.disk_infos)
  return disk_infos_.Get(index);
}
inline ::DiskInfo* DiskCollection::mutable_disk_infos(int index) {
  // @@protoc_insertion_point(field_mutable:DiskCollection.disk_infos)
  return disk_infos_.Mutable(index);
}
inline ::DiskInfo* DiskCollection::add_disk_infos() {
  // @@protoc_insertion_point(field_add:DiskCollection.disk_infos)
  return disk_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DiskInfo >&
DiskCollection::disk_infos() const {
  // @@protoc_insertion_point(field_list:DiskCollection.disk_infos)
  return disk_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::DiskInfo >*
DiskCollection::mutable_disk_infos() {
  // @@protoc_insertion_point(field_mutable_list:DiskCollection.disk_infos)
  return &disk_infos_;
}

// required int32 disk_quantity = 2;
inline bool DiskCollection::has_disk_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskCollection::set_has_disk_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskCollection::clear_has_disk_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskCollection::clear_disk_quantity() {
  disk_quantity_ = 0;
  clear_has_disk_quantity();
}
inline ::google::protobuf::int32 DiskCollection::disk_quantity() const {
  // @@protoc_insertion_point(field_get:DiskCollection.disk_quantity)
  return disk_quantity_;
}
inline void DiskCollection::set_disk_quantity(::google::protobuf::int32 value) {
  set_has_disk_quantity();
  disk_quantity_ = value;
  // @@protoc_insertion_point(field_set:DiskCollection.disk_quantity)
}

// -------------------------------------------------------------------

// DiskInfo

// required string name = 1;
inline bool DiskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DiskInfo::name() const {
  // @@protoc_insertion_point(field_get:DiskInfo.name)
  return *name_;
}
inline void DiskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:DiskInfo.name)
}
inline void DiskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:DiskInfo.name)
}
inline void DiskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DiskInfo.name)
}
inline ::std::string* DiskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DiskInfo.name)
  return name_;
}
inline ::std::string* DiskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiskInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DiskInfo.name)
}

// required string size = 2;
inline bool DiskInfo::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskInfo::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskInfo::clear_size() {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_->clear();
  }
  clear_has_size();
}
inline const ::std::string& DiskInfo::size() const {
  // @@protoc_insertion_point(field_get:DiskInfo.size)
  return *size_;
}
inline void DiskInfo::set_size(const ::std::string& value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set:DiskInfo.size)
}
inline void DiskInfo::set_size(const char* value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set_char:DiskInfo.size)
}
inline void DiskInfo::set_size(const char* value, size_t size) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DiskInfo.size)
}
inline ::std::string* DiskInfo::mutable_size() {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DiskInfo.size)
  return size_;
}
inline ::std::string* DiskInfo::release_size() {
  clear_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = size_;
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiskInfo::set_allocated_size(::std::string* size) {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete size_;
  }
  if (size) {
    set_has_size();
    size_ = size;
  } else {
    clear_has_size();
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DiskInfo.size)
}

// required .DiskInfo.DiskType type = 3;
inline bool DiskInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DiskInfo_DiskType DiskInfo::type() const {
  // @@protoc_insertion_point(field_get:DiskInfo.type)
  return static_cast< ::DiskInfo_DiskType >(type_);
}
inline void DiskInfo::set_type(::DiskInfo_DiskType value) {
  assert(::DiskInfo_DiskType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DiskInfo.type)
}

// required string disk_speed = 4;
inline bool DiskInfo::has_disk_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskInfo::set_has_disk_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskInfo::clear_has_disk_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskInfo::clear_disk_speed() {
  if (disk_speed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disk_speed_->clear();
  }
  clear_has_disk_speed();
}
inline const ::std::string& DiskInfo::disk_speed() const {
  // @@protoc_insertion_point(field_get:DiskInfo.disk_speed)
  return *disk_speed_;
}
inline void DiskInfo::set_disk_speed(const ::std::string& value) {
  set_has_disk_speed();
  if (disk_speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disk_speed_ = new ::std::string;
  }
  disk_speed_->assign(value);
  // @@protoc_insertion_point(field_set:DiskInfo.disk_speed)
}
inline void DiskInfo::set_disk_speed(const char* value) {
  set_has_disk_speed();
  if (disk_speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disk_speed_ = new ::std::string;
  }
  disk_speed_->assign(value);
  // @@protoc_insertion_point(field_set_char:DiskInfo.disk_speed)
}
inline void DiskInfo::set_disk_speed(const char* value, size_t size) {
  set_has_disk_speed();
  if (disk_speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disk_speed_ = new ::std::string;
  }
  disk_speed_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DiskInfo.disk_speed)
}
inline ::std::string* DiskInfo::mutable_disk_speed() {
  set_has_disk_speed();
  if (disk_speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disk_speed_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DiskInfo.disk_speed)
  return disk_speed_;
}
inline ::std::string* DiskInfo::release_disk_speed() {
  clear_has_disk_speed();
  if (disk_speed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = disk_speed_;
    disk_speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiskInfo::set_allocated_disk_speed(::std::string* disk_speed) {
  if (disk_speed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete disk_speed_;
  }
  if (disk_speed) {
    set_has_disk_speed();
    disk_speed_ = disk_speed;
  } else {
    clear_has_disk_speed();
    disk_speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DiskInfo.disk_speed)
}

// -------------------------------------------------------------------

// PortCollection

// repeated .PortInfo port_infos = 1;
inline int PortCollection::port_infos_size() const {
  return port_infos_.size();
}
inline void PortCollection::clear_port_infos() {
  port_infos_.Clear();
}
inline const ::PortInfo& PortCollection::port_infos(int index) const {
  // @@protoc_insertion_point(field_get:PortCollection.port_infos)
  return port_infos_.Get(index);
}
inline ::PortInfo* PortCollection::mutable_port_infos(int index) {
  // @@protoc_insertion_point(field_mutable:PortCollection.port_infos)
  return port_infos_.Mutable(index);
}
inline ::PortInfo* PortCollection::add_port_infos() {
  // @@protoc_insertion_point(field_add:PortCollection.port_infos)
  return port_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PortInfo >&
PortCollection::port_infos() const {
  // @@protoc_insertion_point(field_list:PortCollection.port_infos)
  return port_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::PortInfo >*
PortCollection::mutable_port_infos() {
  // @@protoc_insertion_point(field_mutable_list:PortCollection.port_infos)
  return &port_infos_;
}

// required int32 port_quantity = 2;
inline bool PortCollection::has_port_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortCollection::set_has_port_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortCollection::clear_has_port_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortCollection::clear_port_quantity() {
  port_quantity_ = 0;
  clear_has_port_quantity();
}
inline ::google::protobuf::int32 PortCollection::port_quantity() const {
  // @@protoc_insertion_point(field_get:PortCollection.port_quantity)
  return port_quantity_;
}
inline void PortCollection::set_port_quantity(::google::protobuf::int32 value) {
  set_has_port_quantity();
  port_quantity_ = value;
  // @@protoc_insertion_point(field_set:PortCollection.port_quantity)
}

// -------------------------------------------------------------------

// PortInfo

// optional string firstport = 1;
inline bool PortInfo::has_firstport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortInfo::set_has_firstport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortInfo::clear_has_firstport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortInfo::clear_firstport() {
  if (firstport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstport_->clear();
  }
  clear_has_firstport();
}
inline const ::std::string& PortInfo::firstport() const {
  // @@protoc_insertion_point(field_get:PortInfo.firstport)
  return *firstport_;
}
inline void PortInfo::set_firstport(const ::std::string& value) {
  set_has_firstport();
  if (firstport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstport_ = new ::std::string;
  }
  firstport_->assign(value);
  // @@protoc_insertion_point(field_set:PortInfo.firstport)
}
inline void PortInfo::set_firstport(const char* value) {
  set_has_firstport();
  if (firstport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstport_ = new ::std::string;
  }
  firstport_->assign(value);
  // @@protoc_insertion_point(field_set_char:PortInfo.firstport)
}
inline void PortInfo::set_firstport(const char* value, size_t size) {
  set_has_firstport();
  if (firstport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstport_ = new ::std::string;
  }
  firstport_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PortInfo.firstport)
}
inline ::std::string* PortInfo::mutable_firstport() {
  set_has_firstport();
  if (firstport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstport_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PortInfo.firstport)
  return firstport_;
}
inline ::std::string* PortInfo::release_firstport() {
  clear_has_firstport();
  if (firstport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstport_;
    firstport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PortInfo::set_allocated_firstport(::std::string* firstport) {
  if (firstport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstport_;
  }
  if (firstport) {
    set_has_firstport();
    firstport_ = firstport;
  } else {
    clear_has_firstport();
    firstport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PortInfo.firstport)
}

// optional string lastport = 2;
inline bool PortInfo::has_lastport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortInfo::set_has_lastport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortInfo::clear_has_lastport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortInfo::clear_lastport() {
  if (lastport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastport_->clear();
  }
  clear_has_lastport();
}
inline const ::std::string& PortInfo::lastport() const {
  // @@protoc_insertion_point(field_get:PortInfo.lastport)
  return *lastport_;
}
inline void PortInfo::set_lastport(const ::std::string& value) {
  set_has_lastport();
  if (lastport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastport_ = new ::std::string;
  }
  lastport_->assign(value);
  // @@protoc_insertion_point(field_set:PortInfo.lastport)
}
inline void PortInfo::set_lastport(const char* value) {
  set_has_lastport();
  if (lastport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastport_ = new ::std::string;
  }
  lastport_->assign(value);
  // @@protoc_insertion_point(field_set_char:PortInfo.lastport)
}
inline void PortInfo::set_lastport(const char* value, size_t size) {
  set_has_lastport();
  if (lastport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastport_ = new ::std::string;
  }
  lastport_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PortInfo.lastport)
}
inline ::std::string* PortInfo::mutable_lastport() {
  set_has_lastport();
  if (lastport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastport_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PortInfo.lastport)
  return lastport_;
}
inline ::std::string* PortInfo::release_lastport() {
  clear_has_lastport();
  if (lastport_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastport_;
    lastport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PortInfo::set_allocated_lastport(::std::string* lastport) {
  if (lastport_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastport_;
  }
  if (lastport) {
    set_has_lastport();
    lastport_ = lastport;
  } else {
    clear_has_lastport();
    lastport_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PortInfo.lastport)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DiskInfo_DiskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DiskInfo_DiskType>() {
  return ::DiskInfo_DiskType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hardware_5fresource_2eproto__INCLUDED
