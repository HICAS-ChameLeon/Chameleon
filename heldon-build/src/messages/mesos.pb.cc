// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mesos.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {

namespace {

const ::google::protobuf::Descriptor* FrameworkID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkID_reflection_ = NULL;
const ::google::protobuf::Descriptor* OfferID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OfferID_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveID_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskID_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorID_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerID_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceProviderID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceProviderID_reflection_ = NULL;
const ::google::protobuf::Descriptor* TimeInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimeInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DurationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DurationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Address_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Address_reflection_ = NULL;
const ::google::protobuf::Descriptor* URL_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  URL_reflection_ = NULL;
const ::google::protobuf::Descriptor* Unavailability_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Unavailability_reflection_ = NULL;
const ::google::protobuf::Descriptor* MachineID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MachineID_reflection_ = NULL;
const ::google::protobuf::Descriptor* MachineInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MachineInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MachineInfo_Mode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FrameworkInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkInfo_Capability_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkInfo_Capability_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FrameworkInfo_Capability_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_Command_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_Command_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_Http_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_Http_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_Tcp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_Tcp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CheckInfo_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* HealthCheck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HealthCheck_reflection_ = NULL;
const ::google::protobuf::Descriptor* HealthCheck_HTTPCheckInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HealthCheck_HTTPCheckInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* HealthCheck_TCPCheckInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HealthCheck_TCPCheckInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HealthCheck_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* KillPolicy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KillPolicy_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommandInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommandInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommandInfo_URI_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommandInfo_URI_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ExecutorInfo_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MasterInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveInfo_Capability_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveInfo_Capability_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveInfo_Capability_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Value_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Scalar_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Scalar_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Range_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Range_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Ranges_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Ranges_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Set_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Set_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Text_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Text_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Value_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Attribute_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Attribute_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_AllocationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_AllocationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_ReservationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_ReservationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Persistence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Persistence_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Source_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Path_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Source_Path_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Mount_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Source_Mount_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Resource_DiskInfo_Source_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Resource_RevocableInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_RevocableInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_SharedInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_SharedInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrafficControlStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficControlStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* IpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* IcmpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IcmpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* TcpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TcpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* UdpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UdpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* SNMPStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SNMPStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* DiskStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DiskStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceUsage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceUsage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceUsage_Executor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceUsage_Executor_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceUsage_Executor_Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceUsage_Executor_Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* PerfStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PerfStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Request_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Launch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Launch_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_LaunchGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_LaunchGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Reserve_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Reserve_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Unreserve_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Unreserve_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Create_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Create_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Destroy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Destroy_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* InverseOffer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InverseOffer_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskGroupInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskGroupInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_Command_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_Command_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_Http_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_Http_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_Tcp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_Tcp_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskStatus_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Filters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Filters_reflection_ = NULL;
const ::google::protobuf::Descriptor* Environment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Environment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Environment_Variable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Environment_Variable_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Environment_Variable_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Parameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Parameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* Parameters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Parameters_reflection_ = NULL;
const ::google::protobuf::Descriptor* Credential_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Credential_reflection_ = NULL;
const ::google::protobuf::Descriptor* Credentials_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Credentials_reflection_ = NULL;
const ::google::protobuf::Descriptor* Secret_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Secret_reflection_ = NULL;
const ::google::protobuf::Descriptor* Secret_Reference_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Secret_Reference_reflection_ = NULL;
const ::google::protobuf::Descriptor* Secret_Value_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Secret_Value_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Secret_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RateLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RateLimit_reflection_ = NULL;
const ::google::protobuf::Descriptor* RateLimits_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RateLimits_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_Appc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_Appc_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_Docker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_Docker_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Image_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Volume_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_reflection_ = NULL;
const ::google::protobuf::Descriptor* Volume_Source_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_Source_reflection_ = NULL;
const ::google::protobuf::Descriptor* Volume_Source_DockerVolume_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_Source_DockerVolume_reflection_ = NULL;
const ::google::protobuf::Descriptor* Volume_Source_SandboxPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_Source_SandboxPath_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Volume_Source_SandboxPath_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Volume_Source_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* NetworkInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetworkInfo_IPAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkInfo_IPAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetworkInfo_PortMapping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkInfo_PortMapping_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* NetworkInfo_Protocol_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CapabilityInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CapabilityInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CapabilityInfo_Capability_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LinuxInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LinuxInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* RLimitInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RLimitInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* RLimitInfo_RLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RLimitInfo_RLimit_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RLimitInfo_RLimit_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TTYInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TTYInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* TTYInfo_WindowSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TTYInfo_WindowSize_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_DockerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo_PortMapping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_DockerInfo_PortMapping_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_MesosInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_MesosInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ContainerStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* CgroupInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CgroupInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CgroupInfo_NetCls_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CgroupInfo_NetCls_reflection_ = NULL;
const ::google::protobuf::Descriptor* Labels_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Labels_reflection_ = NULL;
const ::google::protobuf::Descriptor* Label_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Label_reflection_ = NULL;
const ::google::protobuf::Descriptor* Port_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Port_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ports_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ports_reflection_ = NULL;
const ::google::protobuf::Descriptor* DiscoveryInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DiscoveryInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor_ = NULL;
const ::google::protobuf::Descriptor* WeightInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WeightInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* VersionInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Flag_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Flag_reflection_ = NULL;
const ::google::protobuf::Descriptor* Role_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Role_reflection_ = NULL;
const ::google::protobuf::Descriptor* Metric_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Metric_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Device_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Device_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeviceAccess_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeviceAccess_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeviceAccess_Access_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeviceAccess_Access_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeviceWhitelist_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeviceWhitelist_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_mesos_2eproto() {
  protobuf_AddDesc_mesos_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "mesos.proto");
  GOOGLE_CHECK(file != NULL);
  FrameworkID_descriptor_ = file->message_type(0);
  static const int FrameworkID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkID, value_),
  };
  FrameworkID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkID_descriptor_,
      FrameworkID::default_instance_,
      FrameworkID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkID));
  OfferID_descriptor_ = file->message_type(1);
  static const int OfferID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OfferID, value_),
  };
  OfferID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OfferID_descriptor_,
      OfferID::default_instance_,
      OfferID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OfferID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OfferID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OfferID));
  SlaveID_descriptor_ = file->message_type(2);
  static const int SlaveID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveID, value_),
  };
  SlaveID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveID_descriptor_,
      SlaveID::default_instance_,
      SlaveID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveID));
  TaskID_descriptor_ = file->message_type(3);
  static const int TaskID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskID, value_),
  };
  TaskID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskID_descriptor_,
      TaskID::default_instance_,
      TaskID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskID));
  ExecutorID_descriptor_ = file->message_type(4);
  static const int ExecutorID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorID, value_),
  };
  ExecutorID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorID_descriptor_,
      ExecutorID::default_instance_,
      ExecutorID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorID));
  ContainerID_descriptor_ = file->message_type(5);
  static const int ContainerID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, parent_),
  };
  ContainerID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerID_descriptor_,
      ContainerID::default_instance_,
      ContainerID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerID));
  ResourceProviderID_descriptor_ = file->message_type(6);
  static const int ResourceProviderID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceProviderID, value_),
  };
  ResourceProviderID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceProviderID_descriptor_,
      ResourceProviderID::default_instance_,
      ResourceProviderID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceProviderID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceProviderID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceProviderID));
  TimeInfo_descriptor_ = file->message_type(7);
  static const int TimeInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, nanoseconds_),
  };
  TimeInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TimeInfo_descriptor_,
      TimeInfo::default_instance_,
      TimeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TimeInfo));
  DurationInfo_descriptor_ = file->message_type(8);
  static const int DurationInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DurationInfo, nanoseconds_),
  };
  DurationInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DurationInfo_descriptor_,
      DurationInfo::default_instance_,
      DurationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DurationInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DurationInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DurationInfo));
  Address_descriptor_ = file->message_type(9);
  static const int Address_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, port_),
  };
  Address_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Address_descriptor_,
      Address::default_instance_,
      Address_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Address));
  URL_descriptor_ = file->message_type(10);
  static const int URL_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, scheme_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, query_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, fragment_),
  };
  URL_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      URL_descriptor_,
      URL::default_instance_,
      URL_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(URL));
  Unavailability_descriptor_ = file->message_type(11);
  static const int Unavailability_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, duration_),
  };
  Unavailability_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Unavailability_descriptor_,
      Unavailability::default_instance_,
      Unavailability_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Unavailability));
  MachineID_descriptor_ = file->message_type(12);
  static const int MachineID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, ip_),
  };
  MachineID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MachineID_descriptor_,
      MachineID::default_instance_,
      MachineID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MachineID));
  MachineInfo_descriptor_ = file->message_type(13);
  static const int MachineInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, unavailability_),
  };
  MachineInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MachineInfo_descriptor_,
      MachineInfo::default_instance_,
      MachineInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MachineInfo));
  MachineInfo_Mode_descriptor_ = MachineInfo_descriptor_->enum_type(0);
  FrameworkInfo_descriptor_ = file->message_type(14);
  static const int FrameworkInfo_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, failover_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, checkpoint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, role_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, roles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, webui_url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, capabilities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, labels_),
  };
  FrameworkInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkInfo_descriptor_,
      FrameworkInfo::default_instance_,
      FrameworkInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkInfo));
  FrameworkInfo_Capability_descriptor_ = FrameworkInfo_descriptor_->nested_type(0);
  static const int FrameworkInfo_Capability_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo_Capability, type_),
  };
  FrameworkInfo_Capability_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkInfo_Capability_descriptor_,
      FrameworkInfo_Capability::default_instance_,
      FrameworkInfo_Capability_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo_Capability, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo_Capability, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkInfo_Capability));
  FrameworkInfo_Capability_Type_descriptor_ = FrameworkInfo_Capability_descriptor_->enum_type(0);
  CheckInfo_descriptor_ = file->message_type(15);
  static const int CheckInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, http_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, tcp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, delay_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, interval_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, timeout_seconds_),
  };
  CheckInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckInfo_descriptor_,
      CheckInfo::default_instance_,
      CheckInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckInfo));
  CheckInfo_Command_descriptor_ = CheckInfo_descriptor_->nested_type(0);
  static const int CheckInfo_Command_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Command, command_),
  };
  CheckInfo_Command_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckInfo_Command_descriptor_,
      CheckInfo_Command::default_instance_,
      CheckInfo_Command_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Command, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Command, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckInfo_Command));
  CheckInfo_Http_descriptor_ = CheckInfo_descriptor_->nested_type(1);
  static const int CheckInfo_Http_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, path_),
  };
  CheckInfo_Http_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckInfo_Http_descriptor_,
      CheckInfo_Http::default_instance_,
      CheckInfo_Http_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckInfo_Http));
  CheckInfo_Tcp_descriptor_ = CheckInfo_descriptor_->nested_type(2);
  static const int CheckInfo_Tcp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Tcp, port_),
  };
  CheckInfo_Tcp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckInfo_Tcp_descriptor_,
      CheckInfo_Tcp::default_instance_,
      CheckInfo_Tcp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Tcp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Tcp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckInfo_Tcp));
  CheckInfo_Type_descriptor_ = CheckInfo_descriptor_->enum_type(0);
  HealthCheck_descriptor_ = file->message_type(16);
  static const int HealthCheck_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, delay_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, interval_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, timeout_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, consecutive_failures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, grace_period_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, http_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, tcp_),
  };
  HealthCheck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HealthCheck_descriptor_,
      HealthCheck::default_instance_,
      HealthCheck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HealthCheck));
  HealthCheck_HTTPCheckInfo_descriptor_ = HealthCheck_descriptor_->nested_type(0);
  static const int HealthCheck_HTTPCheckInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, scheme_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, statuses_),
  };
  HealthCheck_HTTPCheckInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HealthCheck_HTTPCheckInfo_descriptor_,
      HealthCheck_HTTPCheckInfo::default_instance_,
      HealthCheck_HTTPCheckInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HealthCheck_HTTPCheckInfo));
  HealthCheck_TCPCheckInfo_descriptor_ = HealthCheck_descriptor_->nested_type(1);
  static const int HealthCheck_TCPCheckInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_TCPCheckInfo, port_),
  };
  HealthCheck_TCPCheckInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HealthCheck_TCPCheckInfo_descriptor_,
      HealthCheck_TCPCheckInfo::default_instance_,
      HealthCheck_TCPCheckInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_TCPCheckInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_TCPCheckInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HealthCheck_TCPCheckInfo));
  HealthCheck_Type_descriptor_ = HealthCheck_descriptor_->enum_type(0);
  KillPolicy_descriptor_ = file->message_type(17);
  static const int KillPolicy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillPolicy, grace_period_),
  };
  KillPolicy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KillPolicy_descriptor_,
      KillPolicy::default_instance_,
      KillPolicy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillPolicy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillPolicy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KillPolicy));
  CommandInfo_descriptor_ = file->message_type(18);
  static const int CommandInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, uris_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, environment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, shell_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, arguments_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, user_),
  };
  CommandInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CommandInfo_descriptor_,
      CommandInfo::default_instance_,
      CommandInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CommandInfo));
  CommandInfo_URI_descriptor_ = CommandInfo_descriptor_->nested_type(0);
  static const int CommandInfo_URI_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, executable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, extract_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, cache_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, output_file_),
  };
  CommandInfo_URI_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CommandInfo_URI_descriptor_,
      CommandInfo_URI::default_instance_,
      CommandInfo_URI_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CommandInfo_URI));
  ExecutorInfo_descriptor_ = file->message_type(19);
  static const int ExecutorInfo_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, discovery_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, shutdown_grace_period_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, labels_),
  };
  ExecutorInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorInfo_descriptor_,
      ExecutorInfo::default_instance_,
      ExecutorInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorInfo));
  ExecutorInfo_Type_descriptor_ = ExecutorInfo_descriptor_->enum_type(0);
  MasterInfo_descriptor_ = file->message_type(20);
  static const int MasterInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, address_),
  };
  MasterInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MasterInfo_descriptor_,
      MasterInfo::default_instance_,
      MasterInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MasterInfo));
  SlaveInfo_descriptor_ = file->message_type(21);
  static const int SlaveInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, attributes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, checkpoint_),
  };
  SlaveInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveInfo_descriptor_,
      SlaveInfo::default_instance_,
      SlaveInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveInfo));
  SlaveInfo_Capability_descriptor_ = SlaveInfo_descriptor_->nested_type(0);
  static const int SlaveInfo_Capability_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo_Capability, type_),
  };
  SlaveInfo_Capability_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveInfo_Capability_descriptor_,
      SlaveInfo_Capability::default_instance_,
      SlaveInfo_Capability_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo_Capability, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo_Capability, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveInfo_Capability));
  SlaveInfo_Capability_Type_descriptor_ = SlaveInfo_Capability_descriptor_->enum_type(0);
  Value_descriptor_ = file->message_type(22);
  static const int Value_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, scalar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, text_),
  };
  Value_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_descriptor_,
      Value::default_instance_,
      Value_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value));
  Value_Scalar_descriptor_ = Value_descriptor_->nested_type(0);
  static const int Value_Scalar_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Scalar, value_),
  };
  Value_Scalar_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_Scalar_descriptor_,
      Value_Scalar::default_instance_,
      Value_Scalar_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Scalar, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Scalar, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value_Scalar));
  Value_Range_descriptor_ = Value_descriptor_->nested_type(1);
  static const int Value_Range_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, end_),
  };
  Value_Range_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_Range_descriptor_,
      Value_Range::default_instance_,
      Value_Range_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value_Range));
  Value_Ranges_descriptor_ = Value_descriptor_->nested_type(2);
  static const int Value_Ranges_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Ranges, range_),
  };
  Value_Ranges_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_Ranges_descriptor_,
      Value_Ranges::default_instance_,
      Value_Ranges_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Ranges, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Ranges, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value_Ranges));
  Value_Set_descriptor_ = Value_descriptor_->nested_type(3);
  static const int Value_Set_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Set, item_),
  };
  Value_Set_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_Set_descriptor_,
      Value_Set::default_instance_,
      Value_Set_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Set, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Set, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value_Set));
  Value_Text_descriptor_ = Value_descriptor_->nested_type(4);
  static const int Value_Text_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Text, value_),
  };
  Value_Text_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Value_Text_descriptor_,
      Value_Text::default_instance_,
      Value_Text_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Text, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Text, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Value_Text));
  Value_Type_descriptor_ = Value_descriptor_->enum_type(0);
  Attribute_descriptor_ = file->message_type(23);
  static const int Attribute_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, scalar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, text_),
  };
  Attribute_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Attribute_descriptor_,
      Attribute::default_instance_,
      Attribute_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Attribute));
  Resource_descriptor_ = file->message_type(24);
  static const int Resource_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, provider_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, scalar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, role_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, allocation_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, reservation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, disk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, revocable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, shared_),
  };
  Resource_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_descriptor_,
      Resource::default_instance_,
      Resource_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource));
  Resource_AllocationInfo_descriptor_ = Resource_descriptor_->nested_type(0);
  static const int Resource_AllocationInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_AllocationInfo, role_),
  };
  Resource_AllocationInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_AllocationInfo_descriptor_,
      Resource_AllocationInfo::default_instance_,
      Resource_AllocationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_AllocationInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_AllocationInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_AllocationInfo));
  Resource_ReservationInfo_descriptor_ = Resource_descriptor_->nested_type(1);
  static const int Resource_ReservationInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, labels_),
  };
  Resource_ReservationInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_ReservationInfo_descriptor_,
      Resource_ReservationInfo::default_instance_,
      Resource_ReservationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_ReservationInfo));
  Resource_DiskInfo_descriptor_ = Resource_descriptor_->nested_type(2);
  static const int Resource_DiskInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, persistence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, volume_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, source_),
  };
  Resource_DiskInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_DiskInfo_descriptor_,
      Resource_DiskInfo::default_instance_,
      Resource_DiskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_DiskInfo));
  Resource_DiskInfo_Persistence_descriptor_ = Resource_DiskInfo_descriptor_->nested_type(0);
  static const int Resource_DiskInfo_Persistence_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, principal_),
  };
  Resource_DiskInfo_Persistence_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_DiskInfo_Persistence_descriptor_,
      Resource_DiskInfo_Persistence::default_instance_,
      Resource_DiskInfo_Persistence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_DiskInfo_Persistence));
  Resource_DiskInfo_Source_descriptor_ = Resource_DiskInfo_descriptor_->nested_type(1);
  static const int Resource_DiskInfo_Source_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, mount_),
  };
  Resource_DiskInfo_Source_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_DiskInfo_Source_descriptor_,
      Resource_DiskInfo_Source::default_instance_,
      Resource_DiskInfo_Source_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_DiskInfo_Source));
  Resource_DiskInfo_Source_Path_descriptor_ = Resource_DiskInfo_Source_descriptor_->nested_type(0);
  static const int Resource_DiskInfo_Source_Path_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Path, root_),
  };
  Resource_DiskInfo_Source_Path_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_DiskInfo_Source_Path_descriptor_,
      Resource_DiskInfo_Source_Path::default_instance_,
      Resource_DiskInfo_Source_Path_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Path, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Path, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_DiskInfo_Source_Path));
  Resource_DiskInfo_Source_Mount_descriptor_ = Resource_DiskInfo_Source_descriptor_->nested_type(1);
  static const int Resource_DiskInfo_Source_Mount_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Mount, root_),
  };
  Resource_DiskInfo_Source_Mount_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_DiskInfo_Source_Mount_descriptor_,
      Resource_DiskInfo_Source_Mount::default_instance_,
      Resource_DiskInfo_Source_Mount_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Mount, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Mount, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_DiskInfo_Source_Mount));
  Resource_DiskInfo_Source_Type_descriptor_ = Resource_DiskInfo_Source_descriptor_->enum_type(0);
  Resource_RevocableInfo_descriptor_ = Resource_descriptor_->nested_type(3);
  static const int Resource_RevocableInfo_offsets_[1] = {
  };
  Resource_RevocableInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_RevocableInfo_descriptor_,
      Resource_RevocableInfo::default_instance_,
      Resource_RevocableInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_RevocableInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_RevocableInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_RevocableInfo));
  Resource_SharedInfo_descriptor_ = Resource_descriptor_->nested_type(4);
  static const int Resource_SharedInfo_offsets_[1] = {
  };
  Resource_SharedInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Resource_SharedInfo_descriptor_,
      Resource_SharedInfo::default_instance_,
      Resource_SharedInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_SharedInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_SharedInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Resource_SharedInfo));
  TrafficControlStatistics_descriptor_ = file->message_type(25);
  static const int TrafficControlStatistics_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, backlog_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, drops_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, overlimits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, qlen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, ratebps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, ratepps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, requeues_),
  };
  TrafficControlStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TrafficControlStatistics_descriptor_,
      TrafficControlStatistics::default_instance_,
      TrafficControlStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TrafficControlStatistics));
  IpStatistics_descriptor_ = file->message_type(26);
  static const int IpStatistics_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, forwarding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, defaultttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inreceives_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inhdrerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inaddrerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, forwdatagrams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inunknownprotos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, indiscards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, indelivers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, outrequests_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, outdiscards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, outnoroutes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmtimeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmreqds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmoks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmfails_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, fragoks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, fragfails_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, fragcreates_),
  };
  IpStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IpStatistics_descriptor_,
      IpStatistics::default_instance_,
      IpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IpStatistics));
  IcmpStatistics_descriptor_ = file->message_type(27);
  static const int IcmpStatistics_offsets_[27] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inmsgs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, incsumerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, indestunreachs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, intimeexcds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inparmprobs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, insrcquenchs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inredirects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inechos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inechoreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, intimestamps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, intimestampreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inaddrmasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inaddrmaskreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outmsgs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outdestunreachs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outtimeexcds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outparmprobs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outsrcquenchs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outredirects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outechos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outechoreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outtimestamps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outtimestampreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outaddrmasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outaddrmaskreps_),
  };
  IcmpStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IcmpStatistics_descriptor_,
      IcmpStatistics::default_instance_,
      IcmpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IcmpStatistics));
  TcpStatistics_descriptor_ = file->message_type(28);
  static const int TcpStatistics_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, rtoalgorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, rtomin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, rtomax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, maxconn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, activeopens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, passiveopens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, attemptfails_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, estabresets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, currestab_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, insegs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, outsegs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, retranssegs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, inerrs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, outrsts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, incsumerrors_),
  };
  TcpStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TcpStatistics_descriptor_,
      TcpStatistics::default_instance_,
      TcpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TcpStatistics));
  UdpStatistics_descriptor_ = file->message_type(29);
  static const int UdpStatistics_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, indatagrams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, noports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, inerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, outdatagrams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, rcvbuferrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, sndbuferrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, incsumerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, ignoredmulti_),
  };
  UdpStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UdpStatistics_descriptor_,
      UdpStatistics::default_instance_,
      UdpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UdpStatistics));
  SNMPStatistics_descriptor_ = file->message_type(30);
  static const int SNMPStatistics_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, ip_stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, icmp_stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, tcp_stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, udp_stats_),
  };
  SNMPStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SNMPStatistics_descriptor_,
      SNMPStatistics::default_instance_,
      SNMPStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SNMPStatistics));
  DiskStatistics_descriptor_ = file->message_type(31);
  static const int DiskStatistics_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskStatistics, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskStatistics, persistence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskStatistics, limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskStatistics, used_bytes_),
  };
  DiskStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DiskStatistics_descriptor_,
      DiskStatistics::default_instance_,
      DiskStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DiskStatistics));
  ResourceStatistics_descriptor_ = file->message_type(32);
  static const int ResourceStatistics_offsets_[43] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, processes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, threads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_user_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_system_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_nr_periods_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_nr_throttled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_throttled_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_total_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_total_memsw_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_soft_limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_file_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_anon_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_cache_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_rss_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_mapped_file_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_swap_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_unevictable_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_low_pressure_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_medium_pressure_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_critical_pressure_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, disk_limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, disk_used_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, disk_statistics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, perf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_errors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_dropped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_errors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_dropped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p50_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p90_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p95_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p99_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_active_connections_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_time_wait_connections_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_traffic_control_statistics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_snmp_statistics_),
  };
  ResourceStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceStatistics_descriptor_,
      ResourceStatistics::default_instance_,
      ResourceStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceStatistics));
  ResourceUsage_descriptor_ = file->message_type(33);
  static const int ResourceUsage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, executors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, total_),
  };
  ResourceUsage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceUsage_descriptor_,
      ResourceUsage::default_instance_,
      ResourceUsage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceUsage));
  ResourceUsage_Executor_descriptor_ = ResourceUsage_descriptor_->nested_type(0);
  static const int ResourceUsage_Executor_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, executor_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, allocated_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, statistics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, container_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, tasks_),
  };
  ResourceUsage_Executor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceUsage_Executor_descriptor_,
      ResourceUsage_Executor::default_instance_,
      ResourceUsage_Executor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceUsage_Executor));
  ResourceUsage_Executor_Task_descriptor_ = ResourceUsage_Executor_descriptor_->nested_type(0);
  static const int ResourceUsage_Executor_Task_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, labels_),
  };
  ResourceUsage_Executor_Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceUsage_Executor_Task_descriptor_,
      ResourceUsage_Executor_Task::default_instance_,
      ResourceUsage_Executor_Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceUsage_Executor_Task));
  PerfStatistics_descriptor_ = file->message_type(34);
  static const int PerfStatistics_offsets_[53] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cycles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, stalled_cycles_frontend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, stalled_cycles_backend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, instructions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cache_references_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cache_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, bus_cycles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, ref_cycles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cpu_clock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, task_clock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, page_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, minor_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, major_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, context_switches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cpu_migrations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, alignment_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, emulation_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, itlb_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, itlb_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branch_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branch_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_prefetch_misses_),
  };
  PerfStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PerfStatistics_descriptor_,
      PerfStatistics::default_instance_,
      PerfStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PerfStatistics));
  Request_descriptor_ = file->message_type(35);
  static const int Request_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, resources_),
  };
  Request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Request_descriptor_,
      Request::default_instance_,
      Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Request));
  Offer_descriptor_ = file->message_type(36);
  static const int Offer_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, attributes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, executor_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, unavailability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, allocation_info_),
  };
  Offer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_descriptor_,
      Offer::default_instance_,
      Offer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer));
  Offer_Operation_descriptor_ = Offer_descriptor_->nested_type(0);
  static const int Offer_Operation_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, launch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, launch_group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, reserve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, unreserve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, create_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, destroy_),
  };
  Offer_Operation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_descriptor_,
      Offer_Operation::default_instance_,
      Offer_Operation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation));
  Offer_Operation_Launch_descriptor_ = Offer_Operation_descriptor_->nested_type(0);
  static const int Offer_Operation_Launch_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Launch, task_infos_),
  };
  Offer_Operation_Launch_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_Launch_descriptor_,
      Offer_Operation_Launch::default_instance_,
      Offer_Operation_Launch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Launch, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Launch, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation_Launch));
  Offer_Operation_LaunchGroup_descriptor_ = Offer_Operation_descriptor_->nested_type(1);
  static const int Offer_Operation_LaunchGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, executor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, task_group_),
  };
  Offer_Operation_LaunchGroup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_LaunchGroup_descriptor_,
      Offer_Operation_LaunchGroup::default_instance_,
      Offer_Operation_LaunchGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation_LaunchGroup));
  Offer_Operation_Reserve_descriptor_ = Offer_Operation_descriptor_->nested_type(2);
  static const int Offer_Operation_Reserve_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Reserve, resources_),
  };
  Offer_Operation_Reserve_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_Reserve_descriptor_,
      Offer_Operation_Reserve::default_instance_,
      Offer_Operation_Reserve_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Reserve, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Reserve, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation_Reserve));
  Offer_Operation_Unreserve_descriptor_ = Offer_Operation_descriptor_->nested_type(3);
  static const int Offer_Operation_Unreserve_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Unreserve, resources_),
  };
  Offer_Operation_Unreserve_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_Unreserve_descriptor_,
      Offer_Operation_Unreserve::default_instance_,
      Offer_Operation_Unreserve_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Unreserve, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Unreserve, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation_Unreserve));
  Offer_Operation_Create_descriptor_ = Offer_Operation_descriptor_->nested_type(4);
  static const int Offer_Operation_Create_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Create, volumes_),
  };
  Offer_Operation_Create_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_Create_descriptor_,
      Offer_Operation_Create::default_instance_,
      Offer_Operation_Create_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Create, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Create, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation_Create));
  Offer_Operation_Destroy_descriptor_ = Offer_Operation_descriptor_->nested_type(5);
  static const int Offer_Operation_Destroy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Destroy, volumes_),
  };
  Offer_Operation_Destroy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Offer_Operation_Destroy_descriptor_,
      Offer_Operation_Destroy::default_instance_,
      Offer_Operation_Destroy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Destroy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Destroy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Offer_Operation_Destroy));
  Offer_Operation_Type_descriptor_ = Offer_Operation_descriptor_->enum_type(0);
  InverseOffer_descriptor_ = file->message_type(37);
  static const int InverseOffer_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, unavailability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, resources_),
  };
  InverseOffer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InverseOffer_descriptor_,
      InverseOffer::default_instance_,
      InverseOffer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InverseOffer));
  TaskInfo_descriptor_ = file->message_type(38);
  static const int TaskInfo_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, executor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, health_check_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, check_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, kill_policy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, discovery_),
  };
  TaskInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskInfo_descriptor_,
      TaskInfo::default_instance_,
      TaskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskInfo));
  TaskGroupInfo_descriptor_ = file->message_type(39);
  static const int TaskGroupInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskGroupInfo, tasks_),
  };
  TaskGroupInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskGroupInfo_descriptor_,
      TaskGroupInfo::default_instance_,
      TaskGroupInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskGroupInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskGroupInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskGroupInfo));
  Task_descriptor_ = file->message_type(40);
  static const int Task_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, statuses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, status_update_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, status_update_uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, discovery_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, user_),
  };
  Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Task_descriptor_,
      Task::default_instance_,
      Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Task));
  CheckStatusInfo_descriptor_ = file->message_type(41);
  static const int CheckStatusInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, http_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, tcp_),
  };
  CheckStatusInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckStatusInfo_descriptor_,
      CheckStatusInfo::default_instance_,
      CheckStatusInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckStatusInfo));
  CheckStatusInfo_Command_descriptor_ = CheckStatusInfo_descriptor_->nested_type(0);
  static const int CheckStatusInfo_Command_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Command, exit_code_),
  };
  CheckStatusInfo_Command_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckStatusInfo_Command_descriptor_,
      CheckStatusInfo_Command::default_instance_,
      CheckStatusInfo_Command_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Command, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Command, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckStatusInfo_Command));
  CheckStatusInfo_Http_descriptor_ = CheckStatusInfo_descriptor_->nested_type(1);
  static const int CheckStatusInfo_Http_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Http, status_code_),
  };
  CheckStatusInfo_Http_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckStatusInfo_Http_descriptor_,
      CheckStatusInfo_Http::default_instance_,
      CheckStatusInfo_Http_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Http, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Http, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckStatusInfo_Http));
  CheckStatusInfo_Tcp_descriptor_ = CheckStatusInfo_descriptor_->nested_type(2);
  static const int CheckStatusInfo_Tcp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Tcp, succeeded_),
  };
  CheckStatusInfo_Tcp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckStatusInfo_Tcp_descriptor_,
      CheckStatusInfo_Tcp::default_instance_,
      CheckStatusInfo_Tcp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Tcp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Tcp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckStatusInfo_Tcp));
  TaskStatus_descriptor_ = file->message_type(42);
  static const int TaskStatus_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, reason_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, healthy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, check_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, container_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, unreachable_time_),
  };
  TaskStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskStatus_descriptor_,
      TaskStatus::default_instance_,
      TaskStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskStatus));
  TaskStatus_Source_descriptor_ = TaskStatus_descriptor_->enum_type(0);
  TaskStatus_Reason_descriptor_ = TaskStatus_descriptor_->enum_type(1);
  Filters_descriptor_ = file->message_type(43);
  static const int Filters_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filters, refuse_seconds_),
  };
  Filters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Filters_descriptor_,
      Filters::default_instance_,
      Filters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Filters));
  Environment_descriptor_ = file->message_type(44);
  static const int Environment_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, variables_),
  };
  Environment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Environment_descriptor_,
      Environment::default_instance_,
      Environment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Environment));
  Environment_Variable_descriptor_ = Environment_descriptor_->nested_type(0);
  static const int Environment_Variable_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, secret_),
  };
  Environment_Variable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Environment_Variable_descriptor_,
      Environment_Variable::default_instance_,
      Environment_Variable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Environment_Variable));
  Environment_Variable_Type_descriptor_ = Environment_Variable_descriptor_->enum_type(0);
  Parameter_descriptor_ = file->message_type(45);
  static const int Parameter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, value_),
  };
  Parameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Parameter_descriptor_,
      Parameter::default_instance_,
      Parameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Parameter));
  Parameters_descriptor_ = file->message_type(46);
  static const int Parameters_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameters, parameter_),
  };
  Parameters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Parameters_descriptor_,
      Parameters::default_instance_,
      Parameters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Parameters));
  Credential_descriptor_ = file->message_type(47);
  static const int Credential_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, secret_),
  };
  Credential_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Credential_descriptor_,
      Credential::default_instance_,
      Credential_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Credential));
  Credentials_descriptor_ = file->message_type(48);
  static const int Credentials_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credentials, credentials_),
  };
  Credentials_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Credentials_descriptor_,
      Credentials::default_instance_,
      Credentials_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credentials, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credentials, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Credentials));
  Secret_descriptor_ = file->message_type(49);
  static const int Secret_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, reference_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, value_),
  };
  Secret_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Secret_descriptor_,
      Secret::default_instance_,
      Secret_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Secret));
  Secret_Reference_descriptor_ = Secret_descriptor_->nested_type(0);
  static const int Secret_Reference_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, key_),
  };
  Secret_Reference_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Secret_Reference_descriptor_,
      Secret_Reference::default_instance_,
      Secret_Reference_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Secret_Reference));
  Secret_Value_descriptor_ = Secret_descriptor_->nested_type(1);
  static const int Secret_Value_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Value, data_),
  };
  Secret_Value_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Secret_Value_descriptor_,
      Secret_Value::default_instance_,
      Secret_Value_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Value, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Value, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Secret_Value));
  Secret_Type_descriptor_ = Secret_descriptor_->enum_type(0);
  RateLimit_descriptor_ = file->message_type(50);
  static const int RateLimit_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, qps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, capacity_),
  };
  RateLimit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RateLimit_descriptor_,
      RateLimit::default_instance_,
      RateLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RateLimit));
  RateLimits_descriptor_ = file->message_type(51);
  static const int RateLimits_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, limits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, aggregate_default_qps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, aggregate_default_capacity_),
  };
  RateLimits_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RateLimits_descriptor_,
      RateLimits::default_instance_,
      RateLimits_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RateLimits));
  Image_descriptor_ = file->message_type(52);
  static const int Image_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, appc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, docker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, cached_),
  };
  Image_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Image));
  Image_Appc_descriptor_ = Image_descriptor_->nested_type(0);
  static const int Image_Appc_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, labels_),
  };
  Image_Appc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Image_Appc_descriptor_,
      Image_Appc::default_instance_,
      Image_Appc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Image_Appc));
  Image_Docker_descriptor_ = Image_descriptor_->nested_type(1);
  static const int Image_Docker_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, credential_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, config_),
  };
  Image_Docker_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Image_Docker_descriptor_,
      Image_Docker::default_instance_,
      Image_Docker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Image_Docker));
  Image_Type_descriptor_ = Image_descriptor_->enum_type(0);
  Volume_descriptor_ = file->message_type(53);
  static const int Volume_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, container_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, host_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, source_),
  };
  Volume_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Volume_descriptor_,
      Volume::default_instance_,
      Volume_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Volume));
  Volume_Source_descriptor_ = Volume_descriptor_->nested_type(0);
  static const int Volume_Source_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, docker_volume_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, sandbox_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, secret_),
  };
  Volume_Source_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Volume_Source_descriptor_,
      Volume_Source::default_instance_,
      Volume_Source_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Volume_Source));
  Volume_Source_DockerVolume_descriptor_ = Volume_Source_descriptor_->nested_type(0);
  static const int Volume_Source_DockerVolume_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, driver_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, driver_options_),
  };
  Volume_Source_DockerVolume_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Volume_Source_DockerVolume_descriptor_,
      Volume_Source_DockerVolume::default_instance_,
      Volume_Source_DockerVolume_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Volume_Source_DockerVolume));
  Volume_Source_SandboxPath_descriptor_ = Volume_Source_descriptor_->nested_type(1);
  static const int Volume_Source_SandboxPath_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, path_),
  };
  Volume_Source_SandboxPath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Volume_Source_SandboxPath_descriptor_,
      Volume_Source_SandboxPath::default_instance_,
      Volume_Source_SandboxPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Volume_Source_SandboxPath));
  Volume_Source_SandboxPath_Type_descriptor_ = Volume_Source_SandboxPath_descriptor_->enum_type(0);
  Volume_Source_Type_descriptor_ = Volume_Source_descriptor_->enum_type(0);
  Volume_Mode_descriptor_ = Volume_descriptor_->enum_type(0);
  NetworkInfo_descriptor_ = file->message_type(54);
  static const int NetworkInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, ip_addresses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, groups_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, port_mappings_),
  };
  NetworkInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetworkInfo_descriptor_,
      NetworkInfo::default_instance_,
      NetworkInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetworkInfo));
  NetworkInfo_IPAddress_descriptor_ = NetworkInfo_descriptor_->nested_type(0);
  static const int NetworkInfo_IPAddress_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, protocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, ip_address_),
  };
  NetworkInfo_IPAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetworkInfo_IPAddress_descriptor_,
      NetworkInfo_IPAddress::default_instance_,
      NetworkInfo_IPAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetworkInfo_IPAddress));
  NetworkInfo_PortMapping_descriptor_ = NetworkInfo_descriptor_->nested_type(1);
  static const int NetworkInfo_PortMapping_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, host_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, container_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, protocol_),
  };
  NetworkInfo_PortMapping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetworkInfo_PortMapping_descriptor_,
      NetworkInfo_PortMapping::default_instance_,
      NetworkInfo_PortMapping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetworkInfo_PortMapping));
  NetworkInfo_Protocol_descriptor_ = NetworkInfo_descriptor_->enum_type(0);
  CapabilityInfo_descriptor_ = file->message_type(55);
  static const int CapabilityInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CapabilityInfo, capabilities_),
  };
  CapabilityInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CapabilityInfo_descriptor_,
      CapabilityInfo::default_instance_,
      CapabilityInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CapabilityInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CapabilityInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CapabilityInfo));
  CapabilityInfo_Capability_descriptor_ = CapabilityInfo_descriptor_->enum_type(0);
  LinuxInfo_descriptor_ = file->message_type(56);
  static const int LinuxInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinuxInfo, capability_info_),
  };
  LinuxInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LinuxInfo_descriptor_,
      LinuxInfo::default_instance_,
      LinuxInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinuxInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinuxInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LinuxInfo));
  RLimitInfo_descriptor_ = file->message_type(57);
  static const int RLimitInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo, rlimits_),
  };
  RLimitInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RLimitInfo_descriptor_,
      RLimitInfo::default_instance_,
      RLimitInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RLimitInfo));
  RLimitInfo_RLimit_descriptor_ = RLimitInfo_descriptor_->nested_type(0);
  static const int RLimitInfo_RLimit_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, hard_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, soft_),
  };
  RLimitInfo_RLimit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RLimitInfo_RLimit_descriptor_,
      RLimitInfo_RLimit::default_instance_,
      RLimitInfo_RLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RLimitInfo_RLimit));
  RLimitInfo_RLimit_Type_descriptor_ = RLimitInfo_RLimit_descriptor_->enum_type(0);
  TTYInfo_descriptor_ = file->message_type(58);
  static const int TTYInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo, window_size_),
  };
  TTYInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TTYInfo_descriptor_,
      TTYInfo::default_instance_,
      TTYInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TTYInfo));
  TTYInfo_WindowSize_descriptor_ = TTYInfo_descriptor_->nested_type(0);
  static const int TTYInfo_WindowSize_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, rows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, columns_),
  };
  TTYInfo_WindowSize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TTYInfo_WindowSize_descriptor_,
      TTYInfo_WindowSize::default_instance_,
      TTYInfo_WindowSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TTYInfo_WindowSize));
  ContainerInfo_descriptor_ = file->message_type(59);
  static const int ContainerInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, volumes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, docker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, mesos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, network_infos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, linux_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, rlimit_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, tty_info_),
  };
  ContainerInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerInfo_descriptor_,
      ContainerInfo::default_instance_,
      ContainerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerInfo));
  ContainerInfo_DockerInfo_descriptor_ = ContainerInfo_descriptor_->nested_type(0);
  static const int ContainerInfo_DockerInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, network_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, port_mappings_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, privileged_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, parameters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, force_pull_image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, volume_driver_),
  };
  ContainerInfo_DockerInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerInfo_DockerInfo_descriptor_,
      ContainerInfo_DockerInfo::default_instance_,
      ContainerInfo_DockerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerInfo_DockerInfo));
  ContainerInfo_DockerInfo_PortMapping_descriptor_ = ContainerInfo_DockerInfo_descriptor_->nested_type(0);
  static const int ContainerInfo_DockerInfo_PortMapping_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, host_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, container_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, protocol_),
  };
  ContainerInfo_DockerInfo_PortMapping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerInfo_DockerInfo_PortMapping_descriptor_,
      ContainerInfo_DockerInfo_PortMapping::default_instance_,
      ContainerInfo_DockerInfo_PortMapping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerInfo_DockerInfo_PortMapping));
  ContainerInfo_DockerInfo_Network_descriptor_ = ContainerInfo_DockerInfo_descriptor_->enum_type(0);
  ContainerInfo_MesosInfo_descriptor_ = ContainerInfo_descriptor_->nested_type(1);
  static const int ContainerInfo_MesosInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_MesosInfo, image_),
  };
  ContainerInfo_MesosInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerInfo_MesosInfo_descriptor_,
      ContainerInfo_MesosInfo::default_instance_,
      ContainerInfo_MesosInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_MesosInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_MesosInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerInfo_MesosInfo));
  ContainerInfo_Type_descriptor_ = ContainerInfo_descriptor_->enum_type(0);
  ContainerStatus_descriptor_ = file->message_type(60);
  static const int ContainerStatus_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, container_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, network_infos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, cgroup_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, executor_pid_),
  };
  ContainerStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContainerStatus_descriptor_,
      ContainerStatus::default_instance_,
      ContainerStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContainerStatus));
  CgroupInfo_descriptor_ = file->message_type(61);
  static const int CgroupInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo, net_cls_),
  };
  CgroupInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CgroupInfo_descriptor_,
      CgroupInfo::default_instance_,
      CgroupInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CgroupInfo));
  CgroupInfo_NetCls_descriptor_ = CgroupInfo_descriptor_->nested_type(0);
  static const int CgroupInfo_NetCls_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo_NetCls, classid_),
  };
  CgroupInfo_NetCls_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CgroupInfo_NetCls_descriptor_,
      CgroupInfo_NetCls::default_instance_,
      CgroupInfo_NetCls_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo_NetCls, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo_NetCls, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CgroupInfo_NetCls));
  Labels_descriptor_ = file->message_type(62);
  static const int Labels_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labels, labels_),
  };
  Labels_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Labels_descriptor_,
      Labels::default_instance_,
      Labels_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labels, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labels, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Labels));
  Label_descriptor_ = file->message_type(63);
  static const int Label_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, value_),
  };
  Label_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Label_descriptor_,
      Label::default_instance_,
      Label_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Label));
  Port_descriptor_ = file->message_type(64);
  static const int Port_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, protocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, visibility_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, labels_),
  };
  Port_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Port_descriptor_,
      Port::default_instance_,
      Port_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Port));
  Ports_descriptor_ = file->message_type(65);
  static const int Ports_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ports, ports_),
  };
  Ports_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ports_descriptor_,
      Ports::default_instance_,
      Ports_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ports, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ports, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ports));
  DiscoveryInfo_descriptor_ = file->message_type(66);
  static const int DiscoveryInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, visibility_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, environment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, labels_),
  };
  DiscoveryInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DiscoveryInfo_descriptor_,
      DiscoveryInfo::default_instance_,
      DiscoveryInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DiscoveryInfo));
  DiscoveryInfo_Visibility_descriptor_ = DiscoveryInfo_descriptor_->enum_type(0);
  WeightInfo_descriptor_ = file->message_type(67);
  static const int WeightInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, weight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, role_),
  };
  WeightInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WeightInfo_descriptor_,
      WeightInfo::default_instance_,
      WeightInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WeightInfo));
  VersionInfo_descriptor_ = file->message_type(68);
  static const int VersionInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, build_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, build_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, build_user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, git_sha_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, git_branch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, git_tag_),
  };
  VersionInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionInfo_descriptor_,
      VersionInfo::default_instance_,
      VersionInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionInfo));
  Flag_descriptor_ = file->message_type(69);
  static const int Flag_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, value_),
  };
  Flag_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Flag_descriptor_,
      Flag::default_instance_,
      Flag_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Flag));
  Role_descriptor_ = file->message_type(70);
  static const int Role_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, weight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, frameworks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, resources_),
  };
  Role_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Role_descriptor_,
      Role::default_instance_,
      Role_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Role));
  Metric_descriptor_ = file->message_type(71);
  static const int Metric_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, value_),
  };
  Metric_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Metric_descriptor_,
      Metric::default_instance_,
      Metric_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Metric));
  FileInfo_descriptor_ = file->message_type(72);
  static const int FileInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, nlink_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, mtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, gid_),
  };
  FileInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileInfo_descriptor_,
      FileInfo::default_instance_,
      FileInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileInfo));
  Device_descriptor_ = file->message_type(73);
  static const int Device_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, path_),
  };
  Device_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Device_descriptor_,
      Device::default_instance_,
      Device_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Device, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Device));
  DeviceAccess_descriptor_ = file->message_type(74);
  static const int DeviceAccess_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess, device_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess, access_),
  };
  DeviceAccess_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeviceAccess_descriptor_,
      DeviceAccess::default_instance_,
      DeviceAccess_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeviceAccess));
  DeviceAccess_Access_descriptor_ = DeviceAccess_descriptor_->nested_type(0);
  static const int DeviceAccess_Access_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess_Access, read_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess_Access, write_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess_Access, mknod_),
  };
  DeviceAccess_Access_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeviceAccess_Access_descriptor_,
      DeviceAccess_Access::default_instance_,
      DeviceAccess_Access_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess_Access, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceAccess_Access, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeviceAccess_Access));
  DeviceWhitelist_descriptor_ = file->message_type(75);
  static const int DeviceWhitelist_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceWhitelist, allowed_devices_),
  };
  DeviceWhitelist_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeviceWhitelist_descriptor_,
      DeviceWhitelist::default_instance_,
      DeviceWhitelist_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceWhitelist, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceWhitelist, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeviceWhitelist));
  Status_descriptor_ = file->enum_type(0);
  TaskState_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_mesos_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkID_descriptor_, &FrameworkID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OfferID_descriptor_, &OfferID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveID_descriptor_, &SlaveID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskID_descriptor_, &TaskID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorID_descriptor_, &ExecutorID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerID_descriptor_, &ContainerID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceProviderID_descriptor_, &ResourceProviderID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimeInfo_descriptor_, &TimeInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DurationInfo_descriptor_, &DurationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Address_descriptor_, &Address::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    URL_descriptor_, &URL::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Unavailability_descriptor_, &Unavailability::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MachineID_descriptor_, &MachineID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MachineInfo_descriptor_, &MachineInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkInfo_descriptor_, &FrameworkInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkInfo_Capability_descriptor_, &FrameworkInfo_Capability::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckInfo_descriptor_, &CheckInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckInfo_Command_descriptor_, &CheckInfo_Command::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckInfo_Http_descriptor_, &CheckInfo_Http::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckInfo_Tcp_descriptor_, &CheckInfo_Tcp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HealthCheck_descriptor_, &HealthCheck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HealthCheck_HTTPCheckInfo_descriptor_, &HealthCheck_HTTPCheckInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HealthCheck_TCPCheckInfo_descriptor_, &HealthCheck_TCPCheckInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KillPolicy_descriptor_, &KillPolicy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CommandInfo_descriptor_, &CommandInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CommandInfo_URI_descriptor_, &CommandInfo_URI::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorInfo_descriptor_, &ExecutorInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MasterInfo_descriptor_, &MasterInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveInfo_descriptor_, &SlaveInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveInfo_Capability_descriptor_, &SlaveInfo_Capability::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_descriptor_, &Value::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_Scalar_descriptor_, &Value_Scalar::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_Range_descriptor_, &Value_Range::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_Ranges_descriptor_, &Value_Ranges::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_Set_descriptor_, &Value_Set::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Value_Text_descriptor_, &Value_Text::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Attribute_descriptor_, &Attribute::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_descriptor_, &Resource::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_AllocationInfo_descriptor_, &Resource_AllocationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_ReservationInfo_descriptor_, &Resource_ReservationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_DiskInfo_descriptor_, &Resource_DiskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_DiskInfo_Persistence_descriptor_, &Resource_DiskInfo_Persistence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_DiskInfo_Source_descriptor_, &Resource_DiskInfo_Source::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_DiskInfo_Source_Path_descriptor_, &Resource_DiskInfo_Source_Path::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_DiskInfo_Source_Mount_descriptor_, &Resource_DiskInfo_Source_Mount::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_RevocableInfo_descriptor_, &Resource_RevocableInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Resource_SharedInfo_descriptor_, &Resource_SharedInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TrafficControlStatistics_descriptor_, &TrafficControlStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IpStatistics_descriptor_, &IpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IcmpStatistics_descriptor_, &IcmpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TcpStatistics_descriptor_, &TcpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UdpStatistics_descriptor_, &UdpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SNMPStatistics_descriptor_, &SNMPStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DiskStatistics_descriptor_, &DiskStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceStatistics_descriptor_, &ResourceStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceUsage_descriptor_, &ResourceUsage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceUsage_Executor_descriptor_, &ResourceUsage_Executor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceUsage_Executor_Task_descriptor_, &ResourceUsage_Executor_Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PerfStatistics_descriptor_, &PerfStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Request_descriptor_, &Request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_descriptor_, &Offer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_descriptor_, &Offer_Operation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_Launch_descriptor_, &Offer_Operation_Launch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_LaunchGroup_descriptor_, &Offer_Operation_LaunchGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_Reserve_descriptor_, &Offer_Operation_Reserve::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_Unreserve_descriptor_, &Offer_Operation_Unreserve::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_Create_descriptor_, &Offer_Operation_Create::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Offer_Operation_Destroy_descriptor_, &Offer_Operation_Destroy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InverseOffer_descriptor_, &InverseOffer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskInfo_descriptor_, &TaskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskGroupInfo_descriptor_, &TaskGroupInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Task_descriptor_, &Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckStatusInfo_descriptor_, &CheckStatusInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckStatusInfo_Command_descriptor_, &CheckStatusInfo_Command::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckStatusInfo_Http_descriptor_, &CheckStatusInfo_Http::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckStatusInfo_Tcp_descriptor_, &CheckStatusInfo_Tcp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskStatus_descriptor_, &TaskStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Filters_descriptor_, &Filters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Environment_descriptor_, &Environment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Environment_Variable_descriptor_, &Environment_Variable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Parameter_descriptor_, &Parameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Parameters_descriptor_, &Parameters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Credential_descriptor_, &Credential::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Credentials_descriptor_, &Credentials::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Secret_descriptor_, &Secret::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Secret_Reference_descriptor_, &Secret_Reference::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Secret_Value_descriptor_, &Secret_Value::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RateLimit_descriptor_, &RateLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RateLimits_descriptor_, &RateLimits::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Image_Appc_descriptor_, &Image_Appc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Image_Docker_descriptor_, &Image_Docker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Volume_descriptor_, &Volume::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Volume_Source_descriptor_, &Volume_Source::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Volume_Source_DockerVolume_descriptor_, &Volume_Source_DockerVolume::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Volume_Source_SandboxPath_descriptor_, &Volume_Source_SandboxPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetworkInfo_descriptor_, &NetworkInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetworkInfo_IPAddress_descriptor_, &NetworkInfo_IPAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetworkInfo_PortMapping_descriptor_, &NetworkInfo_PortMapping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CapabilityInfo_descriptor_, &CapabilityInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LinuxInfo_descriptor_, &LinuxInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RLimitInfo_descriptor_, &RLimitInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RLimitInfo_RLimit_descriptor_, &RLimitInfo_RLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TTYInfo_descriptor_, &TTYInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TTYInfo_WindowSize_descriptor_, &TTYInfo_WindowSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerInfo_descriptor_, &ContainerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerInfo_DockerInfo_descriptor_, &ContainerInfo_DockerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerInfo_DockerInfo_PortMapping_descriptor_, &ContainerInfo_DockerInfo_PortMapping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerInfo_MesosInfo_descriptor_, &ContainerInfo_MesosInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContainerStatus_descriptor_, &ContainerStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CgroupInfo_descriptor_, &CgroupInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CgroupInfo_NetCls_descriptor_, &CgroupInfo_NetCls::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Labels_descriptor_, &Labels::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Label_descriptor_, &Label::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Port_descriptor_, &Port::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ports_descriptor_, &Ports::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DiscoveryInfo_descriptor_, &DiscoveryInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WeightInfo_descriptor_, &WeightInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionInfo_descriptor_, &VersionInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Flag_descriptor_, &Flag::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Role_descriptor_, &Role::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Metric_descriptor_, &Metric::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileInfo_descriptor_, &FileInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Device_descriptor_, &Device::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeviceAccess_descriptor_, &DeviceAccess::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeviceAccess_Access_descriptor_, &DeviceAccess_Access::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeviceWhitelist_descriptor_, &DeviceWhitelist::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_mesos_2eproto() {
  delete FrameworkID::default_instance_;
  delete FrameworkID_reflection_;
  delete OfferID::default_instance_;
  delete OfferID_reflection_;
  delete SlaveID::default_instance_;
  delete SlaveID_reflection_;
  delete TaskID::default_instance_;
  delete TaskID_reflection_;
  delete ExecutorID::default_instance_;
  delete ExecutorID_reflection_;
  delete ContainerID::default_instance_;
  delete ContainerID_reflection_;
  delete ResourceProviderID::default_instance_;
  delete ResourceProviderID_reflection_;
  delete TimeInfo::default_instance_;
  delete TimeInfo_reflection_;
  delete DurationInfo::default_instance_;
  delete DurationInfo_reflection_;
  delete Address::default_instance_;
  delete Address_reflection_;
  delete URL::default_instance_;
  delete URL_reflection_;
  delete Unavailability::default_instance_;
  delete Unavailability_reflection_;
  delete MachineID::default_instance_;
  delete MachineID_reflection_;
  delete MachineInfo::default_instance_;
  delete MachineInfo_reflection_;
  delete FrameworkInfo::default_instance_;
  delete FrameworkInfo_reflection_;
  delete FrameworkInfo::_default_role_;
  delete FrameworkInfo_Capability::default_instance_;
  delete FrameworkInfo_Capability_reflection_;
  delete CheckInfo::default_instance_;
  delete CheckInfo_reflection_;
  delete CheckInfo_Command::default_instance_;
  delete CheckInfo_Command_reflection_;
  delete CheckInfo_Http::default_instance_;
  delete CheckInfo_Http_reflection_;
  delete CheckInfo_Tcp::default_instance_;
  delete CheckInfo_Tcp_reflection_;
  delete HealthCheck::default_instance_;
  delete HealthCheck_reflection_;
  delete HealthCheck_HTTPCheckInfo::default_instance_;
  delete HealthCheck_HTTPCheckInfo_reflection_;
  delete HealthCheck_TCPCheckInfo::default_instance_;
  delete HealthCheck_TCPCheckInfo_reflection_;
  delete KillPolicy::default_instance_;
  delete KillPolicy_reflection_;
  delete CommandInfo::default_instance_;
  delete CommandInfo_reflection_;
  delete CommandInfo_URI::default_instance_;
  delete CommandInfo_URI_reflection_;
  delete ExecutorInfo::default_instance_;
  delete ExecutorInfo_reflection_;
  delete MasterInfo::default_instance_;
  delete MasterInfo_reflection_;
  delete SlaveInfo::default_instance_;
  delete SlaveInfo_reflection_;
  delete SlaveInfo_Capability::default_instance_;
  delete SlaveInfo_Capability_reflection_;
  delete Value::default_instance_;
  delete Value_reflection_;
  delete Value_Scalar::default_instance_;
  delete Value_Scalar_reflection_;
  delete Value_Range::default_instance_;
  delete Value_Range_reflection_;
  delete Value_Ranges::default_instance_;
  delete Value_Ranges_reflection_;
  delete Value_Set::default_instance_;
  delete Value_Set_reflection_;
  delete Value_Text::default_instance_;
  delete Value_Text_reflection_;
  delete Attribute::default_instance_;
  delete Attribute_reflection_;
  delete Resource::default_instance_;
  delete Resource_reflection_;
  delete Resource::_default_role_;
  delete Resource_AllocationInfo::default_instance_;
  delete Resource_AllocationInfo_reflection_;
  delete Resource_ReservationInfo::default_instance_;
  delete Resource_ReservationInfo_reflection_;
  delete Resource_DiskInfo::default_instance_;
  delete Resource_DiskInfo_reflection_;
  delete Resource_DiskInfo_Persistence::default_instance_;
  delete Resource_DiskInfo_Persistence_reflection_;
  delete Resource_DiskInfo_Source::default_instance_;
  delete Resource_DiskInfo_Source_reflection_;
  delete Resource_DiskInfo_Source_Path::default_instance_;
  delete Resource_DiskInfo_Source_Path_reflection_;
  delete Resource_DiskInfo_Source_Mount::default_instance_;
  delete Resource_DiskInfo_Source_Mount_reflection_;
  delete Resource_RevocableInfo::default_instance_;
  delete Resource_RevocableInfo_reflection_;
  delete Resource_SharedInfo::default_instance_;
  delete Resource_SharedInfo_reflection_;
  delete TrafficControlStatistics::default_instance_;
  delete TrafficControlStatistics_reflection_;
  delete IpStatistics::default_instance_;
  delete IpStatistics_reflection_;
  delete IcmpStatistics::default_instance_;
  delete IcmpStatistics_reflection_;
  delete TcpStatistics::default_instance_;
  delete TcpStatistics_reflection_;
  delete UdpStatistics::default_instance_;
  delete UdpStatistics_reflection_;
  delete SNMPStatistics::default_instance_;
  delete SNMPStatistics_reflection_;
  delete DiskStatistics::default_instance_;
  delete DiskStatistics_reflection_;
  delete ResourceStatistics::default_instance_;
  delete ResourceStatistics_reflection_;
  delete ResourceUsage::default_instance_;
  delete ResourceUsage_reflection_;
  delete ResourceUsage_Executor::default_instance_;
  delete ResourceUsage_Executor_reflection_;
  delete ResourceUsage_Executor_Task::default_instance_;
  delete ResourceUsage_Executor_Task_reflection_;
  delete PerfStatistics::default_instance_;
  delete PerfStatistics_reflection_;
  delete Request::default_instance_;
  delete Request_reflection_;
  delete Offer::default_instance_;
  delete Offer_reflection_;
  delete Offer_Operation::default_instance_;
  delete Offer_Operation_reflection_;
  delete Offer_Operation_Launch::default_instance_;
  delete Offer_Operation_Launch_reflection_;
  delete Offer_Operation_LaunchGroup::default_instance_;
  delete Offer_Operation_LaunchGroup_reflection_;
  delete Offer_Operation_Reserve::default_instance_;
  delete Offer_Operation_Reserve_reflection_;
  delete Offer_Operation_Unreserve::default_instance_;
  delete Offer_Operation_Unreserve_reflection_;
  delete Offer_Operation_Create::default_instance_;
  delete Offer_Operation_Create_reflection_;
  delete Offer_Operation_Destroy::default_instance_;
  delete Offer_Operation_Destroy_reflection_;
  delete InverseOffer::default_instance_;
  delete InverseOffer_reflection_;
  delete TaskInfo::default_instance_;
  delete TaskInfo_reflection_;
  delete TaskGroupInfo::default_instance_;
  delete TaskGroupInfo_reflection_;
  delete Task::default_instance_;
  delete Task_reflection_;
  delete CheckStatusInfo::default_instance_;
  delete CheckStatusInfo_reflection_;
  delete CheckStatusInfo_Command::default_instance_;
  delete CheckStatusInfo_Command_reflection_;
  delete CheckStatusInfo_Http::default_instance_;
  delete CheckStatusInfo_Http_reflection_;
  delete CheckStatusInfo_Tcp::default_instance_;
  delete CheckStatusInfo_Tcp_reflection_;
  delete TaskStatus::default_instance_;
  delete TaskStatus_reflection_;
  delete Filters::default_instance_;
  delete Filters_reflection_;
  delete Environment::default_instance_;
  delete Environment_reflection_;
  delete Environment_Variable::default_instance_;
  delete Environment_Variable_reflection_;
  delete Parameter::default_instance_;
  delete Parameter_reflection_;
  delete Parameters::default_instance_;
  delete Parameters_reflection_;
  delete Credential::default_instance_;
  delete Credential_reflection_;
  delete Credentials::default_instance_;
  delete Credentials_reflection_;
  delete Secret::default_instance_;
  delete Secret_reflection_;
  delete Secret_Reference::default_instance_;
  delete Secret_Reference_reflection_;
  delete Secret_Value::default_instance_;
  delete Secret_Value_reflection_;
  delete RateLimit::default_instance_;
  delete RateLimit_reflection_;
  delete RateLimits::default_instance_;
  delete RateLimits_reflection_;
  delete Image::default_instance_;
  delete Image_reflection_;
  delete Image_Appc::default_instance_;
  delete Image_Appc_reflection_;
  delete Image_Docker::default_instance_;
  delete Image_Docker_reflection_;
  delete Volume::default_instance_;
  delete Volume_reflection_;
  delete Volume_Source::default_instance_;
  delete Volume_Source_reflection_;
  delete Volume_Source_DockerVolume::default_instance_;
  delete Volume_Source_DockerVolume_reflection_;
  delete Volume_Source_SandboxPath::default_instance_;
  delete Volume_Source_SandboxPath_reflection_;
  delete NetworkInfo::default_instance_;
  delete NetworkInfo_reflection_;
  delete NetworkInfo_IPAddress::default_instance_;
  delete NetworkInfo_IPAddress_reflection_;
  delete NetworkInfo_PortMapping::default_instance_;
  delete NetworkInfo_PortMapping_reflection_;
  delete CapabilityInfo::default_instance_;
  delete CapabilityInfo_reflection_;
  delete LinuxInfo::default_instance_;
  delete LinuxInfo_reflection_;
  delete RLimitInfo::default_instance_;
  delete RLimitInfo_reflection_;
  delete RLimitInfo_RLimit::default_instance_;
  delete RLimitInfo_RLimit_reflection_;
  delete TTYInfo::default_instance_;
  delete TTYInfo_reflection_;
  delete TTYInfo_WindowSize::default_instance_;
  delete TTYInfo_WindowSize_reflection_;
  delete ContainerInfo::default_instance_;
  delete ContainerInfo_reflection_;
  delete ContainerInfo_DockerInfo::default_instance_;
  delete ContainerInfo_DockerInfo_reflection_;
  delete ContainerInfo_DockerInfo_PortMapping::default_instance_;
  delete ContainerInfo_DockerInfo_PortMapping_reflection_;
  delete ContainerInfo_MesosInfo::default_instance_;
  delete ContainerInfo_MesosInfo_reflection_;
  delete ContainerStatus::default_instance_;
  delete ContainerStatus_reflection_;
  delete CgroupInfo::default_instance_;
  delete CgroupInfo_reflection_;
  delete CgroupInfo_NetCls::default_instance_;
  delete CgroupInfo_NetCls_reflection_;
  delete Labels::default_instance_;
  delete Labels_reflection_;
  delete Label::default_instance_;
  delete Label_reflection_;
  delete Port::default_instance_;
  delete Port_reflection_;
  delete Ports::default_instance_;
  delete Ports_reflection_;
  delete DiscoveryInfo::default_instance_;
  delete DiscoveryInfo_reflection_;
  delete WeightInfo::default_instance_;
  delete WeightInfo_reflection_;
  delete VersionInfo::default_instance_;
  delete VersionInfo_reflection_;
  delete Flag::default_instance_;
  delete Flag_reflection_;
  delete Role::default_instance_;
  delete Role_reflection_;
  delete Metric::default_instance_;
  delete Metric_reflection_;
  delete FileInfo::default_instance_;
  delete FileInfo_reflection_;
  delete Device::default_instance_;
  delete Device_reflection_;
  delete DeviceAccess::default_instance_;
  delete DeviceAccess_reflection_;
  delete DeviceAccess_Access::default_instance_;
  delete DeviceAccess_Access_reflection_;
  delete DeviceWhitelist::default_instance_;
  delete DeviceWhitelist_reflection_;
}

void protobuf_AddDesc_mesos_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013mesos.proto\022\005mesos\"\034\n\013FrameworkID\022\r\n\005v"
    "alue\030\001 \002(\t\"\030\n\007OfferID\022\r\n\005value\030\001 \002(\t\"\030\n\007"
    "SlaveID\022\r\n\005value\030\001 \002(\t\"\027\n\006TaskID\022\r\n\005valu"
    "e\030\001 \002(\t\"\033\n\nExecutorID\022\r\n\005value\030\001 \002(\t\"@\n\013"
    "ContainerID\022\r\n\005value\030\001 \002(\t\022\"\n\006parent\030\002 \001"
    "(\0132\022.mesos.ContainerID\"#\n\022ResourceProvid"
    "erID\022\r\n\005value\030\001 \002(\t\"\037\n\010TimeInfo\022\023\n\013nanos"
    "econds\030\001 \002(\003\"#\n\014DurationInfo\022\023\n\013nanoseco"
    "nds\030\001 \002(\003\"5\n\007Address\022\020\n\010hostname\030\001 \001(\t\022\n"
    "\n\002ip\030\002 \001(\t\022\014\n\004port\030\003 \002(\005\"w\n\003URL\022\016\n\006schem"
    "e\030\001 \002(\t\022\037\n\007address\030\002 \002(\0132\016.mesos.Address"
    "\022\014\n\004path\030\003 \001(\t\022\037\n\005query\030\004 \003(\0132\020.mesos.Pa"
    "rameter\022\020\n\010fragment\030\005 \001(\t\"W\n\016Unavailabil"
    "ity\022\036\n\005start\030\001 \002(\0132\017.mesos.TimeInfo\022%\n\010d"
    "uration\030\002 \001(\0132\023.mesos.DurationInfo\")\n\tMa"
    "chineID\022\020\n\010hostname\030\001 \001(\t\022\n\n\002ip\030\002 \001(\t\"\251\001"
    "\n\013MachineInfo\022\034\n\002id\030\001 \002(\0132\020.mesos.Machin"
    "eID\022%\n\004mode\030\002 \001(\0162\027.mesos.MachineInfo.Mo"
    "de\022-\n\016unavailability\030\003 \001(\0132\025.mesos.Unava"
    "ilability\"&\n\004Mode\022\006\n\002UP\020\001\022\014\n\010DRAINING\020\002\022"
    "\010\n\004DOWN\020\003\"\215\004\n\rFrameworkInfo\022\014\n\004user\030\001 \002("
    "\t\022\014\n\004name\030\002 \002(\t\022\036\n\002id\030\003 \001(\0132\022.mesos.Fram"
    "eworkID\022\033\n\020failover_timeout\030\004 \001(\001:\0010\022\031\n\n"
    "checkpoint\030\005 \001(\010:\005false\022\023\n\004role\030\006 \001(\t:\001*"
    "B\002\030\001\022\r\n\005roles\030\014 \003(\t\022\020\n\010hostname\030\007 \001(\t\022\021\n"
    "\tprincipal\030\010 \001(\t\022\021\n\twebui_url\030\t \001(\t\0225\n\014c"
    "apabilities\030\n \003(\0132\037.mesos.FrameworkInfo."
    "Capability\022\035\n\006labels\030\013 \001(\0132\r.mesos.Label"
    "s\032\325\001\n\nCapability\0222\n\004type\030\001 \001(\0162$.mesos.F"
    "rameworkInfo.Capability.Type\"\222\001\n\004Type\022\013\n"
    "\007UNKNOWN\020\000\022\027\n\023REVOCABLE_RESOURCES\020\001\022\026\n\022T"
    "ASK_KILLING_STATE\020\002\022\021\n\rGPU_RESOURCES\020\003\022\024"
    "\n\020SHARED_RESOURCES\020\004\022\023\n\017PARTITION_AWARE\020"
    "\005\022\016\n\nMULTI_ROLE\020\006\"\227\003\n\tCheckInfo\022#\n\004type\030"
    "\001 \001(\0162\025.mesos.CheckInfo.Type\022)\n\007command\030"
    "\002 \001(\0132\030.mesos.CheckInfo.Command\022#\n\004http\030"
    "\003 \001(\0132\025.mesos.CheckInfo.Http\022!\n\003tcp\030\007 \001("
    "\0132\024.mesos.CheckInfo.Tcp\022\031\n\rdelay_seconds"
    "\030\004 \001(\001:\00215\022\034\n\020interval_seconds\030\005 \001(\001:\00210"
    "\022\033\n\017timeout_seconds\030\006 \001(\001:\00220\032.\n\007Command"
    "\022#\n\007command\030\001 \002(\0132\022.mesos.CommandInfo\032\"\n"
    "\004Http\022\014\n\004port\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\032\023\n\003Tcp"
    "\022\014\n\004port\030\001 \002(\r\"3\n\004Type\022\013\n\007UNKNOWN\020\000\022\013\n\007C"
    "OMMAND\020\001\022\010\n\004HTTP\020\002\022\007\n\003TCP\020\003\"\362\003\n\013HealthCh"
    "eck\022\031\n\rdelay_seconds\030\002 \001(\001:\00215\022\034\n\020interv"
    "al_seconds\030\003 \001(\001:\00210\022\033\n\017timeout_seconds\030"
    "\004 \001(\001:\00220\022\037\n\024consecutive_failures\030\005 \001(\r:"
    "\0013\022 \n\024grace_period_seconds\030\006 \001(\001:\00210\022%\n\004"
    "type\030\010 \001(\0162\027.mesos.HealthCheck.Type\022#\n\007c"
    "ommand\030\007 \001(\0132\022.mesos.CommandInfo\022.\n\004http"
    "\030\001 \001(\0132 .mesos.HealthCheck.HTTPCheckInfo"
    "\022,\n\003tcp\030\t \001(\0132\037.mesos.HealthCheck.TCPChe"
    "ckInfo\032M\n\rHTTPCheckInfo\022\016\n\006scheme\030\003 \001(\t\022"
    "\014\n\004port\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\022\020\n\010statuses\030"
    "\004 \003(\r\032\034\n\014TCPCheckInfo\022\014\n\004port\030\001 \002(\r\"3\n\004T"
    "ype\022\013\n\007UNKNOWN\020\000\022\013\n\007COMMAND\020\001\022\010\n\004HTTP\020\002\022"
    "\007\n\003TCP\020\003\"7\n\nKillPolicy\022)\n\014grace_period\030\001"
    " \001(\0132\023.mesos.DurationInfo\"\206\002\n\013CommandInf"
    "o\022$\n\004uris\030\001 \003(\0132\026.mesos.CommandInfo.URI\022"
    "\'\n\013environment\030\002 \001(\0132\022.mesos.Environment"
    "\022\023\n\005shell\030\006 \001(\010:\004true\022\r\n\005value\030\003 \001(\t\022\021\n\t"
    "arguments\030\007 \003(\t\022\014\n\004user\030\005 \001(\t\032c\n\003URI\022\r\n\005"
    "value\030\001 \002(\t\022\022\n\nexecutable\030\002 \001(\010\022\025\n\007extra"
    "ct\030\003 \001(\010:\004true\022\r\n\005cache\030\004 \001(\010\022\023\n\013output_"
    "file\030\005 \001(\t\"\324\003\n\014ExecutorInfo\022&\n\004type\030\017 \001("
    "\0162\030.mesos.ExecutorInfo.Type\022&\n\013executor_"
    "id\030\001 \002(\0132\021.mesos.ExecutorID\022(\n\014framework"
    "_id\030\010 \001(\0132\022.mesos.FrameworkID\022#\n\007command"
    "\030\007 \001(\0132\022.mesos.CommandInfo\022\'\n\tcontainer\030"
    "\013 \001(\0132\024.mesos.ContainerInfo\022\"\n\tresources"
    "\030\005 \003(\0132\017.mesos.Resource\022\014\n\004name\030\t \001(\t\022\022\n"
    "\006source\030\n \001(\tB\002\030\001\022\014\n\004data\030\004 \001(\014\022\'\n\tdisco"
    "very\030\014 \001(\0132\024.mesos.DiscoveryInfo\0222\n\025shut"
    "down_grace_period\030\r \001(\0132\023.mesos.Duration"
    "Info\022\035\n\006labels\030\016 \001(\0132\r.mesos.Labels\",\n\004T"
    "ype\022\013\n\007UNKNOWN\020\000\022\013\n\007DEFAULT\020\001\022\n\n\006CUSTOM\020"
    "\002\"\211\001\n\nMasterInfo\022\n\n\002id\030\001 \002(\t\022\n\n\002ip\030\002 \002(\r"
    "\022\022\n\004port\030\003 \002(\r:\0045050\022\013\n\003pid\030\004 \001(\t\022\020\n\010hos"
    "tname\030\005 \001(\t\022\017\n\007version\030\006 \001(\t\022\037\n\007address\030"
    "\007 \001(\0132\016.mesos.Address\"\225\002\n\tSlaveInfo\022\020\n\010h"
    "ostname\030\001 \002(\t\022\022\n\004port\030\010 \001(\005:\0045051\022\"\n\tres"
    "ources\030\003 \003(\0132\017.mesos.Resource\022$\n\nattribu"
    "tes\030\005 \003(\0132\020.mesos.Attribute\022\032\n\002id\030\006 \001(\0132"
    "\016.mesos.SlaveID\022\031\n\ncheckpoint\030\007 \001(\010:\005fal"
    "se\032a\n\nCapability\022.\n\004type\030\001 \001(\0162 .mesos.S"
    "laveInfo.Capability.Type\"#\n\004Type\022\013\n\007UNKN"
    "OWN\020\000\022\016\n\nMULTI_ROLE\020\001\"\374\002\n\005Value\022\037\n\004type\030"
    "\001 \002(\0162\021.mesos.Value.Type\022#\n\006scalar\030\002 \001(\013"
    "2\023.mesos.Value.Scalar\022#\n\006ranges\030\003 \001(\0132\023."
    "mesos.Value.Ranges\022\035\n\003set\030\004 \001(\0132\020.mesos."
    "Value.Set\022\037\n\004text\030\005 \001(\0132\021.mesos.Value.Te"
    "xt\032\027\n\006Scalar\022\r\n\005value\030\001 \002(\001\032#\n\005Range\022\r\n\005"
    "begin\030\001 \002(\004\022\013\n\003end\030\002 \002(\004\032+\n\006Ranges\022!\n\005ra"
    "nge\030\001 \003(\0132\022.mesos.Value.Range\032\023\n\003Set\022\014\n\004"
    "item\030\001 \003(\t\032\025\n\004Text\022\r\n\005value\030\001 \002(\t\"1\n\004Typ"
    "e\022\n\n\006SCALAR\020\000\022\n\n\006RANGES\020\001\022\007\n\003SET\020\002\022\010\n\004TE"
    "XT\020\003\"\304\001\n\tAttribute\022\014\n\004name\030\001 \002(\t\022\037\n\004type"
    "\030\002 \002(\0162\021.mesos.Value.Type\022#\n\006scalar\030\003 \001("
    "\0132\023.mesos.Value.Scalar\022#\n\006ranges\030\004 \001(\0132\023"
    ".mesos.Value.Ranges\022\035\n\003set\030\006 \001(\0132\020.mesos"
    ".Value.Set\022\037\n\004text\030\005 \001(\0132\021.mesos.Value.T"
    "ext\"\242\010\n\010Resource\022.\n\013provider_id\030\014 \001(\0132\031."
    "mesos.ResourceProviderID\022\014\n\004name\030\001 \002(\t\022\037"
    "\n\004type\030\002 \002(\0162\021.mesos.Value.Type\022#\n\006scala"
    "r\030\003 \001(\0132\023.mesos.Value.Scalar\022#\n\006ranges\030\004"
    " \001(\0132\023.mesos.Value.Ranges\022\035\n\003set\030\005 \001(\0132\020"
    ".mesos.Value.Set\022\017\n\004role\030\006 \001(\t:\001*\0227\n\017all"
    "ocation_info\030\013 \001(\0132\036.mesos.Resource.Allo"
    "cationInfo\0224\n\013reservation\030\010 \001(\0132\037.mesos."
    "Resource.ReservationInfo\022&\n\004disk\030\007 \001(\0132\030"
    ".mesos.Resource.DiskInfo\0220\n\trevocable\030\t "
    "\001(\0132\035.mesos.Resource.RevocableInfo\022*\n\006sh"
    "ared\030\n \001(\0132\032.mesos.Resource.SharedInfo\032\036"
    "\n\016AllocationInfo\022\014\n\004role\030\001 \001(\t\032C\n\017Reserv"
    "ationInfo\022\021\n\tprincipal\030\001 \001(\t\022\035\n\006labels\030\002"
    " \001(\0132\r.mesos.Labels\032\303\003\n\010DiskInfo\0229\n\013pers"
    "istence\030\001 \001(\0132$.mesos.Resource.DiskInfo."
    "Persistence\022\035\n\006volume\030\002 \001(\0132\r.mesos.Volu"
    "me\022/\n\006source\030\003 \001(\0132\037.mesos.Resource.Disk"
    "Info.Source\032,\n\013Persistence\022\n\n\002id\030\001 \002(\t\022\021"
    "\n\tprincipal\030\002 \001(\t\032\375\001\n\006Source\0222\n\004type\030\001 \002"
    "(\0162$.mesos.Resource.DiskInfo.Source.Type"
    "\0222\n\004path\030\002 \001(\0132$.mesos.Resource.DiskInfo"
    ".Source.Path\0224\n\005mount\030\003 \001(\0132%.mesos.Reso"
    "urce.DiskInfo.Source.Mount\032\024\n\004Path\022\014\n\004ro"
    "ot\030\001 \001(\t\032\025\n\005Mount\022\014\n\004root\030\001 \001(\t\"(\n\004Type\022"
    "\013\n\007UNKNOWN\020\000\022\010\n\004PATH\020\001\022\t\n\005MOUNT\020\002\032\017\n\rRev"
    "ocableInfo\032\014\n\nSharedInfo\"\274\001\n\030TrafficCont"
    "rolStatistics\022\n\n\002id\030\001 \002(\t\022\017\n\007backlog\030\002 \001"
    "(\004\022\r\n\005bytes\030\003 \001(\004\022\r\n\005drops\030\004 \001(\004\022\022\n\nover"
    "limits\030\005 \001(\004\022\017\n\007packets\030\006 \001(\004\022\014\n\004qlen\030\007 "
    "\001(\004\022\017\n\007ratebps\030\010 \001(\004\022\017\n\007ratepps\030\t \001(\004\022\020\n"
    "\010requeues\030\n \001(\004\"\225\003\n\014IpStatistics\022\022\n\nForw"
    "arding\030\001 \001(\003\022\022\n\nDefaultTTL\030\002 \001(\003\022\022\n\nInRe"
    "ceives\030\003 \001(\003\022\023\n\013InHdrErrors\030\004 \001(\003\022\024\n\014InA"
    "ddrErrors\030\005 \001(\003\022\025\n\rForwDatagrams\030\006 \001(\003\022\027"
    "\n\017InUnknownProtos\030\007 \001(\003\022\022\n\nInDiscards\030\010 "
    "\001(\003\022\022\n\nInDelivers\030\t \001(\003\022\023\n\013OutRequests\030\n"
    " \001(\003\022\023\n\013OutDiscards\030\013 \001(\003\022\023\n\013OutNoRoutes"
    "\030\014 \001(\003\022\024\n\014ReasmTimeout\030\r \001(\003\022\022\n\nReasmReq"
    "ds\030\016 \001(\003\022\020\n\010ReasmOKs\030\017 \001(\003\022\022\n\nReasmFails"
    "\030\020 \001(\003\022\017\n\007FragOKs\030\021 \001(\003\022\021\n\tFragFails\030\022 \001"
    "(\003\022\023\n\013FragCreates\030\023 \001(\003\"\323\004\n\016IcmpStatisti"
    "cs\022\016\n\006InMsgs\030\001 \001(\003\022\020\n\010InErrors\030\002 \001(\003\022\024\n\014"
    "InCsumErrors\030\003 \001(\003\022\026\n\016InDestUnreachs\030\004 \001"
    "(\003\022\023\n\013InTimeExcds\030\005 \001(\003\022\023\n\013InParmProbs\030\006"
    " \001(\003\022\024\n\014InSrcQuenchs\030\007 \001(\003\022\023\n\013InRedirect"
    "s\030\010 \001(\003\022\017\n\007InEchos\030\t \001(\003\022\022\n\nInEchoReps\030\n"
    " \001(\003\022\024\n\014InTimestamps\030\013 \001(\003\022\027\n\017InTimestam"
    "pReps\030\014 \001(\003\022\023\n\013InAddrMasks\030\r \001(\003\022\026\n\016InAd"
    "drMaskReps\030\016 \001(\003\022\017\n\007OutMsgs\030\017 \001(\003\022\021\n\tOut"
    "Errors\030\020 \001(\003\022\027\n\017OutDestUnreachs\030\021 \001(\003\022\024\n"
    "\014OutTimeExcds\030\022 \001(\003\022\024\n\014OutParmProbs\030\023 \001("
    "\003\022\025\n\rOutSrcQuenchs\030\024 \001(\003\022\024\n\014OutRedirects"
    "\030\025 \001(\003\022\020\n\010OutEchos\030\026 \001(\003\022\023\n\013OutEchoReps\030"
    "\027 \001(\003\022\025\n\rOutTimestamps\030\030 \001(\003\022\030\n\020OutTimes"
    "tampReps\030\031 \001(\003\022\024\n\014OutAddrMasks\030\032 \001(\003\022\027\n\017"
    "OutAddrMaskReps\030\033 \001(\003\"\254\002\n\rTcpStatistics\022"
    "\024\n\014RtoAlgorithm\030\001 \001(\003\022\016\n\006RtoMin\030\002 \001(\003\022\016\n"
    "\006RtoMax\030\003 \001(\003\022\017\n\007MaxConn\030\004 \001(\003\022\023\n\013Active"
    "Opens\030\005 \001(\003\022\024\n\014PassiveOpens\030\006 \001(\003\022\024\n\014Att"
    "emptFails\030\007 \001(\003\022\023\n\013EstabResets\030\010 \001(\003\022\021\n\t"
    "CurrEstab\030\t \001(\003\022\016\n\006InSegs\030\n \001(\003\022\017\n\007OutSe"
    "gs\030\013 \001(\003\022\023\n\013RetransSegs\030\014 \001(\003\022\016\n\006InErrs\030"
    "\r \001(\003\022\017\n\007OutRsts\030\016 \001(\003\022\024\n\014InCsumErrors\030\017"
    " \001(\003\"\265\001\n\rUdpStatistics\022\023\n\013InDatagrams\030\001 "
    "\001(\003\022\017\n\007NoPorts\030\002 \001(\003\022\020\n\010InErrors\030\003 \001(\003\022\024"
    "\n\014OutDatagrams\030\004 \001(\003\022\024\n\014RcvbufErrors\030\005 \001"
    "(\003\022\024\n\014SndbufErrors\030\006 \001(\003\022\024\n\014InCsumErrors"
    "\030\007 \001(\003\022\024\n\014IgnoredMulti\030\010 \001(\003\"\264\001\n\016SNMPSta"
    "tistics\022%\n\010ip_stats\030\001 \001(\0132\023.mesos.IpStat"
    "istics\022)\n\nicmp_stats\030\002 \001(\0132\025.mesos.IcmpS"
    "tatistics\022\'\n\ttcp_stats\030\003 \001(\0132\024.mesos.Tcp"
    "Statistics\022\'\n\tudp_stats\030\004 \001(\0132\024.mesos.Ud"
    "pStatistics\"\245\001\n\016DiskStatistics\022/\n\006source"
    "\030\001 \001(\0132\037.mesos.Resource.DiskInfo.Source\022"
    "9\n\013persistence\030\002 \001(\0132$.mesos.Resource.Di"
    "skInfo.Persistence\022\023\n\013limit_bytes\030\003 \001(\004\022"
    "\022\n\nused_bytes\030\004 \001(\004\"\232\n\n\022ResourceStatisti"
    "cs\022\021\n\ttimestamp\030\001 \002(\001\022\021\n\tprocesses\030\036 \001(\r"
    "\022\017\n\007threads\030\037 \001(\r\022\033\n\023cpus_user_time_secs"
    "\030\002 \001(\001\022\035\n\025cpus_system_time_secs\030\003 \001(\001\022\022\n"
    "\ncpus_limit\030\004 \001(\001\022\027\n\017cpus_nr_periods\030\007 \001"
    "(\r\022\031\n\021cpus_nr_throttled\030\010 \001(\r\022 \n\030cpus_th"
    "rottled_time_secs\030\t \001(\001\022\027\n\017mem_total_byt"
    "es\030$ \001(\004\022\035\n\025mem_total_memsw_bytes\030% \001(\004\022"
    "\027\n\017mem_limit_bytes\030\006 \001(\004\022\034\n\024mem_soft_lim"
    "it_bytes\030& \001(\004\022\026\n\016mem_file_bytes\030\n \001(\004\022\026"
    "\n\016mem_anon_bytes\030\013 \001(\004\022\027\n\017mem_cache_byte"
    "s\030\' \001(\004\022\025\n\rmem_rss_bytes\030\005 \001(\004\022\035\n\025mem_ma"
    "pped_file_bytes\030\014 \001(\004\022\026\n\016mem_swap_bytes\030"
    "( \001(\004\022\035\n\025mem_unevictable_bytes\030) \001(\004\022 \n\030"
    "mem_low_pressure_counter\030  \001(\004\022#\n\033mem_me"
    "dium_pressure_counter\030! \001(\004\022%\n\035mem_criti"
    "cal_pressure_counter\030\" \001(\004\022\030\n\020disk_limit"
    "_bytes\030\032 \001(\004\022\027\n\017disk_used_bytes\030\033 \001(\004\022.\n"
    "\017disk_statistics\030+ \003(\0132\025.mesos.DiskStati"
    "stics\022#\n\004perf\030\r \001(\0132\025.mesos.PerfStatisti"
    "cs\022\026\n\016net_rx_packets\030\016 \001(\004\022\024\n\014net_rx_byt"
    "es\030\017 \001(\004\022\025\n\rnet_rx_errors\030\020 \001(\004\022\026\n\016net_r"
    "x_dropped\030\021 \001(\004\022\026\n\016net_tx_packets\030\022 \001(\004\022"
    "\024\n\014net_tx_bytes\030\023 \001(\004\022\025\n\rnet_tx_errors\030\024"
    " \001(\004\022\026\n\016net_tx_dropped\030\025 \001(\004\022!\n\031net_tcp_"
    "rtt_microsecs_p50\030\026 \001(\001\022!\n\031net_tcp_rtt_m"
    "icrosecs_p90\030\027 \001(\001\022!\n\031net_tcp_rtt_micros"
    "ecs_p95\030\030 \001(\001\022!\n\031net_tcp_rtt_microsecs_p"
    "99\030\031 \001(\001\022\"\n\032net_tcp_active_connections\030\034"
    " \001(\001\022%\n\035net_tcp_time_wait_connections\030\035 "
    "\001(\001\022G\n\036net_traffic_control_statistics\030# "
    "\003(\0132\037.mesos.TrafficControlStatistics\0222\n\023"
    "net_snmp_statistics\030* \001(\0132\025.mesos.SNMPSt"
    "atistics\"\276\003\n\rResourceUsage\0220\n\texecutors\030"
    "\001 \003(\0132\035.mesos.ResourceUsage.Executor\022\036\n\005"
    "total\030\002 \003(\0132\017.mesos.Resource\032\332\002\n\010Executo"
    "r\022*\n\rexecutor_info\030\001 \002(\0132\023.mesos.Executo"
    "rInfo\022\"\n\tallocated\030\002 \003(\0132\017.mesos.Resourc"
    "e\022-\n\nstatistics\030\003 \001(\0132\031.mesos.ResourceSt"
    "atistics\022(\n\014container_id\030\004 \002(\0132\022.mesos.C"
    "ontainerID\0221\n\005tasks\030\005 \003(\0132\".mesos.Resour"
    "ceUsage.Executor.Task\032r\n\004Task\022\014\n\004name\030\001 "
    "\002(\t\022\031\n\002id\030\002 \002(\0132\r.mesos.TaskID\022\"\n\tresour"
    "ces\030\003 \003(\0132\017.mesos.Resource\022\035\n\006labels\030\004 \001"
    "(\0132\r.mesos.Labels\"\260\n\n\016PerfStatistics\022\021\n\t"
    "timestamp\030\001 \002(\001\022\020\n\010duration\030\002 \002(\001\022\016\n\006cyc"
    "les\030\003 \001(\004\022\037\n\027stalled_cycles_frontend\030\004 \001"
    "(\004\022\036\n\026stalled_cycles_backend\030\005 \001(\004\022\024\n\014in"
    "structions\030\006 \001(\004\022\030\n\020cache_references\030\007 \001"
    "(\004\022\024\n\014cache_misses\030\010 \001(\004\022\020\n\010branches\030\t \001"
    "(\004\022\025\n\rbranch_misses\030\n \001(\004\022\022\n\nbus_cycles\030"
    "\013 \001(\004\022\022\n\nref_cycles\030\014 \001(\004\022\021\n\tcpu_clock\030\r"
    " \001(\001\022\022\n\ntask_clock\030\016 \001(\001\022\023\n\013page_faults\030"
    "\017 \001(\004\022\024\n\014minor_faults\030\020 \001(\004\022\024\n\014major_fau"
    "lts\030\021 \001(\004\022\030\n\020context_switches\030\022 \001(\004\022\026\n\016c"
    "pu_migrations\030\023 \001(\004\022\030\n\020alignment_faults\030"
    "\024 \001(\004\022\030\n\020emulation_faults\030\025 \001(\004\022\027\n\017l1_dc"
    "ache_loads\030\026 \001(\004\022\035\n\025l1_dcache_load_misse"
    "s\030\027 \001(\004\022\030\n\020l1_dcache_stores\030\030 \001(\004\022\036\n\026l1_"
    "dcache_store_misses\030\031 \001(\004\022\034\n\024l1_dcache_p"
    "refetches\030\032 \001(\004\022!\n\031l1_dcache_prefetch_mi"
    "sses\030\033 \001(\004\022\027\n\017l1_icache_loads\030\034 \001(\004\022\035\n\025l"
    "1_icache_load_misses\030\035 \001(\004\022\034\n\024l1_icache_"
    "prefetches\030\036 \001(\004\022!\n\031l1_icache_prefetch_m"
    "isses\030\037 \001(\004\022\021\n\tllc_loads\030  \001(\004\022\027\n\017llc_lo"
    "ad_misses\030! \001(\004\022\022\n\nllc_stores\030\" \001(\004\022\030\n\020l"
    "lc_store_misses\030# \001(\004\022\026\n\016llc_prefetches\030"
    "$ \001(\004\022\033\n\023llc_prefetch_misses\030% \001(\004\022\022\n\ndt"
    "lb_loads\030& \001(\004\022\030\n\020dtlb_load_misses\030\' \001(\004"
    "\022\023\n\013dtlb_stores\030( \001(\004\022\031\n\021dtlb_store_miss"
    "es\030) \001(\004\022\027\n\017dtlb_prefetches\030* \001(\004\022\034\n\024dtl"
    "b_prefetch_misses\030+ \001(\004\022\022\n\nitlb_loads\030, "
    "\001(\004\022\030\n\020itlb_load_misses\030- \001(\004\022\024\n\014branch_"
    "loads\030. \001(\004\022\032\n\022branch_load_misses\030/ \001(\004\022"
    "\022\n\nnode_loads\0300 \001(\004\022\030\n\020node_load_misses\030"
    "1 \001(\004\022\023\n\013node_stores\0302 \001(\004\022\031\n\021node_store"
    "_misses\0303 \001(\004\022\027\n\017node_prefetches\0304 \001(\004\022\034"
    "\n\024node_prefetch_misses\0305 \001(\004\"O\n\007Request\022"
    " \n\010slave_id\030\001 \001(\0132\016.mesos.SlaveID\022\"\n\tres"
    "ources\030\002 \003(\0132\017.mesos.Resource\"\215\t\n\005Offer\022"
    "\032\n\002id\030\001 \002(\0132\016.mesos.OfferID\022(\n\014framework"
    "_id\030\002 \002(\0132\022.mesos.FrameworkID\022 \n\010slave_i"
    "d\030\003 \002(\0132\016.mesos.SlaveID\022\020\n\010hostname\030\004 \002("
    "\t\022\027\n\003url\030\010 \001(\0132\n.mesos.URL\022\"\n\tresources\030"
    "\005 \003(\0132\017.mesos.Resource\022$\n\nattributes\030\007 \003"
    "(\0132\020.mesos.Attribute\022\'\n\014executor_ids\030\006 \003"
    "(\0132\021.mesos.ExecutorID\022-\n\016unavailability\030"
    "\t \001(\0132\025.mesos.Unavailability\0227\n\017allocati"
    "on_info\030\n \001(\0132\036.mesos.Resource.Allocatio"
    "nInfo\032\225\006\n\tOperation\022)\n\004type\030\001 \001(\0162\033.meso"
    "s.Offer.Operation.Type\022-\n\006launch\030\002 \001(\0132\035"
    ".mesos.Offer.Operation.Launch\0228\n\014launch_"
    "group\030\007 \001(\0132\".mesos.Offer.Operation.Laun"
    "chGroup\022/\n\007reserve\030\003 \001(\0132\036.mesos.Offer.O"
    "peration.Reserve\0223\n\tunreserve\030\004 \001(\0132 .me"
    "sos.Offer.Operation.Unreserve\022-\n\006create\030"
    "\005 \001(\0132\035.mesos.Offer.Operation.Create\022/\n\007"
    "destroy\030\006 \001(\0132\036.mesos.Offer.Operation.De"
    "stroy\032-\n\006Launch\022#\n\ntask_infos\030\001 \003(\0132\017.me"
    "sos.TaskInfo\032^\n\013LaunchGroup\022%\n\010executor\030"
    "\001 \002(\0132\023.mesos.ExecutorInfo\022(\n\ntask_group"
    "\030\002 \002(\0132\024.mesos.TaskGroupInfo\032-\n\007Reserve\022"
    "\"\n\tresources\030\001 \003(\0132\017.mesos.Resource\032/\n\tU"
    "nreserve\022\"\n\tresources\030\001 \003(\0132\017.mesos.Reso"
    "urce\032*\n\006Create\022 \n\007volumes\030\001 \003(\0132\017.mesos."
    "Resource\032+\n\007Destroy\022 \n\007volumes\030\001 \003(\0132\017.m"
    "esos.Resource\"f\n\004Type\022\013\n\007UNKNOWN\020\000\022\n\n\006LA"
    "UNCH\020\001\022\020\n\014LAUNCH_GROUP\020\006\022\013\n\007RESERVE\020\002\022\r\n"
    "\tUNRESERVE\020\003\022\n\n\006CREATE\020\004\022\013\n\007DESTROY\020\005\"\342\001"
    "\n\014InverseOffer\022\032\n\002id\030\001 \002(\0132\016.mesos.Offer"
    "ID\022\027\n\003url\030\002 \001(\0132\n.mesos.URL\022(\n\014framework"
    "_id\030\003 \002(\0132\022.mesos.FrameworkID\022 \n\010slave_i"
    "d\030\004 \001(\0132\016.mesos.SlaveID\022-\n\016unavailabilit"
    "y\030\005 \002(\0132\025.mesos.Unavailability\022\"\n\tresour"
    "ces\030\006 \003(\0132\017.mesos.Resource\"\274\003\n\010TaskInfo\022"
    "\014\n\004name\030\001 \002(\t\022\036\n\007task_id\030\002 \002(\0132\r.mesos.T"
    "askID\022 \n\010slave_id\030\003 \002(\0132\016.mesos.SlaveID\022"
    "\"\n\tresources\030\004 \003(\0132\017.mesos.Resource\022%\n\010e"
    "xecutor\030\005 \001(\0132\023.mesos.ExecutorInfo\022#\n\007co"
    "mmand\030\007 \001(\0132\022.mesos.CommandInfo\022\'\n\tconta"
    "iner\030\t \001(\0132\024.mesos.ContainerInfo\022(\n\014heal"
    "th_check\030\010 \001(\0132\022.mesos.HealthCheck\022\037\n\005ch"
    "eck\030\r \001(\0132\020.mesos.CheckInfo\022&\n\013kill_poli"
    "cy\030\014 \001(\0132\021.mesos.KillPolicy\022\014\n\004data\030\006 \001("
    "\014\022\035\n\006labels\030\n \001(\0132\r.mesos.Labels\022\'\n\tdisc"
    "overy\030\013 \001(\0132\024.mesos.DiscoveryInfo\"/\n\rTas"
    "kGroupInfo\022\036\n\005tasks\030\001 \003(\0132\017.mesos.TaskIn"
    "fo\"\334\003\n\004Task\022\014\n\004name\030\001 \002(\t\022\036\n\007task_id\030\002 \002"
    "(\0132\r.mesos.TaskID\022(\n\014framework_id\030\003 \002(\0132"
    "\022.mesos.FrameworkID\022&\n\013executor_id\030\004 \001(\013"
    "2\021.mesos.ExecutorID\022 \n\010slave_id\030\005 \002(\0132\016."
    "mesos.SlaveID\022\037\n\005state\030\006 \002(\0162\020.mesos.Tas"
    "kState\022\"\n\tresources\030\007 \003(\0132\017.mesos.Resour"
    "ce\022#\n\010statuses\030\010 \003(\0132\021.mesos.TaskStatus\022"
    "-\n\023status_update_state\030\t \001(\0162\020.mesos.Tas"
    "kState\022\032\n\022status_update_uuid\030\n \001(\014\022\035\n\006la"
    "bels\030\013 \001(\0132\r.mesos.Labels\022\'\n\tdiscovery\030\014"
    " \001(\0132\024.mesos.DiscoveryInfo\022\'\n\tcontainer\030"
    "\r \001(\0132\024.mesos.ContainerInfo\022\014\n\004user\030\016 \001("
    "\t\"\220\002\n\017CheckStatusInfo\022#\n\004type\030\001 \001(\0162\025.me"
    "sos.CheckInfo.Type\022/\n\007command\030\002 \001(\0132\036.me"
    "sos.CheckStatusInfo.Command\022)\n\004http\030\003 \001("
    "\0132\033.mesos.CheckStatusInfo.Http\022\'\n\003tcp\030\004 "
    "\001(\0132\032.mesos.CheckStatusInfo.Tcp\032\034\n\007Comma"
    "nd\022\021\n\texit_code\030\001 \001(\005\032\033\n\004Http\022\023\n\013status_"
    "code\030\001 \001(\r\032\030\n\003Tcp\022\021\n\tsucceeded\030\001 \001(\010\"\377\013\n"
    "\nTaskStatus\022\036\n\007task_id\030\001 \002(\0132\r.mesos.Tas"
    "kID\022\037\n\005state\030\002 \002(\0162\020.mesos.TaskState\022\017\n\007"
    "message\030\004 \001(\t\022(\n\006source\030\t \001(\0162\030.mesos.Ta"
    "skStatus.Source\022(\n\006reason\030\n \001(\0162\030.mesos."
    "TaskStatus.Reason\022\014\n\004data\030\003 \001(\014\022 \n\010slave"
    "_id\030\005 \001(\0132\016.mesos.SlaveID\022&\n\013executor_id"
    "\030\007 \001(\0132\021.mesos.ExecutorID\022\021\n\ttimestamp\030\006"
    " \001(\001\022\014\n\004uuid\030\013 \001(\014\022\017\n\007healthy\030\010 \001(\010\022,\n\014c"
    "heck_status\030\017 \001(\0132\026.mesos.CheckStatusInf"
    "o\022\035\n\006labels\030\014 \001(\0132\r.mesos.Labels\0220\n\020cont"
    "ainer_status\030\r \001(\0132\026.mesos.ContainerStat"
    "us\022)\n\020unreachable_time\030\016 \001(\0132\017.mesos.Tim"
    "eInfo\"B\n\006Source\022\021\n\rSOURCE_MASTER\020\000\022\020\n\014SO"
    "URCE_SLAVE\020\001\022\023\n\017SOURCE_EXECUTOR\020\002\"\322\007\n\006Re"
    "ason\022\"\n\036REASON_COMMAND_EXECUTOR_FAILED\020\000"
    "\022\"\n\036REASON_CONTAINER_LAUNCH_FAILED\020\025\022\037\n\033"
    "REASON_CONTAINER_LIMITATION\020\023\022$\n REASON_"
    "CONTAINER_LIMITATION_DISK\020\024\022&\n\"REASON_CO"
    "NTAINER_LIMITATION_MEMORY\020\010\022\036\n\032REASON_CO"
    "NTAINER_PREEMPTED\020\021\022\"\n\036REASON_CONTAINER_"
    "UPDATE_FAILED\020\026\022(\n$REASON_EXECUTOR_REGIS"
    "TRATION_TIMEOUT\020\027\022*\n&REASON_EXECUTOR_RER"
    "EGISTRATION_TIMEOUT\020\030\022\036\n\032REASON_EXECUTOR"
    "_TERMINATED\020\001\022 \n\034REASON_EXECUTOR_UNREGIS"
    "TERED\020\002\022\034\n\030REASON_FRAMEWORK_REMOVED\020\003\022\023\n"
    "\017REASON_GC_ERROR\020\004\022\036\n\032REASON_INVALID_FRA"
    "MEWORKID\020\005\022\031\n\025REASON_INVALID_OFFERS\020\006\022 \n"
    "\034REASON_IO_SWITCHBOARD_EXITED\020\033\022\036\n\032REASO"
    "N_MASTER_DISCONNECTED\020\007\022\031\n\025REASON_RECONC"
    "ILIATION\020\t\022\034\n\030REASON_RESOURCES_UNKNOWN\020\022"
    "\022\035\n\031REASON_SLAVE_DISCONNECTED\020\n\022\030\n\024REASO"
    "N_SLAVE_REMOVED\020\013\022\032\n\026REASON_SLAVE_RESTAR"
    "TED\020\014\022\030\n\024REASON_SLAVE_UNKNOWN\020\r\022$\n REASO"
    "N_TASK_KILLED_DURING_LAUNCH\020\036\022$\n REASON_"
    "TASK_CHECK_STATUS_UPDATED\020\034\022\035\n\031REASON_TA"
    "SK_GROUP_INVALID\020\031\022\"\n\036REASON_TASK_GROUP_"
    "UNAUTHORIZED\020\032\022\027\n\023REASON_TASK_INVALID\020\016\022"
    "\034\n\030REASON_TASK_UNAUTHORIZED\020\017\022\027\n\023REASON_"
    "TASK_UNKNOWN\020\020\"$\n\007Filters\022\031\n\016refuse_seco"
    "nds\030\001 \001(\001:\0015\"\351\001\n\013Environment\022.\n\tvariable"
    "s\030\001 \003(\0132\033.mesos.Environment.Variable\032\251\001\n"
    "\010Variable\022\014\n\004name\030\001 \002(\t\0225\n\004type\030\003 \001(\0162 ."
    "mesos.Environment.Variable.Type:\005VALUE\022\r"
    "\n\005value\030\002 \001(\t\022\035\n\006secret\030\004 \001(\0132\r.mesos.Se"
    "cret\"*\n\004Type\022\013\n\007UNKNOWN\020\000\022\t\n\005VALUE\020\001\022\n\n\006"
    "SECRET\020\002\"\'\n\tParameter\022\013\n\003key\030\001 \002(\t\022\r\n\005va"
    "lue\030\002 \002(\t\"1\n\nParameters\022#\n\tparameter\030\001 \003"
    "(\0132\020.mesos.Parameter\"/\n\nCredential\022\021\n\tpr"
    "incipal\030\001 \002(\t\022\016\n\006secret\030\002 \001(\t\"5\n\013Credent"
    "ials\022&\n\013credentials\030\001 \003(\0132\021.mesos.Creden"
    "tial\"\350\001\n\006Secret\022 \n\004type\030\001 \001(\0162\022.mesos.Se"
    "cret.Type\022*\n\treference\030\002 \001(\0132\027.mesos.Sec"
    "ret.Reference\022\"\n\005value\030\003 \001(\0132\023.mesos.Sec"
    "ret.Value\032&\n\tReference\022\014\n\004name\030\001 \002(\t\022\013\n\003"
    "key\030\002 \001(\t\032\025\n\005Value\022\014\n\004data\030\001 \002(\014\"-\n\004Type"
    "\022\013\n\007UNKNOWN\020\000\022\r\n\tREFERENCE\020\001\022\t\n\005VALUE\020\002\""
    "=\n\tRateLimit\022\013\n\003qps\030\001 \001(\001\022\021\n\tprincipal\030\002"
    " \002(\t\022\020\n\010capacity\030\003 \001(\004\"q\n\nRateLimits\022 \n\006"
    "limits\030\001 \003(\0132\020.mesos.RateLimit\022\035\n\025aggreg"
    "ate_default_qps\030\002 \001(\001\022\"\n\032aggregate_defau"
    "lt_capacity\030\003 \001(\004\"\305\002\n\005Image\022\037\n\004type\030\001 \002("
    "\0162\021.mesos.Image.Type\022\037\n\004appc\030\002 \001(\0132\021.mes"
    "os.Image.Appc\022#\n\006docker\030\003 \001(\0132\023.mesos.Im"
    "age.Docker\022\024\n\006cached\030\004 \001(\010:\004true\032\?\n\004Appc"
    "\022\014\n\004name\030\001 \002(\t\022\n\n\002id\030\002 \001(\t\022\035\n\006labels\030\003 \001"
    "(\0132\r.mesos.Labels\032`\n\006Docker\022\014\n\004name\030\001 \002("
    "\t\022)\n\ncredential\030\002 \001(\0132\021.mesos.Credential"
    "B\002\030\001\022\035\n\006config\030\003 \001(\0132\r.mesos.Secret\"\034\n\004T"
    "ype\022\010\n\004APPC\020\001\022\n\n\006DOCKER\020\002\"\221\005\n\006Volume\022 \n\004"
    "mode\030\003 \002(\0162\022.mesos.Volume.Mode\022\026\n\016contai"
    "ner_path\030\001 \002(\t\022\021\n\thost_path\030\002 \001(\t\022\033\n\005ima"
    "ge\030\004 \001(\0132\014.mesos.Image\022$\n\006source\030\005 \001(\0132\024"
    ".mesos.Volume.Source\032\336\003\n\006Source\022\'\n\004type\030"
    "\001 \001(\0162\031.mesos.Volume.Source.Type\0228\n\rdock"
    "er_volume\030\002 \001(\0132!.mesos.Volume.Source.Do"
    "ckerVolume\0226\n\014sandbox_path\030\003 \001(\0132 .mesos"
    ".Volume.Source.SandboxPath\022\035\n\006secret\030\004 \001"
    "(\0132\r.mesos.Secret\032W\n\014DockerVolume\022\016\n\006dri"
    "ver\030\001 \001(\t\022\014\n\004name\030\002 \002(\t\022)\n\016driver_option"
    "s\030\003 \001(\0132\021.mesos.Parameters\032{\n\013SandboxPat"
    "h\0223\n\004type\030\001 \001(\0162%.mesos.Volume.Source.Sa"
    "ndboxPath.Type\022\014\n\004path\030\002 \002(\t\")\n\004Type\022\013\n\007"
    "UNKNOWN\020\000\022\010\n\004SELF\020\001\022\n\n\006PARENT\020\002\"D\n\004Type\022"
    "\013\n\007UNKNOWN\020\000\022\021\n\rDOCKER_VOLUME\020\001\022\020\n\014SANDB"
    "OX_PATH\020\002\022\n\n\006SECRET\020\003\"\026\n\004Mode\022\006\n\002RW\020\001\022\006\n"
    "\002RO\020\002\"\361\002\n\013NetworkInfo\0222\n\014ip_addresses\030\005 "
    "\003(\0132\034.mesos.NetworkInfo.IPAddress\022\014\n\004nam"
    "e\030\006 \001(\t\022\016\n\006groups\030\003 \003(\t\022\035\n\006labels\030\004 \001(\0132"
    "\r.mesos.Labels\0225\n\rport_mappings\030\007 \003(\0132\036."
    "mesos.NetworkInfo.PortMapping\032N\n\tIPAddre"
    "ss\022-\n\010protocol\030\001 \001(\0162\033.mesos.NetworkInfo"
    ".Protocol\022\022\n\nip_address\030\002 \001(\t\032J\n\013PortMap"
    "ping\022\021\n\thost_port\030\001 \002(\r\022\026\n\016container_por"
    "t\030\002 \002(\r\022\020\n\010protocol\030\003 \001(\t\"\036\n\010Protocol\022\010\n"
    "\004IPv4\020\001\022\010\n\004IPv6\020\002\"\316\005\n\016CapabilityInfo\0226\n\014"
    "capabilities\030\001 \003(\0162 .mesos.CapabilityInf"
    "o.Capability\"\203\005\n\nCapability\022\013\n\007UNKNOWN\020\000"
    "\022\n\n\005CHOWN\020\350\007\022\021\n\014DAC_OVERRIDE\020\351\007\022\024\n\017DAC_R"
    "EAD_SEARCH\020\352\007\022\013\n\006FOWNER\020\353\007\022\013\n\006FSETID\020\354\007\022"
    "\t\n\004KILL\020\355\007\022\013\n\006SETGID\020\356\007\022\013\n\006SETUID\020\357\007\022\014\n\007"
    "SETPCAP\020\360\007\022\024\n\017LINUX_IMMUTABLE\020\361\007\022\025\n\020NET_"
    "BIND_SERVICE\020\362\007\022\022\n\rNET_BROADCAST\020\363\007\022\016\n\tN"
    "ET_ADMIN\020\364\007\022\014\n\007NET_RAW\020\365\007\022\r\n\010IPC_LOCK\020\366\007"
    "\022\016\n\tIPC_OWNER\020\367\007\022\017\n\nSYS_MODULE\020\370\007\022\016\n\tSYS"
    "_RAWIO\020\371\007\022\017\n\nSYS_CHROOT\020\372\007\022\017\n\nSYS_PTRACE"
    "\020\373\007\022\016\n\tSYS_PACCT\020\374\007\022\016\n\tSYS_ADMIN\020\375\007\022\r\n\010S"
    "YS_BOOT\020\376\007\022\r\n\010SYS_NICE\020\377\007\022\021\n\014SYS_RESOURC"
    "E\020\200\010\022\r\n\010SYS_TIME\020\201\010\022\023\n\016SYS_TTY_CONFIG\020\202\010"
    "\022\n\n\005MKNOD\020\203\010\022\n\n\005LEASE\020\204\010\022\020\n\013AUDIT_WRITE\020"
    "\205\010\022\022\n\rAUDIT_CONTROL\020\206\010\022\014\n\007SETFCAP\020\207\010\022\021\n\014"
    "MAC_OVERRIDE\020\210\010\022\016\n\tMAC_ADMIN\020\211\010\022\013\n\006SYSLO"
    "G\020\212\010\022\017\n\nWAKE_ALARM\020\213\010\022\022\n\rBLOCK_SUSPEND\020\214"
    "\010\022\017\n\nAUDIT_READ\020\215\010\";\n\tLinuxInfo\022.\n\017capab"
    "ility_info\030\001 \001(\0132\025.mesos.CapabilityInfo\""
    "\244\003\n\nRLimitInfo\022)\n\007rlimits\030\001 \003(\0132\030.mesos."
    "RLimitInfo.RLimit\032\352\002\n\006RLimit\022+\n\004type\030\001 \001"
    "(\0162\035.mesos.RLimitInfo.RLimit.Type\022\014\n\004har"
    "d\030\002 \001(\004\022\014\n\004soft\030\003 \001(\004\"\226\002\n\004Type\022\013\n\007UNKNOW"
    "N\020\000\022\013\n\007RLMT_AS\020\001\022\r\n\tRLMT_CORE\020\002\022\014\n\010RLMT_"
    "CPU\020\003\022\r\n\tRLMT_DATA\020\004\022\016\n\nRLMT_FSIZE\020\005\022\016\n\n"
    "RLMT_LOCKS\020\006\022\020\n\014RLMT_MEMLOCK\020\007\022\021\n\rRLMT_M"
    "SGQUEUE\020\010\022\r\n\tRLMT_NICE\020\t\022\017\n\013RLMT_NOFILE\020"
    "\n\022\016\n\nRLMT_NPROC\020\013\022\014\n\010RLMT_RSS\020\014\022\017\n\013RLMT_"
    "RTPRIO\020\r\022\017\n\013RLMT_RTTIME\020\016\022\023\n\017RLMT_SIGPEN"
    "DING\020\017\022\016\n\nRLMT_STACK\020\020\"f\n\007TTYInfo\022.\n\013win"
    "dow_size\030\001 \001(\0132\031.mesos.TTYInfo.WindowSiz"
    "e\032+\n\nWindowSize\022\014\n\004rows\030\001 \002(\r\022\017\n\007columns"
    "\030\002 \002(\r\"\307\006\n\rContainerInfo\022\'\n\004type\030\001 \002(\0162\031"
    ".mesos.ContainerInfo.Type\022\036\n\007volumes\030\002 \003"
    "(\0132\r.mesos.Volume\022\020\n\010hostname\030\004 \001(\t\022/\n\006d"
    "ocker\030\003 \001(\0132\037.mesos.ContainerInfo.Docker"
    "Info\022-\n\005mesos\030\005 \001(\0132\036.mesos.ContainerInf"
    "o.MesosInfo\022)\n\rnetwork_infos\030\007 \003(\0132\022.mes"
    "os.NetworkInfo\022$\n\nlinux_info\030\010 \001(\0132\020.mes"
    "os.LinuxInfo\022&\n\013rlimit_info\030\t \001(\0132\021.meso"
    "s.RLimitInfo\022 \n\010tty_info\030\n \001(\0132\016.mesos.T"
    "TYInfo\032\226\003\n\nDockerInfo\022\r\n\005image\030\001 \002(\t\022>\n\007"
    "network\030\002 \001(\0162\'.mesos.ContainerInfo.Dock"
    "erInfo.Network:\004HOST\022B\n\rport_mappings\030\003 "
    "\003(\0132+.mesos.ContainerInfo.DockerInfo.Por"
    "tMapping\022\031\n\nprivileged\030\004 \001(\010:\005false\022$\n\np"
    "arameters\030\005 \003(\0132\020.mesos.Parameter\022\030\n\020for"
    "ce_pull_image\030\006 \001(\010\022\031\n\rvolume_driver\030\007 \001"
    "(\tB\002\030\001\032J\n\013PortMapping\022\021\n\thost_port\030\001 \002(\r"
    "\022\026\n\016container_port\030\002 \002(\r\022\020\n\010protocol\030\003 \001"
    "(\t\"3\n\007Network\022\010\n\004HOST\020\001\022\n\n\006BRIDGE\020\002\022\010\n\004N"
    "ONE\020\003\022\010\n\004USER\020\004\032(\n\tMesosInfo\022\033\n\005image\030\001 "
    "\001(\0132\014.mesos.Image\"\035\n\004Type\022\n\n\006DOCKER\020\001\022\t\n"
    "\005MESOS\020\002\"\244\001\n\017ContainerStatus\022(\n\014containe"
    "r_id\030\004 \001(\0132\022.mesos.ContainerID\022)\n\rnetwor"
    "k_infos\030\001 \003(\0132\022.mesos.NetworkInfo\022&\n\013cgr"
    "oup_info\030\002 \001(\0132\021.mesos.CgroupInfo\022\024\n\014exe"
    "cutor_pid\030\003 \001(\r\"R\n\nCgroupInfo\022)\n\007net_cls"
    "\030\001 \001(\0132\030.mesos.CgroupInfo.NetCls\032\031\n\006NetC"
    "ls\022\017\n\007classid\030\001 \001(\r\"&\n\006Labels\022\034\n\006labels\030"
    "\001 \003(\0132\014.mesos.Label\"#\n\005Label\022\013\n\003key\030\001 \002("
    "\t\022\r\n\005value\030\002 \001(\t\"\212\001\n\004Port\022\016\n\006number\030\001 \002("
    "\r\022\014\n\004name\030\002 \001(\t\022\020\n\010protocol\030\003 \001(\t\0223\n\nvis"
    "ibility\030\004 \001(\0162\037.mesos.DiscoveryInfo.Visi"
    "bility\022\035\n\006labels\030\005 \001(\0132\r.mesos.Labels\"#\n"
    "\005Ports\022\032\n\005ports\030\001 \003(\0132\013.mesos.Port\"\376\001\n\rD"
    "iscoveryInfo\0223\n\nvisibility\030\001 \002(\0162\037.mesos"
    ".DiscoveryInfo.Visibility\022\014\n\004name\030\002 \001(\t\022"
    "\023\n\013environment\030\003 \001(\t\022\020\n\010location\030\004 \001(\t\022\017"
    "\n\007version\030\005 \001(\t\022\033\n\005ports\030\006 \001(\0132\014.mesos.P"
    "orts\022\035\n\006labels\030\007 \001(\0132\r.mesos.Labels\"6\n\nV"
    "isibility\022\r\n\tFRAMEWORK\020\000\022\013\n\007CLUSTER\020\001\022\014\n"
    "\010EXTERNAL\020\002\"*\n\nWeightInfo\022\016\n\006weight\030\001 \002("
    "\001\022\014\n\004role\030\002 \001(\t\"\220\001\n\013VersionInfo\022\017\n\007versi"
    "on\030\001 \002(\t\022\022\n\nbuild_date\030\002 \001(\t\022\022\n\nbuild_ti"
    "me\030\003 \001(\001\022\022\n\nbuild_user\030\004 \001(\t\022\017\n\007git_sha\030"
    "\005 \001(\t\022\022\n\ngit_branch\030\006 \001(\t\022\017\n\007git_tag\030\007 \001"
    "(\t\"#\n\004Flag\022\014\n\004name\030\001 \002(\t\022\r\n\005value\030\002 \001(\t\""
    "p\n\004Role\022\014\n\004name\030\001 \002(\t\022\016\n\006weight\030\002 \002(\001\022&\n"
    "\nframeworks\030\003 \003(\0132\022.mesos.FrameworkID\022\"\n"
    "\tresources\030\004 \003(\0132\017.mesos.Resource\"%\n\006Met"
    "ric\022\014\n\004name\030\001 \002(\t\022\r\n\005value\030\002 \001(\001\"}\n\010File"
    "Info\022\014\n\004path\030\001 \002(\t\022\r\n\005nlink\030\002 \001(\005\022\014\n\004siz"
    "e\030\003 \001(\004\022\036\n\005mtime\030\004 \001(\0132\017.mesos.TimeInfo\022"
    "\014\n\004mode\030\005 \001(\r\022\013\n\003uid\030\006 \001(\t\022\013\n\003gid\030\007 \001(\t\""
    "\026\n\006Device\022\014\n\004path\030\001 \002(\t\"\217\001\n\014DeviceAccess"
    "\022\035\n\006device\030\001 \002(\0132\r.mesos.Device\022*\n\006acces"
    "s\030\002 \002(\0132\032.mesos.DeviceAccess.Access\0324\n\006A"
    "ccess\022\014\n\004read\030\001 \001(\010\022\r\n\005write\030\002 \001(\010\022\r\n\005mk"
    "nod\030\003 \001(\010\"\?\n\017DeviceWhitelist\022,\n\017allowed_"
    "devices\030\001 \003(\0132\023.mesos.DeviceAccess*\\\n\006St"
    "atus\022\026\n\022DRIVER_NOT_STARTED\020\001\022\022\n\016DRIVER_R"
    "UNNING\020\002\022\022\n\016DRIVER_ABORTED\020\003\022\022\n\016DRIVER_S"
    "TOPPED\020\004*\214\002\n\tTaskState\022\020\n\014TASK_STAGING\020\006"
    "\022\021\n\rTASK_STARTING\020\000\022\020\n\014TASK_RUNNING\020\001\022\020\n"
    "\014TASK_KILLING\020\010\022\021\n\rTASK_FINISHED\020\002\022\017\n\013TA"
    "SK_FAILED\020\003\022\017\n\013TASK_KILLED\020\004\022\016\n\nTASK_ERR"
    "OR\020\007\022\r\n\tTASK_LOST\020\005\022\020\n\014TASK_DROPPED\020\t\022\024\n"
    "\020TASK_UNREACHABLE\020\n\022\r\n\tTASK_GONE\020\013\022\031\n\025TA"
    "SK_GONE_BY_OPERATOR\020\014\022\020\n\014TASK_UNKNOWN\020\rB"
    "\032\n\020org.apache.mesosB\006Protos", 20787);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mesos.proto", &protobuf_RegisterTypes);
  FrameworkID::default_instance_ = new FrameworkID();
  OfferID::default_instance_ = new OfferID();
  SlaveID::default_instance_ = new SlaveID();
  TaskID::default_instance_ = new TaskID();
  ExecutorID::default_instance_ = new ExecutorID();
  ContainerID::default_instance_ = new ContainerID();
  ResourceProviderID::default_instance_ = new ResourceProviderID();
  TimeInfo::default_instance_ = new TimeInfo();
  DurationInfo::default_instance_ = new DurationInfo();
  Address::default_instance_ = new Address();
  URL::default_instance_ = new URL();
  Unavailability::default_instance_ = new Unavailability();
  MachineID::default_instance_ = new MachineID();
  MachineInfo::default_instance_ = new MachineInfo();
  FrameworkInfo::_default_role_ =
      new ::std::string("*", 1);
  FrameworkInfo::default_instance_ = new FrameworkInfo();
  FrameworkInfo_Capability::default_instance_ = new FrameworkInfo_Capability();
  CheckInfo::default_instance_ = new CheckInfo();
  CheckInfo_Command::default_instance_ = new CheckInfo_Command();
  CheckInfo_Http::default_instance_ = new CheckInfo_Http();
  CheckInfo_Tcp::default_instance_ = new CheckInfo_Tcp();
  HealthCheck::default_instance_ = new HealthCheck();
  HealthCheck_HTTPCheckInfo::default_instance_ = new HealthCheck_HTTPCheckInfo();
  HealthCheck_TCPCheckInfo::default_instance_ = new HealthCheck_TCPCheckInfo();
  KillPolicy::default_instance_ = new KillPolicy();
  CommandInfo::default_instance_ = new CommandInfo();
  CommandInfo_URI::default_instance_ = new CommandInfo_URI();
  ExecutorInfo::default_instance_ = new ExecutorInfo();
  MasterInfo::default_instance_ = new MasterInfo();
  SlaveInfo::default_instance_ = new SlaveInfo();
  SlaveInfo_Capability::default_instance_ = new SlaveInfo_Capability();
  Value::default_instance_ = new Value();
  Value_Scalar::default_instance_ = new Value_Scalar();
  Value_Range::default_instance_ = new Value_Range();
  Value_Ranges::default_instance_ = new Value_Ranges();
  Value_Set::default_instance_ = new Value_Set();
  Value_Text::default_instance_ = new Value_Text();
  Attribute::default_instance_ = new Attribute();
  Resource::_default_role_ =
      new ::std::string("*", 1);
  Resource::default_instance_ = new Resource();
  Resource_AllocationInfo::default_instance_ = new Resource_AllocationInfo();
  Resource_ReservationInfo::default_instance_ = new Resource_ReservationInfo();
  Resource_DiskInfo::default_instance_ = new Resource_DiskInfo();
  Resource_DiskInfo_Persistence::default_instance_ = new Resource_DiskInfo_Persistence();
  Resource_DiskInfo_Source::default_instance_ = new Resource_DiskInfo_Source();
  Resource_DiskInfo_Source_Path::default_instance_ = new Resource_DiskInfo_Source_Path();
  Resource_DiskInfo_Source_Mount::default_instance_ = new Resource_DiskInfo_Source_Mount();
  Resource_RevocableInfo::default_instance_ = new Resource_RevocableInfo();
  Resource_SharedInfo::default_instance_ = new Resource_SharedInfo();
  TrafficControlStatistics::default_instance_ = new TrafficControlStatistics();
  IpStatistics::default_instance_ = new IpStatistics();
  IcmpStatistics::default_instance_ = new IcmpStatistics();
  TcpStatistics::default_instance_ = new TcpStatistics();
  UdpStatistics::default_instance_ = new UdpStatistics();
  SNMPStatistics::default_instance_ = new SNMPStatistics();
  DiskStatistics::default_instance_ = new DiskStatistics();
  ResourceStatistics::default_instance_ = new ResourceStatistics();
  ResourceUsage::default_instance_ = new ResourceUsage();
  ResourceUsage_Executor::default_instance_ = new ResourceUsage_Executor();
  ResourceUsage_Executor_Task::default_instance_ = new ResourceUsage_Executor_Task();
  PerfStatistics::default_instance_ = new PerfStatistics();
  Request::default_instance_ = new Request();
  Offer::default_instance_ = new Offer();
  Offer_Operation::default_instance_ = new Offer_Operation();
  Offer_Operation_Launch::default_instance_ = new Offer_Operation_Launch();
  Offer_Operation_LaunchGroup::default_instance_ = new Offer_Operation_LaunchGroup();
  Offer_Operation_Reserve::default_instance_ = new Offer_Operation_Reserve();
  Offer_Operation_Unreserve::default_instance_ = new Offer_Operation_Unreserve();
  Offer_Operation_Create::default_instance_ = new Offer_Operation_Create();
  Offer_Operation_Destroy::default_instance_ = new Offer_Operation_Destroy();
  InverseOffer::default_instance_ = new InverseOffer();
  TaskInfo::default_instance_ = new TaskInfo();
  TaskGroupInfo::default_instance_ = new TaskGroupInfo();
  Task::default_instance_ = new Task();
  CheckStatusInfo::default_instance_ = new CheckStatusInfo();
  CheckStatusInfo_Command::default_instance_ = new CheckStatusInfo_Command();
  CheckStatusInfo_Http::default_instance_ = new CheckStatusInfo_Http();
  CheckStatusInfo_Tcp::default_instance_ = new CheckStatusInfo_Tcp();
  TaskStatus::default_instance_ = new TaskStatus();
  Filters::default_instance_ = new Filters();
  Environment::default_instance_ = new Environment();
  Environment_Variable::default_instance_ = new Environment_Variable();
  Parameter::default_instance_ = new Parameter();
  Parameters::default_instance_ = new Parameters();
  Credential::default_instance_ = new Credential();
  Credentials::default_instance_ = new Credentials();
  Secret::default_instance_ = new Secret();
  Secret_Reference::default_instance_ = new Secret_Reference();
  Secret_Value::default_instance_ = new Secret_Value();
  RateLimit::default_instance_ = new RateLimit();
  RateLimits::default_instance_ = new RateLimits();
  Image::default_instance_ = new Image();
  Image_Appc::default_instance_ = new Image_Appc();
  Image_Docker::default_instance_ = new Image_Docker();
  Volume::default_instance_ = new Volume();
  Volume_Source::default_instance_ = new Volume_Source();
  Volume_Source_DockerVolume::default_instance_ = new Volume_Source_DockerVolume();
  Volume_Source_SandboxPath::default_instance_ = new Volume_Source_SandboxPath();
  NetworkInfo::default_instance_ = new NetworkInfo();
  NetworkInfo_IPAddress::default_instance_ = new NetworkInfo_IPAddress();
  NetworkInfo_PortMapping::default_instance_ = new NetworkInfo_PortMapping();
  CapabilityInfo::default_instance_ = new CapabilityInfo();
  LinuxInfo::default_instance_ = new LinuxInfo();
  RLimitInfo::default_instance_ = new RLimitInfo();
  RLimitInfo_RLimit::default_instance_ = new RLimitInfo_RLimit();
  TTYInfo::default_instance_ = new TTYInfo();
  TTYInfo_WindowSize::default_instance_ = new TTYInfo_WindowSize();
  ContainerInfo::default_instance_ = new ContainerInfo();
  ContainerInfo_DockerInfo::default_instance_ = new ContainerInfo_DockerInfo();
  ContainerInfo_DockerInfo_PortMapping::default_instance_ = new ContainerInfo_DockerInfo_PortMapping();
  ContainerInfo_MesosInfo::default_instance_ = new ContainerInfo_MesosInfo();
  ContainerStatus::default_instance_ = new ContainerStatus();
  CgroupInfo::default_instance_ = new CgroupInfo();
  CgroupInfo_NetCls::default_instance_ = new CgroupInfo_NetCls();
  Labels::default_instance_ = new Labels();
  Label::default_instance_ = new Label();
  Port::default_instance_ = new Port();
  Ports::default_instance_ = new Ports();
  DiscoveryInfo::default_instance_ = new DiscoveryInfo();
  WeightInfo::default_instance_ = new WeightInfo();
  VersionInfo::default_instance_ = new VersionInfo();
  Flag::default_instance_ = new Flag();
  Role::default_instance_ = new Role();
  Metric::default_instance_ = new Metric();
  FileInfo::default_instance_ = new FileInfo();
  Device::default_instance_ = new Device();
  DeviceAccess::default_instance_ = new DeviceAccess();
  DeviceAccess_Access::default_instance_ = new DeviceAccess_Access();
  DeviceWhitelist::default_instance_ = new DeviceWhitelist();
  FrameworkID::default_instance_->InitAsDefaultInstance();
  OfferID::default_instance_->InitAsDefaultInstance();
  SlaveID::default_instance_->InitAsDefaultInstance();
  TaskID::default_instance_->InitAsDefaultInstance();
  ExecutorID::default_instance_->InitAsDefaultInstance();
  ContainerID::default_instance_->InitAsDefaultInstance();
  ResourceProviderID::default_instance_->InitAsDefaultInstance();
  TimeInfo::default_instance_->InitAsDefaultInstance();
  DurationInfo::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  URL::default_instance_->InitAsDefaultInstance();
  Unavailability::default_instance_->InitAsDefaultInstance();
  MachineID::default_instance_->InitAsDefaultInstance();
  MachineInfo::default_instance_->InitAsDefaultInstance();
  FrameworkInfo::default_instance_->InitAsDefaultInstance();
  FrameworkInfo_Capability::default_instance_->InitAsDefaultInstance();
  CheckInfo::default_instance_->InitAsDefaultInstance();
  CheckInfo_Command::default_instance_->InitAsDefaultInstance();
  CheckInfo_Http::default_instance_->InitAsDefaultInstance();
  CheckInfo_Tcp::default_instance_->InitAsDefaultInstance();
  HealthCheck::default_instance_->InitAsDefaultInstance();
  HealthCheck_HTTPCheckInfo::default_instance_->InitAsDefaultInstance();
  HealthCheck_TCPCheckInfo::default_instance_->InitAsDefaultInstance();
  KillPolicy::default_instance_->InitAsDefaultInstance();
  CommandInfo::default_instance_->InitAsDefaultInstance();
  CommandInfo_URI::default_instance_->InitAsDefaultInstance();
  ExecutorInfo::default_instance_->InitAsDefaultInstance();
  MasterInfo::default_instance_->InitAsDefaultInstance();
  SlaveInfo::default_instance_->InitAsDefaultInstance();
  SlaveInfo_Capability::default_instance_->InitAsDefaultInstance();
  Value::default_instance_->InitAsDefaultInstance();
  Value_Scalar::default_instance_->InitAsDefaultInstance();
  Value_Range::default_instance_->InitAsDefaultInstance();
  Value_Ranges::default_instance_->InitAsDefaultInstance();
  Value_Set::default_instance_->InitAsDefaultInstance();
  Value_Text::default_instance_->InitAsDefaultInstance();
  Attribute::default_instance_->InitAsDefaultInstance();
  Resource::default_instance_->InitAsDefaultInstance();
  Resource_AllocationInfo::default_instance_->InitAsDefaultInstance();
  Resource_ReservationInfo::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Persistence::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Source::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Source_Path::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Source_Mount::default_instance_->InitAsDefaultInstance();
  Resource_RevocableInfo::default_instance_->InitAsDefaultInstance();
  Resource_SharedInfo::default_instance_->InitAsDefaultInstance();
  TrafficControlStatistics::default_instance_->InitAsDefaultInstance();
  IpStatistics::default_instance_->InitAsDefaultInstance();
  IcmpStatistics::default_instance_->InitAsDefaultInstance();
  TcpStatistics::default_instance_->InitAsDefaultInstance();
  UdpStatistics::default_instance_->InitAsDefaultInstance();
  SNMPStatistics::default_instance_->InitAsDefaultInstance();
  DiskStatistics::default_instance_->InitAsDefaultInstance();
  ResourceStatistics::default_instance_->InitAsDefaultInstance();
  ResourceUsage::default_instance_->InitAsDefaultInstance();
  ResourceUsage_Executor::default_instance_->InitAsDefaultInstance();
  ResourceUsage_Executor_Task::default_instance_->InitAsDefaultInstance();
  PerfStatistics::default_instance_->InitAsDefaultInstance();
  Request::default_instance_->InitAsDefaultInstance();
  Offer::default_instance_->InitAsDefaultInstance();
  Offer_Operation::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Launch::default_instance_->InitAsDefaultInstance();
  Offer_Operation_LaunchGroup::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Reserve::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Unreserve::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Create::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Destroy::default_instance_->InitAsDefaultInstance();
  InverseOffer::default_instance_->InitAsDefaultInstance();
  TaskInfo::default_instance_->InitAsDefaultInstance();
  TaskGroupInfo::default_instance_->InitAsDefaultInstance();
  Task::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo_Command::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo_Http::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo_Tcp::default_instance_->InitAsDefaultInstance();
  TaskStatus::default_instance_->InitAsDefaultInstance();
  Filters::default_instance_->InitAsDefaultInstance();
  Environment::default_instance_->InitAsDefaultInstance();
  Environment_Variable::default_instance_->InitAsDefaultInstance();
  Parameter::default_instance_->InitAsDefaultInstance();
  Parameters::default_instance_->InitAsDefaultInstance();
  Credential::default_instance_->InitAsDefaultInstance();
  Credentials::default_instance_->InitAsDefaultInstance();
  Secret::default_instance_->InitAsDefaultInstance();
  Secret_Reference::default_instance_->InitAsDefaultInstance();
  Secret_Value::default_instance_->InitAsDefaultInstance();
  RateLimit::default_instance_->InitAsDefaultInstance();
  RateLimits::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  Image_Appc::default_instance_->InitAsDefaultInstance();
  Image_Docker::default_instance_->InitAsDefaultInstance();
  Volume::default_instance_->InitAsDefaultInstance();
  Volume_Source::default_instance_->InitAsDefaultInstance();
  Volume_Source_DockerVolume::default_instance_->InitAsDefaultInstance();
  Volume_Source_SandboxPath::default_instance_->InitAsDefaultInstance();
  NetworkInfo::default_instance_->InitAsDefaultInstance();
  NetworkInfo_IPAddress::default_instance_->InitAsDefaultInstance();
  NetworkInfo_PortMapping::default_instance_->InitAsDefaultInstance();
  CapabilityInfo::default_instance_->InitAsDefaultInstance();
  LinuxInfo::default_instance_->InitAsDefaultInstance();
  RLimitInfo::default_instance_->InitAsDefaultInstance();
  RLimitInfo_RLimit::default_instance_->InitAsDefaultInstance();
  TTYInfo::default_instance_->InitAsDefaultInstance();
  TTYInfo_WindowSize::default_instance_->InitAsDefaultInstance();
  ContainerInfo::default_instance_->InitAsDefaultInstance();
  ContainerInfo_DockerInfo::default_instance_->InitAsDefaultInstance();
  ContainerInfo_DockerInfo_PortMapping::default_instance_->InitAsDefaultInstance();
  ContainerInfo_MesosInfo::default_instance_->InitAsDefaultInstance();
  ContainerStatus::default_instance_->InitAsDefaultInstance();
  CgroupInfo::default_instance_->InitAsDefaultInstance();
  CgroupInfo_NetCls::default_instance_->InitAsDefaultInstance();
  Labels::default_instance_->InitAsDefaultInstance();
  Label::default_instance_->InitAsDefaultInstance();
  Port::default_instance_->InitAsDefaultInstance();
  Ports::default_instance_->InitAsDefaultInstance();
  DiscoveryInfo::default_instance_->InitAsDefaultInstance();
  WeightInfo::default_instance_->InitAsDefaultInstance();
  VersionInfo::default_instance_->InitAsDefaultInstance();
  Flag::default_instance_->InitAsDefaultInstance();
  Role::default_instance_->InitAsDefaultInstance();
  Metric::default_instance_->InitAsDefaultInstance();
  FileInfo::default_instance_->InitAsDefaultInstance();
  Device::default_instance_->InitAsDefaultInstance();
  DeviceAccess::default_instance_->InitAsDefaultInstance();
  DeviceAccess_Access::default_instance_->InitAsDefaultInstance();
  DeviceWhitelist::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mesos_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mesos_2eproto {
  StaticDescriptorInitializer_mesos_2eproto() {
    protobuf_AddDesc_mesos_2eproto();
  }
} static_descriptor_initializer_mesos_2eproto_;
const ::google::protobuf::EnumDescriptor* Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}
bool Status_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TaskState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskState_descriptor_;
}
bool TaskState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkID::kValueFieldNumber;
#endif  // !_MSC_VER

FrameworkID::FrameworkID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FrameworkID)
}

void FrameworkID::InitAsDefaultInstance() {
}

FrameworkID::FrameworkID(const FrameworkID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FrameworkID)
}

void FrameworkID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkID::~FrameworkID() {
  // @@protoc_insertion_point(destructor:mesos.FrameworkID)
  SharedDtor();
}

void FrameworkID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void FrameworkID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkID_descriptor_;
}

const FrameworkID& FrameworkID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FrameworkID* FrameworkID::default_instance_ = NULL;

FrameworkID* FrameworkID::New() const {
  return new FrameworkID;
}

void FrameworkID::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FrameworkID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FrameworkID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FrameworkID)
  return false;
#undef DO_
}

void FrameworkID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FrameworkID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FrameworkID)
}

::google::protobuf::uint8* FrameworkID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FrameworkID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FrameworkID)
  return target;
}

int FrameworkID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkID::MergeFrom(const FrameworkID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkID::CopyFrom(const FrameworkID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FrameworkID::Swap(FrameworkID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkID_descriptor_;
  metadata.reflection = FrameworkID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OfferID::kValueFieldNumber;
#endif  // !_MSC_VER

OfferID::OfferID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.OfferID)
}

void OfferID::InitAsDefaultInstance() {
}

OfferID::OfferID(const OfferID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.OfferID)
}

void OfferID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfferID::~OfferID() {
  // @@protoc_insertion_point(destructor:mesos.OfferID)
  SharedDtor();
}

void OfferID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void OfferID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OfferID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OfferID_descriptor_;
}

const OfferID& OfferID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

OfferID* OfferID::default_instance_ = NULL;

OfferID* OfferID::New() const {
  return new OfferID;
}

void OfferID::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OfferID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.OfferID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.OfferID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.OfferID)
  return false;
#undef DO_
}

void OfferID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.OfferID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.OfferID)
}

::google::protobuf::uint8* OfferID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.OfferID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.OfferID)
  return target;
}

int OfferID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfferID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OfferID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OfferID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OfferID::MergeFrom(const OfferID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OfferID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OfferID::CopyFrom(const OfferID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfferID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OfferID::Swap(OfferID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OfferID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OfferID_descriptor_;
  metadata.reflection = OfferID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveID::kValueFieldNumber;
#endif  // !_MSC_VER

SlaveID::SlaveID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SlaveID)
}

void SlaveID::InitAsDefaultInstance() {
}

SlaveID::SlaveID(const SlaveID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SlaveID)
}

void SlaveID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveID::~SlaveID() {
  // @@protoc_insertion_point(destructor:mesos.SlaveID)
  SharedDtor();
}

void SlaveID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void SlaveID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveID_descriptor_;
}

const SlaveID& SlaveID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SlaveID* SlaveID::default_instance_ = NULL;

SlaveID* SlaveID::New() const {
  return new SlaveID;
}

void SlaveID::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SlaveID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SlaveID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SlaveID)
  return false;
#undef DO_
}

void SlaveID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SlaveID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SlaveID)
}

::google::protobuf::uint8* SlaveID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SlaveID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SlaveID)
  return target;
}

int SlaveID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveID::MergeFrom(const SlaveID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveID::CopyFrom(const SlaveID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveID::Swap(SlaveID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveID_descriptor_;
  metadata.reflection = SlaveID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskID::kValueFieldNumber;
#endif  // !_MSC_VER

TaskID::TaskID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskID)
}

void TaskID::InitAsDefaultInstance() {
}

TaskID::TaskID(const TaskID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskID)
}

void TaskID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskID::~TaskID() {
  // @@protoc_insertion_point(destructor:mesos.TaskID)
  SharedDtor();
}

void TaskID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void TaskID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskID_descriptor_;
}

const TaskID& TaskID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskID* TaskID::default_instance_ = NULL;

TaskID* TaskID::New() const {
  return new TaskID;
}

void TaskID::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskID)
  return false;
#undef DO_
}

void TaskID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskID)
}

::google::protobuf::uint8* TaskID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskID)
  return target;
}

int TaskID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskID::MergeFrom(const TaskID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskID::CopyFrom(const TaskID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TaskID::Swap(TaskID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskID_descriptor_;
  metadata.reflection = TaskID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorID::kValueFieldNumber;
#endif  // !_MSC_VER

ExecutorID::ExecutorID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ExecutorID)
}

void ExecutorID::InitAsDefaultInstance() {
}

ExecutorID::ExecutorID(const ExecutorID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ExecutorID)
}

void ExecutorID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorID::~ExecutorID() {
  // @@protoc_insertion_point(destructor:mesos.ExecutorID)
  SharedDtor();
}

void ExecutorID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void ExecutorID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorID_descriptor_;
}

const ExecutorID& ExecutorID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ExecutorID* ExecutorID::default_instance_ = NULL;

ExecutorID* ExecutorID::New() const {
  return new ExecutorID;
}

void ExecutorID::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ExecutorID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ExecutorID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ExecutorID)
  return false;
#undef DO_
}

void ExecutorID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ExecutorID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ExecutorID)
}

::google::protobuf::uint8* ExecutorID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ExecutorID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ExecutorID)
  return target;
}

int ExecutorID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorID::MergeFrom(const ExecutorID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorID::CopyFrom(const ExecutorID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExecutorID::Swap(ExecutorID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorID_descriptor_;
  metadata.reflection = ExecutorID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerID::kValueFieldNumber;
const int ContainerID::kParentFieldNumber;
#endif  // !_MSC_VER

ContainerID::ContainerID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerID)
}

void ContainerID::InitAsDefaultInstance() {
  parent_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
}

ContainerID::ContainerID(const ContainerID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerID)
}

void ContainerID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerID::~ContainerID() {
  // @@protoc_insertion_point(destructor:mesos.ContainerID)
  SharedDtor();
}

void ContainerID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
    delete parent_;
  }
}

void ContainerID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerID_descriptor_;
}

const ContainerID& ContainerID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerID* ContainerID::default_instance_ = NULL;

ContainerID* ContainerID::New() const {
  return new ContainerID;
}

void ContainerID::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
    if (has_parent()) {
      if (parent_ != NULL) parent_->::mesos::ContainerID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parent;
        break;
      }

      // optional .mesos.ContainerID parent = 2;
      case 2: {
        if (tag == 18) {
         parse_parent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerID)
  return false;
#undef DO_
}

void ContainerID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  // optional .mesos.ContainerID parent = 2;
  if (has_parent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->parent(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerID)
}

::google::protobuf::uint8* ContainerID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  // optional .mesos.ContainerID parent = 2;
  if (has_parent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->parent(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerID)
  return target;
}

int ContainerID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional .mesos.ContainerID parent = 2;
    if (has_parent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parent());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerID::MergeFrom(const ContainerID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_parent()) {
      mutable_parent()->::mesos::ContainerID::MergeFrom(from.parent());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerID::CopyFrom(const ContainerID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_parent()) {
    if (!this->parent().IsInitialized()) return false;
  }
  return true;
}

void ContainerID::Swap(ContainerID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(parent_, other->parent_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerID_descriptor_;
  metadata.reflection = ContainerID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceProviderID::kValueFieldNumber;
#endif  // !_MSC_VER

ResourceProviderID::ResourceProviderID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceProviderID)
}

void ResourceProviderID::InitAsDefaultInstance() {
}

ResourceProviderID::ResourceProviderID(const ResourceProviderID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceProviderID)
}

void ResourceProviderID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceProviderID::~ResourceProviderID() {
  // @@protoc_insertion_point(destructor:mesos.ResourceProviderID)
  SharedDtor();
}

void ResourceProviderID::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void ResourceProviderID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceProviderID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceProviderID_descriptor_;
}

const ResourceProviderID& ResourceProviderID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceProviderID* ResourceProviderID::default_instance_ = NULL;

ResourceProviderID* ResourceProviderID::New() const {
  return new ResourceProviderID;
}

void ResourceProviderID::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceProviderID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceProviderID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceProviderID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceProviderID)
  return false;
#undef DO_
}

void ResourceProviderID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceProviderID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceProviderID)
}

::google::protobuf::uint8* ResourceProviderID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceProviderID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceProviderID)
  return target;
}

int ResourceProviderID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceProviderID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceProviderID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceProviderID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceProviderID::MergeFrom(const ResourceProviderID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceProviderID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceProviderID::CopyFrom(const ResourceProviderID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceProviderID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ResourceProviderID::Swap(ResourceProviderID* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceProviderID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceProviderID_descriptor_;
  metadata.reflection = ResourceProviderID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TimeInfo::kNanosecondsFieldNumber;
#endif  // !_MSC_VER

TimeInfo::TimeInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TimeInfo)
}

void TimeInfo::InitAsDefaultInstance() {
}

TimeInfo::TimeInfo(const TimeInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TimeInfo)
}

void TimeInfo::SharedCtor() {
  _cached_size_ = 0;
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimeInfo::~TimeInfo() {
  // @@protoc_insertion_point(destructor:mesos.TimeInfo)
  SharedDtor();
}

void TimeInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimeInfo_descriptor_;
}

const TimeInfo& TimeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TimeInfo* TimeInfo::default_instance_ = NULL;

TimeInfo* TimeInfo::New() const {
  return new TimeInfo;
}

void TimeInfo::Clear() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TimeInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 nanoseconds = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &nanoseconds_)));
          set_has_nanoseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TimeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TimeInfo)
  return false;
#undef DO_
}

void TimeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TimeInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->nanoseconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TimeInfo)
}

::google::protobuf::uint8* TimeInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TimeInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->nanoseconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TimeInfo)
  return target;
}

int TimeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 nanoseconds = 1;
    if (has_nanoseconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->nanoseconds());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimeInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimeInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TimeInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimeInfo::MergeFrom(const TimeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nanoseconds()) {
      set_nanoseconds(from.nanoseconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimeInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimeInfo::CopyFrom(const TimeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TimeInfo::Swap(TimeInfo* other) {
  if (other != this) {
    std::swap(nanoseconds_, other->nanoseconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TimeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimeInfo_descriptor_;
  metadata.reflection = TimeInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DurationInfo::kNanosecondsFieldNumber;
#endif  // !_MSC_VER

DurationInfo::DurationInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DurationInfo)
}

void DurationInfo::InitAsDefaultInstance() {
}

DurationInfo::DurationInfo(const DurationInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DurationInfo)
}

void DurationInfo::SharedCtor() {
  _cached_size_ = 0;
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DurationInfo::~DurationInfo() {
  // @@protoc_insertion_point(destructor:mesos.DurationInfo)
  SharedDtor();
}

void DurationInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DurationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DurationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DurationInfo_descriptor_;
}

const DurationInfo& DurationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DurationInfo* DurationInfo::default_instance_ = NULL;

DurationInfo* DurationInfo::New() const {
  return new DurationInfo;
}

void DurationInfo::Clear() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DurationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DurationInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 nanoseconds = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &nanoseconds_)));
          set_has_nanoseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DurationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DurationInfo)
  return false;
#undef DO_
}

void DurationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DurationInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->nanoseconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DurationInfo)
}

::google::protobuf::uint8* DurationInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DurationInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->nanoseconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DurationInfo)
  return target;
}

int DurationInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 nanoseconds = 1;
    if (has_nanoseconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->nanoseconds());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DurationInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DurationInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DurationInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DurationInfo::MergeFrom(const DurationInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nanoseconds()) {
      set_nanoseconds(from.nanoseconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DurationInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DurationInfo::CopyFrom(const DurationInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DurationInfo::Swap(DurationInfo* other) {
  if (other != this) {
    std::swap(nanoseconds_, other->nanoseconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DurationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DurationInfo_descriptor_;
  metadata.reflection = DurationInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kHostnameFieldNumber;
const int Address::kIpFieldNumber;
const int Address::kPortFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Address)
}

void Address::InitAsDefaultInstance() {
}

Address::Address(const Address& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Address)
}

void Address::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:mesos.Address)
  SharedDtor();
}

void Address::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Address_descriptor_;
}

const Address& Address::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Address)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string hostname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (tag == 18) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required int32 port = 3;
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Address)
  return false;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Address)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip(), output);
  }

  // required int32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Address)
}

::google::protobuf::uint8* Address::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Address)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hostname(), target);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip(), target);
  }

  // required int32 port = 3;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Address)
  return target;
}

int Address::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string hostname = 1;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // required int32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Address* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Address*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(hostname_, other->hostname_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Address_descriptor_;
  metadata.reflection = Address_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int URL::kSchemeFieldNumber;
const int URL::kAddressFieldNumber;
const int URL::kPathFieldNumber;
const int URL::kQueryFieldNumber;
const int URL::kFragmentFieldNumber;
#endif  // !_MSC_VER

URL::URL()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.URL)
}

void URL::InitAsDefaultInstance() {
  address_ = const_cast< ::mesos::Address*>(&::mesos::Address::default_instance());
}

URL::URL(const URL& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.URL)
}

void URL::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  scheme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_ = NULL;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fragment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

URL::~URL() {
  // @@protoc_insertion_point(destructor:mesos.URL)
  SharedDtor();
}

void URL::SharedDtor() {
  if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scheme_;
  }
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (fragment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fragment_;
  }
  if (this != default_instance_) {
    delete address_;
  }
}

void URL::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* URL::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return URL_descriptor_;
}

const URL& URL::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

URL* URL::default_instance_ = NULL;

URL* URL::New() const {
  return new URL;
}

void URL::Clear() {
  if (_has_bits_[0 / 32] & 23) {
    if (has_scheme()) {
      if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        scheme_->clear();
      }
    }
    if (has_address()) {
      if (address_ != NULL) address_->::mesos::Address::Clear();
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
    if (has_fragment()) {
      if (fragment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        fragment_->clear();
      }
    }
  }
  query_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool URL::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.URL)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string scheme = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_scheme()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->scheme().data(), this->scheme().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "scheme");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }

      // required .mesos.Address address = 2;
      case 2: {
        if (tag == 18) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_path;
        break;
      }

      // optional string path = 3;
      case 3: {
        if (tag == 26) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_query;
        break;
      }

      // repeated .mesos.Parameter query = 4;
      case 4: {
        if (tag == 34) {
         parse_query:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_query()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_query;
        if (input->ExpectTag(42)) goto parse_fragment;
        break;
      }

      // optional string fragment = 5;
      case 5: {
        if (tag == 42) {
         parse_fragment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fragment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->fragment().data(), this->fragment().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "fragment");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.URL)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.URL)
  return false;
#undef DO_
}

void URL::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.URL)
  // required string scheme = 1;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "scheme");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->scheme(), output);
  }

  // required .mesos.Address address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->address(), output);
  }

  // optional string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->path(), output);
  }

  // repeated .mesos.Parameter query = 4;
  for (int i = 0; i < this->query_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->query(i), output);
  }

  // optional string fragment = 5;
  if (has_fragment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fragment().data(), this->fragment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "fragment");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->fragment(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.URL)
}

::google::protobuf::uint8* URL::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.URL)
  // required string scheme = 1;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "scheme");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->scheme(), target);
  }

  // required .mesos.Address address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->address(), target);
  }

  // optional string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->path(), target);
  }

  // repeated .mesos.Parameter query = 4;
  for (int i = 0; i < this->query_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->query(i), target);
  }

  // optional string fragment = 5;
  if (has_fragment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fragment().data(), this->fragment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "fragment");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->fragment(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.URL)
  return target;
}

int URL::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string scheme = 1;
    if (has_scheme()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->scheme());
    }

    // required .mesos.Address address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->address());
    }

    // optional string path = 3;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // optional string fragment = 5;
    if (has_fragment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fragment());
    }

  }
  // repeated .mesos.Parameter query = 4;
  total_size += 1 * this->query_size();
  for (int i = 0; i < this->query_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->query(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void URL::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const URL* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const URL*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void URL::MergeFrom(const URL& from) {
  GOOGLE_CHECK_NE(&from, this);
  query_.MergeFrom(from.query_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_scheme()) {
      set_scheme(from.scheme());
    }
    if (from.has_address()) {
      mutable_address()->::mesos::Address::MergeFrom(from.address());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_fragment()) {
      set_fragment(from.fragment());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void URL::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void URL::CopyFrom(const URL& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool URL::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_address()) {
    if (!this->address().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->query())) return false;
  return true;
}

void URL::Swap(URL* other) {
  if (other != this) {
    std::swap(scheme_, other->scheme_);
    std::swap(address_, other->address_);
    std::swap(path_, other->path_);
    query_.Swap(&other->query_);
    std::swap(fragment_, other->fragment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata URL::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = URL_descriptor_;
  metadata.reflection = URL_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Unavailability::kStartFieldNumber;
const int Unavailability::kDurationFieldNumber;
#endif  // !_MSC_VER

Unavailability::Unavailability()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Unavailability)
}

void Unavailability::InitAsDefaultInstance() {
  start_ = const_cast< ::mesos::TimeInfo*>(&::mesos::TimeInfo::default_instance());
  duration_ = const_cast< ::mesos::DurationInfo*>(&::mesos::DurationInfo::default_instance());
}

Unavailability::Unavailability(const Unavailability& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Unavailability)
}

void Unavailability::SharedCtor() {
  _cached_size_ = 0;
  start_ = NULL;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Unavailability::~Unavailability() {
  // @@protoc_insertion_point(destructor:mesos.Unavailability)
  SharedDtor();
}

void Unavailability::SharedDtor() {
  if (this != default_instance_) {
    delete start_;
    delete duration_;
  }
}

void Unavailability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Unavailability::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Unavailability_descriptor_;
}

const Unavailability& Unavailability::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Unavailability* Unavailability::default_instance_ = NULL;

Unavailability* Unavailability::New() const {
  return new Unavailability;
}

void Unavailability::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_start()) {
      if (start_ != NULL) start_->::mesos::TimeInfo::Clear();
    }
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mesos::DurationInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Unavailability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Unavailability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TimeInfo start = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_duration;
        break;
      }

      // optional .mesos.DurationInfo duration = 2;
      case 2: {
        if (tag == 18) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Unavailability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Unavailability)
  return false;
#undef DO_
}

void Unavailability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Unavailability)
  // required .mesos.TimeInfo start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->start(), output);
  }

  // optional .mesos.DurationInfo duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->duration(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Unavailability)
}

::google::protobuf::uint8* Unavailability::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Unavailability)
  // required .mesos.TimeInfo start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->start(), target);
  }

  // optional .mesos.DurationInfo duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->duration(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Unavailability)
  return target;
}

int Unavailability::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TimeInfo start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->start());
    }

    // optional .mesos.DurationInfo duration = 2;
    if (has_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->duration());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Unavailability::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Unavailability* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Unavailability*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Unavailability::MergeFrom(const Unavailability& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      mutable_start()->::mesos::TimeInfo::MergeFrom(from.start());
    }
    if (from.has_duration()) {
      mutable_duration()->::mesos::DurationInfo::MergeFrom(from.duration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Unavailability::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Unavailability::CopyFrom(const Unavailability& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unavailability::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_start()) {
    if (!this->start().IsInitialized()) return false;
  }
  if (has_duration()) {
    if (!this->duration().IsInitialized()) return false;
  }
  return true;
}

void Unavailability::Swap(Unavailability* other) {
  if (other != this) {
    std::swap(start_, other->start_);
    std::swap(duration_, other->duration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Unavailability::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Unavailability_descriptor_;
  metadata.reflection = Unavailability_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MachineID::kHostnameFieldNumber;
const int MachineID::kIpFieldNumber;
#endif  // !_MSC_VER

MachineID::MachineID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.MachineID)
}

void MachineID::InitAsDefaultInstance() {
}

MachineID::MachineID(const MachineID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.MachineID)
}

void MachineID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MachineID::~MachineID() {
  // @@protoc_insertion_point(destructor:mesos.MachineID)
  SharedDtor();
}

void MachineID::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void MachineID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MachineID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineID_descriptor_;
}

const MachineID& MachineID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

MachineID* MachineID::default_instance_ = NULL;

MachineID* MachineID::New() const {
  return new MachineID;
}

void MachineID::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MachineID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.MachineID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string hostname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (tag == 18) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.MachineID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.MachineID)
  return false;
#undef DO_
}

void MachineID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.MachineID)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.MachineID)
}

::google::protobuf::uint8* MachineID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.MachineID)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hostname(), target);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.MachineID)
  return target;
}

int MachineID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string hostname = 1;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MachineID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MachineID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MachineID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MachineID::MergeFrom(const MachineID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MachineID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MachineID::CopyFrom(const MachineID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineID::IsInitialized() const {

  return true;
}

void MachineID::Swap(MachineID* other) {
  if (other != this) {
    std::swap(hostname_, other->hostname_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MachineID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MachineID_descriptor_;
  metadata.reflection = MachineID_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* MachineInfo_Mode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineInfo_Mode_descriptor_;
}
bool MachineInfo_Mode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const MachineInfo_Mode MachineInfo::UP;
const MachineInfo_Mode MachineInfo::DRAINING;
const MachineInfo_Mode MachineInfo::DOWN;
const MachineInfo_Mode MachineInfo::Mode_MIN;
const MachineInfo_Mode MachineInfo::Mode_MAX;
const int MachineInfo::Mode_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int MachineInfo::kIdFieldNumber;
const int MachineInfo::kModeFieldNumber;
const int MachineInfo::kUnavailabilityFieldNumber;
#endif  // !_MSC_VER

MachineInfo::MachineInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.MachineInfo)
}

void MachineInfo::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::MachineID*>(&::mesos::MachineID::default_instance());
  unavailability_ = const_cast< ::mesos::Unavailability*>(&::mesos::Unavailability::default_instance());
}

MachineInfo::MachineInfo(const MachineInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.MachineInfo)
}

void MachineInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  mode_ = 1;
  unavailability_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MachineInfo::~MachineInfo() {
  // @@protoc_insertion_point(destructor:mesos.MachineInfo)
  SharedDtor();
}

void MachineInfo::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete unavailability_;
  }
}

void MachineInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MachineInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineInfo_descriptor_;
}

const MachineInfo& MachineInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

MachineInfo* MachineInfo::default_instance_ = NULL;

MachineInfo* MachineInfo::New() const {
  return new MachineInfo;
}

void MachineInfo::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::MachineID::Clear();
    }
    mode_ = 1;
    if (has_unavailability()) {
      if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MachineInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.MachineInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.MachineID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mode;
        break;
      }

      // optional .mesos.MachineInfo.Mode mode = 2;
      case 2: {
        if (tag == 16) {
         parse_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::MachineInfo_Mode_IsValid(value)) {
            set_mode(static_cast< ::mesos::MachineInfo_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_unavailability;
        break;
      }

      // optional .mesos.Unavailability unavailability = 3;
      case 3: {
        if (tag == 26) {
         parse_unavailability:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unavailability()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.MachineInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.MachineInfo)
  return false;
#undef DO_
}

void MachineInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.MachineInfo)
  // required .mesos.MachineID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->id(), output);
  }

  // optional .mesos.MachineInfo.Mode mode = 2;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->mode(), output);
  }

  // optional .mesos.Unavailability unavailability = 3;
  if (has_unavailability()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->unavailability(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.MachineInfo)
}

::google::protobuf::uint8* MachineInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.MachineInfo)
  // required .mesos.MachineID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->id(), target);
  }

  // optional .mesos.MachineInfo.Mode mode = 2;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->mode(), target);
  }

  // optional .mesos.Unavailability unavailability = 3;
  if (has_unavailability()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->unavailability(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.MachineInfo)
  return target;
}

int MachineInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.MachineID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional .mesos.MachineInfo.Mode mode = 2;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // optional .mesos.Unavailability unavailability = 3;
    if (has_unavailability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unavailability());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MachineInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MachineInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MachineInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MachineInfo::MergeFrom(const MachineInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::mesos::MachineID::MergeFrom(from.id());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_unavailability()) {
      mutable_unavailability()->::mesos::Unavailability::MergeFrom(from.unavailability());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MachineInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MachineInfo::CopyFrom(const MachineInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_unavailability()) {
    if (!this->unavailability().IsInitialized()) return false;
  }
  return true;
}

void MachineInfo::Swap(MachineInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(mode_, other->mode_);
    std::swap(unavailability_, other->unavailability_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MachineInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MachineInfo_descriptor_;
  metadata.reflection = MachineInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FrameworkInfo_Capability_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInfo_Capability_Type_descriptor_;
}
bool FrameworkInfo_Capability_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::UNKNOWN;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::REVOCABLE_RESOURCES;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::TASK_KILLING_STATE;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::GPU_RESOURCES;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::SHARED_RESOURCES;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::PARTITION_AWARE;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::MULTI_ROLE;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::Type_MIN;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::Type_MAX;
const int FrameworkInfo_Capability::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FrameworkInfo_Capability::kTypeFieldNumber;
#endif  // !_MSC_VER

FrameworkInfo_Capability::FrameworkInfo_Capability()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FrameworkInfo.Capability)
}

void FrameworkInfo_Capability::InitAsDefaultInstance() {
}

FrameworkInfo_Capability::FrameworkInfo_Capability(const FrameworkInfo_Capability& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FrameworkInfo.Capability)
}

void FrameworkInfo_Capability::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkInfo_Capability::~FrameworkInfo_Capability() {
  // @@protoc_insertion_point(destructor:mesos.FrameworkInfo.Capability)
  SharedDtor();
}

void FrameworkInfo_Capability::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FrameworkInfo_Capability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkInfo_Capability::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInfo_Capability_descriptor_;
}

const FrameworkInfo_Capability& FrameworkInfo_Capability::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FrameworkInfo_Capability* FrameworkInfo_Capability::default_instance_ = NULL;

FrameworkInfo_Capability* FrameworkInfo_Capability::New() const {
  return new FrameworkInfo_Capability;
}

void FrameworkInfo_Capability::Clear() {
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkInfo_Capability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FrameworkInfo.Capability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkInfo.Capability.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::FrameworkInfo_Capability_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::FrameworkInfo_Capability_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FrameworkInfo.Capability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FrameworkInfo.Capability)
  return false;
#undef DO_
}

void FrameworkInfo_Capability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FrameworkInfo.Capability)
  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FrameworkInfo.Capability)
}

::google::protobuf::uint8* FrameworkInfo_Capability::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FrameworkInfo.Capability)
  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FrameworkInfo.Capability)
  return target;
}

int FrameworkInfo_Capability::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.FrameworkInfo.Capability.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkInfo_Capability::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkInfo_Capability* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkInfo_Capability*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkInfo_Capability::MergeFrom(const FrameworkInfo_Capability& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkInfo_Capability::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkInfo_Capability::CopyFrom(const FrameworkInfo_Capability& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkInfo_Capability::IsInitialized() const {

  return true;
}

void FrameworkInfo_Capability::Swap(FrameworkInfo_Capability* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkInfo_Capability::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkInfo_Capability_descriptor_;
  metadata.reflection = FrameworkInfo_Capability_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

::std::string* FrameworkInfo::_default_role_ = NULL;
#ifndef _MSC_VER
const int FrameworkInfo::kUserFieldNumber;
const int FrameworkInfo::kNameFieldNumber;
const int FrameworkInfo::kIdFieldNumber;
const int FrameworkInfo::kFailoverTimeoutFieldNumber;
const int FrameworkInfo::kCheckpointFieldNumber;
const int FrameworkInfo::kRoleFieldNumber;
const int FrameworkInfo::kRolesFieldNumber;
const int FrameworkInfo::kHostnameFieldNumber;
const int FrameworkInfo::kPrincipalFieldNumber;
const int FrameworkInfo::kWebuiUrlFieldNumber;
const int FrameworkInfo::kCapabilitiesFieldNumber;
const int FrameworkInfo::kLabelsFieldNumber;
#endif  // !_MSC_VER

FrameworkInfo::FrameworkInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FrameworkInfo)
}

void FrameworkInfo::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

FrameworkInfo::FrameworkInfo(const FrameworkInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FrameworkInfo)
}

void FrameworkInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = NULL;
  failover_timeout_ = 0;
  checkpoint_ = false;
  role_ = const_cast< ::std::string*>(_default_role_);
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  webui_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkInfo::~FrameworkInfo() {
  // @@protoc_insertion_point(destructor:mesos.FrameworkInfo)
  SharedDtor();
}

void FrameworkInfo::SharedDtor() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (role_ != _default_role_) {
    delete role_;
  }
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (webui_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete webui_url_;
  }
  if (this != default_instance_) {
    delete id_;
    delete labels_;
  }
}

void FrameworkInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInfo_descriptor_;
}

const FrameworkInfo& FrameworkInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FrameworkInfo* FrameworkInfo::default_instance_ = NULL;

FrameworkInfo* FrameworkInfo::New() const {
  return new FrameworkInfo;
}

void FrameworkInfo::Clear() {
  if (_has_bits_[0 / 32] & 191) {
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
    }
    failover_timeout_ = 0;
    checkpoint_ = false;
    if (has_role()) {
      if (role_ != _default_role_) {
        role_->assign(*_default_role_);
      }
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 2816) {
    if (has_principal()) {
      if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        principal_->clear();
      }
    }
    if (has_webui_url()) {
      if (webui_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        webui_url_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  roles_.Clear();
  capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FrameworkInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_id;
        break;
      }

      // optional .mesos.FrameworkID id = 3;
      case 3: {
        if (tag == 26) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_failover_timeout;
        break;
      }

      // optional double failover_timeout = 4 [default = 0];
      case 4: {
        if (tag == 33) {
         parse_failover_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &failover_timeout_)));
          set_has_failover_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_checkpoint;
        break;
      }

      // optional bool checkpoint = 5 [default = false];
      case 5: {
        if (tag == 40) {
         parse_checkpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkpoint_)));
          set_has_checkpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_role;
        break;
      }

      // optional string role = 6 [default = "*", deprecated = true];
      case 6: {
        if (tag == 50) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_hostname;
        break;
      }

      // optional string hostname = 7;
      case 7: {
        if (tag == 58) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_principal;
        break;
      }

      // optional string principal = 8;
      case 8: {
        if (tag == 66) {
         parse_principal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_webui_url;
        break;
      }

      // optional string webui_url = 9;
      case 9: {
        if (tag == 74) {
         parse_webui_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_webui_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->webui_url().data(), this->webui_url().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "webui_url");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_capabilities;
        break;
      }

      // repeated .mesos.FrameworkInfo.Capability capabilities = 10;
      case 10: {
        if (tag == 82) {
         parse_capabilities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_capabilities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_capabilities;
        if (input->ExpectTag(90)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 11;
      case 11: {
        if (tag == 90) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_roles;
        break;
      }

      // repeated string roles = 12;
      case 12: {
        if (tag == 98) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_roles()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->roles(this->roles_size() - 1).data(),
            this->roles(this->roles_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roles");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_roles;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FrameworkInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FrameworkInfo)
  return false;
#undef DO_
}

void FrameworkInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FrameworkInfo)
  // required string user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional .mesos.FrameworkID id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->id(), output);
  }

  // optional double failover_timeout = 4 [default = 0];
  if (has_failover_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->failover_timeout(), output);
  }

  // optional bool checkpoint = 5 [default = false];
  if (has_checkpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->checkpoint(), output);
  }

  // optional string role = 6 [default = "*", deprecated = true];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->role(), output);
  }

  // optional string hostname = 7;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->hostname(), output);
  }

  // optional string principal = 8;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->principal(), output);
  }

  // optional string webui_url = 9;
  if (has_webui_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->webui_url().data(), this->webui_url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "webui_url");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->webui_url(), output);
  }

  // repeated .mesos.FrameworkInfo.Capability capabilities = 10;
  for (int i = 0; i < this->capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->capabilities(i), output);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->labels(), output);
  }

  // repeated string roles = 12;
  for (int i = 0; i < this->roles_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->roles(i).data(), this->roles(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "roles");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->roles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FrameworkInfo)
}

::google::protobuf::uint8* FrameworkInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FrameworkInfo)
  // required string user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->user(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional .mesos.FrameworkID id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->id(), target);
  }

  // optional double failover_timeout = 4 [default = 0];
  if (has_failover_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->failover_timeout(), target);
  }

  // optional bool checkpoint = 5 [default = false];
  if (has_checkpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->checkpoint(), target);
  }

  // optional string role = 6 [default = "*", deprecated = true];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->role(), target);
  }

  // optional string hostname = 7;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->hostname(), target);
  }

  // optional string principal = 8;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->principal(), target);
  }

  // optional string webui_url = 9;
  if (has_webui_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->webui_url().data(), this->webui_url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "webui_url");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->webui_url(), target);
  }

  // repeated .mesos.FrameworkInfo.Capability capabilities = 10;
  for (int i = 0; i < this->capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->capabilities(i), target);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->labels(), target);
  }

  // repeated string roles = 12;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->roles(i).data(), this->roles(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roles");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(12, this->roles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FrameworkInfo)
  return target;
}

int FrameworkInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mesos.FrameworkID id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional double failover_timeout = 4 [default = 0];
    if (has_failover_timeout()) {
      total_size += 1 + 8;
    }

    // optional bool checkpoint = 5 [default = false];
    if (has_checkpoint()) {
      total_size += 1 + 1;
    }

    // optional string role = 6 [default = "*", deprecated = true];
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }

    // optional string hostname = 7;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string principal = 8;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

    // optional string webui_url = 9;
    if (has_webui_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->webui_url());
    }

    // optional .mesos.Labels labels = 11;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  // repeated string roles = 12;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->roles(i));
  }

  // repeated .mesos.FrameworkInfo.Capability capabilities = 10;
  total_size += 1 * this->capabilities_size();
  for (int i = 0; i < this->capabilities_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->capabilities(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkInfo::MergeFrom(const FrameworkInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  roles_.MergeFrom(from.roles_);
  capabilities_.MergeFrom(from.capabilities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      set_user(from.user());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_id()) {
      mutable_id()->::mesos::FrameworkID::MergeFrom(from.id());
    }
    if (from.has_failover_timeout()) {
      set_failover_timeout(from.failover_timeout());
    }
    if (from.has_checkpoint()) {
      set_checkpoint(from.checkpoint());
    }
    if (from.has_role()) {
      set_role(from.role());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_principal()) {
      set_principal(from.principal());
    }
    if (from.has_webui_url()) {
      set_webui_url(from.webui_url());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkInfo::CopyFrom(const FrameworkInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void FrameworkInfo::Swap(FrameworkInfo* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    std::swap(name_, other->name_);
    std::swap(id_, other->id_);
    std::swap(failover_timeout_, other->failover_timeout_);
    std::swap(checkpoint_, other->checkpoint_);
    std::swap(role_, other->role_);
    roles_.Swap(&other->roles_);
    std::swap(hostname_, other->hostname_);
    std::swap(principal_, other->principal_);
    std::swap(webui_url_, other->webui_url_);
    capabilities_.Swap(&other->capabilities_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkInfo_descriptor_;
  metadata.reflection = FrameworkInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* CheckInfo_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Type_descriptor_;
}
bool CheckInfo_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CheckInfo_Type CheckInfo::UNKNOWN;
const CheckInfo_Type CheckInfo::COMMAND;
const CheckInfo_Type CheckInfo::HTTP;
const CheckInfo_Type CheckInfo::TCP;
const CheckInfo_Type CheckInfo::Type_MIN;
const CheckInfo_Type CheckInfo::Type_MAX;
const int CheckInfo::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CheckInfo_Command::kCommandFieldNumber;
#endif  // !_MSC_VER

CheckInfo_Command::CheckInfo_Command()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo.Command)
}

void CheckInfo_Command::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
}

CheckInfo_Command::CheckInfo_Command(const CheckInfo_Command& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo.Command)
}

void CheckInfo_Command::SharedCtor() {
  _cached_size_ = 0;
  command_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo_Command::~CheckInfo_Command() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo.Command)
  SharedDtor();
}

void CheckInfo_Command::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
  }
}

void CheckInfo_Command::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo_Command::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Command_descriptor_;
}

const CheckInfo_Command& CheckInfo_Command::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo_Command* CheckInfo_Command::default_instance_ = NULL;

CheckInfo_Command* CheckInfo_Command::New() const {
  return new CheckInfo_Command;
}

void CheckInfo_Command::Clear() {
  if (has_command()) {
    if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckInfo_Command::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo.Command)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.CommandInfo command = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo.Command)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo.Command)
  return false;
#undef DO_
}

void CheckInfo_Command::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo.Command)
  // required .mesos.CommandInfo command = 1;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->command(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo.Command)
}

::google::protobuf::uint8* CheckInfo_Command::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo.Command)
  // required .mesos.CommandInfo command = 1;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->command(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo.Command)
  return target;
}

int CheckInfo_Command::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.CommandInfo command = 1;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo_Command::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckInfo_Command* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckInfo_Command*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckInfo_Command::MergeFrom(const CheckInfo_Command& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckInfo_Command::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo_Command::CopyFrom(const CheckInfo_Command& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo_Command::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_command()) {
    if (!this->command().IsInitialized()) return false;
  }
  return true;
}

void CheckInfo_Command::Swap(CheckInfo_Command* other) {
  if (other != this) {
    std::swap(command_, other->command_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckInfo_Command::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_Command_descriptor_;
  metadata.reflection = CheckInfo_Command_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CheckInfo_Http::kPortFieldNumber;
const int CheckInfo_Http::kPathFieldNumber;
#endif  // !_MSC_VER

CheckInfo_Http::CheckInfo_Http()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo.Http)
}

void CheckInfo_Http::InitAsDefaultInstance() {
}

CheckInfo_Http::CheckInfo_Http(const CheckInfo_Http& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo.Http)
}

void CheckInfo_Http::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  port_ = 0u;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo_Http::~CheckInfo_Http() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo.Http)
  SharedDtor();
}

void CheckInfo_Http::SharedDtor() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void CheckInfo_Http::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo_Http::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Http_descriptor_;
}

const CheckInfo_Http& CheckInfo_Http::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo_Http* CheckInfo_Http::default_instance_ = NULL;

CheckInfo_Http* CheckInfo_Http::New() const {
  return new CheckInfo_Http;
}

void CheckInfo_Http::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    port_ = 0u;
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckInfo_Http::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo.Http)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // optional string path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo.Http)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo.Http)
  return false;
#undef DO_
}

void CheckInfo_Http::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo.Http)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo.Http)
}

::google::protobuf::uint8* CheckInfo_Http::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo.Http)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo.Http)
  return target;
}

int CheckInfo_Http::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 port = 1;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo_Http::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckInfo_Http* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckInfo_Http*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckInfo_Http::MergeFrom(const CheckInfo_Http& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckInfo_Http::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo_Http::CopyFrom(const CheckInfo_Http& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo_Http::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CheckInfo_Http::Swap(CheckInfo_Http* other) {
  if (other != this) {
    std::swap(port_, other->port_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckInfo_Http::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_Http_descriptor_;
  metadata.reflection = CheckInfo_Http_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CheckInfo_Tcp::kPortFieldNumber;
#endif  // !_MSC_VER

CheckInfo_Tcp::CheckInfo_Tcp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo.Tcp)
}

void CheckInfo_Tcp::InitAsDefaultInstance() {
}

CheckInfo_Tcp::CheckInfo_Tcp(const CheckInfo_Tcp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo.Tcp)
}

void CheckInfo_Tcp::SharedCtor() {
  _cached_size_ = 0;
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo_Tcp::~CheckInfo_Tcp() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo.Tcp)
  SharedDtor();
}

void CheckInfo_Tcp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckInfo_Tcp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo_Tcp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Tcp_descriptor_;
}

const CheckInfo_Tcp& CheckInfo_Tcp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo_Tcp* CheckInfo_Tcp::default_instance_ = NULL;

CheckInfo_Tcp* CheckInfo_Tcp::New() const {
  return new CheckInfo_Tcp;
}

void CheckInfo_Tcp::Clear() {
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckInfo_Tcp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo.Tcp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo.Tcp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo.Tcp)
  return false;
#undef DO_
}

void CheckInfo_Tcp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo.Tcp)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo.Tcp)
}

::google::protobuf::uint8* CheckInfo_Tcp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo.Tcp)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo.Tcp)
  return target;
}

int CheckInfo_Tcp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 port = 1;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo_Tcp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckInfo_Tcp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckInfo_Tcp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckInfo_Tcp::MergeFrom(const CheckInfo_Tcp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckInfo_Tcp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo_Tcp::CopyFrom(const CheckInfo_Tcp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo_Tcp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CheckInfo_Tcp::Swap(CheckInfo_Tcp* other) {
  if (other != this) {
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckInfo_Tcp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_Tcp_descriptor_;
  metadata.reflection = CheckInfo_Tcp_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CheckInfo::kTypeFieldNumber;
const int CheckInfo::kCommandFieldNumber;
const int CheckInfo::kHttpFieldNumber;
const int CheckInfo::kTcpFieldNumber;
const int CheckInfo::kDelaySecondsFieldNumber;
const int CheckInfo::kIntervalSecondsFieldNumber;
const int CheckInfo::kTimeoutSecondsFieldNumber;
#endif  // !_MSC_VER

CheckInfo::CheckInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo)
}

void CheckInfo::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CheckInfo_Command*>(&::mesos::CheckInfo_Command::default_instance());
  http_ = const_cast< ::mesos::CheckInfo_Http*>(&::mesos::CheckInfo_Http::default_instance());
  tcp_ = const_cast< ::mesos::CheckInfo_Tcp*>(&::mesos::CheckInfo_Tcp::default_instance());
}

CheckInfo::CheckInfo(const CheckInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo)
}

void CheckInfo::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  command_ = NULL;
  http_ = NULL;
  tcp_ = NULL;
  delay_seconds_ = 15;
  interval_seconds_ = 10;
  timeout_seconds_ = 20;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo::~CheckInfo() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo)
  SharedDtor();
}

void CheckInfo::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
    delete http_;
    delete tcp_;
  }
}

void CheckInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_descriptor_;
}

const CheckInfo& CheckInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo* CheckInfo::default_instance_ = NULL;

CheckInfo* CheckInfo::New() const {
  return new CheckInfo;
}

void CheckInfo::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    type_ = 0;
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CheckInfo_Command::Clear();
    }
    if (has_http()) {
      if (http_ != NULL) http_->::mesos::CheckInfo_Http::Clear();
    }
    if (has_tcp()) {
      if (tcp_ != NULL) tcp_->::mesos::CheckInfo_Tcp::Clear();
    }
    delay_seconds_ = 15;
    interval_seconds_ = 10;
    timeout_seconds_ = 20;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CheckInfo.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::CheckInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::CheckInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_command;
        break;
      }

      // optional .mesos.CheckInfo.Command command = 2;
      case 2: {
        if (tag == 18) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_http;
        break;
      }

      // optional .mesos.CheckInfo.Http http = 3;
      case 3: {
        if (tag == 26) {
         parse_http:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_http()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_delay_seconds;
        break;
      }

      // optional double delay_seconds = 4 [default = 15];
      case 4: {
        if (tag == 33) {
         parse_delay_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &delay_seconds_)));
          set_has_delay_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_interval_seconds;
        break;
      }

      // optional double interval_seconds = 5 [default = 10];
      case 5: {
        if (tag == 41) {
         parse_interval_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &interval_seconds_)));
          set_has_interval_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_timeout_seconds;
        break;
      }

      // optional double timeout_seconds = 6 [default = 20];
      case 6: {
        if (tag == 49) {
         parse_timeout_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timeout_seconds_)));
          set_has_timeout_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_tcp;
        break;
      }

      // optional .mesos.CheckInfo.Tcp tcp = 7;
      case 7: {
        if (tag == 58) {
         parse_tcp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo)
  return false;
#undef DO_
}

void CheckInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.CheckInfo.Command command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->command(), output);
  }

  // optional .mesos.CheckInfo.Http http = 3;
  if (has_http()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->http(), output);
  }

  // optional double delay_seconds = 4 [default = 15];
  if (has_delay_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->delay_seconds(), output);
  }

  // optional double interval_seconds = 5 [default = 10];
  if (has_interval_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->interval_seconds(), output);
  }

  // optional double timeout_seconds = 6 [default = 20];
  if (has_timeout_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->timeout_seconds(), output);
  }

  // optional .mesos.CheckInfo.Tcp tcp = 7;
  if (has_tcp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->tcp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo)
}

::google::protobuf::uint8* CheckInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.CheckInfo.Command command = 2;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->command(), target);
  }

  // optional .mesos.CheckInfo.Http http = 3;
  if (has_http()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->http(), target);
  }

  // optional double delay_seconds = 4 [default = 15];
  if (has_delay_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->delay_seconds(), target);
  }

  // optional double interval_seconds = 5 [default = 10];
  if (has_interval_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->interval_seconds(), target);
  }

  // optional double timeout_seconds = 6 [default = 20];
  if (has_timeout_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->timeout_seconds(), target);
  }

  // optional .mesos.CheckInfo.Tcp tcp = 7;
  if (has_tcp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->tcp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo)
  return target;
}

int CheckInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.CheckInfo.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.CheckInfo.Command command = 2;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional .mesos.CheckInfo.Http http = 3;
    if (has_http()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->http());
    }

    // optional .mesos.CheckInfo.Tcp tcp = 7;
    if (has_tcp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcp());
    }

    // optional double delay_seconds = 4 [default = 15];
    if (has_delay_seconds()) {
      total_size += 1 + 8;
    }

    // optional double interval_seconds = 5 [default = 10];
    if (has_interval_seconds()) {
      total_size += 1 + 8;
    }

    // optional double timeout_seconds = 6 [default = 20];
    if (has_timeout_seconds()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckInfo::MergeFrom(const CheckInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CheckInfo_Command::MergeFrom(from.command());
    }
    if (from.has_http()) {
      mutable_http()->::mesos::CheckInfo_Http::MergeFrom(from.http());
    }
    if (from.has_tcp()) {
      mutable_tcp()->::mesos::CheckInfo_Tcp::MergeFrom(from.tcp());
    }
    if (from.has_delay_seconds()) {
      set_delay_seconds(from.delay_seconds());
    }
    if (from.has_interval_seconds()) {
      set_interval_seconds(from.interval_seconds());
    }
    if (from.has_timeout_seconds()) {
      set_timeout_seconds(from.timeout_seconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo::CopyFrom(const CheckInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo::IsInitialized() const {

  if (has_command()) {
    if (!this->command().IsInitialized()) return false;
  }
  if (has_http()) {
    if (!this->http().IsInitialized()) return false;
  }
  if (has_tcp()) {
    if (!this->tcp().IsInitialized()) return false;
  }
  return true;
}

void CheckInfo::Swap(CheckInfo* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(command_, other->command_);
    std::swap(http_, other->http_);
    std::swap(tcp_, other->tcp_);
    std::swap(delay_seconds_, other->delay_seconds_);
    std::swap(interval_seconds_, other->interval_seconds_);
    std::swap(timeout_seconds_, other->timeout_seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_descriptor_;
  metadata.reflection = CheckInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* HealthCheck_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_Type_descriptor_;
}
bool HealthCheck_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const HealthCheck_Type HealthCheck::UNKNOWN;
const HealthCheck_Type HealthCheck::COMMAND;
const HealthCheck_Type HealthCheck::HTTP;
const HealthCheck_Type HealthCheck::TCP;
const HealthCheck_Type HealthCheck::Type_MIN;
const HealthCheck_Type HealthCheck::Type_MAX;
const int HealthCheck::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int HealthCheck_HTTPCheckInfo::kSchemeFieldNumber;
const int HealthCheck_HTTPCheckInfo::kPortFieldNumber;
const int HealthCheck_HTTPCheckInfo::kPathFieldNumber;
const int HealthCheck_HTTPCheckInfo::kStatusesFieldNumber;
#endif  // !_MSC_VER

HealthCheck_HTTPCheckInfo::HealthCheck_HTTPCheckInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.HealthCheck.HTTPCheckInfo)
}

void HealthCheck_HTTPCheckInfo::InitAsDefaultInstance() {
}

HealthCheck_HTTPCheckInfo::HealthCheck_HTTPCheckInfo(const HealthCheck_HTTPCheckInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.HealthCheck.HTTPCheckInfo)
}

void HealthCheck_HTTPCheckInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  scheme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HealthCheck_HTTPCheckInfo::~HealthCheck_HTTPCheckInfo() {
  // @@protoc_insertion_point(destructor:mesos.HealthCheck.HTTPCheckInfo)
  SharedDtor();
}

void HealthCheck_HTTPCheckInfo::SharedDtor() {
  if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scheme_;
  }
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void HealthCheck_HTTPCheckInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HealthCheck_HTTPCheckInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_HTTPCheckInfo_descriptor_;
}

const HealthCheck_HTTPCheckInfo& HealthCheck_HTTPCheckInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

HealthCheck_HTTPCheckInfo* HealthCheck_HTTPCheckInfo::default_instance_ = NULL;

HealthCheck_HTTPCheckInfo* HealthCheck_HTTPCheckInfo::New() const {
  return new HealthCheck_HTTPCheckInfo;
}

void HealthCheck_HTTPCheckInfo::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_scheme()) {
      if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        scheme_->clear();
      }
    }
    port_ = 0u;
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
  }
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HealthCheck_HTTPCheckInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.HealthCheck.HTTPCheckInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // optional string path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scheme;
        break;
      }

      // optional string scheme = 3;
      case 3: {
        if (tag == 26) {
         parse_scheme:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_scheme()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->scheme().data(), this->scheme().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "scheme");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_statuses;
        break;
      }

      // repeated uint32 statuses = 4;
      case 4: {
        if (tag == 32) {
         parse_statuses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_statuses())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_statuses())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_statuses;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.HealthCheck.HTTPCheckInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.HealthCheck.HTTPCheckInfo)
  return false;
#undef DO_
}

void HealthCheck_HTTPCheckInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.HealthCheck.HTTPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path(), output);
  }

  // optional string scheme = 3;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "scheme");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->scheme(), output);
  }

  // repeated uint32 statuses = 4;
  for (int i = 0; i < this->statuses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->statuses(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.HealthCheck.HTTPCheckInfo)
}

::google::protobuf::uint8* HealthCheck_HTTPCheckInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.HealthCheck.HTTPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }

  // optional string scheme = 3;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "scheme");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->scheme(), target);
  }

  // repeated uint32 statuses = 4;
  for (int i = 0; i < this->statuses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->statuses(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.HealthCheck.HTTPCheckInfo)
  return target;
}

int HealthCheck_HTTPCheckInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string scheme = 3;
    if (has_scheme()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->scheme());
    }

    // required uint32 port = 1;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

  }
  // repeated uint32 statuses = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->statuses_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->statuses(i));
    }
    total_size += 1 * this->statuses_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HealthCheck_HTTPCheckInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HealthCheck_HTTPCheckInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HealthCheck_HTTPCheckInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HealthCheck_HTTPCheckInfo::MergeFrom(const HealthCheck_HTTPCheckInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_scheme()) {
      set_scheme(from.scheme());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HealthCheck_HTTPCheckInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HealthCheck_HTTPCheckInfo::CopyFrom(const HealthCheck_HTTPCheckInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthCheck_HTTPCheckInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void HealthCheck_HTTPCheckInfo::Swap(HealthCheck_HTTPCheckInfo* other) {
  if (other != this) {
    std::swap(scheme_, other->scheme_);
    std::swap(port_, other->port_);
    std::swap(path_, other->path_);
    statuses_.Swap(&other->statuses_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HealthCheck_HTTPCheckInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HealthCheck_HTTPCheckInfo_descriptor_;
  metadata.reflection = HealthCheck_HTTPCheckInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int HealthCheck_TCPCheckInfo::kPortFieldNumber;
#endif  // !_MSC_VER

HealthCheck_TCPCheckInfo::HealthCheck_TCPCheckInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.HealthCheck.TCPCheckInfo)
}

void HealthCheck_TCPCheckInfo::InitAsDefaultInstance() {
}

HealthCheck_TCPCheckInfo::HealthCheck_TCPCheckInfo(const HealthCheck_TCPCheckInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.HealthCheck.TCPCheckInfo)
}

void HealthCheck_TCPCheckInfo::SharedCtor() {
  _cached_size_ = 0;
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HealthCheck_TCPCheckInfo::~HealthCheck_TCPCheckInfo() {
  // @@protoc_insertion_point(destructor:mesos.HealthCheck.TCPCheckInfo)
  SharedDtor();
}

void HealthCheck_TCPCheckInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HealthCheck_TCPCheckInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HealthCheck_TCPCheckInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_TCPCheckInfo_descriptor_;
}

const HealthCheck_TCPCheckInfo& HealthCheck_TCPCheckInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

HealthCheck_TCPCheckInfo* HealthCheck_TCPCheckInfo::default_instance_ = NULL;

HealthCheck_TCPCheckInfo* HealthCheck_TCPCheckInfo::New() const {
  return new HealthCheck_TCPCheckInfo;
}

void HealthCheck_TCPCheckInfo::Clear() {
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HealthCheck_TCPCheckInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.HealthCheck.TCPCheckInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.HealthCheck.TCPCheckInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.HealthCheck.TCPCheckInfo)
  return false;
#undef DO_
}

void HealthCheck_TCPCheckInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.HealthCheck.TCPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.HealthCheck.TCPCheckInfo)
}

::google::protobuf::uint8* HealthCheck_TCPCheckInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.HealthCheck.TCPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.HealthCheck.TCPCheckInfo)
  return target;
}

int HealthCheck_TCPCheckInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 port = 1;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HealthCheck_TCPCheckInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HealthCheck_TCPCheckInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HealthCheck_TCPCheckInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HealthCheck_TCPCheckInfo::MergeFrom(const HealthCheck_TCPCheckInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HealthCheck_TCPCheckInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HealthCheck_TCPCheckInfo::CopyFrom(const HealthCheck_TCPCheckInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthCheck_TCPCheckInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HealthCheck_TCPCheckInfo::Swap(HealthCheck_TCPCheckInfo* other) {
  if (other != this) {
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HealthCheck_TCPCheckInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HealthCheck_TCPCheckInfo_descriptor_;
  metadata.reflection = HealthCheck_TCPCheckInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int HealthCheck::kDelaySecondsFieldNumber;
const int HealthCheck::kIntervalSecondsFieldNumber;
const int HealthCheck::kTimeoutSecondsFieldNumber;
const int HealthCheck::kConsecutiveFailuresFieldNumber;
const int HealthCheck::kGracePeriodSecondsFieldNumber;
const int HealthCheck::kTypeFieldNumber;
const int HealthCheck::kCommandFieldNumber;
const int HealthCheck::kHttpFieldNumber;
const int HealthCheck::kTcpFieldNumber;
#endif  // !_MSC_VER

HealthCheck::HealthCheck()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.HealthCheck)
}

void HealthCheck::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  http_ = const_cast< ::mesos::HealthCheck_HTTPCheckInfo*>(&::mesos::HealthCheck_HTTPCheckInfo::default_instance());
  tcp_ = const_cast< ::mesos::HealthCheck_TCPCheckInfo*>(&::mesos::HealthCheck_TCPCheckInfo::default_instance());
}

HealthCheck::HealthCheck(const HealthCheck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.HealthCheck)
}

void HealthCheck::SharedCtor() {
  _cached_size_ = 0;
  delay_seconds_ = 15;
  interval_seconds_ = 10;
  timeout_seconds_ = 20;
  consecutive_failures_ = 3u;
  grace_period_seconds_ = 10;
  type_ = 0;
  command_ = NULL;
  http_ = NULL;
  tcp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HealthCheck::~HealthCheck() {
  // @@protoc_insertion_point(destructor:mesos.HealthCheck)
  SharedDtor();
}

void HealthCheck::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
    delete http_;
    delete tcp_;
  }
}

void HealthCheck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HealthCheck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_descriptor_;
}

const HealthCheck& HealthCheck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

HealthCheck* HealthCheck::default_instance_ = NULL;

HealthCheck* HealthCheck::New() const {
  return new HealthCheck;
}

void HealthCheck::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    delay_seconds_ = 15;
    interval_seconds_ = 10;
    timeout_seconds_ = 20;
    consecutive_failures_ = 3u;
    grace_period_seconds_ = 10;
    type_ = 0;
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_http()) {
      if (http_ != NULL) http_->::mesos::HealthCheck_HTTPCheckInfo::Clear();
    }
  }
  if (has_tcp()) {
    if (tcp_ != NULL) tcp_->::mesos::HealthCheck_TCPCheckInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HealthCheck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.HealthCheck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_http()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_delay_seconds;
        break;
      }

      // optional double delay_seconds = 2 [default = 15];
      case 2: {
        if (tag == 17) {
         parse_delay_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &delay_seconds_)));
          set_has_delay_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_interval_seconds;
        break;
      }

      // optional double interval_seconds = 3 [default = 10];
      case 3: {
        if (tag == 25) {
         parse_interval_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &interval_seconds_)));
          set_has_interval_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_timeout_seconds;
        break;
      }

      // optional double timeout_seconds = 4 [default = 20];
      case 4: {
        if (tag == 33) {
         parse_timeout_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timeout_seconds_)));
          set_has_timeout_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_consecutive_failures;
        break;
      }

      // optional uint32 consecutive_failures = 5 [default = 3];
      case 5: {
        if (tag == 40) {
         parse_consecutive_failures:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &consecutive_failures_)));
          set_has_consecutive_failures();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_grace_period_seconds;
        break;
      }

      // optional double grace_period_seconds = 6 [default = 10];
      case 6: {
        if (tag == 49) {
         parse_grace_period_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &grace_period_seconds_)));
          set_has_grace_period_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 7;
      case 7: {
        if (tag == 58) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_type;
        break;
      }

      // optional .mesos.HealthCheck.Type type = 8;
      case 8: {
        if (tag == 64) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::HealthCheck_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::HealthCheck_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_tcp;
        break;
      }

      // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
      case 9: {
        if (tag == 74) {
         parse_tcp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.HealthCheck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.HealthCheck)
  return false;
#undef DO_
}

void HealthCheck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.HealthCheck)
  // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
  if (has_http()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->http(), output);
  }

  // optional double delay_seconds = 2 [default = 15];
  if (has_delay_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->delay_seconds(), output);
  }

  // optional double interval_seconds = 3 [default = 10];
  if (has_interval_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->interval_seconds(), output);
  }

  // optional double timeout_seconds = 4 [default = 20];
  if (has_timeout_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->timeout_seconds(), output);
  }

  // optional uint32 consecutive_failures = 5 [default = 3];
  if (has_consecutive_failures()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->consecutive_failures(), output);
  }

  // optional double grace_period_seconds = 6 [default = 10];
  if (has_grace_period_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->grace_period_seconds(), output);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->command(), output);
  }

  // optional .mesos.HealthCheck.Type type = 8;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->type(), output);
  }

  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  if (has_tcp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->tcp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.HealthCheck)
}

::google::protobuf::uint8* HealthCheck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.HealthCheck)
  // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
  if (has_http()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->http(), target);
  }

  // optional double delay_seconds = 2 [default = 15];
  if (has_delay_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->delay_seconds(), target);
  }

  // optional double interval_seconds = 3 [default = 10];
  if (has_interval_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->interval_seconds(), target);
  }

  // optional double timeout_seconds = 4 [default = 20];
  if (has_timeout_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->timeout_seconds(), target);
  }

  // optional uint32 consecutive_failures = 5 [default = 3];
  if (has_consecutive_failures()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->consecutive_failures(), target);
  }

  // optional double grace_period_seconds = 6 [default = 10];
  if (has_grace_period_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->grace_period_seconds(), target);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->command(), target);
  }

  // optional .mesos.HealthCheck.Type type = 8;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->type(), target);
  }

  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  if (has_tcp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->tcp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.HealthCheck)
  return target;
}

int HealthCheck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double delay_seconds = 2 [default = 15];
    if (has_delay_seconds()) {
      total_size += 1 + 8;
    }

    // optional double interval_seconds = 3 [default = 10];
    if (has_interval_seconds()) {
      total_size += 1 + 8;
    }

    // optional double timeout_seconds = 4 [default = 20];
    if (has_timeout_seconds()) {
      total_size += 1 + 8;
    }

    // optional uint32 consecutive_failures = 5 [default = 3];
    if (has_consecutive_failures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->consecutive_failures());
    }

    // optional double grace_period_seconds = 6 [default = 10];
    if (has_grace_period_seconds()) {
      total_size += 1 + 8;
    }

    // optional .mesos.HealthCheck.Type type = 8;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.CommandInfo command = 7;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
    if (has_http()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->http());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
    if (has_tcp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HealthCheck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HealthCheck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HealthCheck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HealthCheck::MergeFrom(const HealthCheck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_delay_seconds()) {
      set_delay_seconds(from.delay_seconds());
    }
    if (from.has_interval_seconds()) {
      set_interval_seconds(from.interval_seconds());
    }
    if (from.has_timeout_seconds()) {
      set_timeout_seconds(from.timeout_seconds());
    }
    if (from.has_consecutive_failures()) {
      set_consecutive_failures(from.consecutive_failures());
    }
    if (from.has_grace_period_seconds()) {
      set_grace_period_seconds(from.grace_period_seconds());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_http()) {
      mutable_http()->::mesos::HealthCheck_HTTPCheckInfo::MergeFrom(from.http());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tcp()) {
      mutable_tcp()->::mesos::HealthCheck_TCPCheckInfo::MergeFrom(from.tcp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HealthCheck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HealthCheck::CopyFrom(const HealthCheck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthCheck::IsInitialized() const {

  if (has_command()) {
    if (!this->command().IsInitialized()) return false;
  }
  if (has_http()) {
    if (!this->http().IsInitialized()) return false;
  }
  if (has_tcp()) {
    if (!this->tcp().IsInitialized()) return false;
  }
  return true;
}

void HealthCheck::Swap(HealthCheck* other) {
  if (other != this) {
    std::swap(delay_seconds_, other->delay_seconds_);
    std::swap(interval_seconds_, other->interval_seconds_);
    std::swap(timeout_seconds_, other->timeout_seconds_);
    std::swap(consecutive_failures_, other->consecutive_failures_);
    std::swap(grace_period_seconds_, other->grace_period_seconds_);
    std::swap(type_, other->type_);
    std::swap(command_, other->command_);
    std::swap(http_, other->http_);
    std::swap(tcp_, other->tcp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HealthCheck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HealthCheck_descriptor_;
  metadata.reflection = HealthCheck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KillPolicy::kGracePeriodFieldNumber;
#endif  // !_MSC_VER

KillPolicy::KillPolicy()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.KillPolicy)
}

void KillPolicy::InitAsDefaultInstance() {
  grace_period_ = const_cast< ::mesos::DurationInfo*>(&::mesos::DurationInfo::default_instance());
}

KillPolicy::KillPolicy(const KillPolicy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.KillPolicy)
}

void KillPolicy::SharedCtor() {
  _cached_size_ = 0;
  grace_period_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KillPolicy::~KillPolicy() {
  // @@protoc_insertion_point(destructor:mesos.KillPolicy)
  SharedDtor();
}

void KillPolicy::SharedDtor() {
  if (this != default_instance_) {
    delete grace_period_;
  }
}

void KillPolicy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KillPolicy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KillPolicy_descriptor_;
}

const KillPolicy& KillPolicy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

KillPolicy* KillPolicy::default_instance_ = NULL;

KillPolicy* KillPolicy::New() const {
  return new KillPolicy;
}

void KillPolicy::Clear() {
  if (has_grace_period()) {
    if (grace_period_ != NULL) grace_period_->::mesos::DurationInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KillPolicy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.KillPolicy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.DurationInfo grace_period = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_grace_period()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.KillPolicy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.KillPolicy)
  return false;
#undef DO_
}

void KillPolicy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.KillPolicy)
  // optional .mesos.DurationInfo grace_period = 1;
  if (has_grace_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->grace_period(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.KillPolicy)
}

::google::protobuf::uint8* KillPolicy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.KillPolicy)
  // optional .mesos.DurationInfo grace_period = 1;
  if (has_grace_period()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->grace_period(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.KillPolicy)
  return target;
}

int KillPolicy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.DurationInfo grace_period = 1;
    if (has_grace_period()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->grace_period());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillPolicy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KillPolicy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KillPolicy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KillPolicy::MergeFrom(const KillPolicy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_grace_period()) {
      mutable_grace_period()->::mesos::DurationInfo::MergeFrom(from.grace_period());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KillPolicy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KillPolicy::CopyFrom(const KillPolicy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillPolicy::IsInitialized() const {

  if (has_grace_period()) {
    if (!this->grace_period().IsInitialized()) return false;
  }
  return true;
}

void KillPolicy::Swap(KillPolicy* other) {
  if (other != this) {
    std::swap(grace_period_, other->grace_period_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KillPolicy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KillPolicy_descriptor_;
  metadata.reflection = KillPolicy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CommandInfo_URI::kValueFieldNumber;
const int CommandInfo_URI::kExecutableFieldNumber;
const int CommandInfo_URI::kExtractFieldNumber;
const int CommandInfo_URI::kCacheFieldNumber;
const int CommandInfo_URI::kOutputFileFieldNumber;
#endif  // !_MSC_VER

CommandInfo_URI::CommandInfo_URI()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CommandInfo.URI)
}

void CommandInfo_URI::InitAsDefaultInstance() {
}

CommandInfo_URI::CommandInfo_URI(const CommandInfo_URI& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CommandInfo.URI)
}

void CommandInfo_URI::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  executable_ = false;
  extract_ = true;
  cache_ = false;
  output_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommandInfo_URI::~CommandInfo_URI() {
  // @@protoc_insertion_point(destructor:mesos.CommandInfo.URI)
  SharedDtor();
}

void CommandInfo_URI::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (output_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete output_file_;
  }
  if (this != default_instance_) {
  }
}

void CommandInfo_URI::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CommandInfo_URI::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandInfo_URI_descriptor_;
}

const CommandInfo_URI& CommandInfo_URI::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CommandInfo_URI* CommandInfo_URI::default_instance_ = NULL;

CommandInfo_URI* CommandInfo_URI::New() const {
  return new CommandInfo_URI;
}

void CommandInfo_URI::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
    executable_ = false;
    extract_ = true;
    cache_ = false;
    if (has_output_file()) {
      if (output_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        output_file_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CommandInfo_URI::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CommandInfo.URI)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_executable;
        break;
      }

      // optional bool executable = 2;
      case 2: {
        if (tag == 16) {
         parse_executable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &executable_)));
          set_has_executable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_extract;
        break;
      }

      // optional bool extract = 3 [default = true];
      case 3: {
        if (tag == 24) {
         parse_extract:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &extract_)));
          set_has_extract();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cache;
        break;
      }

      // optional bool cache = 4;
      case 4: {
        if (tag == 32) {
         parse_cache:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cache_)));
          set_has_cache();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_output_file;
        break;
      }

      // optional string output_file = 5;
      case 5: {
        if (tag == 42) {
         parse_output_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_output_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->output_file().data(), this->output_file().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "output_file");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CommandInfo.URI)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CommandInfo.URI)
  return false;
#undef DO_
}

void CommandInfo_URI::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CommandInfo.URI)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  // optional bool executable = 2;
  if (has_executable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->executable(), output);
  }

  // optional bool extract = 3 [default = true];
  if (has_extract()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->extract(), output);
  }

  // optional bool cache = 4;
  if (has_cache()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->cache(), output);
  }

  // optional string output_file = 5;
  if (has_output_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output_file().data(), this->output_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "output_file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->output_file(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CommandInfo.URI)
}

::google::protobuf::uint8* CommandInfo_URI::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CommandInfo.URI)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  // optional bool executable = 2;
  if (has_executable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->executable(), target);
  }

  // optional bool extract = 3 [default = true];
  if (has_extract()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->extract(), target);
  }

  // optional bool cache = 4;
  if (has_cache()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->cache(), target);
  }

  // optional string output_file = 5;
  if (has_output_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output_file().data(), this->output_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "output_file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->output_file(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CommandInfo.URI)
  return target;
}

int CommandInfo_URI::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional bool executable = 2;
    if (has_executable()) {
      total_size += 1 + 1;
    }

    // optional bool extract = 3 [default = true];
    if (has_extract()) {
      total_size += 1 + 1;
    }

    // optional bool cache = 4;
    if (has_cache()) {
      total_size += 1 + 1;
    }

    // optional string output_file = 5;
    if (has_output_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->output_file());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommandInfo_URI::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CommandInfo_URI* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CommandInfo_URI*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CommandInfo_URI::MergeFrom(const CommandInfo_URI& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_executable()) {
      set_executable(from.executable());
    }
    if (from.has_extract()) {
      set_extract(from.extract());
    }
    if (from.has_cache()) {
      set_cache(from.cache());
    }
    if (from.has_output_file()) {
      set_output_file(from.output_file());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CommandInfo_URI::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommandInfo_URI::CopyFrom(const CommandInfo_URI& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInfo_URI::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CommandInfo_URI::Swap(CommandInfo_URI* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(executable_, other->executable_);
    std::swap(extract_, other->extract_);
    std::swap(cache_, other->cache_);
    std::swap(output_file_, other->output_file_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CommandInfo_URI::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommandInfo_URI_descriptor_;
  metadata.reflection = CommandInfo_URI_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CommandInfo::kUrisFieldNumber;
const int CommandInfo::kEnvironmentFieldNumber;
const int CommandInfo::kShellFieldNumber;
const int CommandInfo::kValueFieldNumber;
const int CommandInfo::kArgumentsFieldNumber;
const int CommandInfo::kUserFieldNumber;
#endif  // !_MSC_VER

CommandInfo::CommandInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CommandInfo)
}

void CommandInfo::InitAsDefaultInstance() {
  environment_ = const_cast< ::mesos::Environment*>(&::mesos::Environment::default_instance());
}

CommandInfo::CommandInfo(const CommandInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CommandInfo)
}

void CommandInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  environment_ = NULL;
  shell_ = true;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommandInfo::~CommandInfo() {
  // @@protoc_insertion_point(destructor:mesos.CommandInfo)
  SharedDtor();
}

void CommandInfo::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (this != default_instance_) {
    delete environment_;
  }
}

void CommandInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CommandInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandInfo_descriptor_;
}

const CommandInfo& CommandInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CommandInfo* CommandInfo::default_instance_ = NULL;

CommandInfo* CommandInfo::New() const {
  return new CommandInfo;
}

void CommandInfo::Clear() {
  if (_has_bits_[0 / 32] & 46) {
    if (has_environment()) {
      if (environment_ != NULL) environment_->::mesos::Environment::Clear();
    }
    shell_ = true;
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_->clear();
      }
    }
  }
  uris_.Clear();
  arguments_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CommandInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CommandInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.CommandInfo.URI uris = 1;
      case 1: {
        if (tag == 10) {
         parse_uris:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_uris()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_uris;
        if (input->ExpectTag(18)) goto parse_environment;
        break;
      }

      // optional .mesos.Environment environment = 2;
      case 2: {
        if (tag == 18) {
         parse_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_environment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional string value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_user;
        break;
      }

      // optional string user = 5;
      case 5: {
        if (tag == 42) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_shell;
        break;
      }

      // optional bool shell = 6 [default = true];
      case 6: {
        if (tag == 48) {
         parse_shell:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shell_)));
          set_has_shell();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_arguments;
        break;
      }

      // repeated string arguments = 7;
      case 7: {
        if (tag == 58) {
         parse_arguments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_arguments()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->arguments(this->arguments_size() - 1).data(),
            this->arguments(this->arguments_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "arguments");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_arguments;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CommandInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CommandInfo)
  return false;
#undef DO_
}

void CommandInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CommandInfo)
  // repeated .mesos.CommandInfo.URI uris = 1;
  for (int i = 0; i < this->uris_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->uris(i), output);
  }

  // optional .mesos.Environment environment = 2;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->environment(), output);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->value(), output);
  }

  // optional string user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->user(), output);
  }

  // optional bool shell = 6 [default = true];
  if (has_shell()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->shell(), output);
  }

  // repeated string arguments = 7;
  for (int i = 0; i < this->arguments_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->arguments(i).data(), this->arguments(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "arguments");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->arguments(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CommandInfo)
}

::google::protobuf::uint8* CommandInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CommandInfo)
  // repeated .mesos.CommandInfo.URI uris = 1;
  for (int i = 0; i < this->uris_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->uris(i), target);
  }

  // optional .mesos.Environment environment = 2;
  if (has_environment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->environment(), target);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->value(), target);
  }

  // optional string user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->user(), target);
  }

  // optional bool shell = 6 [default = true];
  if (has_shell()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->shell(), target);
  }

  // repeated string arguments = 7;
  for (int i = 0; i < this->arguments_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->arguments(i).data(), this->arguments(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "arguments");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(7, this->arguments(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CommandInfo)
  return target;
}

int CommandInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .mesos.Environment environment = 2;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->environment());
    }

    // optional bool shell = 6 [default = true];
    if (has_shell()) {
      total_size += 1 + 1;
    }

    // optional string value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional string user = 5;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

  }
  // repeated .mesos.CommandInfo.URI uris = 1;
  total_size += 1 * this->uris_size();
  for (int i = 0; i < this->uris_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->uris(i));
  }

  // repeated string arguments = 7;
  total_size += 1 * this->arguments_size();
  for (int i = 0; i < this->arguments_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->arguments(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommandInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CommandInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CommandInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CommandInfo::MergeFrom(const CommandInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  uris_.MergeFrom(from.uris_);
  arguments_.MergeFrom(from.arguments_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_environment()) {
      mutable_environment()->::mesos::Environment::MergeFrom(from.environment());
    }
    if (from.has_shell()) {
      set_shell(from.shell());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_user()) {
      set_user(from.user());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CommandInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommandInfo::CopyFrom(const CommandInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->uris())) return false;
  if (has_environment()) {
    if (!this->environment().IsInitialized()) return false;
  }
  return true;
}

void CommandInfo::Swap(CommandInfo* other) {
  if (other != this) {
    uris_.Swap(&other->uris_);
    std::swap(environment_, other->environment_);
    std::swap(shell_, other->shell_);
    std::swap(value_, other->value_);
    arguments_.Swap(&other->arguments_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CommandInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommandInfo_descriptor_;
  metadata.reflection = CommandInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ExecutorInfo_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorInfo_Type_descriptor_;
}
bool ExecutorInfo_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ExecutorInfo_Type ExecutorInfo::UNKNOWN;
const ExecutorInfo_Type ExecutorInfo::DEFAULT;
const ExecutorInfo_Type ExecutorInfo::CUSTOM;
const ExecutorInfo_Type ExecutorInfo::Type_MIN;
const ExecutorInfo_Type ExecutorInfo::Type_MAX;
const int ExecutorInfo::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ExecutorInfo::kTypeFieldNumber;
const int ExecutorInfo::kExecutorIdFieldNumber;
const int ExecutorInfo::kFrameworkIdFieldNumber;
const int ExecutorInfo::kCommandFieldNumber;
const int ExecutorInfo::kContainerFieldNumber;
const int ExecutorInfo::kResourcesFieldNumber;
const int ExecutorInfo::kNameFieldNumber;
const int ExecutorInfo::kSourceFieldNumber;
const int ExecutorInfo::kDataFieldNumber;
const int ExecutorInfo::kDiscoveryFieldNumber;
const int ExecutorInfo::kShutdownGracePeriodFieldNumber;
const int ExecutorInfo::kLabelsFieldNumber;
#endif  // !_MSC_VER

ExecutorInfo::ExecutorInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ExecutorInfo)
}

void ExecutorInfo::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  container_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
  shutdown_grace_period_ = const_cast< ::mesos::DurationInfo*>(&::mesos::DurationInfo::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

ExecutorInfo::ExecutorInfo(const ExecutorInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ExecutorInfo)
}

void ExecutorInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  executor_id_ = NULL;
  framework_id_ = NULL;
  command_ = NULL;
  container_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  discovery_ = NULL;
  shutdown_grace_period_ = NULL;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorInfo::~ExecutorInfo() {
  // @@protoc_insertion_point(destructor:mesos.ExecutorInfo)
  SharedDtor();
}

void ExecutorInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
    delete executor_id_;
    delete framework_id_;
    delete command_;
    delete container_;
    delete discovery_;
    delete shutdown_grace_period_;
    delete labels_;
  }
}

void ExecutorInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorInfo_descriptor_;
}

const ExecutorInfo& ExecutorInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ExecutorInfo* ExecutorInfo::default_instance_ = NULL;

ExecutorInfo* ExecutorInfo::New() const {
  return new ExecutorInfo;
}

void ExecutorInfo::Clear() {
  if (_has_bits_[0 / 32] & 223) {
    type_ = 0;
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_source()) {
      if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        source_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 3840) {
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
    if (has_shutdown_grace_period()) {
      if (shutdown_grace_period_ != NULL) shutdown_grace_period_->::mesos::DurationInfo::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ExecutorInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 5;
      case 5: {
        if (tag == 42) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        if (input->ExpectTag(58)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 7;
      case 7: {
        if (tag == 58) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_framework_id;
        break;
      }

      // optional .mesos.FrameworkID framework_id = 8;
      case 8: {
        if (tag == 66) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_name;
        break;
      }

      // optional string name = 9;
      case 9: {
        if (tag == 74) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_source;
        break;
      }

      // optional string source = 10 [deprecated = true];
      case 10: {
        if (tag == 82) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->source().data(), this->source().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "source");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_container;
        break;
      }

      // optional .mesos.ContainerInfo container = 11;
      case 11: {
        if (tag == 90) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 12;
      case 12: {
        if (tag == 98) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_shutdown_grace_period;
        break;
      }

      // optional .mesos.DurationInfo shutdown_grace_period = 13;
      case 13: {
        if (tag == 106) {
         parse_shutdown_grace_period:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shutdown_grace_period()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 14;
      case 14: {
        if (tag == 114) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_type;
        break;
      }

      // optional .mesos.ExecutorInfo.Type type = 15;
      case 15: {
        if (tag == 120) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::ExecutorInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::ExecutorInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(15, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ExecutorInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ExecutorInfo)
  return false;
#undef DO_
}

void ExecutorInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ExecutorInfo)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // optional bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  // repeated .mesos.Resource resources = 5;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->resources(i), output);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->command(), output);
  }

  // optional .mesos.FrameworkID framework_id = 8;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->framework_id(), output);
  }

  // optional string name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->name(), output);
  }

  // optional string source = 10 [deprecated = true];
  if (has_source()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source().data(), this->source().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->source(), output);
  }

  // optional .mesos.ContainerInfo container = 11;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->container(), output);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->discovery(), output);
  }

  // optional .mesos.DurationInfo shutdown_grace_period = 13;
  if (has_shutdown_grace_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->shutdown_grace_period(), output);
  }

  // optional .mesos.Labels labels = 14;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->labels(), output);
  }

  // optional .mesos.ExecutorInfo.Type type = 15;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      15, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ExecutorInfo)
}

::google::protobuf::uint8* ExecutorInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ExecutorInfo)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // optional bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  // repeated .mesos.Resource resources = 5;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->resources(i), target);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->command(), target);
  }

  // optional .mesos.FrameworkID framework_id = 8;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->framework_id(), target);
  }

  // optional string name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->name(), target);
  }

  // optional string source = 10 [deprecated = true];
  if (has_source()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source().data(), this->source().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->source(), target);
  }

  // optional .mesos.ContainerInfo container = 11;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->container(), target);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->discovery(), target);
  }

  // optional .mesos.DurationInfo shutdown_grace_period = 13;
  if (has_shutdown_grace_period()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->shutdown_grace_period(), target);
  }

  // optional .mesos.Labels labels = 14;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->labels(), target);
  }

  // optional .mesos.ExecutorInfo.Type type = 15;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      15, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ExecutorInfo)
  return target;
}

int ExecutorInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ExecutorInfo.Type type = 15;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required .mesos.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional .mesos.FrameworkID framework_id = 8;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.CommandInfo command = 7;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional .mesos.ContainerInfo container = 11;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container());
    }

    // optional string name = 9;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string source = 10 [deprecated = true];
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .mesos.DiscoveryInfo discovery = 12;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->discovery());
    }

    // optional .mesos.DurationInfo shutdown_grace_period = 13;
    if (has_shutdown_grace_period()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shutdown_grace_period());
    }

    // optional .mesos.Labels labels = 14;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  // repeated .mesos.Resource resources = 5;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorInfo::MergeFrom(const ExecutorInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_container()) {
      mutable_container()->::mesos::ContainerInfo::MergeFrom(from.container());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
    if (from.has_shutdown_grace_period()) {
      mutable_shutdown_grace_period()->::mesos::DurationInfo::MergeFrom(from.shutdown_grace_period());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorInfo::CopyFrom(const ExecutorInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_command()) {
    if (!this->command().IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_discovery()) {
    if (!this->discovery().IsInitialized()) return false;
  }
  if (has_shutdown_grace_period()) {
    if (!this->shutdown_grace_period().IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void ExecutorInfo::Swap(ExecutorInfo* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(command_, other->command_);
    std::swap(container_, other->container_);
    resources_.Swap(&other->resources_);
    std::swap(name_, other->name_);
    std::swap(source_, other->source_);
    std::swap(data_, other->data_);
    std::swap(discovery_, other->discovery_);
    std::swap(shutdown_grace_period_, other->shutdown_grace_period_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorInfo_descriptor_;
  metadata.reflection = ExecutorInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MasterInfo::kIdFieldNumber;
const int MasterInfo::kIpFieldNumber;
const int MasterInfo::kPortFieldNumber;
const int MasterInfo::kPidFieldNumber;
const int MasterInfo::kHostnameFieldNumber;
const int MasterInfo::kVersionFieldNumber;
const int MasterInfo::kAddressFieldNumber;
#endif  // !_MSC_VER

MasterInfo::MasterInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.MasterInfo)
}

void MasterInfo::InitAsDefaultInstance() {
  address_ = const_cast< ::mesos::Address*>(&::mesos::Address::default_instance());
}

MasterInfo::MasterInfo(const MasterInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.MasterInfo)
}

void MasterInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_ = 0u;
  port_ = 5050u;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterInfo::~MasterInfo() {
  // @@protoc_insertion_point(destructor:mesos.MasterInfo)
  SharedDtor();
}

void MasterInfo::SharedDtor() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (this != default_instance_) {
    delete address_;
  }
}

void MasterInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterInfo_descriptor_;
}

const MasterInfo& MasterInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

MasterInfo* MasterInfo::default_instance_ = NULL;

MasterInfo* MasterInfo::New() const {
  return new MasterInfo;
}

void MasterInfo::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        id_->clear();
      }
    }
    ip_ = 0u;
    port_ = 5050u;
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pid_->clear();
      }
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
    if (has_address()) {
      if (address_ != NULL) address_->::mesos::Address::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MasterInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.MasterInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ip;
        break;
      }

      // required uint32 ip = 2;
      case 2: {
        if (tag == 16) {
         parse_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ip_)));
          set_has_ip();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required uint32 port = 3 [default = 5050];
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_pid;
        break;
      }

      // optional string pid = 4;
      case 4: {
        if (tag == 34) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_hostname;
        break;
      }

      // optional string hostname = 5;
      case 5: {
        if (tag == 42) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }

      // optional string version = 6;
      case 6: {
        if (tag == 50) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_address;
        break;
      }

      // optional .mesos.Address address = 7;
      case 7: {
        if (tag == 58) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.MasterInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.MasterInfo)
  return false;
#undef DO_
}

void MasterInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.MasterInfo)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // required uint32 ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ip(), output);
  }

  // required uint32 port = 3 [default = 5050];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // optional string pid = 4;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->pid(), output);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->hostname(), output);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->version(), output);
  }

  // optional .mesos.Address address = 7;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.MasterInfo)
}

::google::protobuf::uint8* MasterInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.MasterInfo)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // required uint32 ip = 2;
  if (has_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ip(), target);
  }

  // required uint32 port = 3 [default = 5050];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->port(), target);
  }

  // optional string pid = 4;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->pid(), target);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->hostname(), target);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  // optional .mesos.Address address = 7;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.MasterInfo)
  return target;
}

int MasterInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // required uint32 ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ip());
    }

    // required uint32 port = 3 [default = 5050];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // optional string pid = 4;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

    // optional string hostname = 5;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string version = 6;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .mesos.Address address = 7;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MasterInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MasterInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MasterInfo::MergeFrom(const MasterInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_address()) {
      mutable_address()->::mesos::Address::MergeFrom(from.address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MasterInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterInfo::CopyFrom(const MasterInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_address()) {
    if (!this->address().IsInitialized()) return false;
  }
  return true;
}

void MasterInfo::Swap(MasterInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(pid_, other->pid_);
    std::swap(hostname_, other->hostname_);
    std::swap(version_, other->version_);
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MasterInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterInfo_descriptor_;
  metadata.reflection = MasterInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveInfo_Capability_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveInfo_Capability_Type_descriptor_;
}
bool SlaveInfo_Capability_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveInfo_Capability_Type SlaveInfo_Capability::UNKNOWN;
const SlaveInfo_Capability_Type SlaveInfo_Capability::MULTI_ROLE;
const SlaveInfo_Capability_Type SlaveInfo_Capability::Type_MIN;
const SlaveInfo_Capability_Type SlaveInfo_Capability::Type_MAX;
const int SlaveInfo_Capability::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveInfo_Capability::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveInfo_Capability::SlaveInfo_Capability()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SlaveInfo.Capability)
}

void SlaveInfo_Capability::InitAsDefaultInstance() {
}

SlaveInfo_Capability::SlaveInfo_Capability(const SlaveInfo_Capability& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SlaveInfo.Capability)
}

void SlaveInfo_Capability::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveInfo_Capability::~SlaveInfo_Capability() {
  // @@protoc_insertion_point(destructor:mesos.SlaveInfo.Capability)
  SharedDtor();
}

void SlaveInfo_Capability::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveInfo_Capability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveInfo_Capability::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveInfo_Capability_descriptor_;
}

const SlaveInfo_Capability& SlaveInfo_Capability::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SlaveInfo_Capability* SlaveInfo_Capability::default_instance_ = NULL;

SlaveInfo_Capability* SlaveInfo_Capability::New() const {
  return new SlaveInfo_Capability;
}

void SlaveInfo_Capability::Clear() {
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveInfo_Capability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SlaveInfo.Capability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.SlaveInfo.Capability.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::SlaveInfo_Capability_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::SlaveInfo_Capability_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SlaveInfo.Capability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SlaveInfo.Capability)
  return false;
#undef DO_
}

void SlaveInfo_Capability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SlaveInfo.Capability)
  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SlaveInfo.Capability)
}

::google::protobuf::uint8* SlaveInfo_Capability::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SlaveInfo.Capability)
  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SlaveInfo.Capability)
  return target;
}

int SlaveInfo_Capability::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.SlaveInfo.Capability.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveInfo_Capability::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveInfo_Capability* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveInfo_Capability*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveInfo_Capability::MergeFrom(const SlaveInfo_Capability& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveInfo_Capability::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveInfo_Capability::CopyFrom(const SlaveInfo_Capability& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveInfo_Capability::IsInitialized() const {

  return true;
}

void SlaveInfo_Capability::Swap(SlaveInfo_Capability* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveInfo_Capability::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveInfo_Capability_descriptor_;
  metadata.reflection = SlaveInfo_Capability_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SlaveInfo::kHostnameFieldNumber;
const int SlaveInfo::kPortFieldNumber;
const int SlaveInfo::kResourcesFieldNumber;
const int SlaveInfo::kAttributesFieldNumber;
const int SlaveInfo::kIdFieldNumber;
const int SlaveInfo::kCheckpointFieldNumber;
#endif  // !_MSC_VER

SlaveInfo::SlaveInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SlaveInfo)
}

void SlaveInfo::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

SlaveInfo::SlaveInfo(const SlaveInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SlaveInfo)
}

void SlaveInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 5051;
  id_ = NULL;
  checkpoint_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveInfo::~SlaveInfo() {
  // @@protoc_insertion_point(destructor:mesos.SlaveInfo)
  SharedDtor();
}

void SlaveInfo::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (this != default_instance_) {
    delete id_;
  }
}

void SlaveInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveInfo_descriptor_;
}

const SlaveInfo& SlaveInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SlaveInfo* SlaveInfo::default_instance_ = NULL;

SlaveInfo* SlaveInfo::New() const {
  return new SlaveInfo;
}

void SlaveInfo::Clear() {
  if (_has_bits_[0 / 32] & 51) {
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    port_ = 5051;
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::SlaveID::Clear();
    }
    checkpoint_ = false;
  }
  resources_.Clear();
  attributes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SlaveInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string hostname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 3;
      case 3: {
        if (tag == 26) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        if (input->ExpectTag(42)) goto parse_attributes;
        break;
      }

      // repeated .mesos.Attribute attributes = 5;
      case 5: {
        if (tag == 42) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attributes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_attributes;
        if (input->ExpectTag(50)) goto parse_id;
        break;
      }

      // optional .mesos.SlaveID id = 6;
      case 6: {
        if (tag == 50) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_checkpoint;
        break;
      }

      // optional bool checkpoint = 7 [default = false];
      case 7: {
        if (tag == 56) {
         parse_checkpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkpoint_)));
          set_has_checkpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_port;
        break;
      }

      // optional int32 port = 8 [default = 5051];
      case 8: {
        if (tag == 64) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SlaveInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SlaveInfo)
  return false;
#undef DO_
}

void SlaveInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SlaveInfo)
  // required string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // repeated .mesos.Resource resources = 3;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->resources(i), output);
  }

  // repeated .mesos.Attribute attributes = 5;
  for (int i = 0; i < this->attributes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->attributes(i), output);
  }

  // optional .mesos.SlaveID id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->id(), output);
  }

  // optional bool checkpoint = 7 [default = false];
  if (has_checkpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->checkpoint(), output);
  }

  // optional int32 port = 8 [default = 5051];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SlaveInfo)
}

::google::protobuf::uint8* SlaveInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SlaveInfo)
  // required string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hostname(), target);
  }

  // repeated .mesos.Resource resources = 3;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->resources(i), target);
  }

  // repeated .mesos.Attribute attributes = 5;
  for (int i = 0; i < this->attributes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->attributes(i), target);
  }

  // optional .mesos.SlaveID id = 6;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->id(), target);
  }

  // optional bool checkpoint = 7 [default = false];
  if (has_checkpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->checkpoint(), target);
  }

  // optional int32 port = 8 [default = 5051];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SlaveInfo)
  return target;
}

int SlaveInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string hostname = 1;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional int32 port = 8 [default = 5051];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

    // optional .mesos.SlaveID id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional bool checkpoint = 7 [default = false];
    if (has_checkpoint()) {
      total_size += 1 + 1;
    }

  }
  // repeated .mesos.Resource resources = 3;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.Attribute attributes = 5;
  total_size += 1 * this->attributes_size();
  for (int i = 0; i < this->attributes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attributes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveInfo::MergeFrom(const SlaveInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  attributes_.MergeFrom(from.attributes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_id()) {
      mutable_id()->::mesos::SlaveID::MergeFrom(from.id());
    }
    if (from.has_checkpoint()) {
      set_checkpoint(from.checkpoint());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveInfo::CopyFrom(const SlaveInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->attributes())) return false;
  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void SlaveInfo::Swap(SlaveInfo* other) {
  if (other != this) {
    std::swap(hostname_, other->hostname_);
    std::swap(port_, other->port_);
    resources_.Swap(&other->resources_);
    attributes_.Swap(&other->attributes_);
    std::swap(id_, other->id_);
    std::swap(checkpoint_, other->checkpoint_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveInfo_descriptor_;
  metadata.reflection = SlaveInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Type_descriptor_;
}
bool Value_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Value_Type Value::SCALAR;
const Value_Type Value::RANGES;
const Value_Type Value::SET;
const Value_Type Value::TEXT;
const Value_Type Value::Type_MIN;
const Value_Type Value::Type_MAX;
const int Value::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Value_Scalar::kValueFieldNumber;
#endif  // !_MSC_VER

Value_Scalar::Value_Scalar()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Scalar)
}

void Value_Scalar::InitAsDefaultInstance() {
}

Value_Scalar::Value_Scalar(const Value_Scalar& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Scalar)
}

void Value_Scalar::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Scalar::~Value_Scalar() {
  // @@protoc_insertion_point(destructor:mesos.Value.Scalar)
  SharedDtor();
}

void Value_Scalar::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Scalar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Scalar::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Scalar_descriptor_;
}

const Value_Scalar& Value_Scalar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Scalar* Value_Scalar::default_instance_ = NULL;

Value_Scalar* Value_Scalar::New() const {
  return new Value_Scalar;
}

void Value_Scalar::Clear() {
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value_Scalar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Scalar)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double value = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Scalar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Scalar)
  return false;
#undef DO_
}

void Value_Scalar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Scalar)
  // required double value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Scalar)
}

::google::protobuf::uint8* Value_Scalar::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Scalar)
  // required double value = 1;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Scalar)
  return target;
}

int Value_Scalar::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double value = 1;
    if (has_value()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Scalar::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value_Scalar* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value_Scalar*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value_Scalar::MergeFrom(const Value_Scalar& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value_Scalar::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Scalar::CopyFrom(const Value_Scalar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Scalar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Value_Scalar::Swap(Value_Scalar* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value_Scalar::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Scalar_descriptor_;
  metadata.reflection = Value_Scalar_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Value_Range::kBeginFieldNumber;
const int Value_Range::kEndFieldNumber;
#endif  // !_MSC_VER

Value_Range::Value_Range()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Range)
}

void Value_Range::InitAsDefaultInstance() {
}

Value_Range::Value_Range(const Value_Range& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Range)
}

void Value_Range::SharedCtor() {
  _cached_size_ = 0;
  begin_ = GOOGLE_ULONGLONG(0);
  end_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Range::~Value_Range() {
  // @@protoc_insertion_point(destructor:mesos.Value.Range)
  SharedDtor();
}

void Value_Range::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Range::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Range_descriptor_;
}

const Value_Range& Value_Range::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Range* Value_Range::default_instance_ = NULL;

Value_Range* Value_Range::New() const {
  return new Value_Range;
}

void Value_Range::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Value_Range*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(begin_, end_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value_Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Range)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 begin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &begin_)));
          set_has_begin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_end;
        break;
      }

      // required uint64 end = 2;
      case 2: {
        if (tag == 16) {
         parse_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &end_)));
          set_has_end();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Range)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Range)
  return false;
#undef DO_
}

void Value_Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Range)
  // required uint64 begin = 1;
  if (has_begin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->begin(), output);
  }

  // required uint64 end = 2;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->end(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Range)
}

::google::protobuf::uint8* Value_Range::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Range)
  // required uint64 begin = 1;
  if (has_begin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->begin(), target);
  }

  // required uint64 end = 2;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->end(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Range)
  return target;
}

int Value_Range::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 begin = 1;
    if (has_begin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->begin());
    }

    // required uint64 end = 2;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->end());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Range::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value_Range* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value_Range*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value_Range::MergeFrom(const Value_Range& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin()) {
      set_begin(from.begin());
    }
    if (from.has_end()) {
      set_end(from.end());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value_Range::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Range::CopyFrom(const Value_Range& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Range::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Value_Range::Swap(Value_Range* other) {
  if (other != this) {
    std::swap(begin_, other->begin_);
    std::swap(end_, other->end_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value_Range::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Range_descriptor_;
  metadata.reflection = Value_Range_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Value_Ranges::kRangeFieldNumber;
#endif  // !_MSC_VER

Value_Ranges::Value_Ranges()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Ranges)
}

void Value_Ranges::InitAsDefaultInstance() {
}

Value_Ranges::Value_Ranges(const Value_Ranges& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Ranges)
}

void Value_Ranges::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Ranges::~Value_Ranges() {
  // @@protoc_insertion_point(destructor:mesos.Value.Ranges)
  SharedDtor();
}

void Value_Ranges::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Ranges::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Ranges::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Ranges_descriptor_;
}

const Value_Ranges& Value_Ranges::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Ranges* Value_Ranges::default_instance_ = NULL;

Value_Ranges* Value_Ranges::New() const {
  return new Value_Ranges;
}

void Value_Ranges::Clear() {
  range_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value_Ranges::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Ranges)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Value.Range range = 1;
      case 1: {
        if (tag == 10) {
         parse_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_range;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Ranges)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Ranges)
  return false;
#undef DO_
}

void Value_Ranges::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Ranges)
  // repeated .mesos.Value.Range range = 1;
  for (int i = 0; i < this->range_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->range(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Ranges)
}

::google::protobuf::uint8* Value_Ranges::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Ranges)
  // repeated .mesos.Value.Range range = 1;
  for (int i = 0; i < this->range_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->range(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Ranges)
  return target;
}

int Value_Ranges::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Value.Range range = 1;
  total_size += 1 * this->range_size();
  for (int i = 0; i < this->range_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->range(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Ranges::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value_Ranges* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value_Ranges*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value_Ranges::MergeFrom(const Value_Ranges& from) {
  GOOGLE_CHECK_NE(&from, this);
  range_.MergeFrom(from.range_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value_Ranges::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Ranges::CopyFrom(const Value_Ranges& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Ranges::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->range())) return false;
  return true;
}

void Value_Ranges::Swap(Value_Ranges* other) {
  if (other != this) {
    range_.Swap(&other->range_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value_Ranges::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Ranges_descriptor_;
  metadata.reflection = Value_Ranges_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Value_Set::kItemFieldNumber;
#endif  // !_MSC_VER

Value_Set::Value_Set()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Set)
}

void Value_Set::InitAsDefaultInstance() {
}

Value_Set::Value_Set(const Value_Set& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Set)
}

void Value_Set::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Set::~Value_Set() {
  // @@protoc_insertion_point(destructor:mesos.Value.Set)
  SharedDtor();
}

void Value_Set::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Set::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Set::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Set_descriptor_;
}

const Value_Set& Value_Set::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Set* Value_Set::default_instance_ = NULL;

Value_Set* Value_Set::New() const {
  return new Value_Set;
}

void Value_Set::Clear() {
  item_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value_Set::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Set)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string item = 1;
      case 1: {
        if (tag == 10) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_item()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->item(this->item_size() - 1).data(),
            this->item(this->item_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "item");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_item;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Set)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Set)
  return false;
#undef DO_
}

void Value_Set::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Set)
  // repeated string item = 1;
  for (int i = 0; i < this->item_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->item(i).data(), this->item(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "item");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->item(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Set)
}

::google::protobuf::uint8* Value_Set::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Set)
  // repeated string item = 1;
  for (int i = 0; i < this->item_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->item(i).data(), this->item(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "item");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->item(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Set)
  return target;
}

int Value_Set::ByteSize() const {
  int total_size = 0;

  // repeated string item = 1;
  total_size += 1 * this->item_size();
  for (int i = 0; i < this->item_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->item(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Set::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value_Set* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value_Set*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value_Set::MergeFrom(const Value_Set& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_.MergeFrom(from.item_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value_Set::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Set::CopyFrom(const Value_Set& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Set::IsInitialized() const {

  return true;
}

void Value_Set::Swap(Value_Set* other) {
  if (other != this) {
    item_.Swap(&other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value_Set::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Set_descriptor_;
  metadata.reflection = Value_Set_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Value_Text::kValueFieldNumber;
#endif  // !_MSC_VER

Value_Text::Value_Text()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Text)
}

void Value_Text::InitAsDefaultInstance() {
}

Value_Text::Value_Text(const Value_Text& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Text)
}

void Value_Text::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Text::~Value_Text() {
  // @@protoc_insertion_point(destructor:mesos.Value.Text)
  SharedDtor();
}

void Value_Text::SharedDtor() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void Value_Text::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Text::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Text_descriptor_;
}

const Value_Text& Value_Text::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Text* Value_Text::default_instance_ = NULL;

Value_Text* Value_Text::New() const {
  return new Value_Text;
}

void Value_Text::Clear() {
  if (has_value()) {
    if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      value_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value_Text::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Text)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Text)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Text)
  return false;
#undef DO_
}

void Value_Text::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Text)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Text)
}

::google::protobuf::uint8* Value_Text::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Text)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Text)
  return target;
}

int Value_Text::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Text::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value_Text* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value_Text*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value_Text::MergeFrom(const Value_Text& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value_Text::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Text::CopyFrom(const Value_Text& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Text::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Value_Text::Swap(Value_Text* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value_Text::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Text_descriptor_;
  metadata.reflection = Value_Text_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Value::kTypeFieldNumber;
const int Value::kScalarFieldNumber;
const int Value::kRangesFieldNumber;
const int Value::kSetFieldNumber;
const int Value::kTextFieldNumber;
#endif  // !_MSC_VER

Value::Value()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value)
}

void Value::InitAsDefaultInstance() {
  scalar_ = const_cast< ::mesos::Value_Scalar*>(&::mesos::Value_Scalar::default_instance());
  ranges_ = const_cast< ::mesos::Value_Ranges*>(&::mesos::Value_Ranges::default_instance());
  set_ = const_cast< ::mesos::Value_Set*>(&::mesos::Value_Set::default_instance());
  text_ = const_cast< ::mesos::Value_Text*>(&::mesos::Value_Text::default_instance());
}

Value::Value(const Value& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value)
}

void Value::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  scalar_ = NULL;
  ranges_ = NULL;
  set_ = NULL;
  text_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value::~Value() {
  // @@protoc_insertion_point(destructor:mesos.Value)
  SharedDtor();
}

void Value::SharedDtor() {
  if (this != default_instance_) {
    delete scalar_;
    delete ranges_;
    delete set_;
    delete text_;
  }
}

void Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_descriptor_;
}

const Value& Value::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value* Value::default_instance_ = NULL;

Value* Value::New() const {
  return new Value;
}

void Value::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    type_ = 0;
    if (has_scalar()) {
      if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
    }
    if (has_ranges()) {
      if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
    }
    if (has_set()) {
      if (set_ != NULL) set_->::mesos::Value_Set::Clear();
    }
    if (has_text()) {
      if (text_ != NULL) text_->::mesos::Value_Text::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Value.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Value_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Value_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scalar;
        break;
      }

      // optional .mesos.Value.Scalar scalar = 2;
      case 2: {
        if (tag == 18) {
         parse_scalar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ranges;
        break;
      }

      // optional .mesos.Value.Ranges ranges = 3;
      case 3: {
        if (tag == 26) {
         parse_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_set;
        break;
      }

      // optional .mesos.Value.Set set = 4;
      case 4: {
        if (tag == 34) {
         parse_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_text;
        break;
      }

      // optional .mesos.Value.Text text = 5;
      case 5: {
        if (tag == 42) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_text()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value)
  return false;
#undef DO_
}

void Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value)
  // required .mesos.Value.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Value.Scalar scalar = 2;
  if (has_scalar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->scalar(), output);
  }

  // optional .mesos.Value.Ranges ranges = 3;
  if (has_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->ranges(), output);
  }

  // optional .mesos.Value.Set set = 4;
  if (has_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->set(), output);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->text(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value)
}

::google::protobuf::uint8* Value::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value)
  // required .mesos.Value.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Value.Scalar scalar = 2;
  if (has_scalar()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->scalar(), target);
  }

  // optional .mesos.Value.Ranges ranges = 3;
  if (has_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->ranges(), target);
  }

  // optional .mesos.Value.Set set = 4;
  if (has_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->set(), target);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->text(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value)
  return target;
}

int Value::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.Value.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Value.Scalar scalar = 2;
    if (has_scalar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scalar());
    }

    // optional .mesos.Value.Ranges ranges = 3;
    if (has_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ranges());
    }

    // optional .mesos.Value.Set set = 4;
    if (has_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->set());
    }

    // optional .mesos.Value.Text text = 5;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->text());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Value* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Value*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Value::MergeFrom(const Value& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_scalar()) {
      mutable_scalar()->::mesos::Value_Scalar::MergeFrom(from.scalar());
    }
    if (from.has_ranges()) {
      mutable_ranges()->::mesos::Value_Ranges::MergeFrom(from.ranges());
    }
    if (from.has_set()) {
      mutable_set()->::mesos::Value_Set::MergeFrom(from.set());
    }
    if (from.has_text()) {
      mutable_text()->::mesos::Value_Text::MergeFrom(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Value::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value::CopyFrom(const Value& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_scalar()) {
    if (!this->scalar().IsInitialized()) return false;
  }
  if (has_ranges()) {
    if (!this->ranges().IsInitialized()) return false;
  }
  if (has_text()) {
    if (!this->text().IsInitialized()) return false;
  }
  return true;
}

void Value::Swap(Value* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(scalar_, other->scalar_);
    std::swap(ranges_, other->ranges_);
    std::swap(set_, other->set_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Value::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_descriptor_;
  metadata.reflection = Value_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Attribute::kNameFieldNumber;
const int Attribute::kTypeFieldNumber;
const int Attribute::kScalarFieldNumber;
const int Attribute::kRangesFieldNumber;
const int Attribute::kSetFieldNumber;
const int Attribute::kTextFieldNumber;
#endif  // !_MSC_VER

Attribute::Attribute()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Attribute)
}

void Attribute::InitAsDefaultInstance() {
  scalar_ = const_cast< ::mesos::Value_Scalar*>(&::mesos::Value_Scalar::default_instance());
  ranges_ = const_cast< ::mesos::Value_Ranges*>(&::mesos::Value_Ranges::default_instance());
  set_ = const_cast< ::mesos::Value_Set*>(&::mesos::Value_Set::default_instance());
  text_ = const_cast< ::mesos::Value_Text*>(&::mesos::Value_Text::default_instance());
}

Attribute::Attribute(const Attribute& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Attribute)
}

void Attribute::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  scalar_ = NULL;
  ranges_ = NULL;
  set_ = NULL;
  text_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attribute::~Attribute() {
  // @@protoc_insertion_point(destructor:mesos.Attribute)
  SharedDtor();
}

void Attribute::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete scalar_;
    delete ranges_;
    delete set_;
    delete text_;
  }
}

void Attribute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Attribute::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Attribute_descriptor_;
}

const Attribute& Attribute::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Attribute* Attribute::default_instance_ = NULL;

Attribute* Attribute::New() const {
  return new Attribute;
}

void Attribute::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    type_ = 0;
    if (has_scalar()) {
      if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
    }
    if (has_ranges()) {
      if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
    }
    if (has_set()) {
      if (set_ != NULL) set_->::mesos::Value_Set::Clear();
    }
    if (has_text()) {
      if (text_ != NULL) text_->::mesos::Value_Text::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Attribute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Attribute)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .mesos.Value.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Value_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Value_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scalar;
        break;
      }

      // optional .mesos.Value.Scalar scalar = 3;
      case 3: {
        if (tag == 26) {
         parse_scalar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ranges;
        break;
      }

      // optional .mesos.Value.Ranges ranges = 4;
      case 4: {
        if (tag == 34) {
         parse_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_text;
        break;
      }

      // optional .mesos.Value.Text text = 5;
      case 5: {
        if (tag == 42) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_text()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_set;
        break;
      }

      // optional .mesos.Value.Set set = 6;
      case 6: {
        if (tag == 50) {
         parse_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Attribute)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Attribute)
  return false;
#undef DO_
}

void Attribute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Attribute)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->scalar(), output);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->ranges(), output);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->text(), output);
  }

  // optional .mesos.Value.Set set = 6;
  if (has_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->set(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Attribute)
}

::google::protobuf::uint8* Attribute::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Attribute)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->scalar(), target);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->ranges(), target);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->text(), target);
  }

  // optional .mesos.Value.Set set = 6;
  if (has_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->set(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Attribute)
  return target;
}

int Attribute::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .mesos.Value.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Value.Scalar scalar = 3;
    if (has_scalar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scalar());
    }

    // optional .mesos.Value.Ranges ranges = 4;
    if (has_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ranges());
    }

    // optional .mesos.Value.Set set = 6;
    if (has_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->set());
    }

    // optional .mesos.Value.Text text = 5;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->text());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attribute::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Attribute* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Attribute*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Attribute::MergeFrom(const Attribute& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_scalar()) {
      mutable_scalar()->::mesos::Value_Scalar::MergeFrom(from.scalar());
    }
    if (from.has_ranges()) {
      mutable_ranges()->::mesos::Value_Ranges::MergeFrom(from.ranges());
    }
    if (from.has_set()) {
      mutable_set()->::mesos::Value_Set::MergeFrom(from.set());
    }
    if (from.has_text()) {
      mutable_text()->::mesos::Value_Text::MergeFrom(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Attribute::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Attribute::CopyFrom(const Attribute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribute::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_scalar()) {
    if (!this->scalar().IsInitialized()) return false;
  }
  if (has_ranges()) {
    if (!this->ranges().IsInitialized()) return false;
  }
  if (has_text()) {
    if (!this->text().IsInitialized()) return false;
  }
  return true;
}

void Attribute::Swap(Attribute* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(scalar_, other->scalar_);
    std::swap(ranges_, other->ranges_);
    std::swap(set_, other->set_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Attribute::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Attribute_descriptor_;
  metadata.reflection = Attribute_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Resource_AllocationInfo::kRoleFieldNumber;
#endif  // !_MSC_VER

Resource_AllocationInfo::Resource_AllocationInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.AllocationInfo)
}

void Resource_AllocationInfo::InitAsDefaultInstance() {
}

Resource_AllocationInfo::Resource_AllocationInfo(const Resource_AllocationInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.AllocationInfo)
}

void Resource_AllocationInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_AllocationInfo::~Resource_AllocationInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.AllocationInfo)
  SharedDtor();
}

void Resource_AllocationInfo::SharedDtor() {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_;
  }
  if (this != default_instance_) {
  }
}

void Resource_AllocationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_AllocationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_AllocationInfo_descriptor_;
}

const Resource_AllocationInfo& Resource_AllocationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_AllocationInfo* Resource_AllocationInfo::default_instance_ = NULL;

Resource_AllocationInfo* Resource_AllocationInfo::New() const {
  return new Resource_AllocationInfo;
}

void Resource_AllocationInfo::Clear() {
  if (has_role()) {
    if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      role_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_AllocationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.AllocationInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string role = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.AllocationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.AllocationInfo)
  return false;
#undef DO_
}

void Resource_AllocationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.AllocationInfo)
  // optional string role = 1;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->role(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.AllocationInfo)
}

::google::protobuf::uint8* Resource_AllocationInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.AllocationInfo)
  // optional string role = 1;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->role(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.AllocationInfo)
  return target;
}

int Resource_AllocationInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string role = 1;
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_AllocationInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_AllocationInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_AllocationInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_AllocationInfo::MergeFrom(const Resource_AllocationInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_role()) {
      set_role(from.role());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_AllocationInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_AllocationInfo::CopyFrom(const Resource_AllocationInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_AllocationInfo::IsInitialized() const {

  return true;
}

void Resource_AllocationInfo::Swap(Resource_AllocationInfo* other) {
  if (other != this) {
    std::swap(role_, other->role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_AllocationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_AllocationInfo_descriptor_;
  metadata.reflection = Resource_AllocationInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Resource_ReservationInfo::kPrincipalFieldNumber;
const int Resource_ReservationInfo::kLabelsFieldNumber;
#endif  // !_MSC_VER

Resource_ReservationInfo::Resource_ReservationInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.ReservationInfo)
}

void Resource_ReservationInfo::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

Resource_ReservationInfo::Resource_ReservationInfo(const Resource_ReservationInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.ReservationInfo)
}

void Resource_ReservationInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_ReservationInfo::~Resource_ReservationInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.ReservationInfo)
  SharedDtor();
}

void Resource_ReservationInfo::SharedDtor() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (this != default_instance_) {
    delete labels_;
  }
}

void Resource_ReservationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_ReservationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_ReservationInfo_descriptor_;
}

const Resource_ReservationInfo& Resource_ReservationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_ReservationInfo* Resource_ReservationInfo::default_instance_ = NULL;

Resource_ReservationInfo* Resource_ReservationInfo::New() const {
  return new Resource_ReservationInfo;
}

void Resource_ReservationInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_principal()) {
      if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        principal_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_ReservationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.ReservationInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string principal = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 2;
      case 2: {
        if (tag == 18) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.ReservationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.ReservationInfo)
  return false;
#undef DO_
}

void Resource_ReservationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.ReservationInfo)
  // optional string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->principal(), output);
  }

  // optional .mesos.Labels labels = 2;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->labels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.ReservationInfo)
}

::google::protobuf::uint8* Resource_ReservationInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.ReservationInfo)
  // optional string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->principal(), target);
  }

  // optional .mesos.Labels labels = 2;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->labels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.ReservationInfo)
  return target;
}

int Resource_ReservationInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string principal = 1;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

    // optional .mesos.Labels labels = 2;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_ReservationInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_ReservationInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_ReservationInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_ReservationInfo::MergeFrom(const Resource_ReservationInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_principal()) {
      set_principal(from.principal());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_ReservationInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_ReservationInfo::CopyFrom(const Resource_ReservationInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_ReservationInfo::IsInitialized() const {

  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void Resource_ReservationInfo::Swap(Resource_ReservationInfo* other) {
  if (other != this) {
    std::swap(principal_, other->principal_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_ReservationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_ReservationInfo_descriptor_;
  metadata.reflection = Resource_ReservationInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Resource_DiskInfo_Persistence::kIdFieldNumber;
const int Resource_DiskInfo_Persistence::kPrincipalFieldNumber;
#endif  // !_MSC_VER

Resource_DiskInfo_Persistence::Resource_DiskInfo_Persistence()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Persistence)
}

void Resource_DiskInfo_Persistence::InitAsDefaultInstance() {
}

Resource_DiskInfo_Persistence::Resource_DiskInfo_Persistence(const Resource_DiskInfo_Persistence& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Persistence)
}

void Resource_DiskInfo_Persistence::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Persistence::~Resource_DiskInfo_Persistence() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Persistence)
  SharedDtor();
}

void Resource_DiskInfo_Persistence::SharedDtor() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (this != default_instance_) {
  }
}

void Resource_DiskInfo_Persistence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Persistence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Persistence_descriptor_;
}

const Resource_DiskInfo_Persistence& Resource_DiskInfo_Persistence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Persistence* Resource_DiskInfo_Persistence::default_instance_ = NULL;

Resource_DiskInfo_Persistence* Resource_DiskInfo_Persistence::New() const {
  return new Resource_DiskInfo_Persistence;
}

void Resource_DiskInfo_Persistence::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        id_->clear();
      }
    }
    if (has_principal()) {
      if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        principal_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_DiskInfo_Persistence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Persistence)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_principal;
        break;
      }

      // optional string principal = 2;
      case 2: {
        if (tag == 18) {
         parse_principal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Persistence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Persistence)
  return false;
#undef DO_
}

void Resource_DiskInfo_Persistence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Persistence)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // optional string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->principal(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Persistence)
}

::google::protobuf::uint8* Resource_DiskInfo_Persistence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Persistence)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // optional string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->principal(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Persistence)
  return target;
}

int Resource_DiskInfo_Persistence::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional string principal = 2;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Persistence::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_DiskInfo_Persistence* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_DiskInfo_Persistence*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Persistence::MergeFrom(const Resource_DiskInfo_Persistence& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_principal()) {
      set_principal(from.principal());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_DiskInfo_Persistence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Persistence::CopyFrom(const Resource_DiskInfo_Persistence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Persistence::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Resource_DiskInfo_Persistence::Swap(Resource_DiskInfo_Persistence* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(principal_, other->principal_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_DiskInfo_Persistence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Persistence_descriptor_;
  metadata.reflection = Resource_DiskInfo_Persistence_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* Resource_DiskInfo_Source_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_Type_descriptor_;
}
bool Resource_DiskInfo_Source_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::UNKNOWN;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::PATH;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::MOUNT;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::Type_MIN;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::Type_MAX;
const int Resource_DiskInfo_Source::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Resource_DiskInfo_Source_Path::kRootFieldNumber;
#endif  // !_MSC_VER

Resource_DiskInfo_Source_Path::Resource_DiskInfo_Source_Path()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Source.Path)
}

void Resource_DiskInfo_Source_Path::InitAsDefaultInstance() {
}

Resource_DiskInfo_Source_Path::Resource_DiskInfo_Source_Path(const Resource_DiskInfo_Source_Path& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Source.Path)
}

void Resource_DiskInfo_Source_Path::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Source_Path::~Resource_DiskInfo_Source_Path() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Source.Path)
  SharedDtor();
}

void Resource_DiskInfo_Source_Path::SharedDtor() {
  if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete root_;
  }
  if (this != default_instance_) {
  }
}

void Resource_DiskInfo_Source_Path::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Path::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_Path_descriptor_;
}

const Resource_DiskInfo_Source_Path& Resource_DiskInfo_Source_Path::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source_Path::default_instance_ = NULL;

Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source_Path::New() const {
  return new Resource_DiskInfo_Source_Path;
}

void Resource_DiskInfo_Source_Path::Clear() {
  if (has_root()) {
    if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      root_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_DiskInfo_Source_Path::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Source.Path)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string root = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_root()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->root().data(), this->root().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "root");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Source.Path)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Source.Path)
  return false;
#undef DO_
}

void Resource_DiskInfo_Source_Path::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Source.Path)
  // optional string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "root");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->root(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Source.Path)
}

::google::protobuf::uint8* Resource_DiskInfo_Source_Path::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Source.Path)
  // optional string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "root");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->root(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Source.Path)
  return target;
}

int Resource_DiskInfo_Source_Path::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string root = 1;
    if (has_root()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->root());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Source_Path::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_DiskInfo_Source_Path* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_DiskInfo_Source_Path*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Source_Path::MergeFrom(const Resource_DiskInfo_Source_Path& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_root()) {
      set_root(from.root());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_DiskInfo_Source_Path::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Source_Path::CopyFrom(const Resource_DiskInfo_Source_Path& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Source_Path::IsInitialized() const {

  return true;
}

void Resource_DiskInfo_Source_Path::Swap(Resource_DiskInfo_Source_Path* other) {
  if (other != this) {
    std::swap(root_, other->root_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_DiskInfo_Source_Path::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Source_Path_descriptor_;
  metadata.reflection = Resource_DiskInfo_Source_Path_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Resource_DiskInfo_Source_Mount::kRootFieldNumber;
#endif  // !_MSC_VER

Resource_DiskInfo_Source_Mount::Resource_DiskInfo_Source_Mount()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Source.Mount)
}

void Resource_DiskInfo_Source_Mount::InitAsDefaultInstance() {
}

Resource_DiskInfo_Source_Mount::Resource_DiskInfo_Source_Mount(const Resource_DiskInfo_Source_Mount& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Source.Mount)
}

void Resource_DiskInfo_Source_Mount::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Source_Mount::~Resource_DiskInfo_Source_Mount() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Source.Mount)
  SharedDtor();
}

void Resource_DiskInfo_Source_Mount::SharedDtor() {
  if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete root_;
  }
  if (this != default_instance_) {
  }
}

void Resource_DiskInfo_Source_Mount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Mount::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_Mount_descriptor_;
}

const Resource_DiskInfo_Source_Mount& Resource_DiskInfo_Source_Mount::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source_Mount::default_instance_ = NULL;

Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source_Mount::New() const {
  return new Resource_DiskInfo_Source_Mount;
}

void Resource_DiskInfo_Source_Mount::Clear() {
  if (has_root()) {
    if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      root_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_DiskInfo_Source_Mount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Source.Mount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string root = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_root()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->root().data(), this->root().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "root");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Source.Mount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Source.Mount)
  return false;
#undef DO_
}

void Resource_DiskInfo_Source_Mount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Source.Mount)
  // optional string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "root");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->root(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Source.Mount)
}

::google::protobuf::uint8* Resource_DiskInfo_Source_Mount::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Source.Mount)
  // optional string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "root");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->root(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Source.Mount)
  return target;
}

int Resource_DiskInfo_Source_Mount::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string root = 1;
    if (has_root()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->root());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Source_Mount::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_DiskInfo_Source_Mount* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_DiskInfo_Source_Mount*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Source_Mount::MergeFrom(const Resource_DiskInfo_Source_Mount& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_root()) {
      set_root(from.root());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_DiskInfo_Source_Mount::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Source_Mount::CopyFrom(const Resource_DiskInfo_Source_Mount& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Source_Mount::IsInitialized() const {

  return true;
}

void Resource_DiskInfo_Source_Mount::Swap(Resource_DiskInfo_Source_Mount* other) {
  if (other != this) {
    std::swap(root_, other->root_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_DiskInfo_Source_Mount::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Source_Mount_descriptor_;
  metadata.reflection = Resource_DiskInfo_Source_Mount_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Resource_DiskInfo_Source::kTypeFieldNumber;
const int Resource_DiskInfo_Source::kPathFieldNumber;
const int Resource_DiskInfo_Source::kMountFieldNumber;
#endif  // !_MSC_VER

Resource_DiskInfo_Source::Resource_DiskInfo_Source()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Source)
}

void Resource_DiskInfo_Source::InitAsDefaultInstance() {
  path_ = const_cast< ::mesos::Resource_DiskInfo_Source_Path*>(&::mesos::Resource_DiskInfo_Source_Path::default_instance());
  mount_ = const_cast< ::mesos::Resource_DiskInfo_Source_Mount*>(&::mesos::Resource_DiskInfo_Source_Mount::default_instance());
}

Resource_DiskInfo_Source::Resource_DiskInfo_Source(const Resource_DiskInfo_Source& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Source)
}

void Resource_DiskInfo_Source::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  path_ = NULL;
  mount_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Source::~Resource_DiskInfo_Source() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Source)
  SharedDtor();
}

void Resource_DiskInfo_Source::SharedDtor() {
  if (this != default_instance_) {
    delete path_;
    delete mount_;
  }
}

void Resource_DiskInfo_Source::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_descriptor_;
}

const Resource_DiskInfo_Source& Resource_DiskInfo_Source::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Source* Resource_DiskInfo_Source::default_instance_ = NULL;

Resource_DiskInfo_Source* Resource_DiskInfo_Source::New() const {
  return new Resource_DiskInfo_Source;
}

void Resource_DiskInfo_Source::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 0;
    if (has_path()) {
      if (path_ != NULL) path_->::mesos::Resource_DiskInfo_Source_Path::Clear();
    }
    if (has_mount()) {
      if (mount_ != NULL) mount_->::mesos::Resource_DiskInfo_Source_Mount::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_DiskInfo_Source::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Source)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Resource.DiskInfo.Source.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Resource_DiskInfo_Source_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Resource_DiskInfo_Source_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_mount;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
      case 3: {
        if (tag == 26) {
         parse_mount:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mount()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Source)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Source)
  return false;
#undef DO_
}

void Resource_DiskInfo_Source::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Source)
  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->path(), output);
  }

  // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
  if (has_mount()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->mount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Source)
}

::google::protobuf::uint8* Resource_DiskInfo_Source::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Source)
  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
  if (has_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->path(), target);
  }

  // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
  if (has_mount()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->mount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Source)
  return target;
}

int Resource_DiskInfo_Source::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.Resource.DiskInfo.Source.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->path());
    }

    // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
    if (has_mount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mount());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Source::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_DiskInfo_Source* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_DiskInfo_Source*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Source::MergeFrom(const Resource_DiskInfo_Source& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_path()) {
      mutable_path()->::mesos::Resource_DiskInfo_Source_Path::MergeFrom(from.path());
    }
    if (from.has_mount()) {
      mutable_mount()->::mesos::Resource_DiskInfo_Source_Mount::MergeFrom(from.mount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_DiskInfo_Source::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Source::CopyFrom(const Resource_DiskInfo_Source& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Source::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Resource_DiskInfo_Source::Swap(Resource_DiskInfo_Source* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(path_, other->path_);
    std::swap(mount_, other->mount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_DiskInfo_Source::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Source_descriptor_;
  metadata.reflection = Resource_DiskInfo_Source_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Resource_DiskInfo::kPersistenceFieldNumber;
const int Resource_DiskInfo::kVolumeFieldNumber;
const int Resource_DiskInfo::kSourceFieldNumber;
#endif  // !_MSC_VER

Resource_DiskInfo::Resource_DiskInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo)
}

void Resource_DiskInfo::InitAsDefaultInstance() {
  persistence_ = const_cast< ::mesos::Resource_DiskInfo_Persistence*>(&::mesos::Resource_DiskInfo_Persistence::default_instance());
  volume_ = const_cast< ::mesos::Volume*>(&::mesos::Volume::default_instance());
  source_ = const_cast< ::mesos::Resource_DiskInfo_Source*>(&::mesos::Resource_DiskInfo_Source::default_instance());
}

Resource_DiskInfo::Resource_DiskInfo(const Resource_DiskInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo)
}

void Resource_DiskInfo::SharedCtor() {
  _cached_size_ = 0;
  persistence_ = NULL;
  volume_ = NULL;
  source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo::~Resource_DiskInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo)
  SharedDtor();
}

void Resource_DiskInfo::SharedDtor() {
  if (this != default_instance_) {
    delete persistence_;
    delete volume_;
    delete source_;
  }
}

void Resource_DiskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_descriptor_;
}

const Resource_DiskInfo& Resource_DiskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo* Resource_DiskInfo::default_instance_ = NULL;

Resource_DiskInfo* Resource_DiskInfo::New() const {
  return new Resource_DiskInfo;
}

void Resource_DiskInfo::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_persistence()) {
      if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
    }
    if (has_volume()) {
      if (volume_ != NULL) volume_->::mesos::Volume::Clear();
    }
    if (has_source()) {
      if (source_ != NULL) source_->::mesos::Resource_DiskInfo_Source::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_DiskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_persistence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_volume;
        break;
      }

      // optional .mesos.Volume volume = 2;
      case 2: {
        if (tag == 18) {
         parse_volume:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_volume()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Source source = 3;
      case 3: {
        if (tag == 26) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo)
  return false;
#undef DO_
}

void Resource_DiskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo)
  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  if (has_persistence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->persistence(), output);
  }

  // optional .mesos.Volume volume = 2;
  if (has_volume()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->volume(), output);
  }

  // optional .mesos.Resource.DiskInfo.Source source = 3;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->source(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo)
}

::google::protobuf::uint8* Resource_DiskInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo)
  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  if (has_persistence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->persistence(), target);
  }

  // optional .mesos.Volume volume = 2;
  if (has_volume()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->volume(), target);
  }

  // optional .mesos.Resource.DiskInfo.Source source = 3;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->source(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo)
  return target;
}

int Resource_DiskInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
    if (has_persistence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->persistence());
    }

    // optional .mesos.Volume volume = 2;
    if (has_volume()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->volume());
    }

    // optional .mesos.Resource.DiskInfo.Source source = 3;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_DiskInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_DiskInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_DiskInfo::MergeFrom(const Resource_DiskInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_persistence()) {
      mutable_persistence()->::mesos::Resource_DiskInfo_Persistence::MergeFrom(from.persistence());
    }
    if (from.has_volume()) {
      mutable_volume()->::mesos::Volume::MergeFrom(from.volume());
    }
    if (from.has_source()) {
      mutable_source()->::mesos::Resource_DiskInfo_Source::MergeFrom(from.source());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_DiskInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo::CopyFrom(const Resource_DiskInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo::IsInitialized() const {

  if (has_persistence()) {
    if (!this->persistence().IsInitialized()) return false;
  }
  if (has_volume()) {
    if (!this->volume().IsInitialized()) return false;
  }
  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  return true;
}

void Resource_DiskInfo::Swap(Resource_DiskInfo* other) {
  if (other != this) {
    std::swap(persistence_, other->persistence_);
    std::swap(volume_, other->volume_);
    std::swap(source_, other->source_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_DiskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_descriptor_;
  metadata.reflection = Resource_DiskInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Resource_RevocableInfo::Resource_RevocableInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.RevocableInfo)
}

void Resource_RevocableInfo::InitAsDefaultInstance() {
}

Resource_RevocableInfo::Resource_RevocableInfo(const Resource_RevocableInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.RevocableInfo)
}

void Resource_RevocableInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_RevocableInfo::~Resource_RevocableInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.RevocableInfo)
  SharedDtor();
}

void Resource_RevocableInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Resource_RevocableInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_RevocableInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_RevocableInfo_descriptor_;
}

const Resource_RevocableInfo& Resource_RevocableInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_RevocableInfo* Resource_RevocableInfo::default_instance_ = NULL;

Resource_RevocableInfo* Resource_RevocableInfo::New() const {
  return new Resource_RevocableInfo;
}

void Resource_RevocableInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_RevocableInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.RevocableInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.RevocableInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.RevocableInfo)
  return false;
#undef DO_
}

void Resource_RevocableInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.RevocableInfo)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.RevocableInfo)
}

::google::protobuf::uint8* Resource_RevocableInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.RevocableInfo)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.RevocableInfo)
  return target;
}

int Resource_RevocableInfo::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_RevocableInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_RevocableInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_RevocableInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_RevocableInfo::MergeFrom(const Resource_RevocableInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_RevocableInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_RevocableInfo::CopyFrom(const Resource_RevocableInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_RevocableInfo::IsInitialized() const {

  return true;
}

void Resource_RevocableInfo::Swap(Resource_RevocableInfo* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_RevocableInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_RevocableInfo_descriptor_;
  metadata.reflection = Resource_RevocableInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Resource_SharedInfo::Resource_SharedInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.SharedInfo)
}

void Resource_SharedInfo::InitAsDefaultInstance() {
}

Resource_SharedInfo::Resource_SharedInfo(const Resource_SharedInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.SharedInfo)
}

void Resource_SharedInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_SharedInfo::~Resource_SharedInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.SharedInfo)
  SharedDtor();
}

void Resource_SharedInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Resource_SharedInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_SharedInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_SharedInfo_descriptor_;
}

const Resource_SharedInfo& Resource_SharedInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_SharedInfo* Resource_SharedInfo::default_instance_ = NULL;

Resource_SharedInfo* Resource_SharedInfo::New() const {
  return new Resource_SharedInfo;
}

void Resource_SharedInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource_SharedInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.SharedInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.SharedInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.SharedInfo)
  return false;
#undef DO_
}

void Resource_SharedInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.SharedInfo)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.SharedInfo)
}

::google::protobuf::uint8* Resource_SharedInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.SharedInfo)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.SharedInfo)
  return target;
}

int Resource_SharedInfo::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_SharedInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource_SharedInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource_SharedInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource_SharedInfo::MergeFrom(const Resource_SharedInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource_SharedInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_SharedInfo::CopyFrom(const Resource_SharedInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_SharedInfo::IsInitialized() const {

  return true;
}

void Resource_SharedInfo::Swap(Resource_SharedInfo* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource_SharedInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_SharedInfo_descriptor_;
  metadata.reflection = Resource_SharedInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

::std::string* Resource::_default_role_ = NULL;
#ifndef _MSC_VER
const int Resource::kProviderIdFieldNumber;
const int Resource::kNameFieldNumber;
const int Resource::kTypeFieldNumber;
const int Resource::kScalarFieldNumber;
const int Resource::kRangesFieldNumber;
const int Resource::kSetFieldNumber;
const int Resource::kRoleFieldNumber;
const int Resource::kAllocationInfoFieldNumber;
const int Resource::kReservationFieldNumber;
const int Resource::kDiskFieldNumber;
const int Resource::kRevocableFieldNumber;
const int Resource::kSharedFieldNumber;
#endif  // !_MSC_VER

Resource::Resource()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource)
}

void Resource::InitAsDefaultInstance() {
  provider_id_ = const_cast< ::mesos::ResourceProviderID*>(&::mesos::ResourceProviderID::default_instance());
  scalar_ = const_cast< ::mesos::Value_Scalar*>(&::mesos::Value_Scalar::default_instance());
  ranges_ = const_cast< ::mesos::Value_Ranges*>(&::mesos::Value_Ranges::default_instance());
  set_ = const_cast< ::mesos::Value_Set*>(&::mesos::Value_Set::default_instance());
  allocation_info_ = const_cast< ::mesos::Resource_AllocationInfo*>(&::mesos::Resource_AllocationInfo::default_instance());
  reservation_ = const_cast< ::mesos::Resource_ReservationInfo*>(&::mesos::Resource_ReservationInfo::default_instance());
  disk_ = const_cast< ::mesos::Resource_DiskInfo*>(&::mesos::Resource_DiskInfo::default_instance());
  revocable_ = const_cast< ::mesos::Resource_RevocableInfo*>(&::mesos::Resource_RevocableInfo::default_instance());
  shared_ = const_cast< ::mesos::Resource_SharedInfo*>(&::mesos::Resource_SharedInfo::default_instance());
}

Resource::Resource(const Resource& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource)
}

void Resource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  provider_id_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  scalar_ = NULL;
  ranges_ = NULL;
  set_ = NULL;
  role_ = const_cast< ::std::string*>(_default_role_);
  allocation_info_ = NULL;
  reservation_ = NULL;
  disk_ = NULL;
  revocable_ = NULL;
  shared_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource::~Resource() {
  // @@protoc_insertion_point(destructor:mesos.Resource)
  SharedDtor();
}

void Resource::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (role_ != _default_role_) {
    delete role_;
  }
  if (this != default_instance_) {
    delete provider_id_;
    delete scalar_;
    delete ranges_;
    delete set_;
    delete allocation_info_;
    delete reservation_;
    delete disk_;
    delete revocable_;
    delete shared_;
  }
}

void Resource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_descriptor_;
}

const Resource& Resource::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource* Resource::default_instance_ = NULL;

Resource* Resource::New() const {
  return new Resource;
}

void Resource::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_provider_id()) {
      if (provider_id_ != NULL) provider_id_->::mesos::ResourceProviderID::Clear();
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    type_ = 0;
    if (has_scalar()) {
      if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
    }
    if (has_ranges()) {
      if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
    }
    if (has_set()) {
      if (set_ != NULL) set_->::mesos::Value_Set::Clear();
    }
    if (has_role()) {
      if (role_ != _default_role_) {
        role_->assign(*_default_role_);
      }
    }
    if (has_allocation_info()) {
      if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 3840) {
    if (has_reservation()) {
      if (reservation_ != NULL) reservation_->::mesos::Resource_ReservationInfo::Clear();
    }
    if (has_disk()) {
      if (disk_ != NULL) disk_->::mesos::Resource_DiskInfo::Clear();
    }
    if (has_revocable()) {
      if (revocable_ != NULL) revocable_->::mesos::Resource_RevocableInfo::Clear();
    }
    if (has_shared()) {
      if (shared_ != NULL) shared_->::mesos::Resource_SharedInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Resource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .mesos.Value.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Value_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Value_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scalar;
        break;
      }

      // optional .mesos.Value.Scalar scalar = 3;
      case 3: {
        if (tag == 26) {
         parse_scalar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ranges;
        break;
      }

      // optional .mesos.Value.Ranges ranges = 4;
      case 4: {
        if (tag == 34) {
         parse_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_set;
        break;
      }

      // optional .mesos.Value.Set set = 5;
      case 5: {
        if (tag == 42) {
         parse_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_role;
        break;
      }

      // optional string role = 6 [default = "*"];
      case 6: {
        if (tag == 50) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_disk;
        break;
      }

      // optional .mesos.Resource.DiskInfo disk = 7;
      case 7: {
        if (tag == 58) {
         parse_disk:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_disk()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_reservation;
        break;
      }

      // optional .mesos.Resource.ReservationInfo reservation = 8;
      case 8: {
        if (tag == 66) {
         parse_reservation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reservation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_revocable;
        break;
      }

      // optional .mesos.Resource.RevocableInfo revocable = 9;
      case 9: {
        if (tag == 74) {
         parse_revocable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_revocable()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_shared;
        break;
      }

      // optional .mesos.Resource.SharedInfo shared = 10;
      case 10: {
        if (tag == 82) {
         parse_shared:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shared()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_allocation_info;
        break;
      }

      // optional .mesos.Resource.AllocationInfo allocation_info = 11;
      case 11: {
        if (tag == 90) {
         parse_allocation_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_allocation_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_provider_id;
        break;
      }

      // optional .mesos.ResourceProviderID provider_id = 12;
      case 12: {
        if (tag == 98) {
         parse_provider_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_provider_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource)
  return false;
#undef DO_
}

void Resource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->scalar(), output);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->ranges(), output);
  }

  // optional .mesos.Value.Set set = 5;
  if (has_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->set(), output);
  }

  // optional string role = 6 [default = "*"];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->role(), output);
  }

  // optional .mesos.Resource.DiskInfo disk = 7;
  if (has_disk()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->disk(), output);
  }

  // optional .mesos.Resource.ReservationInfo reservation = 8;
  if (has_reservation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->reservation(), output);
  }

  // optional .mesos.Resource.RevocableInfo revocable = 9;
  if (has_revocable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->revocable(), output);
  }

  // optional .mesos.Resource.SharedInfo shared = 10;
  if (has_shared()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->shared(), output);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 11;
  if (has_allocation_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->allocation_info(), output);
  }

  // optional .mesos.ResourceProviderID provider_id = 12;
  if (has_provider_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->provider_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource)
}

::google::protobuf::uint8* Resource::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->scalar(), target);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->ranges(), target);
  }

  // optional .mesos.Value.Set set = 5;
  if (has_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->set(), target);
  }

  // optional string role = 6 [default = "*"];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->role(), target);
  }

  // optional .mesos.Resource.DiskInfo disk = 7;
  if (has_disk()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->disk(), target);
  }

  // optional .mesos.Resource.ReservationInfo reservation = 8;
  if (has_reservation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->reservation(), target);
  }

  // optional .mesos.Resource.RevocableInfo revocable = 9;
  if (has_revocable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->revocable(), target);
  }

  // optional .mesos.Resource.SharedInfo shared = 10;
  if (has_shared()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->shared(), target);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 11;
  if (has_allocation_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->allocation_info(), target);
  }

  // optional .mesos.ResourceProviderID provider_id = 12;
  if (has_provider_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->provider_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource)
  return target;
}

int Resource::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ResourceProviderID provider_id = 12;
    if (has_provider_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->provider_id());
    }

    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .mesos.Value.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Value.Scalar scalar = 3;
    if (has_scalar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scalar());
    }

    // optional .mesos.Value.Ranges ranges = 4;
    if (has_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ranges());
    }

    // optional .mesos.Value.Set set = 5;
    if (has_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->set());
    }

    // optional string role = 6 [default = "*"];
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }

    // optional .mesos.Resource.AllocationInfo allocation_info = 11;
    if (has_allocation_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->allocation_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.Resource.ReservationInfo reservation = 8;
    if (has_reservation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reservation());
    }

    // optional .mesos.Resource.DiskInfo disk = 7;
    if (has_disk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->disk());
    }

    // optional .mesos.Resource.RevocableInfo revocable = 9;
    if (has_revocable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->revocable());
    }

    // optional .mesos.Resource.SharedInfo shared = 10;
    if (has_shared()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shared());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Resource* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Resource*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Resource::MergeFrom(const Resource& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_provider_id()) {
      mutable_provider_id()->::mesos::ResourceProviderID::MergeFrom(from.provider_id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_scalar()) {
      mutable_scalar()->::mesos::Value_Scalar::MergeFrom(from.scalar());
    }
    if (from.has_ranges()) {
      mutable_ranges()->::mesos::Value_Ranges::MergeFrom(from.ranges());
    }
    if (from.has_set()) {
      mutable_set()->::mesos::Value_Set::MergeFrom(from.set());
    }
    if (from.has_role()) {
      set_role(from.role());
    }
    if (from.has_allocation_info()) {
      mutable_allocation_info()->::mesos::Resource_AllocationInfo::MergeFrom(from.allocation_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_reservation()) {
      mutable_reservation()->::mesos::Resource_ReservationInfo::MergeFrom(from.reservation());
    }
    if (from.has_disk()) {
      mutable_disk()->::mesos::Resource_DiskInfo::MergeFrom(from.disk());
    }
    if (from.has_revocable()) {
      mutable_revocable()->::mesos::Resource_RevocableInfo::MergeFrom(from.revocable());
    }
    if (from.has_shared()) {
      mutable_shared()->::mesos::Resource_SharedInfo::MergeFrom(from.shared());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Resource::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource::CopyFrom(const Resource& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_provider_id()) {
    if (!this->provider_id().IsInitialized()) return false;
  }
  if (has_scalar()) {
    if (!this->scalar().IsInitialized()) return false;
  }
  if (has_ranges()) {
    if (!this->ranges().IsInitialized()) return false;
  }
  if (has_reservation()) {
    if (!this->reservation().IsInitialized()) return false;
  }
  if (has_disk()) {
    if (!this->disk().IsInitialized()) return false;
  }
  return true;
}

void Resource::Swap(Resource* other) {
  if (other != this) {
    std::swap(provider_id_, other->provider_id_);
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(scalar_, other->scalar_);
    std::swap(ranges_, other->ranges_);
    std::swap(set_, other->set_);
    std::swap(role_, other->role_);
    std::swap(allocation_info_, other->allocation_info_);
    std::swap(reservation_, other->reservation_);
    std::swap(disk_, other->disk_);
    std::swap(revocable_, other->revocable_);
    std::swap(shared_, other->shared_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Resource::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_descriptor_;
  metadata.reflection = Resource_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TrafficControlStatistics::kIdFieldNumber;
const int TrafficControlStatistics::kBacklogFieldNumber;
const int TrafficControlStatistics::kBytesFieldNumber;
const int TrafficControlStatistics::kDropsFieldNumber;
const int TrafficControlStatistics::kOverlimitsFieldNumber;
const int TrafficControlStatistics::kPacketsFieldNumber;
const int TrafficControlStatistics::kQlenFieldNumber;
const int TrafficControlStatistics::kRatebpsFieldNumber;
const int TrafficControlStatistics::kRateppsFieldNumber;
const int TrafficControlStatistics::kRequeuesFieldNumber;
#endif  // !_MSC_VER

TrafficControlStatistics::TrafficControlStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TrafficControlStatistics)
}

void TrafficControlStatistics::InitAsDefaultInstance() {
}

TrafficControlStatistics::TrafficControlStatistics(const TrafficControlStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TrafficControlStatistics)
}

void TrafficControlStatistics::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  backlog_ = GOOGLE_ULONGLONG(0);
  bytes_ = GOOGLE_ULONGLONG(0);
  drops_ = GOOGLE_ULONGLONG(0);
  overlimits_ = GOOGLE_ULONGLONG(0);
  packets_ = GOOGLE_ULONGLONG(0);
  qlen_ = GOOGLE_ULONGLONG(0);
  ratebps_ = GOOGLE_ULONGLONG(0);
  ratepps_ = GOOGLE_ULONGLONG(0);
  requeues_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficControlStatistics::~TrafficControlStatistics() {
  // @@protoc_insertion_point(destructor:mesos.TrafficControlStatistics)
  SharedDtor();
}

void TrafficControlStatistics::SharedDtor() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (this != default_instance_) {
  }
}

void TrafficControlStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficControlStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficControlStatistics_descriptor_;
}

const TrafficControlStatistics& TrafficControlStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TrafficControlStatistics* TrafficControlStatistics::default_instance_ = NULL;

TrafficControlStatistics* TrafficControlStatistics::New() const {
  return new TrafficControlStatistics;
}

void TrafficControlStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TrafficControlStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(backlog_, ratebps_);
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        id_->clear();
      }
    }
  }
  ZR_(ratepps_, requeues_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TrafficControlStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TrafficControlStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_backlog;
        break;
      }

      // optional uint64 backlog = 2;
      case 2: {
        if (tag == 16) {
         parse_backlog:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &backlog_)));
          set_has_backlog();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_bytes;
        break;
      }

      // optional uint64 bytes = 3;
      case 3: {
        if (tag == 24) {
         parse_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_)));
          set_has_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_drops;
        break;
      }

      // optional uint64 drops = 4;
      case 4: {
        if (tag == 32) {
         parse_drops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &drops_)));
          set_has_drops();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_overlimits;
        break;
      }

      // optional uint64 overlimits = 5;
      case 5: {
        if (tag == 40) {
         parse_overlimits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &overlimits_)));
          set_has_overlimits();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_packets;
        break;
      }

      // optional uint64 packets = 6;
      case 6: {
        if (tag == 48) {
         parse_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &packets_)));
          set_has_packets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_qlen;
        break;
      }

      // optional uint64 qlen = 7;
      case 7: {
        if (tag == 56) {
         parse_qlen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &qlen_)));
          set_has_qlen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_ratebps;
        break;
      }

      // optional uint64 ratebps = 8;
      case 8: {
        if (tag == 64) {
         parse_ratebps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ratebps_)));
          set_has_ratebps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_ratepps;
        break;
      }

      // optional uint64 ratepps = 9;
      case 9: {
        if (tag == 72) {
         parse_ratepps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ratepps_)));
          set_has_ratepps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_requeues;
        break;
      }

      // optional uint64 requeues = 10;
      case 10: {
        if (tag == 80) {
         parse_requeues:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requeues_)));
          set_has_requeues();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TrafficControlStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TrafficControlStatistics)
  return false;
#undef DO_
}

void TrafficControlStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TrafficControlStatistics)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // optional uint64 backlog = 2;
  if (has_backlog()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->backlog(), output);
  }

  // optional uint64 bytes = 3;
  if (has_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->bytes(), output);
  }

  // optional uint64 drops = 4;
  if (has_drops()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->drops(), output);
  }

  // optional uint64 overlimits = 5;
  if (has_overlimits()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->overlimits(), output);
  }

  // optional uint64 packets = 6;
  if (has_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->packets(), output);
  }

  // optional uint64 qlen = 7;
  if (has_qlen()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->qlen(), output);
  }

  // optional uint64 ratebps = 8;
  if (has_ratebps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->ratebps(), output);
  }

  // optional uint64 ratepps = 9;
  if (has_ratepps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->ratepps(), output);
  }

  // optional uint64 requeues = 10;
  if (has_requeues()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->requeues(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TrafficControlStatistics)
}

::google::protobuf::uint8* TrafficControlStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TrafficControlStatistics)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // optional uint64 backlog = 2;
  if (has_backlog()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->backlog(), target);
  }

  // optional uint64 bytes = 3;
  if (has_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->bytes(), target);
  }

  // optional uint64 drops = 4;
  if (has_drops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->drops(), target);
  }

  // optional uint64 overlimits = 5;
  if (has_overlimits()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->overlimits(), target);
  }

  // optional uint64 packets = 6;
  if (has_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->packets(), target);
  }

  // optional uint64 qlen = 7;
  if (has_qlen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->qlen(), target);
  }

  // optional uint64 ratebps = 8;
  if (has_ratebps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->ratebps(), target);
  }

  // optional uint64 ratepps = 9;
  if (has_ratepps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->ratepps(), target);
  }

  // optional uint64 requeues = 10;
  if (has_requeues()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->requeues(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TrafficControlStatistics)
  return target;
}

int TrafficControlStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional uint64 backlog = 2;
    if (has_backlog()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->backlog());
    }

    // optional uint64 bytes = 3;
    if (has_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bytes());
    }

    // optional uint64 drops = 4;
    if (has_drops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->drops());
    }

    // optional uint64 overlimits = 5;
    if (has_overlimits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->overlimits());
    }

    // optional uint64 packets = 6;
    if (has_packets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->packets());
    }

    // optional uint64 qlen = 7;
    if (has_qlen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->qlen());
    }

    // optional uint64 ratebps = 8;
    if (has_ratebps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ratebps());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 ratepps = 9;
    if (has_ratepps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ratepps());
    }

    // optional uint64 requeues = 10;
    if (has_requeues()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->requeues());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficControlStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TrafficControlStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TrafficControlStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TrafficControlStatistics::MergeFrom(const TrafficControlStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_backlog()) {
      set_backlog(from.backlog());
    }
    if (from.has_bytes()) {
      set_bytes(from.bytes());
    }
    if (from.has_drops()) {
      set_drops(from.drops());
    }
    if (from.has_overlimits()) {
      set_overlimits(from.overlimits());
    }
    if (from.has_packets()) {
      set_packets(from.packets());
    }
    if (from.has_qlen()) {
      set_qlen(from.qlen());
    }
    if (from.has_ratebps()) {
      set_ratebps(from.ratebps());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ratepps()) {
      set_ratepps(from.ratepps());
    }
    if (from.has_requeues()) {
      set_requeues(from.requeues());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TrafficControlStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficControlStatistics::CopyFrom(const TrafficControlStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficControlStatistics::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TrafficControlStatistics::Swap(TrafficControlStatistics* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(backlog_, other->backlog_);
    std::swap(bytes_, other->bytes_);
    std::swap(drops_, other->drops_);
    std::swap(overlimits_, other->overlimits_);
    std::swap(packets_, other->packets_);
    std::swap(qlen_, other->qlen_);
    std::swap(ratebps_, other->ratebps_);
    std::swap(ratepps_, other->ratepps_);
    std::swap(requeues_, other->requeues_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TrafficControlStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficControlStatistics_descriptor_;
  metadata.reflection = TrafficControlStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IpStatistics::kForwardingFieldNumber;
const int IpStatistics::kDefaultTTLFieldNumber;
const int IpStatistics::kInReceivesFieldNumber;
const int IpStatistics::kInHdrErrorsFieldNumber;
const int IpStatistics::kInAddrErrorsFieldNumber;
const int IpStatistics::kForwDatagramsFieldNumber;
const int IpStatistics::kInUnknownProtosFieldNumber;
const int IpStatistics::kInDiscardsFieldNumber;
const int IpStatistics::kInDeliversFieldNumber;
const int IpStatistics::kOutRequestsFieldNumber;
const int IpStatistics::kOutDiscardsFieldNumber;
const int IpStatistics::kOutNoRoutesFieldNumber;
const int IpStatistics::kReasmTimeoutFieldNumber;
const int IpStatistics::kReasmReqdsFieldNumber;
const int IpStatistics::kReasmOKsFieldNumber;
const int IpStatistics::kReasmFailsFieldNumber;
const int IpStatistics::kFragOKsFieldNumber;
const int IpStatistics::kFragFailsFieldNumber;
const int IpStatistics::kFragCreatesFieldNumber;
#endif  // !_MSC_VER

IpStatistics::IpStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.IpStatistics)
}

void IpStatistics::InitAsDefaultInstance() {
}

IpStatistics::IpStatistics(const IpStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.IpStatistics)
}

void IpStatistics::SharedCtor() {
  _cached_size_ = 0;
  forwarding_ = GOOGLE_LONGLONG(0);
  defaultttl_ = GOOGLE_LONGLONG(0);
  inreceives_ = GOOGLE_LONGLONG(0);
  inhdrerrors_ = GOOGLE_LONGLONG(0);
  inaddrerrors_ = GOOGLE_LONGLONG(0);
  forwdatagrams_ = GOOGLE_LONGLONG(0);
  inunknownprotos_ = GOOGLE_LONGLONG(0);
  indiscards_ = GOOGLE_LONGLONG(0);
  indelivers_ = GOOGLE_LONGLONG(0);
  outrequests_ = GOOGLE_LONGLONG(0);
  outdiscards_ = GOOGLE_LONGLONG(0);
  outnoroutes_ = GOOGLE_LONGLONG(0);
  reasmtimeout_ = GOOGLE_LONGLONG(0);
  reasmreqds_ = GOOGLE_LONGLONG(0);
  reasmoks_ = GOOGLE_LONGLONG(0);
  reasmfails_ = GOOGLE_LONGLONG(0);
  fragoks_ = GOOGLE_LONGLONG(0);
  fragfails_ = GOOGLE_LONGLONG(0);
  fragcreates_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpStatistics::~IpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.IpStatistics)
  SharedDtor();
}

void IpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IpStatistics_descriptor_;
}

const IpStatistics& IpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

IpStatistics* IpStatistics::default_instance_ = NULL;

IpStatistics* IpStatistics::New() const {
  return new IpStatistics;
}

void IpStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IpStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(forwarding_, indiscards_);
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(indelivers_, reasmfails_);
  }
  ZR_(fragoks_, fragcreates_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.IpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 Forwarding = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &forwarding_)));
          set_has_forwarding();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_DefaultTTL;
        break;
      }

      // optional int64 DefaultTTL = 2;
      case 2: {
        if (tag == 16) {
         parse_DefaultTTL:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &defaultttl_)));
          set_has_defaultttl();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_InReceives;
        break;
      }

      // optional int64 InReceives = 3;
      case 3: {
        if (tag == 24) {
         parse_InReceives:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inreceives_)));
          set_has_inreceives();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_InHdrErrors;
        break;
      }

      // optional int64 InHdrErrors = 4;
      case 4: {
        if (tag == 32) {
         parse_InHdrErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inhdrerrors_)));
          set_has_inhdrerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_InAddrErrors;
        break;
      }

      // optional int64 InAddrErrors = 5;
      case 5: {
        if (tag == 40) {
         parse_InAddrErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inaddrerrors_)));
          set_has_inaddrerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ForwDatagrams;
        break;
      }

      // optional int64 ForwDatagrams = 6;
      case 6: {
        if (tag == 48) {
         parse_ForwDatagrams:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &forwdatagrams_)));
          set_has_forwdatagrams();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_InUnknownProtos;
        break;
      }

      // optional int64 InUnknownProtos = 7;
      case 7: {
        if (tag == 56) {
         parse_InUnknownProtos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inunknownprotos_)));
          set_has_inunknownprotos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_InDiscards;
        break;
      }

      // optional int64 InDiscards = 8;
      case 8: {
        if (tag == 64) {
         parse_InDiscards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indiscards_)));
          set_has_indiscards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_InDelivers;
        break;
      }

      // optional int64 InDelivers = 9;
      case 9: {
        if (tag == 72) {
         parse_InDelivers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indelivers_)));
          set_has_indelivers();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_OutRequests;
        break;
      }

      // optional int64 OutRequests = 10;
      case 10: {
        if (tag == 80) {
         parse_OutRequests:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outrequests_)));
          set_has_outrequests();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_OutDiscards;
        break;
      }

      // optional int64 OutDiscards = 11;
      case 11: {
        if (tag == 88) {
         parse_OutDiscards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outdiscards_)));
          set_has_outdiscards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_OutNoRoutes;
        break;
      }

      // optional int64 OutNoRoutes = 12;
      case 12: {
        if (tag == 96) {
         parse_OutNoRoutes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outnoroutes_)));
          set_has_outnoroutes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_ReasmTimeout;
        break;
      }

      // optional int64 ReasmTimeout = 13;
      case 13: {
        if (tag == 104) {
         parse_ReasmTimeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmtimeout_)));
          set_has_reasmtimeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_ReasmReqds;
        break;
      }

      // optional int64 ReasmReqds = 14;
      case 14: {
        if (tag == 112) {
         parse_ReasmReqds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmreqds_)));
          set_has_reasmreqds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_ReasmOKs;
        break;
      }

      // optional int64 ReasmOKs = 15;
      case 15: {
        if (tag == 120) {
         parse_ReasmOKs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmoks_)));
          set_has_reasmoks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_ReasmFails;
        break;
      }

      // optional int64 ReasmFails = 16;
      case 16: {
        if (tag == 128) {
         parse_ReasmFails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmfails_)));
          set_has_reasmfails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_FragOKs;
        break;
      }

      // optional int64 FragOKs = 17;
      case 17: {
        if (tag == 136) {
         parse_FragOKs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fragoks_)));
          set_has_fragoks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_FragFails;
        break;
      }

      // optional int64 FragFails = 18;
      case 18: {
        if (tag == 144) {
         parse_FragFails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fragfails_)));
          set_has_fragfails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_FragCreates;
        break;
      }

      // optional int64 FragCreates = 19;
      case 19: {
        if (tag == 152) {
         parse_FragCreates:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fragcreates_)));
          set_has_fragcreates();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.IpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.IpStatistics)
  return false;
#undef DO_
}

void IpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.IpStatistics)
  // optional int64 Forwarding = 1;
  if (has_forwarding()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->forwarding(), output);
  }

  // optional int64 DefaultTTL = 2;
  if (has_defaultttl()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->defaultttl(), output);
  }

  // optional int64 InReceives = 3;
  if (has_inreceives()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->inreceives(), output);
  }

  // optional int64 InHdrErrors = 4;
  if (has_inhdrerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->inhdrerrors(), output);
  }

  // optional int64 InAddrErrors = 5;
  if (has_inaddrerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->inaddrerrors(), output);
  }

  // optional int64 ForwDatagrams = 6;
  if (has_forwdatagrams()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->forwdatagrams(), output);
  }

  // optional int64 InUnknownProtos = 7;
  if (has_inunknownprotos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->inunknownprotos(), output);
  }

  // optional int64 InDiscards = 8;
  if (has_indiscards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->indiscards(), output);
  }

  // optional int64 InDelivers = 9;
  if (has_indelivers()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->indelivers(), output);
  }

  // optional int64 OutRequests = 10;
  if (has_outrequests()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->outrequests(), output);
  }

  // optional int64 OutDiscards = 11;
  if (has_outdiscards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->outdiscards(), output);
  }

  // optional int64 OutNoRoutes = 12;
  if (has_outnoroutes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->outnoroutes(), output);
  }

  // optional int64 ReasmTimeout = 13;
  if (has_reasmtimeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->reasmtimeout(), output);
  }

  // optional int64 ReasmReqds = 14;
  if (has_reasmreqds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->reasmreqds(), output);
  }

  // optional int64 ReasmOKs = 15;
  if (has_reasmoks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(15, this->reasmoks(), output);
  }

  // optional int64 ReasmFails = 16;
  if (has_reasmfails()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(16, this->reasmfails(), output);
  }

  // optional int64 FragOKs = 17;
  if (has_fragoks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(17, this->fragoks(), output);
  }

  // optional int64 FragFails = 18;
  if (has_fragfails()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->fragfails(), output);
  }

  // optional int64 FragCreates = 19;
  if (has_fragcreates()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(19, this->fragcreates(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.IpStatistics)
}

::google::protobuf::uint8* IpStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.IpStatistics)
  // optional int64 Forwarding = 1;
  if (has_forwarding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->forwarding(), target);
  }

  // optional int64 DefaultTTL = 2;
  if (has_defaultttl()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->defaultttl(), target);
  }

  // optional int64 InReceives = 3;
  if (has_inreceives()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->inreceives(), target);
  }

  // optional int64 InHdrErrors = 4;
  if (has_inhdrerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->inhdrerrors(), target);
  }

  // optional int64 InAddrErrors = 5;
  if (has_inaddrerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->inaddrerrors(), target);
  }

  // optional int64 ForwDatagrams = 6;
  if (has_forwdatagrams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->forwdatagrams(), target);
  }

  // optional int64 InUnknownProtos = 7;
  if (has_inunknownprotos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->inunknownprotos(), target);
  }

  // optional int64 InDiscards = 8;
  if (has_indiscards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->indiscards(), target);
  }

  // optional int64 InDelivers = 9;
  if (has_indelivers()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->indelivers(), target);
  }

  // optional int64 OutRequests = 10;
  if (has_outrequests()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->outrequests(), target);
  }

  // optional int64 OutDiscards = 11;
  if (has_outdiscards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->outdiscards(), target);
  }

  // optional int64 OutNoRoutes = 12;
  if (has_outnoroutes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(12, this->outnoroutes(), target);
  }

  // optional int64 ReasmTimeout = 13;
  if (has_reasmtimeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->reasmtimeout(), target);
  }

  // optional int64 ReasmReqds = 14;
  if (has_reasmreqds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->reasmreqds(), target);
  }

  // optional int64 ReasmOKs = 15;
  if (has_reasmoks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(15, this->reasmoks(), target);
  }

  // optional int64 ReasmFails = 16;
  if (has_reasmfails()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(16, this->reasmfails(), target);
  }

  // optional int64 FragOKs = 17;
  if (has_fragoks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(17, this->fragoks(), target);
  }

  // optional int64 FragFails = 18;
  if (has_fragfails()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(18, this->fragfails(), target);
  }

  // optional int64 FragCreates = 19;
  if (has_fragcreates()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(19, this->fragcreates(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.IpStatistics)
  return target;
}

int IpStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 Forwarding = 1;
    if (has_forwarding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->forwarding());
    }

    // optional int64 DefaultTTL = 2;
    if (has_defaultttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->defaultttl());
    }

    // optional int64 InReceives = 3;
    if (has_inreceives()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inreceives());
    }

    // optional int64 InHdrErrors = 4;
    if (has_inhdrerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inhdrerrors());
    }

    // optional int64 InAddrErrors = 5;
    if (has_inaddrerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inaddrerrors());
    }

    // optional int64 ForwDatagrams = 6;
    if (has_forwdatagrams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->forwdatagrams());
    }

    // optional int64 InUnknownProtos = 7;
    if (has_inunknownprotos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inunknownprotos());
    }

    // optional int64 InDiscards = 8;
    if (has_indiscards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indiscards());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 InDelivers = 9;
    if (has_indelivers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indelivers());
    }

    // optional int64 OutRequests = 10;
    if (has_outrequests()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outrequests());
    }

    // optional int64 OutDiscards = 11;
    if (has_outdiscards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outdiscards());
    }

    // optional int64 OutNoRoutes = 12;
    if (has_outnoroutes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outnoroutes());
    }

    // optional int64 ReasmTimeout = 13;
    if (has_reasmtimeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmtimeout());
    }

    // optional int64 ReasmReqds = 14;
    if (has_reasmreqds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmreqds());
    }

    // optional int64 ReasmOKs = 15;
    if (has_reasmoks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmoks());
    }

    // optional int64 ReasmFails = 16;
    if (has_reasmfails()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmfails());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int64 FragOKs = 17;
    if (has_fragoks()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fragoks());
    }

    // optional int64 FragFails = 18;
    if (has_fragfails()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fragfails());
    }

    // optional int64 FragCreates = 19;
    if (has_fragcreates()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fragcreates());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IpStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IpStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IpStatistics::MergeFrom(const IpStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_forwarding()) {
      set_forwarding(from.forwarding());
    }
    if (from.has_defaultttl()) {
      set_defaultttl(from.defaultttl());
    }
    if (from.has_inreceives()) {
      set_inreceives(from.inreceives());
    }
    if (from.has_inhdrerrors()) {
      set_inhdrerrors(from.inhdrerrors());
    }
    if (from.has_inaddrerrors()) {
      set_inaddrerrors(from.inaddrerrors());
    }
    if (from.has_forwdatagrams()) {
      set_forwdatagrams(from.forwdatagrams());
    }
    if (from.has_inunknownprotos()) {
      set_inunknownprotos(from.inunknownprotos());
    }
    if (from.has_indiscards()) {
      set_indiscards(from.indiscards());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_indelivers()) {
      set_indelivers(from.indelivers());
    }
    if (from.has_outrequests()) {
      set_outrequests(from.outrequests());
    }
    if (from.has_outdiscards()) {
      set_outdiscards(from.outdiscards());
    }
    if (from.has_outnoroutes()) {
      set_outnoroutes(from.outnoroutes());
    }
    if (from.has_reasmtimeout()) {
      set_reasmtimeout(from.reasmtimeout());
    }
    if (from.has_reasmreqds()) {
      set_reasmreqds(from.reasmreqds());
    }
    if (from.has_reasmoks()) {
      set_reasmoks(from.reasmoks());
    }
    if (from.has_reasmfails()) {
      set_reasmfails(from.reasmfails());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_fragoks()) {
      set_fragoks(from.fragoks());
    }
    if (from.has_fragfails()) {
      set_fragfails(from.fragfails());
    }
    if (from.has_fragcreates()) {
      set_fragcreates(from.fragcreates());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IpStatistics::CopyFrom(const IpStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpStatistics::IsInitialized() const {

  return true;
}

void IpStatistics::Swap(IpStatistics* other) {
  if (other != this) {
    std::swap(forwarding_, other->forwarding_);
    std::swap(defaultttl_, other->defaultttl_);
    std::swap(inreceives_, other->inreceives_);
    std::swap(inhdrerrors_, other->inhdrerrors_);
    std::swap(inaddrerrors_, other->inaddrerrors_);
    std::swap(forwdatagrams_, other->forwdatagrams_);
    std::swap(inunknownprotos_, other->inunknownprotos_);
    std::swap(indiscards_, other->indiscards_);
    std::swap(indelivers_, other->indelivers_);
    std::swap(outrequests_, other->outrequests_);
    std::swap(outdiscards_, other->outdiscards_);
    std::swap(outnoroutes_, other->outnoroutes_);
    std::swap(reasmtimeout_, other->reasmtimeout_);
    std::swap(reasmreqds_, other->reasmreqds_);
    std::swap(reasmoks_, other->reasmoks_);
    std::swap(reasmfails_, other->reasmfails_);
    std::swap(fragoks_, other->fragoks_);
    std::swap(fragfails_, other->fragfails_);
    std::swap(fragcreates_, other->fragcreates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IpStatistics_descriptor_;
  metadata.reflection = IpStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IcmpStatistics::kInMsgsFieldNumber;
const int IcmpStatistics::kInErrorsFieldNumber;
const int IcmpStatistics::kInCsumErrorsFieldNumber;
const int IcmpStatistics::kInDestUnreachsFieldNumber;
const int IcmpStatistics::kInTimeExcdsFieldNumber;
const int IcmpStatistics::kInParmProbsFieldNumber;
const int IcmpStatistics::kInSrcQuenchsFieldNumber;
const int IcmpStatistics::kInRedirectsFieldNumber;
const int IcmpStatistics::kInEchosFieldNumber;
const int IcmpStatistics::kInEchoRepsFieldNumber;
const int IcmpStatistics::kInTimestampsFieldNumber;
const int IcmpStatistics::kInTimestampRepsFieldNumber;
const int IcmpStatistics::kInAddrMasksFieldNumber;
const int IcmpStatistics::kInAddrMaskRepsFieldNumber;
const int IcmpStatistics::kOutMsgsFieldNumber;
const int IcmpStatistics::kOutErrorsFieldNumber;
const int IcmpStatistics::kOutDestUnreachsFieldNumber;
const int IcmpStatistics::kOutTimeExcdsFieldNumber;
const int IcmpStatistics::kOutParmProbsFieldNumber;
const int IcmpStatistics::kOutSrcQuenchsFieldNumber;
const int IcmpStatistics::kOutRedirectsFieldNumber;
const int IcmpStatistics::kOutEchosFieldNumber;
const int IcmpStatistics::kOutEchoRepsFieldNumber;
const int IcmpStatistics::kOutTimestampsFieldNumber;
const int IcmpStatistics::kOutTimestampRepsFieldNumber;
const int IcmpStatistics::kOutAddrMasksFieldNumber;
const int IcmpStatistics::kOutAddrMaskRepsFieldNumber;
#endif  // !_MSC_VER

IcmpStatistics::IcmpStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.IcmpStatistics)
}

void IcmpStatistics::InitAsDefaultInstance() {
}

IcmpStatistics::IcmpStatistics(const IcmpStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.IcmpStatistics)
}

void IcmpStatistics::SharedCtor() {
  _cached_size_ = 0;
  inmsgs_ = GOOGLE_LONGLONG(0);
  inerrors_ = GOOGLE_LONGLONG(0);
  incsumerrors_ = GOOGLE_LONGLONG(0);
  indestunreachs_ = GOOGLE_LONGLONG(0);
  intimeexcds_ = GOOGLE_LONGLONG(0);
  inparmprobs_ = GOOGLE_LONGLONG(0);
  insrcquenchs_ = GOOGLE_LONGLONG(0);
  inredirects_ = GOOGLE_LONGLONG(0);
  inechos_ = GOOGLE_LONGLONG(0);
  inechoreps_ = GOOGLE_LONGLONG(0);
  intimestamps_ = GOOGLE_LONGLONG(0);
  intimestampreps_ = GOOGLE_LONGLONG(0);
  inaddrmasks_ = GOOGLE_LONGLONG(0);
  inaddrmaskreps_ = GOOGLE_LONGLONG(0);
  outmsgs_ = GOOGLE_LONGLONG(0);
  outerrors_ = GOOGLE_LONGLONG(0);
  outdestunreachs_ = GOOGLE_LONGLONG(0);
  outtimeexcds_ = GOOGLE_LONGLONG(0);
  outparmprobs_ = GOOGLE_LONGLONG(0);
  outsrcquenchs_ = GOOGLE_LONGLONG(0);
  outredirects_ = GOOGLE_LONGLONG(0);
  outechos_ = GOOGLE_LONGLONG(0);
  outechoreps_ = GOOGLE_LONGLONG(0);
  outtimestamps_ = GOOGLE_LONGLONG(0);
  outtimestampreps_ = GOOGLE_LONGLONG(0);
  outaddrmasks_ = GOOGLE_LONGLONG(0);
  outaddrmaskreps_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IcmpStatistics::~IcmpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.IcmpStatistics)
  SharedDtor();
}

void IcmpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IcmpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IcmpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IcmpStatistics_descriptor_;
}

const IcmpStatistics& IcmpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

IcmpStatistics* IcmpStatistics::default_instance_ = NULL;

IcmpStatistics* IcmpStatistics::New() const {
  return new IcmpStatistics;
}

void IcmpStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IcmpStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(inmsgs_, inredirects_);
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(inechos_, outerrors_);
  }
  if (_has_bits_[16 / 32] & 16711680) {
    ZR_(outdestunreachs_, outtimestamps_);
  }
  ZR_(outtimestampreps_, outaddrmaskreps_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IcmpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.IcmpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 InMsgs = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inmsgs_)));
          set_has_inmsgs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_InErrors;
        break;
      }

      // optional int64 InErrors = 2;
      case 2: {
        if (tag == 16) {
         parse_InErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inerrors_)));
          set_has_inerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_InCsumErrors;
        break;
      }

      // optional int64 InCsumErrors = 3;
      case 3: {
        if (tag == 24) {
         parse_InCsumErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &incsumerrors_)));
          set_has_incsumerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_InDestUnreachs;
        break;
      }

      // optional int64 InDestUnreachs = 4;
      case 4: {
        if (tag == 32) {
         parse_InDestUnreachs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indestunreachs_)));
          set_has_indestunreachs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_InTimeExcds;
        break;
      }

      // optional int64 InTimeExcds = 5;
      case 5: {
        if (tag == 40) {
         parse_InTimeExcds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &intimeexcds_)));
          set_has_intimeexcds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_InParmProbs;
        break;
      }

      // optional int64 InParmProbs = 6;
      case 6: {
        if (tag == 48) {
         parse_InParmProbs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inparmprobs_)));
          set_has_inparmprobs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_InSrcQuenchs;
        break;
      }

      // optional int64 InSrcQuenchs = 7;
      case 7: {
        if (tag == 56) {
         parse_InSrcQuenchs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &insrcquenchs_)));
          set_has_insrcquenchs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_InRedirects;
        break;
      }

      // optional int64 InRedirects = 8;
      case 8: {
        if (tag == 64) {
         parse_InRedirects:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inredirects_)));
          set_has_inredirects();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_InEchos;
        break;
      }

      // optional int64 InEchos = 9;
      case 9: {
        if (tag == 72) {
         parse_InEchos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inechos_)));
          set_has_inechos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_InEchoReps;
        break;
      }

      // optional int64 InEchoReps = 10;
      case 10: {
        if (tag == 80) {
         parse_InEchoReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inechoreps_)));
          set_has_inechoreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_InTimestamps;
        break;
      }

      // optional int64 InTimestamps = 11;
      case 11: {
        if (tag == 88) {
         parse_InTimestamps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &intimestamps_)));
          set_has_intimestamps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_InTimestampReps;
        break;
      }

      // optional int64 InTimestampReps = 12;
      case 12: {
        if (tag == 96) {
         parse_InTimestampReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &intimestampreps_)));
          set_has_intimestampreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_InAddrMasks;
        break;
      }

      // optional int64 InAddrMasks = 13;
      case 13: {
        if (tag == 104) {
         parse_InAddrMasks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inaddrmasks_)));
          set_has_inaddrmasks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_InAddrMaskReps;
        break;
      }

      // optional int64 InAddrMaskReps = 14;
      case 14: {
        if (tag == 112) {
         parse_InAddrMaskReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inaddrmaskreps_)));
          set_has_inaddrmaskreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_OutMsgs;
        break;
      }

      // optional int64 OutMsgs = 15;
      case 15: {
        if (tag == 120) {
         parse_OutMsgs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outmsgs_)));
          set_has_outmsgs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_OutErrors;
        break;
      }

      // optional int64 OutErrors = 16;
      case 16: {
        if (tag == 128) {
         parse_OutErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outerrors_)));
          set_has_outerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_OutDestUnreachs;
        break;
      }

      // optional int64 OutDestUnreachs = 17;
      case 17: {
        if (tag == 136) {
         parse_OutDestUnreachs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outdestunreachs_)));
          set_has_outdestunreachs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_OutTimeExcds;
        break;
      }

      // optional int64 OutTimeExcds = 18;
      case 18: {
        if (tag == 144) {
         parse_OutTimeExcds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outtimeexcds_)));
          set_has_outtimeexcds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_OutParmProbs;
        break;
      }

      // optional int64 OutParmProbs = 19;
      case 19: {
        if (tag == 152) {
         parse_OutParmProbs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outparmprobs_)));
          set_has_outparmprobs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_OutSrcQuenchs;
        break;
      }

      // optional int64 OutSrcQuenchs = 20;
      case 20: {
        if (tag == 160) {
         parse_OutSrcQuenchs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outsrcquenchs_)));
          set_has_outsrcquenchs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_OutRedirects;
        break;
      }

      // optional int64 OutRedirects = 21;
      case 21: {
        if (tag == 168) {
         parse_OutRedirects:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outredirects_)));
          set_has_outredirects();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_OutEchos;
        break;
      }

      // optional int64 OutEchos = 22;
      case 22: {
        if (tag == 176) {
         parse_OutEchos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outechos_)));
          set_has_outechos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_OutEchoReps;
        break;
      }

      // optional int64 OutEchoReps = 23;
      case 23: {
        if (tag == 184) {
         parse_OutEchoReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outechoreps_)));
          set_has_outechoreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_OutTimestamps;
        break;
      }

      // optional int64 OutTimestamps = 24;
      case 24: {
        if (tag == 192) {
         parse_OutTimestamps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outtimestamps_)));
          set_has_outtimestamps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_OutTimestampReps;
        break;
      }

      // optional int64 OutTimestampReps = 25;
      case 25: {
        if (tag == 200) {
         parse_OutTimestampReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outtimestampreps_)));
          set_has_outtimestampreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_OutAddrMasks;
        break;
      }

      // optional int64 OutAddrMasks = 26;
      case 26: {
        if (tag == 208) {
         parse_OutAddrMasks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outaddrmasks_)));
          set_has_outaddrmasks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_OutAddrMaskReps;
        break;
      }

      // optional int64 OutAddrMaskReps = 27;
      case 27: {
        if (tag == 216) {
         parse_OutAddrMaskReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outaddrmaskreps_)));
          set_has_outaddrmaskreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.IcmpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.IcmpStatistics)
  return false;
#undef DO_
}

void IcmpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.IcmpStatistics)
  // optional int64 InMsgs = 1;
  if (has_inmsgs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->inmsgs(), output);
  }

  // optional int64 InErrors = 2;
  if (has_inerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->inerrors(), output);
  }

  // optional int64 InCsumErrors = 3;
  if (has_incsumerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->incsumerrors(), output);
  }

  // optional int64 InDestUnreachs = 4;
  if (has_indestunreachs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->indestunreachs(), output);
  }

  // optional int64 InTimeExcds = 5;
  if (has_intimeexcds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->intimeexcds(), output);
  }

  // optional int64 InParmProbs = 6;
  if (has_inparmprobs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->inparmprobs(), output);
  }

  // optional int64 InSrcQuenchs = 7;
  if (has_insrcquenchs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->insrcquenchs(), output);
  }

  // optional int64 InRedirects = 8;
  if (has_inredirects()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->inredirects(), output);
  }

  // optional int64 InEchos = 9;
  if (has_inechos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->inechos(), output);
  }

  // optional int64 InEchoReps = 10;
  if (has_inechoreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->inechoreps(), output);
  }

  // optional int64 InTimestamps = 11;
  if (has_intimestamps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->intimestamps(), output);
  }

  // optional int64 InTimestampReps = 12;
  if (has_intimestampreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->intimestampreps(), output);
  }

  // optional int64 InAddrMasks = 13;
  if (has_inaddrmasks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->inaddrmasks(), output);
  }

  // optional int64 InAddrMaskReps = 14;
  if (has_inaddrmaskreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->inaddrmaskreps(), output);
  }

  // optional int64 OutMsgs = 15;
  if (has_outmsgs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(15, this->outmsgs(), output);
  }

  // optional int64 OutErrors = 16;
  if (has_outerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(16, this->outerrors(), output);
  }

  // optional int64 OutDestUnreachs = 17;
  if (has_outdestunreachs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(17, this->outdestunreachs(), output);
  }

  // optional int64 OutTimeExcds = 18;
  if (has_outtimeexcds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->outtimeexcds(), output);
  }

  // optional int64 OutParmProbs = 19;
  if (has_outparmprobs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(19, this->outparmprobs(), output);
  }

  // optional int64 OutSrcQuenchs = 20;
  if (has_outsrcquenchs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(20, this->outsrcquenchs(), output);
  }

  // optional int64 OutRedirects = 21;
  if (has_outredirects()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(21, this->outredirects(), output);
  }

  // optional int64 OutEchos = 22;
  if (has_outechos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(22, this->outechos(), output);
  }

  // optional int64 OutEchoReps = 23;
  if (has_outechoreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(23, this->outechoreps(), output);
  }

  // optional int64 OutTimestamps = 24;
  if (has_outtimestamps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(24, this->outtimestamps(), output);
  }

  // optional int64 OutTimestampReps = 25;
  if (has_outtimestampreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(25, this->outtimestampreps(), output);
  }

  // optional int64 OutAddrMasks = 26;
  if (has_outaddrmasks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(26, this->outaddrmasks(), output);
  }

  // optional int64 OutAddrMaskReps = 27;
  if (has_outaddrmaskreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(27, this->outaddrmaskreps(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.IcmpStatistics)
}

::google::protobuf::uint8* IcmpStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.IcmpStatistics)
  // optional int64 InMsgs = 1;
  if (has_inmsgs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->inmsgs(), target);
  }

  // optional int64 InErrors = 2;
  if (has_inerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->inerrors(), target);
  }

  // optional int64 InCsumErrors = 3;
  if (has_incsumerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->incsumerrors(), target);
  }

  // optional int64 InDestUnreachs = 4;
  if (has_indestunreachs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->indestunreachs(), target);
  }

  // optional int64 InTimeExcds = 5;
  if (has_intimeexcds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->intimeexcds(), target);
  }

  // optional int64 InParmProbs = 6;
  if (has_inparmprobs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->inparmprobs(), target);
  }

  // optional int64 InSrcQuenchs = 7;
  if (has_insrcquenchs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->insrcquenchs(), target);
  }

  // optional int64 InRedirects = 8;
  if (has_inredirects()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->inredirects(), target);
  }

  // optional int64 InEchos = 9;
  if (has_inechos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->inechos(), target);
  }

  // optional int64 InEchoReps = 10;
  if (has_inechoreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->inechoreps(), target);
  }

  // optional int64 InTimestamps = 11;
  if (has_intimestamps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->intimestamps(), target);
  }

  // optional int64 InTimestampReps = 12;
  if (has_intimestampreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(12, this->intimestampreps(), target);
  }

  // optional int64 InAddrMasks = 13;
  if (has_inaddrmasks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->inaddrmasks(), target);
  }

  // optional int64 InAddrMaskReps = 14;
  if (has_inaddrmaskreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->inaddrmaskreps(), target);
  }

  // optional int64 OutMsgs = 15;
  if (has_outmsgs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(15, this->outmsgs(), target);
  }

  // optional int64 OutErrors = 16;
  if (has_outerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(16, this->outerrors(), target);
  }

  // optional int64 OutDestUnreachs = 17;
  if (has_outdestunreachs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(17, this->outdestunreachs(), target);
  }

  // optional int64 OutTimeExcds = 18;
  if (has_outtimeexcds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(18, this->outtimeexcds(), target);
  }

  // optional int64 OutParmProbs = 19;
  if (has_outparmprobs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(19, this->outparmprobs(), target);
  }

  // optional int64 OutSrcQuenchs = 20;
  if (has_outsrcquenchs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(20, this->outsrcquenchs(), target);
  }

  // optional int64 OutRedirects = 21;
  if (has_outredirects()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(21, this->outredirects(), target);
  }

  // optional int64 OutEchos = 22;
  if (has_outechos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(22, this->outechos(), target);
  }

  // optional int64 OutEchoReps = 23;
  if (has_outechoreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(23, this->outechoreps(), target);
  }

  // optional int64 OutTimestamps = 24;
  if (has_outtimestamps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(24, this->outtimestamps(), target);
  }

  // optional int64 OutTimestampReps = 25;
  if (has_outtimestampreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(25, this->outtimestampreps(), target);
  }

  // optional int64 OutAddrMasks = 26;
  if (has_outaddrmasks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(26, this->outaddrmasks(), target);
  }

  // optional int64 OutAddrMaskReps = 27;
  if (has_outaddrmaskreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(27, this->outaddrmaskreps(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.IcmpStatistics)
  return target;
}

int IcmpStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 InMsgs = 1;
    if (has_inmsgs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inmsgs());
    }

    // optional int64 InErrors = 2;
    if (has_inerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inerrors());
    }

    // optional int64 InCsumErrors = 3;
    if (has_incsumerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->incsumerrors());
    }

    // optional int64 InDestUnreachs = 4;
    if (has_indestunreachs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indestunreachs());
    }

    // optional int64 InTimeExcds = 5;
    if (has_intimeexcds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->intimeexcds());
    }

    // optional int64 InParmProbs = 6;
    if (has_inparmprobs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inparmprobs());
    }

    // optional int64 InSrcQuenchs = 7;
    if (has_insrcquenchs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->insrcquenchs());
    }

    // optional int64 InRedirects = 8;
    if (has_inredirects()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inredirects());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 InEchos = 9;
    if (has_inechos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inechos());
    }

    // optional int64 InEchoReps = 10;
    if (has_inechoreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inechoreps());
    }

    // optional int64 InTimestamps = 11;
    if (has_intimestamps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->intimestamps());
    }

    // optional int64 InTimestampReps = 12;
    if (has_intimestampreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->intimestampreps());
    }

    // optional int64 InAddrMasks = 13;
    if (has_inaddrmasks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inaddrmasks());
    }

    // optional int64 InAddrMaskReps = 14;
    if (has_inaddrmaskreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inaddrmaskreps());
    }

    // optional int64 OutMsgs = 15;
    if (has_outmsgs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outmsgs());
    }

    // optional int64 OutErrors = 16;
    if (has_outerrors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outerrors());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int64 OutDestUnreachs = 17;
    if (has_outdestunreachs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outdestunreachs());
    }

    // optional int64 OutTimeExcds = 18;
    if (has_outtimeexcds()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outtimeexcds());
    }

    // optional int64 OutParmProbs = 19;
    if (has_outparmprobs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outparmprobs());
    }

    // optional int64 OutSrcQuenchs = 20;
    if (has_outsrcquenchs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outsrcquenchs());
    }

    // optional int64 OutRedirects = 21;
    if (has_outredirects()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outredirects());
    }

    // optional int64 OutEchos = 22;
    if (has_outechos()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outechos());
    }

    // optional int64 OutEchoReps = 23;
    if (has_outechoreps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outechoreps());
    }

    // optional int64 OutTimestamps = 24;
    if (has_outtimestamps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outtimestamps());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional int64 OutTimestampReps = 25;
    if (has_outtimestampreps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outtimestampreps());
    }

    // optional int64 OutAddrMasks = 26;
    if (has_outaddrmasks()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outaddrmasks());
    }

    // optional int64 OutAddrMaskReps = 27;
    if (has_outaddrmaskreps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outaddrmaskreps());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IcmpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IcmpStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IcmpStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IcmpStatistics::MergeFrom(const IcmpStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_inmsgs()) {
      set_inmsgs(from.inmsgs());
    }
    if (from.has_inerrors()) {
      set_inerrors(from.inerrors());
    }
    if (from.has_incsumerrors()) {
      set_incsumerrors(from.incsumerrors());
    }
    if (from.has_indestunreachs()) {
      set_indestunreachs(from.indestunreachs());
    }
    if (from.has_intimeexcds()) {
      set_intimeexcds(from.intimeexcds());
    }
    if (from.has_inparmprobs()) {
      set_inparmprobs(from.inparmprobs());
    }
    if (from.has_insrcquenchs()) {
      set_insrcquenchs(from.insrcquenchs());
    }
    if (from.has_inredirects()) {
      set_inredirects(from.inredirects());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_inechos()) {
      set_inechos(from.inechos());
    }
    if (from.has_inechoreps()) {
      set_inechoreps(from.inechoreps());
    }
    if (from.has_intimestamps()) {
      set_intimestamps(from.intimestamps());
    }
    if (from.has_intimestampreps()) {
      set_intimestampreps(from.intimestampreps());
    }
    if (from.has_inaddrmasks()) {
      set_inaddrmasks(from.inaddrmasks());
    }
    if (from.has_inaddrmaskreps()) {
      set_inaddrmaskreps(from.inaddrmaskreps());
    }
    if (from.has_outmsgs()) {
      set_outmsgs(from.outmsgs());
    }
    if (from.has_outerrors()) {
      set_outerrors(from.outerrors());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_outdestunreachs()) {
      set_outdestunreachs(from.outdestunreachs());
    }
    if (from.has_outtimeexcds()) {
      set_outtimeexcds(from.outtimeexcds());
    }
    if (from.has_outparmprobs()) {
      set_outparmprobs(from.outparmprobs());
    }
    if (from.has_outsrcquenchs()) {
      set_outsrcquenchs(from.outsrcquenchs());
    }
    if (from.has_outredirects()) {
      set_outredirects(from.outredirects());
    }
    if (from.has_outechos()) {
      set_outechos(from.outechos());
    }
    if (from.has_outechoreps()) {
      set_outechoreps(from.outechoreps());
    }
    if (from.has_outtimestamps()) {
      set_outtimestamps(from.outtimestamps());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_outtimestampreps()) {
      set_outtimestampreps(from.outtimestampreps());
    }
    if (from.has_outaddrmasks()) {
      set_outaddrmasks(from.outaddrmasks());
    }
    if (from.has_outaddrmaskreps()) {
      set_outaddrmaskreps(from.outaddrmaskreps());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IcmpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IcmpStatistics::CopyFrom(const IcmpStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IcmpStatistics::IsInitialized() const {

  return true;
}

void IcmpStatistics::Swap(IcmpStatistics* other) {
  if (other != this) {
    std::swap(inmsgs_, other->inmsgs_);
    std::swap(inerrors_, other->inerrors_);
    std::swap(incsumerrors_, other->incsumerrors_);
    std::swap(indestunreachs_, other->indestunreachs_);
    std::swap(intimeexcds_, other->intimeexcds_);
    std::swap(inparmprobs_, other->inparmprobs_);
    std::swap(insrcquenchs_, other->insrcquenchs_);
    std::swap(inredirects_, other->inredirects_);
    std::swap(inechos_, other->inechos_);
    std::swap(inechoreps_, other->inechoreps_);
    std::swap(intimestamps_, other->intimestamps_);
    std::swap(intimestampreps_, other->intimestampreps_);
    std::swap(inaddrmasks_, other->inaddrmasks_);
    std::swap(inaddrmaskreps_, other->inaddrmaskreps_);
    std::swap(outmsgs_, other->outmsgs_);
    std::swap(outerrors_, other->outerrors_);
    std::swap(outdestunreachs_, other->outdestunreachs_);
    std::swap(outtimeexcds_, other->outtimeexcds_);
    std::swap(outparmprobs_, other->outparmprobs_);
    std::swap(outsrcquenchs_, other->outsrcquenchs_);
    std::swap(outredirects_, other->outredirects_);
    std::swap(outechos_, other->outechos_);
    std::swap(outechoreps_, other->outechoreps_);
    std::swap(outtimestamps_, other->outtimestamps_);
    std::swap(outtimestampreps_, other->outtimestampreps_);
    std::swap(outaddrmasks_, other->outaddrmasks_);
    std::swap(outaddrmaskreps_, other->outaddrmaskreps_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IcmpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IcmpStatistics_descriptor_;
  metadata.reflection = IcmpStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TcpStatistics::kRtoAlgorithmFieldNumber;
const int TcpStatistics::kRtoMinFieldNumber;
const int TcpStatistics::kRtoMaxFieldNumber;
const int TcpStatistics::kMaxConnFieldNumber;
const int TcpStatistics::kActiveOpensFieldNumber;
const int TcpStatistics::kPassiveOpensFieldNumber;
const int TcpStatistics::kAttemptFailsFieldNumber;
const int TcpStatistics::kEstabResetsFieldNumber;
const int TcpStatistics::kCurrEstabFieldNumber;
const int TcpStatistics::kInSegsFieldNumber;
const int TcpStatistics::kOutSegsFieldNumber;
const int TcpStatistics::kRetransSegsFieldNumber;
const int TcpStatistics::kInErrsFieldNumber;
const int TcpStatistics::kOutRstsFieldNumber;
const int TcpStatistics::kInCsumErrorsFieldNumber;
#endif  // !_MSC_VER

TcpStatistics::TcpStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TcpStatistics)
}

void TcpStatistics::InitAsDefaultInstance() {
}

TcpStatistics::TcpStatistics(const TcpStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TcpStatistics)
}

void TcpStatistics::SharedCtor() {
  _cached_size_ = 0;
  rtoalgorithm_ = GOOGLE_LONGLONG(0);
  rtomin_ = GOOGLE_LONGLONG(0);
  rtomax_ = GOOGLE_LONGLONG(0);
  maxconn_ = GOOGLE_LONGLONG(0);
  activeopens_ = GOOGLE_LONGLONG(0);
  passiveopens_ = GOOGLE_LONGLONG(0);
  attemptfails_ = GOOGLE_LONGLONG(0);
  estabresets_ = GOOGLE_LONGLONG(0);
  currestab_ = GOOGLE_LONGLONG(0);
  insegs_ = GOOGLE_LONGLONG(0);
  outsegs_ = GOOGLE_LONGLONG(0);
  retranssegs_ = GOOGLE_LONGLONG(0);
  inerrs_ = GOOGLE_LONGLONG(0);
  outrsts_ = GOOGLE_LONGLONG(0);
  incsumerrors_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpStatistics::~TcpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.TcpStatistics)
  SharedDtor();
}

void TcpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TcpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TcpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TcpStatistics_descriptor_;
}

const TcpStatistics& TcpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TcpStatistics* TcpStatistics::default_instance_ = NULL;

TcpStatistics* TcpStatistics::New() const {
  return new TcpStatistics;
}

void TcpStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TcpStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(rtoalgorithm_, estabresets_);
  }
  if (_has_bits_[8 / 32] & 32512) {
    ZR_(currestab_, incsumerrors_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TcpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TcpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 RtoAlgorithm = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rtoalgorithm_)));
          set_has_rtoalgorithm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RtoMin;
        break;
      }

      // optional int64 RtoMin = 2;
      case 2: {
        if (tag == 16) {
         parse_RtoMin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rtomin_)));
          set_has_rtomin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RtoMax;
        break;
      }

      // optional int64 RtoMax = 3;
      case 3: {
        if (tag == 24) {
         parse_RtoMax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rtomax_)));
          set_has_rtomax();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_MaxConn;
        break;
      }

      // optional int64 MaxConn = 4;
      case 4: {
        if (tag == 32) {
         parse_MaxConn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxconn_)));
          set_has_maxconn();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ActiveOpens;
        break;
      }

      // optional int64 ActiveOpens = 5;
      case 5: {
        if (tag == 40) {
         parse_ActiveOpens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &activeopens_)));
          set_has_activeopens();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_PassiveOpens;
        break;
      }

      // optional int64 PassiveOpens = 6;
      case 6: {
        if (tag == 48) {
         parse_PassiveOpens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &passiveopens_)));
          set_has_passiveopens();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_AttemptFails;
        break;
      }

      // optional int64 AttemptFails = 7;
      case 7: {
        if (tag == 56) {
         parse_AttemptFails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &attemptfails_)));
          set_has_attemptfails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_EstabResets;
        break;
      }

      // optional int64 EstabResets = 8;
      case 8: {
        if (tag == 64) {
         parse_EstabResets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &estabresets_)));
          set_has_estabresets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_CurrEstab;
        break;
      }

      // optional int64 CurrEstab = 9;
      case 9: {
        if (tag == 72) {
         parse_CurrEstab:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &currestab_)));
          set_has_currestab();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_InSegs;
        break;
      }

      // optional int64 InSegs = 10;
      case 10: {
        if (tag == 80) {
         parse_InSegs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &insegs_)));
          set_has_insegs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_OutSegs;
        break;
      }

      // optional int64 OutSegs = 11;
      case 11: {
        if (tag == 88) {
         parse_OutSegs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outsegs_)));
          set_has_outsegs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_RetransSegs;
        break;
      }

      // optional int64 RetransSegs = 12;
      case 12: {
        if (tag == 96) {
         parse_RetransSegs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &retranssegs_)));
          set_has_retranssegs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_InErrs;
        break;
      }

      // optional int64 InErrs = 13;
      case 13: {
        if (tag == 104) {
         parse_InErrs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inerrs_)));
          set_has_inerrs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_OutRsts;
        break;
      }

      // optional int64 OutRsts = 14;
      case 14: {
        if (tag == 112) {
         parse_OutRsts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outrsts_)));
          set_has_outrsts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_InCsumErrors;
        break;
      }

      // optional int64 InCsumErrors = 15;
      case 15: {
        if (tag == 120) {
         parse_InCsumErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &incsumerrors_)));
          set_has_incsumerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TcpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TcpStatistics)
  return false;
#undef DO_
}

void TcpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TcpStatistics)
  // optional int64 RtoAlgorithm = 1;
  if (has_rtoalgorithm()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->rtoalgorithm(), output);
  }

  // optional int64 RtoMin = 2;
  if (has_rtomin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->rtomin(), output);
  }

  // optional int64 RtoMax = 3;
  if (has_rtomax()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->rtomax(), output);
  }

  // optional int64 MaxConn = 4;
  if (has_maxconn()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->maxconn(), output);
  }

  // optional int64 ActiveOpens = 5;
  if (has_activeopens()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->activeopens(), output);
  }

  // optional int64 PassiveOpens = 6;
  if (has_passiveopens()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->passiveopens(), output);
  }

  // optional int64 AttemptFails = 7;
  if (has_attemptfails()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->attemptfails(), output);
  }

  // optional int64 EstabResets = 8;
  if (has_estabresets()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->estabresets(), output);
  }

  // optional int64 CurrEstab = 9;
  if (has_currestab()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->currestab(), output);
  }

  // optional int64 InSegs = 10;
  if (has_insegs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->insegs(), output);
  }

  // optional int64 OutSegs = 11;
  if (has_outsegs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->outsegs(), output);
  }

  // optional int64 RetransSegs = 12;
  if (has_retranssegs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->retranssegs(), output);
  }

  // optional int64 InErrs = 13;
  if (has_inerrs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->inerrs(), output);
  }

  // optional int64 OutRsts = 14;
  if (has_outrsts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->outrsts(), output);
  }

  // optional int64 InCsumErrors = 15;
  if (has_incsumerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(15, this->incsumerrors(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TcpStatistics)
}

::google::protobuf::uint8* TcpStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TcpStatistics)
  // optional int64 RtoAlgorithm = 1;
  if (has_rtoalgorithm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->rtoalgorithm(), target);
  }

  // optional int64 RtoMin = 2;
  if (has_rtomin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->rtomin(), target);
  }

  // optional int64 RtoMax = 3;
  if (has_rtomax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->rtomax(), target);
  }

  // optional int64 MaxConn = 4;
  if (has_maxconn()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->maxconn(), target);
  }

  // optional int64 ActiveOpens = 5;
  if (has_activeopens()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->activeopens(), target);
  }

  // optional int64 PassiveOpens = 6;
  if (has_passiveopens()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->passiveopens(), target);
  }

  // optional int64 AttemptFails = 7;
  if (has_attemptfails()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->attemptfails(), target);
  }

  // optional int64 EstabResets = 8;
  if (has_estabresets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->estabresets(), target);
  }

  // optional int64 CurrEstab = 9;
  if (has_currestab()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->currestab(), target);
  }

  // optional int64 InSegs = 10;
  if (has_insegs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->insegs(), target);
  }

  // optional int64 OutSegs = 11;
  if (has_outsegs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->outsegs(), target);
  }

  // optional int64 RetransSegs = 12;
  if (has_retranssegs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(12, this->retranssegs(), target);
  }

  // optional int64 InErrs = 13;
  if (has_inerrs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->inerrs(), target);
  }

  // optional int64 OutRsts = 14;
  if (has_outrsts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->outrsts(), target);
  }

  // optional int64 InCsumErrors = 15;
  if (has_incsumerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(15, this->incsumerrors(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TcpStatistics)
  return target;
}

int TcpStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 RtoAlgorithm = 1;
    if (has_rtoalgorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rtoalgorithm());
    }

    // optional int64 RtoMin = 2;
    if (has_rtomin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rtomin());
    }

    // optional int64 RtoMax = 3;
    if (has_rtomax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rtomax());
    }

    // optional int64 MaxConn = 4;
    if (has_maxconn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->maxconn());
    }

    // optional int64 ActiveOpens = 5;
    if (has_activeopens()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->activeopens());
    }

    // optional int64 PassiveOpens = 6;
    if (has_passiveopens()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->passiveopens());
    }

    // optional int64 AttemptFails = 7;
    if (has_attemptfails()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->attemptfails());
    }

    // optional int64 EstabResets = 8;
    if (has_estabresets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->estabresets());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 CurrEstab = 9;
    if (has_currestab()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->currestab());
    }

    // optional int64 InSegs = 10;
    if (has_insegs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->insegs());
    }

    // optional int64 OutSegs = 11;
    if (has_outsegs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outsegs());
    }

    // optional int64 RetransSegs = 12;
    if (has_retranssegs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->retranssegs());
    }

    // optional int64 InErrs = 13;
    if (has_inerrs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inerrs());
    }

    // optional int64 OutRsts = 14;
    if (has_outrsts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outrsts());
    }

    // optional int64 InCsumErrors = 15;
    if (has_incsumerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->incsumerrors());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TcpStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TcpStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TcpStatistics::MergeFrom(const TcpStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rtoalgorithm()) {
      set_rtoalgorithm(from.rtoalgorithm());
    }
    if (from.has_rtomin()) {
      set_rtomin(from.rtomin());
    }
    if (from.has_rtomax()) {
      set_rtomax(from.rtomax());
    }
    if (from.has_maxconn()) {
      set_maxconn(from.maxconn());
    }
    if (from.has_activeopens()) {
      set_activeopens(from.activeopens());
    }
    if (from.has_passiveopens()) {
      set_passiveopens(from.passiveopens());
    }
    if (from.has_attemptfails()) {
      set_attemptfails(from.attemptfails());
    }
    if (from.has_estabresets()) {
      set_estabresets(from.estabresets());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_currestab()) {
      set_currestab(from.currestab());
    }
    if (from.has_insegs()) {
      set_insegs(from.insegs());
    }
    if (from.has_outsegs()) {
      set_outsegs(from.outsegs());
    }
    if (from.has_retranssegs()) {
      set_retranssegs(from.retranssegs());
    }
    if (from.has_inerrs()) {
      set_inerrs(from.inerrs());
    }
    if (from.has_outrsts()) {
      set_outrsts(from.outrsts());
    }
    if (from.has_incsumerrors()) {
      set_incsumerrors(from.incsumerrors());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TcpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TcpStatistics::CopyFrom(const TcpStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpStatistics::IsInitialized() const {

  return true;
}

void TcpStatistics::Swap(TcpStatistics* other) {
  if (other != this) {
    std::swap(rtoalgorithm_, other->rtoalgorithm_);
    std::swap(rtomin_, other->rtomin_);
    std::swap(rtomax_, other->rtomax_);
    std::swap(maxconn_, other->maxconn_);
    std::swap(activeopens_, other->activeopens_);
    std::swap(passiveopens_, other->passiveopens_);
    std::swap(attemptfails_, other->attemptfails_);
    std::swap(estabresets_, other->estabresets_);
    std::swap(currestab_, other->currestab_);
    std::swap(insegs_, other->insegs_);
    std::swap(outsegs_, other->outsegs_);
    std::swap(retranssegs_, other->retranssegs_);
    std::swap(inerrs_, other->inerrs_);
    std::swap(outrsts_, other->outrsts_);
    std::swap(incsumerrors_, other->incsumerrors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TcpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TcpStatistics_descriptor_;
  metadata.reflection = TcpStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UdpStatistics::kInDatagramsFieldNumber;
const int UdpStatistics::kNoPortsFieldNumber;
const int UdpStatistics::kInErrorsFieldNumber;
const int UdpStatistics::kOutDatagramsFieldNumber;
const int UdpStatistics::kRcvbufErrorsFieldNumber;
const int UdpStatistics::kSndbufErrorsFieldNumber;
const int UdpStatistics::kInCsumErrorsFieldNumber;
const int UdpStatistics::kIgnoredMultiFieldNumber;
#endif  // !_MSC_VER

UdpStatistics::UdpStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.UdpStatistics)
}

void UdpStatistics::InitAsDefaultInstance() {
}

UdpStatistics::UdpStatistics(const UdpStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.UdpStatistics)
}

void UdpStatistics::SharedCtor() {
  _cached_size_ = 0;
  indatagrams_ = GOOGLE_LONGLONG(0);
  noports_ = GOOGLE_LONGLONG(0);
  inerrors_ = GOOGLE_LONGLONG(0);
  outdatagrams_ = GOOGLE_LONGLONG(0);
  rcvbuferrors_ = GOOGLE_LONGLONG(0);
  sndbuferrors_ = GOOGLE_LONGLONG(0);
  incsumerrors_ = GOOGLE_LONGLONG(0);
  ignoredmulti_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UdpStatistics::~UdpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.UdpStatistics)
  SharedDtor();
}

void UdpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UdpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UdpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UdpStatistics_descriptor_;
}

const UdpStatistics& UdpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

UdpStatistics* UdpStatistics::default_instance_ = NULL;

UdpStatistics* UdpStatistics::New() const {
  return new UdpStatistics;
}

void UdpStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UdpStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(indatagrams_, ignoredmulti_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UdpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.UdpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 InDatagrams = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indatagrams_)));
          set_has_indatagrams();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_NoPorts;
        break;
      }

      // optional int64 NoPorts = 2;
      case 2: {
        if (tag == 16) {
         parse_NoPorts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &noports_)));
          set_has_noports();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_InErrors;
        break;
      }

      // optional int64 InErrors = 3;
      case 3: {
        if (tag == 24) {
         parse_InErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inerrors_)));
          set_has_inerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_OutDatagrams;
        break;
      }

      // optional int64 OutDatagrams = 4;
      case 4: {
        if (tag == 32) {
         parse_OutDatagrams:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outdatagrams_)));
          set_has_outdatagrams();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_RcvbufErrors;
        break;
      }

      // optional int64 RcvbufErrors = 5;
      case 5: {
        if (tag == 40) {
         parse_RcvbufErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rcvbuferrors_)));
          set_has_rcvbuferrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_SndbufErrors;
        break;
      }

      // optional int64 SndbufErrors = 6;
      case 6: {
        if (tag == 48) {
         parse_SndbufErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sndbuferrors_)));
          set_has_sndbuferrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_InCsumErrors;
        break;
      }

      // optional int64 InCsumErrors = 7;
      case 7: {
        if (tag == 56) {
         parse_InCsumErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &incsumerrors_)));
          set_has_incsumerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_IgnoredMulti;
        break;
      }

      // optional int64 IgnoredMulti = 8;
      case 8: {
        if (tag == 64) {
         parse_IgnoredMulti:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &ignoredmulti_)));
          set_has_ignoredmulti();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.UdpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.UdpStatistics)
  return false;
#undef DO_
}

void UdpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.UdpStatistics)
  // optional int64 InDatagrams = 1;
  if (has_indatagrams()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->indatagrams(), output);
  }

  // optional int64 NoPorts = 2;
  if (has_noports()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->noports(), output);
  }

  // optional int64 InErrors = 3;
  if (has_inerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->inerrors(), output);
  }

  // optional int64 OutDatagrams = 4;
  if (has_outdatagrams()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->outdatagrams(), output);
  }

  // optional int64 RcvbufErrors = 5;
  if (has_rcvbuferrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->rcvbuferrors(), output);
  }

  // optional int64 SndbufErrors = 6;
  if (has_sndbuferrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->sndbuferrors(), output);
  }

  // optional int64 InCsumErrors = 7;
  if (has_incsumerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->incsumerrors(), output);
  }

  // optional int64 IgnoredMulti = 8;
  if (has_ignoredmulti()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->ignoredmulti(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.UdpStatistics)
}

::google::protobuf::uint8* UdpStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.UdpStatistics)
  // optional int64 InDatagrams = 1;
  if (has_indatagrams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->indatagrams(), target);
  }

  // optional int64 NoPorts = 2;
  if (has_noports()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->noports(), target);
  }

  // optional int64 InErrors = 3;
  if (has_inerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->inerrors(), target);
  }

  // optional int64 OutDatagrams = 4;
  if (has_outdatagrams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->outdatagrams(), target);
  }

  // optional int64 RcvbufErrors = 5;
  if (has_rcvbuferrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->rcvbuferrors(), target);
  }

  // optional int64 SndbufErrors = 6;
  if (has_sndbuferrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->sndbuferrors(), target);
  }

  // optional int64 InCsumErrors = 7;
  if (has_incsumerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->incsumerrors(), target);
  }

  // optional int64 IgnoredMulti = 8;
  if (has_ignoredmulti()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->ignoredmulti(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.UdpStatistics)
  return target;
}

int UdpStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 InDatagrams = 1;
    if (has_indatagrams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indatagrams());
    }

    // optional int64 NoPorts = 2;
    if (has_noports()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->noports());
    }

    // optional int64 InErrors = 3;
    if (has_inerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inerrors());
    }

    // optional int64 OutDatagrams = 4;
    if (has_outdatagrams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outdatagrams());
    }

    // optional int64 RcvbufErrors = 5;
    if (has_rcvbuferrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rcvbuferrors());
    }

    // optional int64 SndbufErrors = 6;
    if (has_sndbuferrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sndbuferrors());
    }

    // optional int64 InCsumErrors = 7;
    if (has_incsumerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->incsumerrors());
    }

    // optional int64 IgnoredMulti = 8;
    if (has_ignoredmulti()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->ignoredmulti());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UdpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UdpStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UdpStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UdpStatistics::MergeFrom(const UdpStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_indatagrams()) {
      set_indatagrams(from.indatagrams());
    }
    if (from.has_noports()) {
      set_noports(from.noports());
    }
    if (from.has_inerrors()) {
      set_inerrors(from.inerrors());
    }
    if (from.has_outdatagrams()) {
      set_outdatagrams(from.outdatagrams());
    }
    if (from.has_rcvbuferrors()) {
      set_rcvbuferrors(from.rcvbuferrors());
    }
    if (from.has_sndbuferrors()) {
      set_sndbuferrors(from.sndbuferrors());
    }
    if (from.has_incsumerrors()) {
      set_incsumerrors(from.incsumerrors());
    }
    if (from.has_ignoredmulti()) {
      set_ignoredmulti(from.ignoredmulti());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UdpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UdpStatistics::CopyFrom(const UdpStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UdpStatistics::IsInitialized() const {

  return true;
}

void UdpStatistics::Swap(UdpStatistics* other) {
  if (other != this) {
    std::swap(indatagrams_, other->indatagrams_);
    std::swap(noports_, other->noports_);
    std::swap(inerrors_, other->inerrors_);
    std::swap(outdatagrams_, other->outdatagrams_);
    std::swap(rcvbuferrors_, other->rcvbuferrors_);
    std::swap(sndbuferrors_, other->sndbuferrors_);
    std::swap(incsumerrors_, other->incsumerrors_);
    std::swap(ignoredmulti_, other->ignoredmulti_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UdpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UdpStatistics_descriptor_;
  metadata.reflection = UdpStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SNMPStatistics::kIpStatsFieldNumber;
const int SNMPStatistics::kIcmpStatsFieldNumber;
const int SNMPStatistics::kTcpStatsFieldNumber;
const int SNMPStatistics::kUdpStatsFieldNumber;
#endif  // !_MSC_VER

SNMPStatistics::SNMPStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SNMPStatistics)
}

void SNMPStatistics::InitAsDefaultInstance() {
  ip_stats_ = const_cast< ::mesos::IpStatistics*>(&::mesos::IpStatistics::default_instance());
  icmp_stats_ = const_cast< ::mesos::IcmpStatistics*>(&::mesos::IcmpStatistics::default_instance());
  tcp_stats_ = const_cast< ::mesos::TcpStatistics*>(&::mesos::TcpStatistics::default_instance());
  udp_stats_ = const_cast< ::mesos::UdpStatistics*>(&::mesos::UdpStatistics::default_instance());
}

SNMPStatistics::SNMPStatistics(const SNMPStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SNMPStatistics)
}

void SNMPStatistics::SharedCtor() {
  _cached_size_ = 0;
  ip_stats_ = NULL;
  icmp_stats_ = NULL;
  tcp_stats_ = NULL;
  udp_stats_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SNMPStatistics::~SNMPStatistics() {
  // @@protoc_insertion_point(destructor:mesos.SNMPStatistics)
  SharedDtor();
}

void SNMPStatistics::SharedDtor() {
  if (this != default_instance_) {
    delete ip_stats_;
    delete icmp_stats_;
    delete tcp_stats_;
    delete udp_stats_;
  }
}

void SNMPStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SNMPStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SNMPStatistics_descriptor_;
}

const SNMPStatistics& SNMPStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SNMPStatistics* SNMPStatistics::default_instance_ = NULL;

SNMPStatistics* SNMPStatistics::New() const {
  return new SNMPStatistics;
}

void SNMPStatistics::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_ip_stats()) {
      if (ip_stats_ != NULL) ip_stats_->::mesos::IpStatistics::Clear();
    }
    if (has_icmp_stats()) {
      if (icmp_stats_ != NULL) icmp_stats_->::mesos::IcmpStatistics::Clear();
    }
    if (has_tcp_stats()) {
      if (tcp_stats_ != NULL) tcp_stats_->::mesos::TcpStatistics::Clear();
    }
    if (has_udp_stats()) {
      if (udp_stats_ != NULL) udp_stats_->::mesos::UdpStatistics::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SNMPStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SNMPStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.IpStatistics ip_stats = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ip_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_icmp_stats;
        break;
      }

      // optional .mesos.IcmpStatistics icmp_stats = 2;
      case 2: {
        if (tag == 18) {
         parse_icmp_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_icmp_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tcp_stats;
        break;
      }

      // optional .mesos.TcpStatistics tcp_stats = 3;
      case 3: {
        if (tag == 26) {
         parse_tcp_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_udp_stats;
        break;
      }

      // optional .mesos.UdpStatistics udp_stats = 4;
      case 4: {
        if (tag == 34) {
         parse_udp_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_udp_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SNMPStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SNMPStatistics)
  return false;
#undef DO_
}

void SNMPStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SNMPStatistics)
  // optional .mesos.IpStatistics ip_stats = 1;
  if (has_ip_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ip_stats(), output);
  }

  // optional .mesos.IcmpStatistics icmp_stats = 2;
  if (has_icmp_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->icmp_stats(), output);
  }

  // optional .mesos.TcpStatistics tcp_stats = 3;
  if (has_tcp_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tcp_stats(), output);
  }

  // optional .mesos.UdpStatistics udp_stats = 4;
  if (has_udp_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->udp_stats(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SNMPStatistics)
}

::google::protobuf::uint8* SNMPStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SNMPStatistics)
  // optional .mesos.IpStatistics ip_stats = 1;
  if (has_ip_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ip_stats(), target);
  }

  // optional .mesos.IcmpStatistics icmp_stats = 2;
  if (has_icmp_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->icmp_stats(), target);
  }

  // optional .mesos.TcpStatistics tcp_stats = 3;
  if (has_tcp_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tcp_stats(), target);
  }

  // optional .mesos.UdpStatistics udp_stats = 4;
  if (has_udp_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->udp_stats(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SNMPStatistics)
  return target;
}

int SNMPStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.IpStatistics ip_stats = 1;
    if (has_ip_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ip_stats());
    }

    // optional .mesos.IcmpStatistics icmp_stats = 2;
    if (has_icmp_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->icmp_stats());
    }

    // optional .mesos.TcpStatistics tcp_stats = 3;
    if (has_tcp_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcp_stats());
    }

    // optional .mesos.UdpStatistics udp_stats = 4;
    if (has_udp_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->udp_stats());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SNMPStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SNMPStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SNMPStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SNMPStatistics::MergeFrom(const SNMPStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip_stats()) {
      mutable_ip_stats()->::mesos::IpStatistics::MergeFrom(from.ip_stats());
    }
    if (from.has_icmp_stats()) {
      mutable_icmp_stats()->::mesos::IcmpStatistics::MergeFrom(from.icmp_stats());
    }
    if (from.has_tcp_stats()) {
      mutable_tcp_stats()->::mesos::TcpStatistics::MergeFrom(from.tcp_stats());
    }
    if (from.has_udp_stats()) {
      mutable_udp_stats()->::mesos::UdpStatistics::MergeFrom(from.udp_stats());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SNMPStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SNMPStatistics::CopyFrom(const SNMPStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SNMPStatistics::IsInitialized() const {

  return true;
}

void SNMPStatistics::Swap(SNMPStatistics* other) {
  if (other != this) {
    std::swap(ip_stats_, other->ip_stats_);
    std::swap(icmp_stats_, other->icmp_stats_);
    std::swap(tcp_stats_, other->tcp_stats_);
    std::swap(udp_stats_, other->udp_stats_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SNMPStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SNMPStatistics_descriptor_;
  metadata.reflection = SNMPStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DiskStatistics::kSourceFieldNumber;
const int DiskStatistics::kPersistenceFieldNumber;
const int DiskStatistics::kLimitBytesFieldNumber;
const int DiskStatistics::kUsedBytesFieldNumber;
#endif  // !_MSC_VER

DiskStatistics::DiskStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DiskStatistics)
}

void DiskStatistics::InitAsDefaultInstance() {
  source_ = const_cast< ::mesos::Resource_DiskInfo_Source*>(&::mesos::Resource_DiskInfo_Source::default_instance());
  persistence_ = const_cast< ::mesos::Resource_DiskInfo_Persistence*>(&::mesos::Resource_DiskInfo_Persistence::default_instance());
}

DiskStatistics::DiskStatistics(const DiskStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DiskStatistics)
}

void DiskStatistics::SharedCtor() {
  _cached_size_ = 0;
  source_ = NULL;
  persistence_ = NULL;
  limit_bytes_ = GOOGLE_ULONGLONG(0);
  used_bytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiskStatistics::~DiskStatistics() {
  // @@protoc_insertion_point(destructor:mesos.DiskStatistics)
  SharedDtor();
}

void DiskStatistics::SharedDtor() {
  if (this != default_instance_) {
    delete source_;
    delete persistence_;
  }
}

void DiskStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DiskStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiskStatistics_descriptor_;
}

const DiskStatistics& DiskStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DiskStatistics* DiskStatistics::default_instance_ = NULL;

DiskStatistics* DiskStatistics::New() const {
  return new DiskStatistics;
}

void DiskStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DiskStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(limit_bytes_, used_bytes_);
    if (has_source()) {
      if (source_ != NULL) source_->::mesos::Resource_DiskInfo_Source::Clear();
    }
    if (has_persistence()) {
      if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DiskStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DiskStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Resource.DiskInfo.Source source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_persistence;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
      case 2: {
        if (tag == 18) {
         parse_persistence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_persistence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_limit_bytes;
        break;
      }

      // optional uint64 limit_bytes = 3;
      case 3: {
        if (tag == 24) {
         parse_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &limit_bytes_)));
          set_has_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_used_bytes;
        break;
      }

      // optional uint64 used_bytes = 4;
      case 4: {
        if (tag == 32) {
         parse_used_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &used_bytes_)));
          set_has_used_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DiskStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DiskStatistics)
  return false;
#undef DO_
}

void DiskStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DiskStatistics)
  // optional .mesos.Resource.DiskInfo.Source source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->source(), output);
  }

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
  if (has_persistence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->persistence(), output);
  }

  // optional uint64 limit_bytes = 3;
  if (has_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->limit_bytes(), output);
  }

  // optional uint64 used_bytes = 4;
  if (has_used_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->used_bytes(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DiskStatistics)
}

::google::protobuf::uint8* DiskStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DiskStatistics)
  // optional .mesos.Resource.DiskInfo.Source source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->source(), target);
  }

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
  if (has_persistence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->persistence(), target);
  }

  // optional uint64 limit_bytes = 3;
  if (has_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->limit_bytes(), target);
  }

  // optional uint64 used_bytes = 4;
  if (has_used_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->used_bytes(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DiskStatistics)
  return target;
}

int DiskStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Resource.DiskInfo.Source source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

    // optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
    if (has_persistence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->persistence());
    }

    // optional uint64 limit_bytes = 3;
    if (has_limit_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->limit_bytes());
    }

    // optional uint64 used_bytes = 4;
    if (has_used_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->used_bytes());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiskStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DiskStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DiskStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DiskStatistics::MergeFrom(const DiskStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      mutable_source()->::mesos::Resource_DiskInfo_Source::MergeFrom(from.source());
    }
    if (from.has_persistence()) {
      mutable_persistence()->::mesos::Resource_DiskInfo_Persistence::MergeFrom(from.persistence());
    }
    if (from.has_limit_bytes()) {
      set_limit_bytes(from.limit_bytes());
    }
    if (from.has_used_bytes()) {
      set_used_bytes(from.used_bytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DiskStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DiskStatistics::CopyFrom(const DiskStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiskStatistics::IsInitialized() const {

  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  if (has_persistence()) {
    if (!this->persistence().IsInitialized()) return false;
  }
  return true;
}

void DiskStatistics::Swap(DiskStatistics* other) {
  if (other != this) {
    std::swap(source_, other->source_);
    std::swap(persistence_, other->persistence_);
    std::swap(limit_bytes_, other->limit_bytes_);
    std::swap(used_bytes_, other->used_bytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DiskStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DiskStatistics_descriptor_;
  metadata.reflection = DiskStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceStatistics::kTimestampFieldNumber;
const int ResourceStatistics::kProcessesFieldNumber;
const int ResourceStatistics::kThreadsFieldNumber;
const int ResourceStatistics::kCpusUserTimeSecsFieldNumber;
const int ResourceStatistics::kCpusSystemTimeSecsFieldNumber;
const int ResourceStatistics::kCpusLimitFieldNumber;
const int ResourceStatistics::kCpusNrPeriodsFieldNumber;
const int ResourceStatistics::kCpusNrThrottledFieldNumber;
const int ResourceStatistics::kCpusThrottledTimeSecsFieldNumber;
const int ResourceStatistics::kMemTotalBytesFieldNumber;
const int ResourceStatistics::kMemTotalMemswBytesFieldNumber;
const int ResourceStatistics::kMemLimitBytesFieldNumber;
const int ResourceStatistics::kMemSoftLimitBytesFieldNumber;
const int ResourceStatistics::kMemFileBytesFieldNumber;
const int ResourceStatistics::kMemAnonBytesFieldNumber;
const int ResourceStatistics::kMemCacheBytesFieldNumber;
const int ResourceStatistics::kMemRssBytesFieldNumber;
const int ResourceStatistics::kMemMappedFileBytesFieldNumber;
const int ResourceStatistics::kMemSwapBytesFieldNumber;
const int ResourceStatistics::kMemUnevictableBytesFieldNumber;
const int ResourceStatistics::kMemLowPressureCounterFieldNumber;
const int ResourceStatistics::kMemMediumPressureCounterFieldNumber;
const int ResourceStatistics::kMemCriticalPressureCounterFieldNumber;
const int ResourceStatistics::kDiskLimitBytesFieldNumber;
const int ResourceStatistics::kDiskUsedBytesFieldNumber;
const int ResourceStatistics::kDiskStatisticsFieldNumber;
const int ResourceStatistics::kPerfFieldNumber;
const int ResourceStatistics::kNetRxPacketsFieldNumber;
const int ResourceStatistics::kNetRxBytesFieldNumber;
const int ResourceStatistics::kNetRxErrorsFieldNumber;
const int ResourceStatistics::kNetRxDroppedFieldNumber;
const int ResourceStatistics::kNetTxPacketsFieldNumber;
const int ResourceStatistics::kNetTxBytesFieldNumber;
const int ResourceStatistics::kNetTxErrorsFieldNumber;
const int ResourceStatistics::kNetTxDroppedFieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP50FieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP90FieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP95FieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP99FieldNumber;
const int ResourceStatistics::kNetTcpActiveConnectionsFieldNumber;
const int ResourceStatistics::kNetTcpTimeWaitConnectionsFieldNumber;
const int ResourceStatistics::kNetTrafficControlStatisticsFieldNumber;
const int ResourceStatistics::kNetSnmpStatisticsFieldNumber;
#endif  // !_MSC_VER

ResourceStatistics::ResourceStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceStatistics)
}

void ResourceStatistics::InitAsDefaultInstance() {
  perf_ = const_cast< ::mesos::PerfStatistics*>(&::mesos::PerfStatistics::default_instance());
  net_snmp_statistics_ = const_cast< ::mesos::SNMPStatistics*>(&::mesos::SNMPStatistics::default_instance());
}

ResourceStatistics::ResourceStatistics(const ResourceStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceStatistics)
}

void ResourceStatistics::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  processes_ = 0u;
  threads_ = 0u;
  cpus_user_time_secs_ = 0;
  cpus_system_time_secs_ = 0;
  cpus_limit_ = 0;
  cpus_nr_periods_ = 0u;
  cpus_nr_throttled_ = 0u;
  cpus_throttled_time_secs_ = 0;
  mem_total_bytes_ = GOOGLE_ULONGLONG(0);
  mem_total_memsw_bytes_ = GOOGLE_ULONGLONG(0);
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  mem_soft_limit_bytes_ = GOOGLE_ULONGLONG(0);
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  mem_cache_bytes_ = GOOGLE_ULONGLONG(0);
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  mem_swap_bytes_ = GOOGLE_ULONGLONG(0);
  mem_unevictable_bytes_ = GOOGLE_ULONGLONG(0);
  mem_low_pressure_counter_ = GOOGLE_ULONGLONG(0);
  mem_medium_pressure_counter_ = GOOGLE_ULONGLONG(0);
  mem_critical_pressure_counter_ = GOOGLE_ULONGLONG(0);
  disk_limit_bytes_ = GOOGLE_ULONGLONG(0);
  disk_used_bytes_ = GOOGLE_ULONGLONG(0);
  perf_ = NULL;
  net_rx_packets_ = GOOGLE_ULONGLONG(0);
  net_rx_bytes_ = GOOGLE_ULONGLONG(0);
  net_rx_errors_ = GOOGLE_ULONGLONG(0);
  net_rx_dropped_ = GOOGLE_ULONGLONG(0);
  net_tx_packets_ = GOOGLE_ULONGLONG(0);
  net_tx_bytes_ = GOOGLE_ULONGLONG(0);
  net_tx_errors_ = GOOGLE_ULONGLONG(0);
  net_tx_dropped_ = GOOGLE_ULONGLONG(0);
  net_tcp_rtt_microsecs_p50_ = 0;
  net_tcp_rtt_microsecs_p90_ = 0;
  net_tcp_rtt_microsecs_p95_ = 0;
  net_tcp_rtt_microsecs_p99_ = 0;
  net_tcp_active_connections_ = 0;
  net_tcp_time_wait_connections_ = 0;
  net_snmp_statistics_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceStatistics::~ResourceStatistics() {
  // @@protoc_insertion_point(destructor:mesos.ResourceStatistics)
  SharedDtor();
}

void ResourceStatistics::SharedDtor() {
  if (this != default_instance_) {
    delete perf_;
    delete net_snmp_statistics_;
  }
}

void ResourceStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceStatistics_descriptor_;
}

const ResourceStatistics& ResourceStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceStatistics* ResourceStatistics::default_instance_ = NULL;

ResourceStatistics* ResourceStatistics::New() const {
  return new ResourceStatistics;
}

void ResourceStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ResourceStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(timestamp_, cpus_nr_throttled_);
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(cpus_throttled_time_secs_, mem_cache_bytes_);
  }
  if (_has_bits_[16 / 32] & 16711680) {
    ZR_(mem_rss_bytes_, disk_limit_bytes_);
  }
  if (_has_bits_[24 / 32] & 4244635648) {
    ZR_(net_rx_packets_, net_tx_packets_);
    disk_used_bytes_ = GOOGLE_ULONGLONG(0);
    if (has_perf()) {
      if (perf_ != NULL) perf_->::mesos::PerfStatistics::Clear();
    }
  }
  if (_has_bits_[32 / 32] & 255) {
    ZR_(net_tx_bytes_, net_tcp_active_connections_);
  }
  if (_has_bits_[40 / 32] & 1280) {
    net_tcp_time_wait_connections_ = 0;
    if (has_net_snmp_statistics()) {
      if (net_snmp_statistics_ != NULL) net_snmp_statistics_->::mesos::SNMPStatistics::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  disk_statistics_.Clear();
  net_traffic_control_statistics_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_cpus_user_time_secs;
        break;
      }

      // optional double cpus_user_time_secs = 2;
      case 2: {
        if (tag == 17) {
         parse_cpus_user_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_user_time_secs_)));
          set_has_cpus_user_time_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_cpus_system_time_secs;
        break;
      }

      // optional double cpus_system_time_secs = 3;
      case 3: {
        if (tag == 25) {
         parse_cpus_system_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_system_time_secs_)));
          set_has_cpus_system_time_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_cpus_limit;
        break;
      }

      // optional double cpus_limit = 4;
      case 4: {
        if (tag == 33) {
         parse_cpus_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_limit_)));
          set_has_cpus_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mem_rss_bytes;
        break;
      }

      // optional uint64 mem_rss_bytes = 5;
      case 5: {
        if (tag == 40) {
         parse_mem_rss_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_rss_bytes_)));
          set_has_mem_rss_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_mem_limit_bytes;
        break;
      }

      // optional uint64 mem_limit_bytes = 6;
      case 6: {
        if (tag == 48) {
         parse_mem_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_limit_bytes_)));
          set_has_mem_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_cpus_nr_periods;
        break;
      }

      // optional uint32 cpus_nr_periods = 7;
      case 7: {
        if (tag == 56) {
         parse_cpus_nr_periods:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpus_nr_periods_)));
          set_has_cpus_nr_periods();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_cpus_nr_throttled;
        break;
      }

      // optional uint32 cpus_nr_throttled = 8;
      case 8: {
        if (tag == 64) {
         parse_cpus_nr_throttled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpus_nr_throttled_)));
          set_has_cpus_nr_throttled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_cpus_throttled_time_secs;
        break;
      }

      // optional double cpus_throttled_time_secs = 9;
      case 9: {
        if (tag == 73) {
         parse_cpus_throttled_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_throttled_time_secs_)));
          set_has_cpus_throttled_time_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_mem_file_bytes;
        break;
      }

      // optional uint64 mem_file_bytes = 10;
      case 10: {
        if (tag == 80) {
         parse_mem_file_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_file_bytes_)));
          set_has_mem_file_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_mem_anon_bytes;
        break;
      }

      // optional uint64 mem_anon_bytes = 11;
      case 11: {
        if (tag == 88) {
         parse_mem_anon_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_anon_bytes_)));
          set_has_mem_anon_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_mem_mapped_file_bytes;
        break;
      }

      // optional uint64 mem_mapped_file_bytes = 12;
      case 12: {
        if (tag == 96) {
         parse_mem_mapped_file_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_mapped_file_bytes_)));
          set_has_mem_mapped_file_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_perf;
        break;
      }

      // optional .mesos.PerfStatistics perf = 13;
      case 13: {
        if (tag == 106) {
         parse_perf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_perf()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_net_rx_packets;
        break;
      }

      // optional uint64 net_rx_packets = 14;
      case 14: {
        if (tag == 112) {
         parse_net_rx_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_packets_)));
          set_has_net_rx_packets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_net_rx_bytes;
        break;
      }

      // optional uint64 net_rx_bytes = 15;
      case 15: {
        if (tag == 120) {
         parse_net_rx_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_bytes_)));
          set_has_net_rx_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_net_rx_errors;
        break;
      }

      // optional uint64 net_rx_errors = 16;
      case 16: {
        if (tag == 128) {
         parse_net_rx_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_errors_)));
          set_has_net_rx_errors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_net_rx_dropped;
        break;
      }

      // optional uint64 net_rx_dropped = 17;
      case 17: {
        if (tag == 136) {
         parse_net_rx_dropped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_dropped_)));
          set_has_net_rx_dropped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_net_tx_packets;
        break;
      }

      // optional uint64 net_tx_packets = 18;
      case 18: {
        if (tag == 144) {
         parse_net_tx_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_packets_)));
          set_has_net_tx_packets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_net_tx_bytes;
        break;
      }

      // optional uint64 net_tx_bytes = 19;
      case 19: {
        if (tag == 152) {
         parse_net_tx_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_bytes_)));
          set_has_net_tx_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_net_tx_errors;
        break;
      }

      // optional uint64 net_tx_errors = 20;
      case 20: {
        if (tag == 160) {
         parse_net_tx_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_errors_)));
          set_has_net_tx_errors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_net_tx_dropped;
        break;
      }

      // optional uint64 net_tx_dropped = 21;
      case 21: {
        if (tag == 168) {
         parse_net_tx_dropped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_dropped_)));
          set_has_net_tx_dropped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(177)) goto parse_net_tcp_rtt_microsecs_p50;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p50 = 22;
      case 22: {
        if (tag == 177) {
         parse_net_tcp_rtt_microsecs_p50:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p50_)));
          set_has_net_tcp_rtt_microsecs_p50();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(185)) goto parse_net_tcp_rtt_microsecs_p90;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p90 = 23;
      case 23: {
        if (tag == 185) {
         parse_net_tcp_rtt_microsecs_p90:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p90_)));
          set_has_net_tcp_rtt_microsecs_p90();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(193)) goto parse_net_tcp_rtt_microsecs_p95;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p95 = 24;
      case 24: {
        if (tag == 193) {
         parse_net_tcp_rtt_microsecs_p95:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p95_)));
          set_has_net_tcp_rtt_microsecs_p95();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(201)) goto parse_net_tcp_rtt_microsecs_p99;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p99 = 25;
      case 25: {
        if (tag == 201) {
         parse_net_tcp_rtt_microsecs_p99:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p99_)));
          set_has_net_tcp_rtt_microsecs_p99();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_disk_limit_bytes;
        break;
      }

      // optional uint64 disk_limit_bytes = 26;
      case 26: {
        if (tag == 208) {
         parse_disk_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &disk_limit_bytes_)));
          set_has_disk_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_disk_used_bytes;
        break;
      }

      // optional uint64 disk_used_bytes = 27;
      case 27: {
        if (tag == 216) {
         parse_disk_used_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &disk_used_bytes_)));
          set_has_disk_used_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(225)) goto parse_net_tcp_active_connections;
        break;
      }

      // optional double net_tcp_active_connections = 28;
      case 28: {
        if (tag == 225) {
         parse_net_tcp_active_connections:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_active_connections_)));
          set_has_net_tcp_active_connections();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(233)) goto parse_net_tcp_time_wait_connections;
        break;
      }

      // optional double net_tcp_time_wait_connections = 29;
      case 29: {
        if (tag == 233) {
         parse_net_tcp_time_wait_connections:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_time_wait_connections_)));
          set_has_net_tcp_time_wait_connections();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_processes;
        break;
      }

      // optional uint32 processes = 30;
      case 30: {
        if (tag == 240) {
         parse_processes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &processes_)));
          set_has_processes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_threads;
        break;
      }

      // optional uint32 threads = 31;
      case 31: {
        if (tag == 248) {
         parse_threads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &threads_)));
          set_has_threads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_mem_low_pressure_counter;
        break;
      }

      // optional uint64 mem_low_pressure_counter = 32;
      case 32: {
        if (tag == 256) {
         parse_mem_low_pressure_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_low_pressure_counter_)));
          set_has_mem_low_pressure_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_mem_medium_pressure_counter;
        break;
      }

      // optional uint64 mem_medium_pressure_counter = 33;
      case 33: {
        if (tag == 264) {
         parse_mem_medium_pressure_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_medium_pressure_counter_)));
          set_has_mem_medium_pressure_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_mem_critical_pressure_counter;
        break;
      }

      // optional uint64 mem_critical_pressure_counter = 34;
      case 34: {
        if (tag == 272) {
         parse_mem_critical_pressure_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_critical_pressure_counter_)));
          set_has_mem_critical_pressure_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_net_traffic_control_statistics;
        break;
      }

      // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
      case 35: {
        if (tag == 282) {
         parse_net_traffic_control_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_net_traffic_control_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_net_traffic_control_statistics;
        if (input->ExpectTag(288)) goto parse_mem_total_bytes;
        break;
      }

      // optional uint64 mem_total_bytes = 36;
      case 36: {
        if (tag == 288) {
         parse_mem_total_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_total_bytes_)));
          set_has_mem_total_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_mem_total_memsw_bytes;
        break;
      }

      // optional uint64 mem_total_memsw_bytes = 37;
      case 37: {
        if (tag == 296) {
         parse_mem_total_memsw_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_total_memsw_bytes_)));
          set_has_mem_total_memsw_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_mem_soft_limit_bytes;
        break;
      }

      // optional uint64 mem_soft_limit_bytes = 38;
      case 38: {
        if (tag == 304) {
         parse_mem_soft_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_soft_limit_bytes_)));
          set_has_mem_soft_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(312)) goto parse_mem_cache_bytes;
        break;
      }

      // optional uint64 mem_cache_bytes = 39;
      case 39: {
        if (tag == 312) {
         parse_mem_cache_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_cache_bytes_)));
          set_has_mem_cache_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(320)) goto parse_mem_swap_bytes;
        break;
      }

      // optional uint64 mem_swap_bytes = 40;
      case 40: {
        if (tag == 320) {
         parse_mem_swap_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_swap_bytes_)));
          set_has_mem_swap_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_mem_unevictable_bytes;
        break;
      }

      // optional uint64 mem_unevictable_bytes = 41;
      case 41: {
        if (tag == 328) {
         parse_mem_unevictable_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_unevictable_bytes_)));
          set_has_mem_unevictable_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(338)) goto parse_net_snmp_statistics;
        break;
      }

      // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
      case 42: {
        if (tag == 338) {
         parse_net_snmp_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_net_snmp_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(346)) goto parse_disk_statistics;
        break;
      }

      // repeated .mesos.DiskStatistics disk_statistics = 43;
      case 43: {
        if (tag == 346) {
         parse_disk_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_disk_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(346)) goto parse_disk_statistics;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceStatistics)
  return false;
#undef DO_
}

void ResourceStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->timestamp(), output);
  }

  // optional double cpus_user_time_secs = 2;
  if (has_cpus_user_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->cpus_user_time_secs(), output);
  }

  // optional double cpus_system_time_secs = 3;
  if (has_cpus_system_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->cpus_system_time_secs(), output);
  }

  // optional double cpus_limit = 4;
  if (has_cpus_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->cpus_limit(), output);
  }

  // optional uint64 mem_rss_bytes = 5;
  if (has_mem_rss_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->mem_rss_bytes(), output);
  }

  // optional uint64 mem_limit_bytes = 6;
  if (has_mem_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->mem_limit_bytes(), output);
  }

  // optional uint32 cpus_nr_periods = 7;
  if (has_cpus_nr_periods()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->cpus_nr_periods(), output);
  }

  // optional uint32 cpus_nr_throttled = 8;
  if (has_cpus_nr_throttled()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->cpus_nr_throttled(), output);
  }

  // optional double cpus_throttled_time_secs = 9;
  if (has_cpus_throttled_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->cpus_throttled_time_secs(), output);
  }

  // optional uint64 mem_file_bytes = 10;
  if (has_mem_file_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->mem_file_bytes(), output);
  }

  // optional uint64 mem_anon_bytes = 11;
  if (has_mem_anon_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->mem_anon_bytes(), output);
  }

  // optional uint64 mem_mapped_file_bytes = 12;
  if (has_mem_mapped_file_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->mem_mapped_file_bytes(), output);
  }

  // optional .mesos.PerfStatistics perf = 13;
  if (has_perf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->perf(), output);
  }

  // optional uint64 net_rx_packets = 14;
  if (has_net_rx_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->net_rx_packets(), output);
  }

  // optional uint64 net_rx_bytes = 15;
  if (has_net_rx_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->net_rx_bytes(), output);
  }

  // optional uint64 net_rx_errors = 16;
  if (has_net_rx_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->net_rx_errors(), output);
  }

  // optional uint64 net_rx_dropped = 17;
  if (has_net_rx_dropped()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->net_rx_dropped(), output);
  }

  // optional uint64 net_tx_packets = 18;
  if (has_net_tx_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->net_tx_packets(), output);
  }

  // optional uint64 net_tx_bytes = 19;
  if (has_net_tx_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->net_tx_bytes(), output);
  }

  // optional uint64 net_tx_errors = 20;
  if (has_net_tx_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(20, this->net_tx_errors(), output);
  }

  // optional uint64 net_tx_dropped = 21;
  if (has_net_tx_dropped()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->net_tx_dropped(), output);
  }

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  if (has_net_tcp_rtt_microsecs_p50()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(22, this->net_tcp_rtt_microsecs_p50(), output);
  }

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  if (has_net_tcp_rtt_microsecs_p90()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->net_tcp_rtt_microsecs_p90(), output);
  }

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  if (has_net_tcp_rtt_microsecs_p95()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->net_tcp_rtt_microsecs_p95(), output);
  }

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  if (has_net_tcp_rtt_microsecs_p99()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->net_tcp_rtt_microsecs_p99(), output);
  }

  // optional uint64 disk_limit_bytes = 26;
  if (has_disk_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->disk_limit_bytes(), output);
  }

  // optional uint64 disk_used_bytes = 27;
  if (has_disk_used_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(27, this->disk_used_bytes(), output);
  }

  // optional double net_tcp_active_connections = 28;
  if (has_net_tcp_active_connections()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->net_tcp_active_connections(), output);
  }

  // optional double net_tcp_time_wait_connections = 29;
  if (has_net_tcp_time_wait_connections()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(29, this->net_tcp_time_wait_connections(), output);
  }

  // optional uint32 processes = 30;
  if (has_processes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(30, this->processes(), output);
  }

  // optional uint32 threads = 31;
  if (has_threads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->threads(), output);
  }

  // optional uint64 mem_low_pressure_counter = 32;
  if (has_mem_low_pressure_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(32, this->mem_low_pressure_counter(), output);
  }

  // optional uint64 mem_medium_pressure_counter = 33;
  if (has_mem_medium_pressure_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(33, this->mem_medium_pressure_counter(), output);
  }

  // optional uint64 mem_critical_pressure_counter = 34;
  if (has_mem_critical_pressure_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(34, this->mem_critical_pressure_counter(), output);
  }

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  for (int i = 0; i < this->net_traffic_control_statistics_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, this->net_traffic_control_statistics(i), output);
  }

  // optional uint64 mem_total_bytes = 36;
  if (has_mem_total_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(36, this->mem_total_bytes(), output);
  }

  // optional uint64 mem_total_memsw_bytes = 37;
  if (has_mem_total_memsw_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(37, this->mem_total_memsw_bytes(), output);
  }

  // optional uint64 mem_soft_limit_bytes = 38;
  if (has_mem_soft_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(38, this->mem_soft_limit_bytes(), output);
  }

  // optional uint64 mem_cache_bytes = 39;
  if (has_mem_cache_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(39, this->mem_cache_bytes(), output);
  }

  // optional uint64 mem_swap_bytes = 40;
  if (has_mem_swap_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(40, this->mem_swap_bytes(), output);
  }

  // optional uint64 mem_unevictable_bytes = 41;
  if (has_mem_unevictable_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(41, this->mem_unevictable_bytes(), output);
  }

  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  if (has_net_snmp_statistics()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      42, this->net_snmp_statistics(), output);
  }

  // repeated .mesos.DiskStatistics disk_statistics = 43;
  for (int i = 0; i < this->disk_statistics_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      43, this->disk_statistics(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceStatistics)
}

::google::protobuf::uint8* ResourceStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->timestamp(), target);
  }

  // optional double cpus_user_time_secs = 2;
  if (has_cpus_user_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->cpus_user_time_secs(), target);
  }

  // optional double cpus_system_time_secs = 3;
  if (has_cpus_system_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->cpus_system_time_secs(), target);
  }

  // optional double cpus_limit = 4;
  if (has_cpus_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->cpus_limit(), target);
  }

  // optional uint64 mem_rss_bytes = 5;
  if (has_mem_rss_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->mem_rss_bytes(), target);
  }

  // optional uint64 mem_limit_bytes = 6;
  if (has_mem_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->mem_limit_bytes(), target);
  }

  // optional uint32 cpus_nr_periods = 7;
  if (has_cpus_nr_periods()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->cpus_nr_periods(), target);
  }

  // optional uint32 cpus_nr_throttled = 8;
  if (has_cpus_nr_throttled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->cpus_nr_throttled(), target);
  }

  // optional double cpus_throttled_time_secs = 9;
  if (has_cpus_throttled_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->cpus_throttled_time_secs(), target);
  }

  // optional uint64 mem_file_bytes = 10;
  if (has_mem_file_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->mem_file_bytes(), target);
  }

  // optional uint64 mem_anon_bytes = 11;
  if (has_mem_anon_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->mem_anon_bytes(), target);
  }

  // optional uint64 mem_mapped_file_bytes = 12;
  if (has_mem_mapped_file_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->mem_mapped_file_bytes(), target);
  }

  // optional .mesos.PerfStatistics perf = 13;
  if (has_perf()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->perf(), target);
  }

  // optional uint64 net_rx_packets = 14;
  if (has_net_rx_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(14, this->net_rx_packets(), target);
  }

  // optional uint64 net_rx_bytes = 15;
  if (has_net_rx_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->net_rx_bytes(), target);
  }

  // optional uint64 net_rx_errors = 16;
  if (has_net_rx_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(16, this->net_rx_errors(), target);
  }

  // optional uint64 net_rx_dropped = 17;
  if (has_net_rx_dropped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(17, this->net_rx_dropped(), target);
  }

  // optional uint64 net_tx_packets = 18;
  if (has_net_tx_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(18, this->net_tx_packets(), target);
  }

  // optional uint64 net_tx_bytes = 19;
  if (has_net_tx_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(19, this->net_tx_bytes(), target);
  }

  // optional uint64 net_tx_errors = 20;
  if (has_net_tx_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(20, this->net_tx_errors(), target);
  }

  // optional uint64 net_tx_dropped = 21;
  if (has_net_tx_dropped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->net_tx_dropped(), target);
  }

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  if (has_net_tcp_rtt_microsecs_p50()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(22, this->net_tcp_rtt_microsecs_p50(), target);
  }

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  if (has_net_tcp_rtt_microsecs_p90()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->net_tcp_rtt_microsecs_p90(), target);
  }

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  if (has_net_tcp_rtt_microsecs_p95()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(24, this->net_tcp_rtt_microsecs_p95(), target);
  }

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  if (has_net_tcp_rtt_microsecs_p99()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->net_tcp_rtt_microsecs_p99(), target);
  }

  // optional uint64 disk_limit_bytes = 26;
  if (has_disk_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(26, this->disk_limit_bytes(), target);
  }

  // optional uint64 disk_used_bytes = 27;
  if (has_disk_used_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(27, this->disk_used_bytes(), target);
  }

  // optional double net_tcp_active_connections = 28;
  if (has_net_tcp_active_connections()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->net_tcp_active_connections(), target);
  }

  // optional double net_tcp_time_wait_connections = 29;
  if (has_net_tcp_time_wait_connections()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(29, this->net_tcp_time_wait_connections(), target);
  }

  // optional uint32 processes = 30;
  if (has_processes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(30, this->processes(), target);
  }

  // optional uint32 threads = 31;
  if (has_threads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(31, this->threads(), target);
  }

  // optional uint64 mem_low_pressure_counter = 32;
  if (has_mem_low_pressure_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(32, this->mem_low_pressure_counter(), target);
  }

  // optional uint64 mem_medium_pressure_counter = 33;
  if (has_mem_medium_pressure_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(33, this->mem_medium_pressure_counter(), target);
  }

  // optional uint64 mem_critical_pressure_counter = 34;
  if (has_mem_critical_pressure_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(34, this->mem_critical_pressure_counter(), target);
  }

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  for (int i = 0; i < this->net_traffic_control_statistics_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        35, this->net_traffic_control_statistics(i), target);
  }

  // optional uint64 mem_total_bytes = 36;
  if (has_mem_total_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(36, this->mem_total_bytes(), target);
  }

  // optional uint64 mem_total_memsw_bytes = 37;
  if (has_mem_total_memsw_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(37, this->mem_total_memsw_bytes(), target);
  }

  // optional uint64 mem_soft_limit_bytes = 38;
  if (has_mem_soft_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(38, this->mem_soft_limit_bytes(), target);
  }

  // optional uint64 mem_cache_bytes = 39;
  if (has_mem_cache_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(39, this->mem_cache_bytes(), target);
  }

  // optional uint64 mem_swap_bytes = 40;
  if (has_mem_swap_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(40, this->mem_swap_bytes(), target);
  }

  // optional uint64 mem_unevictable_bytes = 41;
  if (has_mem_unevictable_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(41, this->mem_unevictable_bytes(), target);
  }

  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  if (has_net_snmp_statistics()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        42, this->net_snmp_statistics(), target);
  }

  // repeated .mesos.DiskStatistics disk_statistics = 43;
  for (int i = 0; i < this->disk_statistics_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        43, this->disk_statistics(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceStatistics)
  return target;
}

int ResourceStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional uint32 processes = 30;
    if (has_processes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->processes());
    }

    // optional uint32 threads = 31;
    if (has_threads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->threads());
    }

    // optional double cpus_user_time_secs = 2;
    if (has_cpus_user_time_secs()) {
      total_size += 1 + 8;
    }

    // optional double cpus_system_time_secs = 3;
    if (has_cpus_system_time_secs()) {
      total_size += 1 + 8;
    }

    // optional double cpus_limit = 4;
    if (has_cpus_limit()) {
      total_size += 1 + 8;
    }

    // optional uint32 cpus_nr_periods = 7;
    if (has_cpus_nr_periods()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cpus_nr_periods());
    }

    // optional uint32 cpus_nr_throttled = 8;
    if (has_cpus_nr_throttled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cpus_nr_throttled());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double cpus_throttled_time_secs = 9;
    if (has_cpus_throttled_time_secs()) {
      total_size += 1 + 8;
    }

    // optional uint64 mem_total_bytes = 36;
    if (has_mem_total_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_total_bytes());
    }

    // optional uint64 mem_total_memsw_bytes = 37;
    if (has_mem_total_memsw_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_total_memsw_bytes());
    }

    // optional uint64 mem_limit_bytes = 6;
    if (has_mem_limit_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_limit_bytes());
    }

    // optional uint64 mem_soft_limit_bytes = 38;
    if (has_mem_soft_limit_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_soft_limit_bytes());
    }

    // optional uint64 mem_file_bytes = 10;
    if (has_mem_file_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_file_bytes());
    }

    // optional uint64 mem_anon_bytes = 11;
    if (has_mem_anon_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_anon_bytes());
    }

    // optional uint64 mem_cache_bytes = 39;
    if (has_mem_cache_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_cache_bytes());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint64 mem_rss_bytes = 5;
    if (has_mem_rss_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_rss_bytes());
    }

    // optional uint64 mem_mapped_file_bytes = 12;
    if (has_mem_mapped_file_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_mapped_file_bytes());
    }

    // optional uint64 mem_swap_bytes = 40;
    if (has_mem_swap_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_swap_bytes());
    }

    // optional uint64 mem_unevictable_bytes = 41;
    if (has_mem_unevictable_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_unevictable_bytes());
    }

    // optional uint64 mem_low_pressure_counter = 32;
    if (has_mem_low_pressure_counter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_low_pressure_counter());
    }

    // optional uint64 mem_medium_pressure_counter = 33;
    if (has_mem_medium_pressure_counter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_medium_pressure_counter());
    }

    // optional uint64 mem_critical_pressure_counter = 34;
    if (has_mem_critical_pressure_counter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_critical_pressure_counter());
    }

    // optional uint64 disk_limit_bytes = 26;
    if (has_disk_limit_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->disk_limit_bytes());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional uint64 disk_used_bytes = 27;
    if (has_disk_used_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->disk_used_bytes());
    }

    // optional .mesos.PerfStatistics perf = 13;
    if (has_perf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->perf());
    }

    // optional uint64 net_rx_packets = 14;
    if (has_net_rx_packets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_packets());
    }

    // optional uint64 net_rx_bytes = 15;
    if (has_net_rx_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_bytes());
    }

    // optional uint64 net_rx_errors = 16;
    if (has_net_rx_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_errors());
    }

    // optional uint64 net_rx_dropped = 17;
    if (has_net_rx_dropped()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_dropped());
    }

    // optional uint64 net_tx_packets = 18;
    if (has_net_tx_packets()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_packets());
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional uint64 net_tx_bytes = 19;
    if (has_net_tx_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_bytes());
    }

    // optional uint64 net_tx_errors = 20;
    if (has_net_tx_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_errors());
    }

    // optional uint64 net_tx_dropped = 21;
    if (has_net_tx_dropped()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_dropped());
    }

    // optional double net_tcp_rtt_microsecs_p50 = 22;
    if (has_net_tcp_rtt_microsecs_p50()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_rtt_microsecs_p90 = 23;
    if (has_net_tcp_rtt_microsecs_p90()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_rtt_microsecs_p95 = 24;
    if (has_net_tcp_rtt_microsecs_p95()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_rtt_microsecs_p99 = 25;
    if (has_net_tcp_rtt_microsecs_p99()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_active_connections = 28;
    if (has_net_tcp_active_connections()) {
      total_size += 2 + 8;
    }

  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional double net_tcp_time_wait_connections = 29;
    if (has_net_tcp_time_wait_connections()) {
      total_size += 2 + 8;
    }

    // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
    if (has_net_snmp_statistics()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->net_snmp_statistics());
    }

  }
  // repeated .mesos.DiskStatistics disk_statistics = 43;
  total_size += 2 * this->disk_statistics_size();
  for (int i = 0; i < this->disk_statistics_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->disk_statistics(i));
  }

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  total_size += 2 * this->net_traffic_control_statistics_size();
  for (int i = 0; i < this->net_traffic_control_statistics_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->net_traffic_control_statistics(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceStatistics::MergeFrom(const ResourceStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  disk_statistics_.MergeFrom(from.disk_statistics_);
  net_traffic_control_statistics_.MergeFrom(from.net_traffic_control_statistics_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_processes()) {
      set_processes(from.processes());
    }
    if (from.has_threads()) {
      set_threads(from.threads());
    }
    if (from.has_cpus_user_time_secs()) {
      set_cpus_user_time_secs(from.cpus_user_time_secs());
    }
    if (from.has_cpus_system_time_secs()) {
      set_cpus_system_time_secs(from.cpus_system_time_secs());
    }
    if (from.has_cpus_limit()) {
      set_cpus_limit(from.cpus_limit());
    }
    if (from.has_cpus_nr_periods()) {
      set_cpus_nr_periods(from.cpus_nr_periods());
    }
    if (from.has_cpus_nr_throttled()) {
      set_cpus_nr_throttled(from.cpus_nr_throttled());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_cpus_throttled_time_secs()) {
      set_cpus_throttled_time_secs(from.cpus_throttled_time_secs());
    }
    if (from.has_mem_total_bytes()) {
      set_mem_total_bytes(from.mem_total_bytes());
    }
    if (from.has_mem_total_memsw_bytes()) {
      set_mem_total_memsw_bytes(from.mem_total_memsw_bytes());
    }
    if (from.has_mem_limit_bytes()) {
      set_mem_limit_bytes(from.mem_limit_bytes());
    }
    if (from.has_mem_soft_limit_bytes()) {
      set_mem_soft_limit_bytes(from.mem_soft_limit_bytes());
    }
    if (from.has_mem_file_bytes()) {
      set_mem_file_bytes(from.mem_file_bytes());
    }
    if (from.has_mem_anon_bytes()) {
      set_mem_anon_bytes(from.mem_anon_bytes());
    }
    if (from.has_mem_cache_bytes()) {
      set_mem_cache_bytes(from.mem_cache_bytes());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_mem_rss_bytes()) {
      set_mem_rss_bytes(from.mem_rss_bytes());
    }
    if (from.has_mem_mapped_file_bytes()) {
      set_mem_mapped_file_bytes(from.mem_mapped_file_bytes());
    }
    if (from.has_mem_swap_bytes()) {
      set_mem_swap_bytes(from.mem_swap_bytes());
    }
    if (from.has_mem_unevictable_bytes()) {
      set_mem_unevictable_bytes(from.mem_unevictable_bytes());
    }
    if (from.has_mem_low_pressure_counter()) {
      set_mem_low_pressure_counter(from.mem_low_pressure_counter());
    }
    if (from.has_mem_medium_pressure_counter()) {
      set_mem_medium_pressure_counter(from.mem_medium_pressure_counter());
    }
    if (from.has_mem_critical_pressure_counter()) {
      set_mem_critical_pressure_counter(from.mem_critical_pressure_counter());
    }
    if (from.has_disk_limit_bytes()) {
      set_disk_limit_bytes(from.disk_limit_bytes());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_disk_used_bytes()) {
      set_disk_used_bytes(from.disk_used_bytes());
    }
    if (from.has_perf()) {
      mutable_perf()->::mesos::PerfStatistics::MergeFrom(from.perf());
    }
    if (from.has_net_rx_packets()) {
      set_net_rx_packets(from.net_rx_packets());
    }
    if (from.has_net_rx_bytes()) {
      set_net_rx_bytes(from.net_rx_bytes());
    }
    if (from.has_net_rx_errors()) {
      set_net_rx_errors(from.net_rx_errors());
    }
    if (from.has_net_rx_dropped()) {
      set_net_rx_dropped(from.net_rx_dropped());
    }
    if (from.has_net_tx_packets()) {
      set_net_tx_packets(from.net_tx_packets());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_net_tx_bytes()) {
      set_net_tx_bytes(from.net_tx_bytes());
    }
    if (from.has_net_tx_errors()) {
      set_net_tx_errors(from.net_tx_errors());
    }
    if (from.has_net_tx_dropped()) {
      set_net_tx_dropped(from.net_tx_dropped());
    }
    if (from.has_net_tcp_rtt_microsecs_p50()) {
      set_net_tcp_rtt_microsecs_p50(from.net_tcp_rtt_microsecs_p50());
    }
    if (from.has_net_tcp_rtt_microsecs_p90()) {
      set_net_tcp_rtt_microsecs_p90(from.net_tcp_rtt_microsecs_p90());
    }
    if (from.has_net_tcp_rtt_microsecs_p95()) {
      set_net_tcp_rtt_microsecs_p95(from.net_tcp_rtt_microsecs_p95());
    }
    if (from.has_net_tcp_rtt_microsecs_p99()) {
      set_net_tcp_rtt_microsecs_p99(from.net_tcp_rtt_microsecs_p99());
    }
    if (from.has_net_tcp_active_connections()) {
      set_net_tcp_active_connections(from.net_tcp_active_connections());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_net_tcp_time_wait_connections()) {
      set_net_tcp_time_wait_connections(from.net_tcp_time_wait_connections());
    }
    if (from.has_net_snmp_statistics()) {
      mutable_net_snmp_statistics()->::mesos::SNMPStatistics::MergeFrom(from.net_snmp_statistics());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceStatistics::CopyFrom(const ResourceStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceStatistics::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->disk_statistics())) return false;
  if (has_perf()) {
    if (!this->perf().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->net_traffic_control_statistics())) return false;
  return true;
}

void ResourceStatistics::Swap(ResourceStatistics* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(processes_, other->processes_);
    std::swap(threads_, other->threads_);
    std::swap(cpus_user_time_secs_, other->cpus_user_time_secs_);
    std::swap(cpus_system_time_secs_, other->cpus_system_time_secs_);
    std::swap(cpus_limit_, other->cpus_limit_);
    std::swap(cpus_nr_periods_, other->cpus_nr_periods_);
    std::swap(cpus_nr_throttled_, other->cpus_nr_throttled_);
    std::swap(cpus_throttled_time_secs_, other->cpus_throttled_time_secs_);
    std::swap(mem_total_bytes_, other->mem_total_bytes_);
    std::swap(mem_total_memsw_bytes_, other->mem_total_memsw_bytes_);
    std::swap(mem_limit_bytes_, other->mem_limit_bytes_);
    std::swap(mem_soft_limit_bytes_, other->mem_soft_limit_bytes_);
    std::swap(mem_file_bytes_, other->mem_file_bytes_);
    std::swap(mem_anon_bytes_, other->mem_anon_bytes_);
    std::swap(mem_cache_bytes_, other->mem_cache_bytes_);
    std::swap(mem_rss_bytes_, other->mem_rss_bytes_);
    std::swap(mem_mapped_file_bytes_, other->mem_mapped_file_bytes_);
    std::swap(mem_swap_bytes_, other->mem_swap_bytes_);
    std::swap(mem_unevictable_bytes_, other->mem_unevictable_bytes_);
    std::swap(mem_low_pressure_counter_, other->mem_low_pressure_counter_);
    std::swap(mem_medium_pressure_counter_, other->mem_medium_pressure_counter_);
    std::swap(mem_critical_pressure_counter_, other->mem_critical_pressure_counter_);
    std::swap(disk_limit_bytes_, other->disk_limit_bytes_);
    std::swap(disk_used_bytes_, other->disk_used_bytes_);
    disk_statistics_.Swap(&other->disk_statistics_);
    std::swap(perf_, other->perf_);
    std::swap(net_rx_packets_, other->net_rx_packets_);
    std::swap(net_rx_bytes_, other->net_rx_bytes_);
    std::swap(net_rx_errors_, other->net_rx_errors_);
    std::swap(net_rx_dropped_, other->net_rx_dropped_);
    std::swap(net_tx_packets_, other->net_tx_packets_);
    std::swap(net_tx_bytes_, other->net_tx_bytes_);
    std::swap(net_tx_errors_, other->net_tx_errors_);
    std::swap(net_tx_dropped_, other->net_tx_dropped_);
    std::swap(net_tcp_rtt_microsecs_p50_, other->net_tcp_rtt_microsecs_p50_);
    std::swap(net_tcp_rtt_microsecs_p90_, other->net_tcp_rtt_microsecs_p90_);
    std::swap(net_tcp_rtt_microsecs_p95_, other->net_tcp_rtt_microsecs_p95_);
    std::swap(net_tcp_rtt_microsecs_p99_, other->net_tcp_rtt_microsecs_p99_);
    std::swap(net_tcp_active_connections_, other->net_tcp_active_connections_);
    std::swap(net_tcp_time_wait_connections_, other->net_tcp_time_wait_connections_);
    net_traffic_control_statistics_.Swap(&other->net_traffic_control_statistics_);
    std::swap(net_snmp_statistics_, other->net_snmp_statistics_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceStatistics_descriptor_;
  metadata.reflection = ResourceStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceUsage_Executor_Task::kNameFieldNumber;
const int ResourceUsage_Executor_Task::kIdFieldNumber;
const int ResourceUsage_Executor_Task::kResourcesFieldNumber;
const int ResourceUsage_Executor_Task::kLabelsFieldNumber;
#endif  // !_MSC_VER

ResourceUsage_Executor_Task::ResourceUsage_Executor_Task()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceUsage.Executor.Task)
}

void ResourceUsage_Executor_Task::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

ResourceUsage_Executor_Task::ResourceUsage_Executor_Task(const ResourceUsage_Executor_Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceUsage.Executor.Task)
}

void ResourceUsage_Executor_Task::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = NULL;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceUsage_Executor_Task::~ResourceUsage_Executor_Task() {
  // @@protoc_insertion_point(destructor:mesos.ResourceUsage.Executor.Task)
  SharedDtor();
}

void ResourceUsage_Executor_Task::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete id_;
    delete labels_;
  }
}

void ResourceUsage_Executor_Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceUsage_Executor_Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceUsage_Executor_Task_descriptor_;
}

const ResourceUsage_Executor_Task& ResourceUsage_Executor_Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceUsage_Executor_Task* ResourceUsage_Executor_Task::default_instance_ = NULL;

ResourceUsage_Executor_Task* ResourceUsage_Executor_Task::New() const {
  return new ResourceUsage_Executor_Task;
}

void ResourceUsage_Executor_Task::Clear() {
  if (_has_bits_[0 / 32] & 11) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::TaskID::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceUsage_Executor_Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceUsage.Executor.Task)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // required .mesos.TaskID id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 3;
      case 3: {
        if (tag == 26) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        if (input->ExpectTag(34)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 4;
      case 4: {
        if (tag == 34) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceUsage.Executor.Task)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceUsage.Executor.Task)
  return false;
#undef DO_
}

void ResourceUsage_Executor_Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceUsage.Executor.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.TaskID id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->id(), output);
  }

  // repeated .mesos.Resource resources = 3;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->resources(i), output);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->labels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceUsage.Executor.Task)
}

::google::protobuf::uint8* ResourceUsage_Executor_Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceUsage.Executor.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->id(), target);
  }

  // repeated .mesos.Resource resources = 3;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->resources(i), target);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->labels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceUsage.Executor.Task)
  return target;
}

int ResourceUsage_Executor_Task::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .mesos.TaskID id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional .mesos.Labels labels = 4;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  // repeated .mesos.Resource resources = 3;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceUsage_Executor_Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceUsage_Executor_Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceUsage_Executor_Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceUsage_Executor_Task::MergeFrom(const ResourceUsage_Executor_Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_id()) {
      mutable_id()->::mesos::TaskID::MergeFrom(from.id());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceUsage_Executor_Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceUsage_Executor_Task::CopyFrom(const ResourceUsage_Executor_Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceUsage_Executor_Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void ResourceUsage_Executor_Task::Swap(ResourceUsage_Executor_Task* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(id_, other->id_);
    resources_.Swap(&other->resources_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceUsage_Executor_Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceUsage_Executor_Task_descriptor_;
  metadata.reflection = ResourceUsage_Executor_Task_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ResourceUsage_Executor::kExecutorInfoFieldNumber;
const int ResourceUsage_Executor::kAllocatedFieldNumber;
const int ResourceUsage_Executor::kStatisticsFieldNumber;
const int ResourceUsage_Executor::kContainerIdFieldNumber;
const int ResourceUsage_Executor::kTasksFieldNumber;
#endif  // !_MSC_VER

ResourceUsage_Executor::ResourceUsage_Executor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceUsage.Executor)
}

void ResourceUsage_Executor::InitAsDefaultInstance() {
  executor_info_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  statistics_ = const_cast< ::mesos::ResourceStatistics*>(&::mesos::ResourceStatistics::default_instance());
  container_id_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
}

ResourceUsage_Executor::ResourceUsage_Executor(const ResourceUsage_Executor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceUsage.Executor)
}

void ResourceUsage_Executor::SharedCtor() {
  _cached_size_ = 0;
  executor_info_ = NULL;
  statistics_ = NULL;
  container_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceUsage_Executor::~ResourceUsage_Executor() {
  // @@protoc_insertion_point(destructor:mesos.ResourceUsage.Executor)
  SharedDtor();
}

void ResourceUsage_Executor::SharedDtor() {
  if (this != default_instance_) {
    delete executor_info_;
    delete statistics_;
    delete container_id_;
  }
}

void ResourceUsage_Executor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceUsage_Executor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceUsage_Executor_descriptor_;
}

const ResourceUsage_Executor& ResourceUsage_Executor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceUsage_Executor* ResourceUsage_Executor::default_instance_ = NULL;

ResourceUsage_Executor* ResourceUsage_Executor::New() const {
  return new ResourceUsage_Executor;
}

void ResourceUsage_Executor::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    if (has_executor_info()) {
      if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
    }
    if (has_statistics()) {
      if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
    }
    if (has_container_id()) {
      if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
    }
  }
  allocated_.Clear();
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceUsage_Executor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceUsage.Executor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorInfo executor_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_allocated;
        break;
      }

      // repeated .mesos.Resource allocated = 2;
      case 2: {
        if (tag == 18) {
         parse_allocated:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_allocated()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_allocated;
        if (input->ExpectTag(26)) goto parse_statistics;
        break;
      }

      // optional .mesos.ResourceStatistics statistics = 3;
      case 3: {
        if (tag == 26) {
         parse_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_container_id;
        break;
      }

      // required .mesos.ContainerID container_id = 4;
      case 4: {
        if (tag == 34) {
         parse_container_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_tasks;
        break;
      }

      // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
      case 5: {
        if (tag == 42) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_tasks;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceUsage.Executor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceUsage.Executor)
  return false;
#undef DO_
}

void ResourceUsage_Executor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceUsage.Executor)
  // required .mesos.ExecutorInfo executor_info = 1;
  if (has_executor_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_info(), output);
  }

  // repeated .mesos.Resource allocated = 2;
  for (int i = 0; i < this->allocated_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->allocated(i), output);
  }

  // optional .mesos.ResourceStatistics statistics = 3;
  if (has_statistics()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->statistics(), output);
  }

  // required .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->container_id(), output);
  }

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceUsage.Executor)
}

::google::protobuf::uint8* ResourceUsage_Executor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceUsage.Executor)
  // required .mesos.ExecutorInfo executor_info = 1;
  if (has_executor_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_info(), target);
  }

  // repeated .mesos.Resource allocated = 2;
  for (int i = 0; i < this->allocated_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->allocated(i), target);
  }

  // optional .mesos.ResourceStatistics statistics = 3;
  if (has_statistics()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->statistics(), target);
  }

  // required .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->container_id(), target);
  }

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceUsage.Executor)
  return target;
}

int ResourceUsage_Executor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorInfo executor_info = 1;
    if (has_executor_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_info());
    }

    // optional .mesos.ResourceStatistics statistics = 3;
    if (has_statistics()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->statistics());
    }

    // required .mesos.ContainerID container_id = 4;
    if (has_container_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container_id());
    }

  }
  // repeated .mesos.Resource allocated = 2;
  total_size += 1 * this->allocated_size();
  for (int i = 0; i < this->allocated_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->allocated(i));
  }

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceUsage_Executor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceUsage_Executor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceUsage_Executor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceUsage_Executor::MergeFrom(const ResourceUsage_Executor& from) {
  GOOGLE_CHECK_NE(&from, this);
  allocated_.MergeFrom(from.allocated_);
  tasks_.MergeFrom(from.tasks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_info()) {
      mutable_executor_info()->::mesos::ExecutorInfo::MergeFrom(from.executor_info());
    }
    if (from.has_statistics()) {
      mutable_statistics()->::mesos::ResourceStatistics::MergeFrom(from.statistics());
    }
    if (from.has_container_id()) {
      mutable_container_id()->::mesos::ContainerID::MergeFrom(from.container_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceUsage_Executor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceUsage_Executor::CopyFrom(const ResourceUsage_Executor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceUsage_Executor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  if (has_executor_info()) {
    if (!this->executor_info().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->allocated())) return false;
  if (has_statistics()) {
    if (!this->statistics().IsInitialized()) return false;
  }
  if (has_container_id()) {
    if (!this->container_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void ResourceUsage_Executor::Swap(ResourceUsage_Executor* other) {
  if (other != this) {
    std::swap(executor_info_, other->executor_info_);
    allocated_.Swap(&other->allocated_);
    std::swap(statistics_, other->statistics_);
    std::swap(container_id_, other->container_id_);
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceUsage_Executor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceUsage_Executor_descriptor_;
  metadata.reflection = ResourceUsage_Executor_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ResourceUsage::kExecutorsFieldNumber;
const int ResourceUsage::kTotalFieldNumber;
#endif  // !_MSC_VER

ResourceUsage::ResourceUsage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceUsage)
}

void ResourceUsage::InitAsDefaultInstance() {
}

ResourceUsage::ResourceUsage(const ResourceUsage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceUsage)
}

void ResourceUsage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceUsage::~ResourceUsage() {
  // @@protoc_insertion_point(destructor:mesos.ResourceUsage)
  SharedDtor();
}

void ResourceUsage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResourceUsage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceUsage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceUsage_descriptor_;
}

const ResourceUsage& ResourceUsage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceUsage* ResourceUsage::default_instance_ = NULL;

ResourceUsage* ResourceUsage::New() const {
  return new ResourceUsage;
}

void ResourceUsage::Clear() {
  executors_.Clear();
  total_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceUsage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceUsage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.ResourceUsage.Executor executors = 1;
      case 1: {
        if (tag == 10) {
         parse_executors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_executors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_executors;
        if (input->ExpectTag(18)) goto parse_total;
        break;
      }

      // repeated .mesos.Resource total = 2;
      case 2: {
        if (tag == 18) {
         parse_total:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_total()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_total;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceUsage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceUsage)
  return false;
#undef DO_
}

void ResourceUsage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceUsage)
  // repeated .mesos.ResourceUsage.Executor executors = 1;
  for (int i = 0; i < this->executors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executors(i), output);
  }

  // repeated .mesos.Resource total = 2;
  for (int i = 0; i < this->total_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->total(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceUsage)
}

::google::protobuf::uint8* ResourceUsage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceUsage)
  // repeated .mesos.ResourceUsage.Executor executors = 1;
  for (int i = 0; i < this->executors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executors(i), target);
  }

  // repeated .mesos.Resource total = 2;
  for (int i = 0; i < this->total_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->total(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceUsage)
  return target;
}

int ResourceUsage::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.ResourceUsage.Executor executors = 1;
  total_size += 1 * this->executors_size();
  for (int i = 0; i < this->executors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->executors(i));
  }

  // repeated .mesos.Resource total = 2;
  total_size += 1 * this->total_size();
  for (int i = 0; i < this->total_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->total(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceUsage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceUsage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceUsage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceUsage::MergeFrom(const ResourceUsage& from) {
  GOOGLE_CHECK_NE(&from, this);
  executors_.MergeFrom(from.executors_);
  total_.MergeFrom(from.total_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceUsage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceUsage::CopyFrom(const ResourceUsage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceUsage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->executors())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->total())) return false;
  return true;
}

void ResourceUsage::Swap(ResourceUsage* other) {
  if (other != this) {
    executors_.Swap(&other->executors_);
    total_.Swap(&other->total_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceUsage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceUsage_descriptor_;
  metadata.reflection = ResourceUsage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PerfStatistics::kTimestampFieldNumber;
const int PerfStatistics::kDurationFieldNumber;
const int PerfStatistics::kCyclesFieldNumber;
const int PerfStatistics::kStalledCyclesFrontendFieldNumber;
const int PerfStatistics::kStalledCyclesBackendFieldNumber;
const int PerfStatistics::kInstructionsFieldNumber;
const int PerfStatistics::kCacheReferencesFieldNumber;
const int PerfStatistics::kCacheMissesFieldNumber;
const int PerfStatistics::kBranchesFieldNumber;
const int PerfStatistics::kBranchMissesFieldNumber;
const int PerfStatistics::kBusCyclesFieldNumber;
const int PerfStatistics::kRefCyclesFieldNumber;
const int PerfStatistics::kCpuClockFieldNumber;
const int PerfStatistics::kTaskClockFieldNumber;
const int PerfStatistics::kPageFaultsFieldNumber;
const int PerfStatistics::kMinorFaultsFieldNumber;
const int PerfStatistics::kMajorFaultsFieldNumber;
const int PerfStatistics::kContextSwitchesFieldNumber;
const int PerfStatistics::kCpuMigrationsFieldNumber;
const int PerfStatistics::kAlignmentFaultsFieldNumber;
const int PerfStatistics::kEmulationFaultsFieldNumber;
const int PerfStatistics::kL1DcacheLoadsFieldNumber;
const int PerfStatistics::kL1DcacheLoadMissesFieldNumber;
const int PerfStatistics::kL1DcacheStoresFieldNumber;
const int PerfStatistics::kL1DcacheStoreMissesFieldNumber;
const int PerfStatistics::kL1DcachePrefetchesFieldNumber;
const int PerfStatistics::kL1DcachePrefetchMissesFieldNumber;
const int PerfStatistics::kL1IcacheLoadsFieldNumber;
const int PerfStatistics::kL1IcacheLoadMissesFieldNumber;
const int PerfStatistics::kL1IcachePrefetchesFieldNumber;
const int PerfStatistics::kL1IcachePrefetchMissesFieldNumber;
const int PerfStatistics::kLlcLoadsFieldNumber;
const int PerfStatistics::kLlcLoadMissesFieldNumber;
const int PerfStatistics::kLlcStoresFieldNumber;
const int PerfStatistics::kLlcStoreMissesFieldNumber;
const int PerfStatistics::kLlcPrefetchesFieldNumber;
const int PerfStatistics::kLlcPrefetchMissesFieldNumber;
const int PerfStatistics::kDtlbLoadsFieldNumber;
const int PerfStatistics::kDtlbLoadMissesFieldNumber;
const int PerfStatistics::kDtlbStoresFieldNumber;
const int PerfStatistics::kDtlbStoreMissesFieldNumber;
const int PerfStatistics::kDtlbPrefetchesFieldNumber;
const int PerfStatistics::kDtlbPrefetchMissesFieldNumber;
const int PerfStatistics::kItlbLoadsFieldNumber;
const int PerfStatistics::kItlbLoadMissesFieldNumber;
const int PerfStatistics::kBranchLoadsFieldNumber;
const int PerfStatistics::kBranchLoadMissesFieldNumber;
const int PerfStatistics::kNodeLoadsFieldNumber;
const int PerfStatistics::kNodeLoadMissesFieldNumber;
const int PerfStatistics::kNodeStoresFieldNumber;
const int PerfStatistics::kNodeStoreMissesFieldNumber;
const int PerfStatistics::kNodePrefetchesFieldNumber;
const int PerfStatistics::kNodePrefetchMissesFieldNumber;
#endif  // !_MSC_VER

PerfStatistics::PerfStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.PerfStatistics)
}

void PerfStatistics::InitAsDefaultInstance() {
}

PerfStatistics::PerfStatistics(const PerfStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.PerfStatistics)
}

void PerfStatistics::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  duration_ = 0;
  cycles_ = GOOGLE_ULONGLONG(0);
  stalled_cycles_frontend_ = GOOGLE_ULONGLONG(0);
  stalled_cycles_backend_ = GOOGLE_ULONGLONG(0);
  instructions_ = GOOGLE_ULONGLONG(0);
  cache_references_ = GOOGLE_ULONGLONG(0);
  cache_misses_ = GOOGLE_ULONGLONG(0);
  branches_ = GOOGLE_ULONGLONG(0);
  branch_misses_ = GOOGLE_ULONGLONG(0);
  bus_cycles_ = GOOGLE_ULONGLONG(0);
  ref_cycles_ = GOOGLE_ULONGLONG(0);
  cpu_clock_ = 0;
  task_clock_ = 0;
  page_faults_ = GOOGLE_ULONGLONG(0);
  minor_faults_ = GOOGLE_ULONGLONG(0);
  major_faults_ = GOOGLE_ULONGLONG(0);
  context_switches_ = GOOGLE_ULONGLONG(0);
  cpu_migrations_ = GOOGLE_ULONGLONG(0);
  alignment_faults_ = GOOGLE_ULONGLONG(0);
  emulation_faults_ = GOOGLE_ULONGLONG(0);
  l1_dcache_loads_ = GOOGLE_ULONGLONG(0);
  l1_dcache_load_misses_ = GOOGLE_ULONGLONG(0);
  l1_dcache_stores_ = GOOGLE_ULONGLONG(0);
  l1_dcache_store_misses_ = GOOGLE_ULONGLONG(0);
  l1_dcache_prefetches_ = GOOGLE_ULONGLONG(0);
  l1_dcache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  l1_icache_loads_ = GOOGLE_ULONGLONG(0);
  l1_icache_load_misses_ = GOOGLE_ULONGLONG(0);
  l1_icache_prefetches_ = GOOGLE_ULONGLONG(0);
  l1_icache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  llc_loads_ = GOOGLE_ULONGLONG(0);
  llc_load_misses_ = GOOGLE_ULONGLONG(0);
  llc_stores_ = GOOGLE_ULONGLONG(0);
  llc_store_misses_ = GOOGLE_ULONGLONG(0);
  llc_prefetches_ = GOOGLE_ULONGLONG(0);
  llc_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  dtlb_loads_ = GOOGLE_ULONGLONG(0);
  dtlb_load_misses_ = GOOGLE_ULONGLONG(0);
  dtlb_stores_ = GOOGLE_ULONGLONG(0);
  dtlb_store_misses_ = GOOGLE_ULONGLONG(0);
  dtlb_prefetches_ = GOOGLE_ULONGLONG(0);
  dtlb_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  itlb_loads_ = GOOGLE_ULONGLONG(0);
  itlb_load_misses_ = GOOGLE_ULONGLONG(0);
  branch_loads_ = GOOGLE_ULONGLONG(0);
  branch_load_misses_ = GOOGLE_ULONGLONG(0);
  node_loads_ = GOOGLE_ULONGLONG(0);
  node_load_misses_ = GOOGLE_ULONGLONG(0);
  node_stores_ = GOOGLE_ULONGLONG(0);
  node_store_misses_ = GOOGLE_ULONGLONG(0);
  node_prefetches_ = GOOGLE_ULONGLONG(0);
  node_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PerfStatistics::~PerfStatistics() {
  // @@protoc_insertion_point(destructor:mesos.PerfStatistics)
  SharedDtor();
}

void PerfStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PerfStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PerfStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PerfStatistics_descriptor_;
}

const PerfStatistics& PerfStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

PerfStatistics* PerfStatistics::default_instance_ = NULL;

PerfStatistics* PerfStatistics::New() const {
  return new PerfStatistics;
}

void PerfStatistics::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PerfStatistics*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(timestamp_, cache_misses_);
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(branches_, minor_faults_);
  }
  if (_has_bits_[16 / 32] & 16711680) {
    ZR_(major_faults_, l1_dcache_stores_);
  }
  if (_has_bits_[24 / 32] & 4278190080) {
    ZR_(l1_dcache_store_misses_, llc_loads_);
  }
  if (_has_bits_[32 / 32] & 255) {
    ZR_(llc_load_misses_, dtlb_stores_);
  }
  if (_has_bits_[40 / 32] & 65280) {
    ZR_(dtlb_store_misses_, node_loads_);
  }
  if (_has_bits_[48 / 32] & 2031616) {
    ZR_(node_load_misses_, node_prefetch_misses_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PerfStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.PerfStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_duration;
        break;
      }

      // required double duration = 2;
      case 2: {
        if (tag == 17) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_cycles;
        break;
      }

      // optional uint64 cycles = 3;
      case 3: {
        if (tag == 24) {
         parse_cycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cycles_)));
          set_has_cycles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_stalled_cycles_frontend;
        break;
      }

      // optional uint64 stalled_cycles_frontend = 4;
      case 4: {
        if (tag == 32) {
         parse_stalled_cycles_frontend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &stalled_cycles_frontend_)));
          set_has_stalled_cycles_frontend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_stalled_cycles_backend;
        break;
      }

      // optional uint64 stalled_cycles_backend = 5;
      case 5: {
        if (tag == 40) {
         parse_stalled_cycles_backend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &stalled_cycles_backend_)));
          set_has_stalled_cycles_backend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_instructions;
        break;
      }

      // optional uint64 instructions = 6;
      case 6: {
        if (tag == 48) {
         parse_instructions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &instructions_)));
          set_has_instructions();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_cache_references;
        break;
      }

      // optional uint64 cache_references = 7;
      case 7: {
        if (tag == 56) {
         parse_cache_references:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cache_references_)));
          set_has_cache_references();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_cache_misses;
        break;
      }

      // optional uint64 cache_misses = 8;
      case 8: {
        if (tag == 64) {
         parse_cache_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cache_misses_)));
          set_has_cache_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_branches;
        break;
      }

      // optional uint64 branches = 9;
      case 9: {
        if (tag == 72) {
         parse_branches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branches_)));
          set_has_branches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_branch_misses;
        break;
      }

      // optional uint64 branch_misses = 10;
      case 10: {
        if (tag == 80) {
         parse_branch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branch_misses_)));
          set_has_branch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_bus_cycles;
        break;
      }

      // optional uint64 bus_cycles = 11;
      case 11: {
        if (tag == 88) {
         parse_bus_cycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bus_cycles_)));
          set_has_bus_cycles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_ref_cycles;
        break;
      }

      // optional uint64 ref_cycles = 12;
      case 12: {
        if (tag == 96) {
         parse_ref_cycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ref_cycles_)));
          set_has_ref_cycles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(105)) goto parse_cpu_clock;
        break;
      }

      // optional double cpu_clock = 13;
      case 13: {
        if (tag == 105) {
         parse_cpu_clock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpu_clock_)));
          set_has_cpu_clock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(113)) goto parse_task_clock;
        break;
      }

      // optional double task_clock = 14;
      case 14: {
        if (tag == 113) {
         parse_task_clock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &task_clock_)));
          set_has_task_clock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_page_faults;
        break;
      }

      // optional uint64 page_faults = 15;
      case 15: {
        if (tag == 120) {
         parse_page_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_faults_)));
          set_has_page_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_minor_faults;
        break;
      }

      // optional uint64 minor_faults = 16;
      case 16: {
        if (tag == 128) {
         parse_minor_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &minor_faults_)));
          set_has_minor_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_major_faults;
        break;
      }

      // optional uint64 major_faults = 17;
      case 17: {
        if (tag == 136) {
         parse_major_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &major_faults_)));
          set_has_major_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_context_switches;
        break;
      }

      // optional uint64 context_switches = 18;
      case 18: {
        if (tag == 144) {
         parse_context_switches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &context_switches_)));
          set_has_context_switches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_cpu_migrations;
        break;
      }

      // optional uint64 cpu_migrations = 19;
      case 19: {
        if (tag == 152) {
         parse_cpu_migrations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cpu_migrations_)));
          set_has_cpu_migrations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_alignment_faults;
        break;
      }

      // optional uint64 alignment_faults = 20;
      case 20: {
        if (tag == 160) {
         parse_alignment_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &alignment_faults_)));
          set_has_alignment_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_emulation_faults;
        break;
      }

      // optional uint64 emulation_faults = 21;
      case 21: {
        if (tag == 168) {
         parse_emulation_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &emulation_faults_)));
          set_has_emulation_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_l1_dcache_loads;
        break;
      }

      // optional uint64 l1_dcache_loads = 22;
      case 22: {
        if (tag == 176) {
         parse_l1_dcache_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_loads_)));
          set_has_l1_dcache_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_l1_dcache_load_misses;
        break;
      }

      // optional uint64 l1_dcache_load_misses = 23;
      case 23: {
        if (tag == 184) {
         parse_l1_dcache_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_load_misses_)));
          set_has_l1_dcache_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_l1_dcache_stores;
        break;
      }

      // optional uint64 l1_dcache_stores = 24;
      case 24: {
        if (tag == 192) {
         parse_l1_dcache_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_stores_)));
          set_has_l1_dcache_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_l1_dcache_store_misses;
        break;
      }

      // optional uint64 l1_dcache_store_misses = 25;
      case 25: {
        if (tag == 200) {
         parse_l1_dcache_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_store_misses_)));
          set_has_l1_dcache_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_l1_dcache_prefetches;
        break;
      }

      // optional uint64 l1_dcache_prefetches = 26;
      case 26: {
        if (tag == 208) {
         parse_l1_dcache_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_prefetches_)));
          set_has_l1_dcache_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_l1_dcache_prefetch_misses;
        break;
      }

      // optional uint64 l1_dcache_prefetch_misses = 27;
      case 27: {
        if (tag == 216) {
         parse_l1_dcache_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_prefetch_misses_)));
          set_has_l1_dcache_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_l1_icache_loads;
        break;
      }

      // optional uint64 l1_icache_loads = 28;
      case 28: {
        if (tag == 224) {
         parse_l1_icache_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_loads_)));
          set_has_l1_icache_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_l1_icache_load_misses;
        break;
      }

      // optional uint64 l1_icache_load_misses = 29;
      case 29: {
        if (tag == 232) {
         parse_l1_icache_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_load_misses_)));
          set_has_l1_icache_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_l1_icache_prefetches;
        break;
      }

      // optional uint64 l1_icache_prefetches = 30;
      case 30: {
        if (tag == 240) {
         parse_l1_icache_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_prefetches_)));
          set_has_l1_icache_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_l1_icache_prefetch_misses;
        break;
      }

      // optional uint64 l1_icache_prefetch_misses = 31;
      case 31: {
        if (tag == 248) {
         parse_l1_icache_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_prefetch_misses_)));
          set_has_l1_icache_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_llc_loads;
        break;
      }

      // optional uint64 llc_loads = 32;
      case 32: {
        if (tag == 256) {
         parse_llc_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_loads_)));
          set_has_llc_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_llc_load_misses;
        break;
      }

      // optional uint64 llc_load_misses = 33;
      case 33: {
        if (tag == 264) {
         parse_llc_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_load_misses_)));
          set_has_llc_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_llc_stores;
        break;
      }

      // optional uint64 llc_stores = 34;
      case 34: {
        if (tag == 272) {
         parse_llc_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_stores_)));
          set_has_llc_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(280)) goto parse_llc_store_misses;
        break;
      }

      // optional uint64 llc_store_misses = 35;
      case 35: {
        if (tag == 280) {
         parse_llc_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_store_misses_)));
          set_has_llc_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_llc_prefetches;
        break;
      }

      // optional uint64 llc_prefetches = 36;
      case 36: {
        if (tag == 288) {
         parse_llc_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_prefetches_)));
          set_has_llc_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_llc_prefetch_misses;
        break;
      }

      // optional uint64 llc_prefetch_misses = 37;
      case 37: {
        if (tag == 296) {
         parse_llc_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_prefetch_misses_)));
          set_has_llc_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_dtlb_loads;
        break;
      }

      // optional uint64 dtlb_loads = 38;
      case 38: {
        if (tag == 304) {
         parse_dtlb_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_loads_)));
          set_has_dtlb_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(312)) goto parse_dtlb_load_misses;
        break;
      }

      // optional uint64 dtlb_load_misses = 39;
      case 39: {
        if (tag == 312) {
         parse_dtlb_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_load_misses_)));
          set_has_dtlb_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(320)) goto parse_dtlb_stores;
        break;
      }

      // optional uint64 dtlb_stores = 40;
      case 40: {
        if (tag == 320) {
         parse_dtlb_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_stores_)));
          set_has_dtlb_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_dtlb_store_misses;
        break;
      }

      // optional uint64 dtlb_store_misses = 41;
      case 41: {
        if (tag == 328) {
         parse_dtlb_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_store_misses_)));
          set_has_dtlb_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(336)) goto parse_dtlb_prefetches;
        break;
      }

      // optional uint64 dtlb_prefetches = 42;
      case 42: {
        if (tag == 336) {
         parse_dtlb_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_prefetches_)));
          set_has_dtlb_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(344)) goto parse_dtlb_prefetch_misses;
        break;
      }

      // optional uint64 dtlb_prefetch_misses = 43;
      case 43: {
        if (tag == 344) {
         parse_dtlb_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_prefetch_misses_)));
          set_has_dtlb_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(352)) goto parse_itlb_loads;
        break;
      }

      // optional uint64 itlb_loads = 44;
      case 44: {
        if (tag == 352) {
         parse_itlb_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itlb_loads_)));
          set_has_itlb_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(360)) goto parse_itlb_load_misses;
        break;
      }

      // optional uint64 itlb_load_misses = 45;
      case 45: {
        if (tag == 360) {
         parse_itlb_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itlb_load_misses_)));
          set_has_itlb_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(368)) goto parse_branch_loads;
        break;
      }

      // optional uint64 branch_loads = 46;
      case 46: {
        if (tag == 368) {
         parse_branch_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branch_loads_)));
          set_has_branch_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(376)) goto parse_branch_load_misses;
        break;
      }

      // optional uint64 branch_load_misses = 47;
      case 47: {
        if (tag == 376) {
         parse_branch_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branch_load_misses_)));
          set_has_branch_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(384)) goto parse_node_loads;
        break;
      }

      // optional uint64 node_loads = 48;
      case 48: {
        if (tag == 384) {
         parse_node_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_loads_)));
          set_has_node_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(392)) goto parse_node_load_misses;
        break;
      }

      // optional uint64 node_load_misses = 49;
      case 49: {
        if (tag == 392) {
         parse_node_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_load_misses_)));
          set_has_node_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(400)) goto parse_node_stores;
        break;
      }

      // optional uint64 node_stores = 50;
      case 50: {
        if (tag == 400) {
         parse_node_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_stores_)));
          set_has_node_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(408)) goto parse_node_store_misses;
        break;
      }

      // optional uint64 node_store_misses = 51;
      case 51: {
        if (tag == 408) {
         parse_node_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_store_misses_)));
          set_has_node_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(416)) goto parse_node_prefetches;
        break;
      }

      // optional uint64 node_prefetches = 52;
      case 52: {
        if (tag == 416) {
         parse_node_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_prefetches_)));
          set_has_node_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(424)) goto parse_node_prefetch_misses;
        break;
      }

      // optional uint64 node_prefetch_misses = 53;
      case 53: {
        if (tag == 424) {
         parse_node_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_prefetch_misses_)));
          set_has_node_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.PerfStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.PerfStatistics)
  return false;
#undef DO_
}

void PerfStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.PerfStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->timestamp(), output);
  }

  // required double duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->duration(), output);
  }

  // optional uint64 cycles = 3;
  if (has_cycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->cycles(), output);
  }

  // optional uint64 stalled_cycles_frontend = 4;
  if (has_stalled_cycles_frontend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->stalled_cycles_frontend(), output);
  }

  // optional uint64 stalled_cycles_backend = 5;
  if (has_stalled_cycles_backend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->stalled_cycles_backend(), output);
  }

  // optional uint64 instructions = 6;
  if (has_instructions()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->instructions(), output);
  }

  // optional uint64 cache_references = 7;
  if (has_cache_references()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->cache_references(), output);
  }

  // optional uint64 cache_misses = 8;
  if (has_cache_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->cache_misses(), output);
  }

  // optional uint64 branches = 9;
  if (has_branches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->branches(), output);
  }

  // optional uint64 branch_misses = 10;
  if (has_branch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->branch_misses(), output);
  }

  // optional uint64 bus_cycles = 11;
  if (has_bus_cycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->bus_cycles(), output);
  }

  // optional uint64 ref_cycles = 12;
  if (has_ref_cycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->ref_cycles(), output);
  }

  // optional double cpu_clock = 13;
  if (has_cpu_clock()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->cpu_clock(), output);
  }

  // optional double task_clock = 14;
  if (has_task_clock()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->task_clock(), output);
  }

  // optional uint64 page_faults = 15;
  if (has_page_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->page_faults(), output);
  }

  // optional uint64 minor_faults = 16;
  if (has_minor_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->minor_faults(), output);
  }

  // optional uint64 major_faults = 17;
  if (has_major_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->major_faults(), output);
  }

  // optional uint64 context_switches = 18;
  if (has_context_switches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->context_switches(), output);
  }

  // optional uint64 cpu_migrations = 19;
  if (has_cpu_migrations()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->cpu_migrations(), output);
  }

  // optional uint64 alignment_faults = 20;
  if (has_alignment_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(20, this->alignment_faults(), output);
  }

  // optional uint64 emulation_faults = 21;
  if (has_emulation_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->emulation_faults(), output);
  }

  // optional uint64 l1_dcache_loads = 22;
  if (has_l1_dcache_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(22, this->l1_dcache_loads(), output);
  }

  // optional uint64 l1_dcache_load_misses = 23;
  if (has_l1_dcache_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(23, this->l1_dcache_load_misses(), output);
  }

  // optional uint64 l1_dcache_stores = 24;
  if (has_l1_dcache_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(24, this->l1_dcache_stores(), output);
  }

  // optional uint64 l1_dcache_store_misses = 25;
  if (has_l1_dcache_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(25, this->l1_dcache_store_misses(), output);
  }

  // optional uint64 l1_dcache_prefetches = 26;
  if (has_l1_dcache_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->l1_dcache_prefetches(), output);
  }

  // optional uint64 l1_dcache_prefetch_misses = 27;
  if (has_l1_dcache_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(27, this->l1_dcache_prefetch_misses(), output);
  }

  // optional uint64 l1_icache_loads = 28;
  if (has_l1_icache_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(28, this->l1_icache_loads(), output);
  }

  // optional uint64 l1_icache_load_misses = 29;
  if (has_l1_icache_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(29, this->l1_icache_load_misses(), output);
  }

  // optional uint64 l1_icache_prefetches = 30;
  if (has_l1_icache_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(30, this->l1_icache_prefetches(), output);
  }

  // optional uint64 l1_icache_prefetch_misses = 31;
  if (has_l1_icache_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(31, this->l1_icache_prefetch_misses(), output);
  }

  // optional uint64 llc_loads = 32;
  if (has_llc_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(32, this->llc_loads(), output);
  }

  // optional uint64 llc_load_misses = 33;
  if (has_llc_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(33, this->llc_load_misses(), output);
  }

  // optional uint64 llc_stores = 34;
  if (has_llc_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(34, this->llc_stores(), output);
  }

  // optional uint64 llc_store_misses = 35;
  if (has_llc_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(35, this->llc_store_misses(), output);
  }

  // optional uint64 llc_prefetches = 36;
  if (has_llc_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(36, this->llc_prefetches(), output);
  }

  // optional uint64 llc_prefetch_misses = 37;
  if (has_llc_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(37, this->llc_prefetch_misses(), output);
  }

  // optional uint64 dtlb_loads = 38;
  if (has_dtlb_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(38, this->dtlb_loads(), output);
  }

  // optional uint64 dtlb_load_misses = 39;
  if (has_dtlb_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(39, this->dtlb_load_misses(), output);
  }

  // optional uint64 dtlb_stores = 40;
  if (has_dtlb_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(40, this->dtlb_stores(), output);
  }

  // optional uint64 dtlb_store_misses = 41;
  if (has_dtlb_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(41, this->dtlb_store_misses(), output);
  }

  // optional uint64 dtlb_prefetches = 42;
  if (has_dtlb_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(42, this->dtlb_prefetches(), output);
  }

  // optional uint64 dtlb_prefetch_misses = 43;
  if (has_dtlb_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(43, this->dtlb_prefetch_misses(), output);
  }

  // optional uint64 itlb_loads = 44;
  if (has_itlb_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(44, this->itlb_loads(), output);
  }

  // optional uint64 itlb_load_misses = 45;
  if (has_itlb_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(45, this->itlb_load_misses(), output);
  }

  // optional uint64 branch_loads = 46;
  if (has_branch_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(46, this->branch_loads(), output);
  }

  // optional uint64 branch_load_misses = 47;
  if (has_branch_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(47, this->branch_load_misses(), output);
  }

  // optional uint64 node_loads = 48;
  if (has_node_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(48, this->node_loads(), output);
  }

  // optional uint64 node_load_misses = 49;
  if (has_node_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(49, this->node_load_misses(), output);
  }

  // optional uint64 node_stores = 50;
  if (has_node_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(50, this->node_stores(), output);
  }

  // optional uint64 node_store_misses = 51;
  if (has_node_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(51, this->node_store_misses(), output);
  }

  // optional uint64 node_prefetches = 52;
  if (has_node_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(52, this->node_prefetches(), output);
  }

  // optional uint64 node_prefetch_misses = 53;
  if (has_node_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(53, this->node_prefetch_misses(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.PerfStatistics)
}

::google::protobuf::uint8* PerfStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.PerfStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->timestamp(), target);
  }

  // required double duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->duration(), target);
  }

  // optional uint64 cycles = 3;
  if (has_cycles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->cycles(), target);
  }

  // optional uint64 stalled_cycles_frontend = 4;
  if (has_stalled_cycles_frontend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->stalled_cycles_frontend(), target);
  }

  // optional uint64 stalled_cycles_backend = 5;
  if (has_stalled_cycles_backend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->stalled_cycles_backend(), target);
  }

  // optional uint64 instructions = 6;
  if (has_instructions()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->instructions(), target);
  }

  // optional uint64 cache_references = 7;
  if (has_cache_references()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->cache_references(), target);
  }

  // optional uint64 cache_misses = 8;
  if (has_cache_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->cache_misses(), target);
  }

  // optional uint64 branches = 9;
  if (has_branches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->branches(), target);
  }

  // optional uint64 branch_misses = 10;
  if (has_branch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->branch_misses(), target);
  }

  // optional uint64 bus_cycles = 11;
  if (has_bus_cycles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->bus_cycles(), target);
  }

  // optional uint64 ref_cycles = 12;
  if (has_ref_cycles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->ref_cycles(), target);
  }

  // optional double cpu_clock = 13;
  if (has_cpu_clock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->cpu_clock(), target);
  }

  // optional double task_clock = 14;
  if (has_task_clock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->task_clock(), target);
  }

  // optional uint64 page_faults = 15;
  if (has_page_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->page_faults(), target);
  }

  // optional uint64 minor_faults = 16;
  if (has_minor_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(16, this->minor_faults(), target);
  }

  // optional uint64 major_faults = 17;
  if (has_major_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(17, this->major_faults(), target);
  }

  // optional uint64 context_switches = 18;
  if (has_context_switches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(18, this->context_switches(), target);
  }

  // optional uint64 cpu_migrations = 19;
  if (has_cpu_migrations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(19, this->cpu_migrations(), target);
  }

  // optional uint64 alignment_faults = 20;
  if (has_alignment_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(20, this->alignment_faults(), target);
  }

  // optional uint64 emulation_faults = 21;
  if (has_emulation_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->emulation_faults(), target);
  }

  // optional uint64 l1_dcache_loads = 22;
  if (has_l1_dcache_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(22, this->l1_dcache_loads(), target);
  }

  // optional uint64 l1_dcache_load_misses = 23;
  if (has_l1_dcache_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(23, this->l1_dcache_load_misses(), target);
  }

  // optional uint64 l1_dcache_stores = 24;
  if (has_l1_dcache_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(24, this->l1_dcache_stores(), target);
  }

  // optional uint64 l1_dcache_store_misses = 25;
  if (has_l1_dcache_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(25, this->l1_dcache_store_misses(), target);
  }

  // optional uint64 l1_dcache_prefetches = 26;
  if (has_l1_dcache_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(26, this->l1_dcache_prefetches(), target);
  }

  // optional uint64 l1_dcache_prefetch_misses = 27;
  if (has_l1_dcache_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(27, this->l1_dcache_prefetch_misses(), target);
  }

  // optional uint64 l1_icache_loads = 28;
  if (has_l1_icache_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(28, this->l1_icache_loads(), target);
  }

  // optional uint64 l1_icache_load_misses = 29;
  if (has_l1_icache_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(29, this->l1_icache_load_misses(), target);
  }

  // optional uint64 l1_icache_prefetches = 30;
  if (has_l1_icache_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(30, this->l1_icache_prefetches(), target);
  }

  // optional uint64 l1_icache_prefetch_misses = 31;
  if (has_l1_icache_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(31, this->l1_icache_prefetch_misses(), target);
  }

  // optional uint64 llc_loads = 32;
  if (has_llc_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(32, this->llc_loads(), target);
  }

  // optional uint64 llc_load_misses = 33;
  if (has_llc_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(33, this->llc_load_misses(), target);
  }

  // optional uint64 llc_stores = 34;
  if (has_llc_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(34, this->llc_stores(), target);
  }

  // optional uint64 llc_store_misses = 35;
  if (has_llc_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(35, this->llc_store_misses(), target);
  }

  // optional uint64 llc_prefetches = 36;
  if (has_llc_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(36, this->llc_prefetches(), target);
  }

  // optional uint64 llc_prefetch_misses = 37;
  if (has_llc_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(37, this->llc_prefetch_misses(), target);
  }

  // optional uint64 dtlb_loads = 38;
  if (has_dtlb_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(38, this->dtlb_loads(), target);
  }

  // optional uint64 dtlb_load_misses = 39;
  if (has_dtlb_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(39, this->dtlb_load_misses(), target);
  }

  // optional uint64 dtlb_stores = 40;
  if (has_dtlb_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(40, this->dtlb_stores(), target);
  }

  // optional uint64 dtlb_store_misses = 41;
  if (has_dtlb_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(41, this->dtlb_store_misses(), target);
  }

  // optional uint64 dtlb_prefetches = 42;
  if (has_dtlb_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(42, this->dtlb_prefetches(), target);
  }

  // optional uint64 dtlb_prefetch_misses = 43;
  if (has_dtlb_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(43, this->dtlb_prefetch_misses(), target);
  }

  // optional uint64 itlb_loads = 44;
  if (has_itlb_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(44, this->itlb_loads(), target);
  }

  // optional uint64 itlb_load_misses = 45;
  if (has_itlb_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(45, this->itlb_load_misses(), target);
  }

  // optional uint64 branch_loads = 46;
  if (has_branch_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(46, this->branch_loads(), target);
  }

  // optional uint64 branch_load_misses = 47;
  if (has_branch_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(47, this->branch_load_misses(), target);
  }

  // optional uint64 node_loads = 48;
  if (has_node_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(48, this->node_loads(), target);
  }

  // optional uint64 node_load_misses = 49;
  if (has_node_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(49, this->node_load_misses(), target);
  }

  // optional uint64 node_stores = 50;
  if (has_node_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(50, this->node_stores(), target);
  }

  // optional uint64 node_store_misses = 51;
  if (has_node_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(51, this->node_store_misses(), target);
  }

  // optional uint64 node_prefetches = 52;
  if (has_node_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(52, this->node_prefetches(), target);
  }

  // optional uint64 node_prefetch_misses = 53;
  if (has_node_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(53, this->node_prefetch_misses(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.PerfStatistics)
  return target;
}

int PerfStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // required double duration = 2;
    if (has_duration()) {
      total_size += 1 + 8;
    }

    // optional uint64 cycles = 3;
    if (has_cycles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cycles());
    }

    // optional uint64 stalled_cycles_frontend = 4;
    if (has_stalled_cycles_frontend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->stalled_cycles_frontend());
    }

    // optional uint64 stalled_cycles_backend = 5;
    if (has_stalled_cycles_backend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->stalled_cycles_backend());
    }

    // optional uint64 instructions = 6;
    if (has_instructions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->instructions());
    }

    // optional uint64 cache_references = 7;
    if (has_cache_references()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cache_references());
    }

    // optional uint64 cache_misses = 8;
    if (has_cache_misses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cache_misses());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 branches = 9;
    if (has_branches()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branches());
    }

    // optional uint64 branch_misses = 10;
    if (has_branch_misses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branch_misses());
    }

    // optional uint64 bus_cycles = 11;
    if (has_bus_cycles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bus_cycles());
    }

    // optional uint64 ref_cycles = 12;
    if (has_ref_cycles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ref_cycles());
    }

    // optional double cpu_clock = 13;
    if (has_cpu_clock()) {
      total_size += 1 + 8;
    }

    // optional double task_clock = 14;
    if (has_task_clock()) {
      total_size += 1 + 8;
    }

    // optional uint64 page_faults = 15;
    if (has_page_faults()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->page_faults());
    }

    // optional uint64 minor_faults = 16;
    if (has_minor_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->minor_faults());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint64 major_faults = 17;
    if (has_major_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->major_faults());
    }

    // optional uint64 context_switches = 18;
    if (has_context_switches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->context_switches());
    }

    // optional uint64 cpu_migrations = 19;
    if (has_cpu_migrations()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cpu_migrations());
    }

    // optional uint64 alignment_faults = 20;
    if (has_alignment_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->alignment_faults());
    }

    // optional uint64 emulation_faults = 21;
    if (has_emulation_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->emulation_faults());
    }

    // optional uint64 l1_dcache_loads = 22;
    if (has_l1_dcache_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_loads());
    }

    // optional uint64 l1_dcache_load_misses = 23;
    if (has_l1_dcache_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_load_misses());
    }

    // optional uint64 l1_dcache_stores = 24;
    if (has_l1_dcache_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_stores());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional uint64 l1_dcache_store_misses = 25;
    if (has_l1_dcache_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_store_misses());
    }

    // optional uint64 l1_dcache_prefetches = 26;
    if (has_l1_dcache_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_prefetches());
    }

    // optional uint64 l1_dcache_prefetch_misses = 27;
    if (has_l1_dcache_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_prefetch_misses());
    }

    // optional uint64 l1_icache_loads = 28;
    if (has_l1_icache_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_loads());
    }

    // optional uint64 l1_icache_load_misses = 29;
    if (has_l1_icache_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_load_misses());
    }

    // optional uint64 l1_icache_prefetches = 30;
    if (has_l1_icache_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_prefetches());
    }

    // optional uint64 l1_icache_prefetch_misses = 31;
    if (has_l1_icache_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_prefetch_misses());
    }

    // optional uint64 llc_loads = 32;
    if (has_llc_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_loads());
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional uint64 llc_load_misses = 33;
    if (has_llc_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_load_misses());
    }

    // optional uint64 llc_stores = 34;
    if (has_llc_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_stores());
    }

    // optional uint64 llc_store_misses = 35;
    if (has_llc_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_store_misses());
    }

    // optional uint64 llc_prefetches = 36;
    if (has_llc_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_prefetches());
    }

    // optional uint64 llc_prefetch_misses = 37;
    if (has_llc_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_prefetch_misses());
    }

    // optional uint64 dtlb_loads = 38;
    if (has_dtlb_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_loads());
    }

    // optional uint64 dtlb_load_misses = 39;
    if (has_dtlb_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_load_misses());
    }

    // optional uint64 dtlb_stores = 40;
    if (has_dtlb_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_stores());
    }

  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional uint64 dtlb_store_misses = 41;
    if (has_dtlb_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_store_misses());
    }

    // optional uint64 dtlb_prefetches = 42;
    if (has_dtlb_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_prefetches());
    }

    // optional uint64 dtlb_prefetch_misses = 43;
    if (has_dtlb_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_prefetch_misses());
    }

    // optional uint64 itlb_loads = 44;
    if (has_itlb_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itlb_loads());
    }

    // optional uint64 itlb_load_misses = 45;
    if (has_itlb_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itlb_load_misses());
    }

    // optional uint64 branch_loads = 46;
    if (has_branch_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branch_loads());
    }

    // optional uint64 branch_load_misses = 47;
    if (has_branch_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branch_load_misses());
    }

    // optional uint64 node_loads = 48;
    if (has_node_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_loads());
    }

  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    // optional uint64 node_load_misses = 49;
    if (has_node_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_load_misses());
    }

    // optional uint64 node_stores = 50;
    if (has_node_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_stores());
    }

    // optional uint64 node_store_misses = 51;
    if (has_node_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_store_misses());
    }

    // optional uint64 node_prefetches = 52;
    if (has_node_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_prefetches());
    }

    // optional uint64 node_prefetch_misses = 53;
    if (has_node_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_prefetch_misses());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PerfStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PerfStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PerfStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PerfStatistics::MergeFrom(const PerfStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_cycles()) {
      set_cycles(from.cycles());
    }
    if (from.has_stalled_cycles_frontend()) {
      set_stalled_cycles_frontend(from.stalled_cycles_frontend());
    }
    if (from.has_stalled_cycles_backend()) {
      set_stalled_cycles_backend(from.stalled_cycles_backend());
    }
    if (from.has_instructions()) {
      set_instructions(from.instructions());
    }
    if (from.has_cache_references()) {
      set_cache_references(from.cache_references());
    }
    if (from.has_cache_misses()) {
      set_cache_misses(from.cache_misses());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_branches()) {
      set_branches(from.branches());
    }
    if (from.has_branch_misses()) {
      set_branch_misses(from.branch_misses());
    }
    if (from.has_bus_cycles()) {
      set_bus_cycles(from.bus_cycles());
    }
    if (from.has_ref_cycles()) {
      set_ref_cycles(from.ref_cycles());
    }
    if (from.has_cpu_clock()) {
      set_cpu_clock(from.cpu_clock());
    }
    if (from.has_task_clock()) {
      set_task_clock(from.task_clock());
    }
    if (from.has_page_faults()) {
      set_page_faults(from.page_faults());
    }
    if (from.has_minor_faults()) {
      set_minor_faults(from.minor_faults());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_major_faults()) {
      set_major_faults(from.major_faults());
    }
    if (from.has_context_switches()) {
      set_context_switches(from.context_switches());
    }
    if (from.has_cpu_migrations()) {
      set_cpu_migrations(from.cpu_migrations());
    }
    if (from.has_alignment_faults()) {
      set_alignment_faults(from.alignment_faults());
    }
    if (from.has_emulation_faults()) {
      set_emulation_faults(from.emulation_faults());
    }
    if (from.has_l1_dcache_loads()) {
      set_l1_dcache_loads(from.l1_dcache_loads());
    }
    if (from.has_l1_dcache_load_misses()) {
      set_l1_dcache_load_misses(from.l1_dcache_load_misses());
    }
    if (from.has_l1_dcache_stores()) {
      set_l1_dcache_stores(from.l1_dcache_stores());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_l1_dcache_store_misses()) {
      set_l1_dcache_store_misses(from.l1_dcache_store_misses());
    }
    if (from.has_l1_dcache_prefetches()) {
      set_l1_dcache_prefetches(from.l1_dcache_prefetches());
    }
    if (from.has_l1_dcache_prefetch_misses()) {
      set_l1_dcache_prefetch_misses(from.l1_dcache_prefetch_misses());
    }
    if (from.has_l1_icache_loads()) {
      set_l1_icache_loads(from.l1_icache_loads());
    }
    if (from.has_l1_icache_load_misses()) {
      set_l1_icache_load_misses(from.l1_icache_load_misses());
    }
    if (from.has_l1_icache_prefetches()) {
      set_l1_icache_prefetches(from.l1_icache_prefetches());
    }
    if (from.has_l1_icache_prefetch_misses()) {
      set_l1_icache_prefetch_misses(from.l1_icache_prefetch_misses());
    }
    if (from.has_llc_loads()) {
      set_llc_loads(from.llc_loads());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_llc_load_misses()) {
      set_llc_load_misses(from.llc_load_misses());
    }
    if (from.has_llc_stores()) {
      set_llc_stores(from.llc_stores());
    }
    if (from.has_llc_store_misses()) {
      set_llc_store_misses(from.llc_store_misses());
    }
    if (from.has_llc_prefetches()) {
      set_llc_prefetches(from.llc_prefetches());
    }
    if (from.has_llc_prefetch_misses()) {
      set_llc_prefetch_misses(from.llc_prefetch_misses());
    }
    if (from.has_dtlb_loads()) {
      set_dtlb_loads(from.dtlb_loads());
    }
    if (from.has_dtlb_load_misses()) {
      set_dtlb_load_misses(from.dtlb_load_misses());
    }
    if (from.has_dtlb_stores()) {
      set_dtlb_stores(from.dtlb_stores());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_dtlb_store_misses()) {
      set_dtlb_store_misses(from.dtlb_store_misses());
    }
    if (from.has_dtlb_prefetches()) {
      set_dtlb_prefetches(from.dtlb_prefetches());
    }
    if (from.has_dtlb_prefetch_misses()) {
      set_dtlb_prefetch_misses(from.dtlb_prefetch_misses());
    }
    if (from.has_itlb_loads()) {
      set_itlb_loads(from.itlb_loads());
    }
    if (from.has_itlb_load_misses()) {
      set_itlb_load_misses(from.itlb_load_misses());
    }
    if (from.has_branch_loads()) {
      set_branch_loads(from.branch_loads());
    }
    if (from.has_branch_load_misses()) {
      set_branch_load_misses(from.branch_load_misses());
    }
    if (from.has_node_loads()) {
      set_node_loads(from.node_loads());
    }
  }
  if (from._has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    if (from.has_node_load_misses()) {
      set_node_load_misses(from.node_load_misses());
    }
    if (from.has_node_stores()) {
      set_node_stores(from.node_stores());
    }
    if (from.has_node_store_misses()) {
      set_node_store_misses(from.node_store_misses());
    }
    if (from.has_node_prefetches()) {
      set_node_prefetches(from.node_prefetches());
    }
    if (from.has_node_prefetch_misses()) {
      set_node_prefetch_misses(from.node_prefetch_misses());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PerfStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PerfStatistics::CopyFrom(const PerfStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerfStatistics::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PerfStatistics::Swap(PerfStatistics* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(duration_, other->duration_);
    std::swap(cycles_, other->cycles_);
    std::swap(stalled_cycles_frontend_, other->stalled_cycles_frontend_);
    std::swap(stalled_cycles_backend_, other->stalled_cycles_backend_);
    std::swap(instructions_, other->instructions_);
    std::swap(cache_references_, other->cache_references_);
    std::swap(cache_misses_, other->cache_misses_);
    std::swap(branches_, other->branches_);
    std::swap(branch_misses_, other->branch_misses_);
    std::swap(bus_cycles_, other->bus_cycles_);
    std::swap(ref_cycles_, other->ref_cycles_);
    std::swap(cpu_clock_, other->cpu_clock_);
    std::swap(task_clock_, other->task_clock_);
    std::swap(page_faults_, other->page_faults_);
    std::swap(minor_faults_, other->minor_faults_);
    std::swap(major_faults_, other->major_faults_);
    std::swap(context_switches_, other->context_switches_);
    std::swap(cpu_migrations_, other->cpu_migrations_);
    std::swap(alignment_faults_, other->alignment_faults_);
    std::swap(emulation_faults_, other->emulation_faults_);
    std::swap(l1_dcache_loads_, other->l1_dcache_loads_);
    std::swap(l1_dcache_load_misses_, other->l1_dcache_load_misses_);
    std::swap(l1_dcache_stores_, other->l1_dcache_stores_);
    std::swap(l1_dcache_store_misses_, other->l1_dcache_store_misses_);
    std::swap(l1_dcache_prefetches_, other->l1_dcache_prefetches_);
    std::swap(l1_dcache_prefetch_misses_, other->l1_dcache_prefetch_misses_);
    std::swap(l1_icache_loads_, other->l1_icache_loads_);
    std::swap(l1_icache_load_misses_, other->l1_icache_load_misses_);
    std::swap(l1_icache_prefetches_, other->l1_icache_prefetches_);
    std::swap(l1_icache_prefetch_misses_, other->l1_icache_prefetch_misses_);
    std::swap(llc_loads_, other->llc_loads_);
    std::swap(llc_load_misses_, other->llc_load_misses_);
    std::swap(llc_stores_, other->llc_stores_);
    std::swap(llc_store_misses_, other->llc_store_misses_);
    std::swap(llc_prefetches_, other->llc_prefetches_);
    std::swap(llc_prefetch_misses_, other->llc_prefetch_misses_);
    std::swap(dtlb_loads_, other->dtlb_loads_);
    std::swap(dtlb_load_misses_, other->dtlb_load_misses_);
    std::swap(dtlb_stores_, other->dtlb_stores_);
    std::swap(dtlb_store_misses_, other->dtlb_store_misses_);
    std::swap(dtlb_prefetches_, other->dtlb_prefetches_);
    std::swap(dtlb_prefetch_misses_, other->dtlb_prefetch_misses_);
    std::swap(itlb_loads_, other->itlb_loads_);
    std::swap(itlb_load_misses_, other->itlb_load_misses_);
    std::swap(branch_loads_, other->branch_loads_);
    std::swap(branch_load_misses_, other->branch_load_misses_);
    std::swap(node_loads_, other->node_loads_);
    std::swap(node_load_misses_, other->node_load_misses_);
    std::swap(node_stores_, other->node_stores_);
    std::swap(node_store_misses_, other->node_store_misses_);
    std::swap(node_prefetches_, other->node_prefetches_);
    std::swap(node_prefetch_misses_, other->node_prefetch_misses_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PerfStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PerfStatistics_descriptor_;
  metadata.reflection = PerfStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Request::kSlaveIdFieldNumber;
const int Request::kResourcesFieldNumber;
#endif  // !_MSC_VER

Request::Request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Request)
}

void Request::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

Request::Request(const Request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Request)
}

void Request::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:mesos.Request)
  SharedDtor();
}

void Request::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_descriptor_;
}

const Request& Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Request* Request::default_instance_ = NULL;

Request* Request::New() const {
  return new Request;
}

void Request::Clear() {
  if (has_slave_id()) {
    if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 2;
      case 2: {
        if (tag == 18) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Request)
  return false;
#undef DO_
}

void Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Request)
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // repeated .mesos.Resource resources = 2;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Request)
}

::google::protobuf::uint8* Request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Request)
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // repeated .mesos.Resource resources = 2;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Request)
  return target;
}

int Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  // repeated .mesos.Resource resources = 2;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Request::MergeFrom(const Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Request::CopyFrom(const Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Request::Swap(Request* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Request_descriptor_;
  metadata.reflection = Request_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Type_descriptor_;
}
bool Offer_Operation_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Offer_Operation_Type Offer_Operation::UNKNOWN;
const Offer_Operation_Type Offer_Operation::LAUNCH;
const Offer_Operation_Type Offer_Operation::LAUNCH_GROUP;
const Offer_Operation_Type Offer_Operation::RESERVE;
const Offer_Operation_Type Offer_Operation::UNRESERVE;
const Offer_Operation_Type Offer_Operation::CREATE;
const Offer_Operation_Type Offer_Operation::DESTROY;
const Offer_Operation_Type Offer_Operation::Type_MIN;
const Offer_Operation_Type Offer_Operation::Type_MAX;
const int Offer_Operation::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Offer_Operation_Launch::kTaskInfosFieldNumber;
#endif  // !_MSC_VER

Offer_Operation_Launch::Offer_Operation_Launch()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Launch)
}

void Offer_Operation_Launch::InitAsDefaultInstance() {
}

Offer_Operation_Launch::Offer_Operation_Launch(const Offer_Operation_Launch& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Launch)
}

void Offer_Operation_Launch::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Launch::~Offer_Operation_Launch() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Launch)
  SharedDtor();
}

void Offer_Operation_Launch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Launch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Launch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Launch_descriptor_;
}

const Offer_Operation_Launch& Offer_Operation_Launch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Launch* Offer_Operation_Launch::default_instance_ = NULL;

Offer_Operation_Launch* Offer_Operation_Launch::New() const {
  return new Offer_Operation_Launch;
}

void Offer_Operation_Launch::Clear() {
  task_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation_Launch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Launch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.TaskInfo task_infos = 1;
      case 1: {
        if (tag == 10) {
         parse_task_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_task_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_task_infos;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Launch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Launch)
  return false;
#undef DO_
}

void Offer_Operation_Launch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Launch)
  // repeated .mesos.TaskInfo task_infos = 1;
  for (int i = 0; i < this->task_infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_infos(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Launch)
}

::google::protobuf::uint8* Offer_Operation_Launch::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Launch)
  // repeated .mesos.TaskInfo task_infos = 1;
  for (int i = 0; i < this->task_infos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_infos(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Launch)
  return target;
}

int Offer_Operation_Launch::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.TaskInfo task_infos = 1;
  total_size += 1 * this->task_infos_size();
  for (int i = 0; i < this->task_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->task_infos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Launch::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation_Launch* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation_Launch*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation_Launch::MergeFrom(const Offer_Operation_Launch& from) {
  GOOGLE_CHECK_NE(&from, this);
  task_infos_.MergeFrom(from.task_infos_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation_Launch::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Launch::CopyFrom(const Offer_Operation_Launch& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Launch::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->task_infos())) return false;
  return true;
}

void Offer_Operation_Launch::Swap(Offer_Operation_Launch* other) {
  if (other != this) {
    task_infos_.Swap(&other->task_infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation_Launch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Launch_descriptor_;
  metadata.reflection = Offer_Operation_Launch_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer_Operation_LaunchGroup::kExecutorFieldNumber;
const int Offer_Operation_LaunchGroup::kTaskGroupFieldNumber;
#endif  // !_MSC_VER

Offer_Operation_LaunchGroup::Offer_Operation_LaunchGroup()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.LaunchGroup)
}

void Offer_Operation_LaunchGroup::InitAsDefaultInstance() {
  executor_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  task_group_ = const_cast< ::mesos::TaskGroupInfo*>(&::mesos::TaskGroupInfo::default_instance());
}

Offer_Operation_LaunchGroup::Offer_Operation_LaunchGroup(const Offer_Operation_LaunchGroup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.LaunchGroup)
}

void Offer_Operation_LaunchGroup::SharedCtor() {
  _cached_size_ = 0;
  executor_ = NULL;
  task_group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_LaunchGroup::~Offer_Operation_LaunchGroup() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.LaunchGroup)
  SharedDtor();
}

void Offer_Operation_LaunchGroup::SharedDtor() {
  if (this != default_instance_) {
    delete executor_;
    delete task_group_;
  }
}

void Offer_Operation_LaunchGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_LaunchGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_LaunchGroup_descriptor_;
}

const Offer_Operation_LaunchGroup& Offer_Operation_LaunchGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_LaunchGroup* Offer_Operation_LaunchGroup::default_instance_ = NULL;

Offer_Operation_LaunchGroup* Offer_Operation_LaunchGroup::New() const {
  return new Offer_Operation_LaunchGroup;
}

void Offer_Operation_LaunchGroup::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_executor()) {
      if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
    }
    if (has_task_group()) {
      if (task_group_ != NULL) task_group_->::mesos::TaskGroupInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation_LaunchGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.LaunchGroup)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorInfo executor = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_group;
        break;
      }

      // required .mesos.TaskGroupInfo task_group = 2;
      case 2: {
        if (tag == 18) {
         parse_task_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_group()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.LaunchGroup)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.LaunchGroup)
  return false;
#undef DO_
}

void Offer_Operation_LaunchGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.LaunchGroup)
  // required .mesos.ExecutorInfo executor = 1;
  if (has_executor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor(), output);
  }

  // required .mesos.TaskGroupInfo task_group = 2;
  if (has_task_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_group(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.LaunchGroup)
}

::google::protobuf::uint8* Offer_Operation_LaunchGroup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.LaunchGroup)
  // required .mesos.ExecutorInfo executor = 1;
  if (has_executor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor(), target);
  }

  // required .mesos.TaskGroupInfo task_group = 2;
  if (has_task_group()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_group(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.LaunchGroup)
  return target;
}

int Offer_Operation_LaunchGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorInfo executor = 1;
    if (has_executor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor());
    }

    // required .mesos.TaskGroupInfo task_group = 2;
    if (has_task_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_group());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_LaunchGroup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation_LaunchGroup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation_LaunchGroup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation_LaunchGroup::MergeFrom(const Offer_Operation_LaunchGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor()) {
      mutable_executor()->::mesos::ExecutorInfo::MergeFrom(from.executor());
    }
    if (from.has_task_group()) {
      mutable_task_group()->::mesos::TaskGroupInfo::MergeFrom(from.task_group());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation_LaunchGroup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_LaunchGroup::CopyFrom(const Offer_Operation_LaunchGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_LaunchGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_executor()) {
    if (!this->executor().IsInitialized()) return false;
  }
  if (has_task_group()) {
    if (!this->task_group().IsInitialized()) return false;
  }
  return true;
}

void Offer_Operation_LaunchGroup::Swap(Offer_Operation_LaunchGroup* other) {
  if (other != this) {
    std::swap(executor_, other->executor_);
    std::swap(task_group_, other->task_group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation_LaunchGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_LaunchGroup_descriptor_;
  metadata.reflection = Offer_Operation_LaunchGroup_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer_Operation_Reserve::kResourcesFieldNumber;
#endif  // !_MSC_VER

Offer_Operation_Reserve::Offer_Operation_Reserve()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Reserve)
}

void Offer_Operation_Reserve::InitAsDefaultInstance() {
}

Offer_Operation_Reserve::Offer_Operation_Reserve(const Offer_Operation_Reserve& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Reserve)
}

void Offer_Operation_Reserve::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Reserve::~Offer_Operation_Reserve() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Reserve)
  SharedDtor();
}

void Offer_Operation_Reserve::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Reserve::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Reserve::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Reserve_descriptor_;
}

const Offer_Operation_Reserve& Offer_Operation_Reserve::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Reserve* Offer_Operation_Reserve::default_instance_ = NULL;

Offer_Operation_Reserve* Offer_Operation_Reserve::New() const {
  return new Offer_Operation_Reserve;
}

void Offer_Operation_Reserve::Clear() {
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation_Reserve::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Reserve)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (tag == 10) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Reserve)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Reserve)
  return false;
#undef DO_
}

void Offer_Operation_Reserve::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Reserve)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Reserve)
}

::google::protobuf::uint8* Offer_Operation_Reserve::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Reserve)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Reserve)
  return target;
}

int Offer_Operation_Reserve::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Reserve::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation_Reserve* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation_Reserve*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation_Reserve::MergeFrom(const Offer_Operation_Reserve& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation_Reserve::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Reserve::CopyFrom(const Offer_Operation_Reserve& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Reserve::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Offer_Operation_Reserve::Swap(Offer_Operation_Reserve* other) {
  if (other != this) {
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation_Reserve::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Reserve_descriptor_;
  metadata.reflection = Offer_Operation_Reserve_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer_Operation_Unreserve::kResourcesFieldNumber;
#endif  // !_MSC_VER

Offer_Operation_Unreserve::Offer_Operation_Unreserve()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Unreserve)
}

void Offer_Operation_Unreserve::InitAsDefaultInstance() {
}

Offer_Operation_Unreserve::Offer_Operation_Unreserve(const Offer_Operation_Unreserve& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Unreserve)
}

void Offer_Operation_Unreserve::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Unreserve::~Offer_Operation_Unreserve() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Unreserve)
  SharedDtor();
}

void Offer_Operation_Unreserve::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Unreserve::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Unreserve::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Unreserve_descriptor_;
}

const Offer_Operation_Unreserve& Offer_Operation_Unreserve::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Unreserve* Offer_Operation_Unreserve::default_instance_ = NULL;

Offer_Operation_Unreserve* Offer_Operation_Unreserve::New() const {
  return new Offer_Operation_Unreserve;
}

void Offer_Operation_Unreserve::Clear() {
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation_Unreserve::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Unreserve)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (tag == 10) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Unreserve)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Unreserve)
  return false;
#undef DO_
}

void Offer_Operation_Unreserve::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Unreserve)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Unreserve)
}

::google::protobuf::uint8* Offer_Operation_Unreserve::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Unreserve)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Unreserve)
  return target;
}

int Offer_Operation_Unreserve::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Unreserve::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation_Unreserve* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation_Unreserve*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation_Unreserve::MergeFrom(const Offer_Operation_Unreserve& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation_Unreserve::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Unreserve::CopyFrom(const Offer_Operation_Unreserve& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Unreserve::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Offer_Operation_Unreserve::Swap(Offer_Operation_Unreserve* other) {
  if (other != this) {
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation_Unreserve::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Unreserve_descriptor_;
  metadata.reflection = Offer_Operation_Unreserve_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer_Operation_Create::kVolumesFieldNumber;
#endif  // !_MSC_VER

Offer_Operation_Create::Offer_Operation_Create()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Create)
}

void Offer_Operation_Create::InitAsDefaultInstance() {
}

Offer_Operation_Create::Offer_Operation_Create(const Offer_Operation_Create& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Create)
}

void Offer_Operation_Create::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Create::~Offer_Operation_Create() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Create)
  SharedDtor();
}

void Offer_Operation_Create::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Create::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Create::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Create_descriptor_;
}

const Offer_Operation_Create& Offer_Operation_Create::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Create* Offer_Operation_Create::default_instance_ = NULL;

Offer_Operation_Create* Offer_Operation_Create::New() const {
  return new Offer_Operation_Create;
}

void Offer_Operation_Create::Clear() {
  volumes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation_Create::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Create)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource volumes = 1;
      case 1: {
        if (tag == 10) {
         parse_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_volumes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_volumes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Create)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Create)
  return false;
#undef DO_
}

void Offer_Operation_Create::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Create)
  // repeated .mesos.Resource volumes = 1;
  for (int i = 0; i < this->volumes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->volumes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Create)
}

::google::protobuf::uint8* Offer_Operation_Create::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Create)
  // repeated .mesos.Resource volumes = 1;
  for (int i = 0; i < this->volumes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->volumes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Create)
  return target;
}

int Offer_Operation_Create::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Resource volumes = 1;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Create::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation_Create* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation_Create*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation_Create::MergeFrom(const Offer_Operation_Create& from) {
  GOOGLE_CHECK_NE(&from, this);
  volumes_.MergeFrom(from.volumes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation_Create::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Create::CopyFrom(const Offer_Operation_Create& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Create::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->volumes())) return false;
  return true;
}

void Offer_Operation_Create::Swap(Offer_Operation_Create* other) {
  if (other != this) {
    volumes_.Swap(&other->volumes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation_Create::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Create_descriptor_;
  metadata.reflection = Offer_Operation_Create_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer_Operation_Destroy::kVolumesFieldNumber;
#endif  // !_MSC_VER

Offer_Operation_Destroy::Offer_Operation_Destroy()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Destroy)
}

void Offer_Operation_Destroy::InitAsDefaultInstance() {
}

Offer_Operation_Destroy::Offer_Operation_Destroy(const Offer_Operation_Destroy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Destroy)
}

void Offer_Operation_Destroy::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Destroy::~Offer_Operation_Destroy() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Destroy)
  SharedDtor();
}

void Offer_Operation_Destroy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Destroy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Destroy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Destroy_descriptor_;
}

const Offer_Operation_Destroy& Offer_Operation_Destroy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Destroy* Offer_Operation_Destroy::default_instance_ = NULL;

Offer_Operation_Destroy* Offer_Operation_Destroy::New() const {
  return new Offer_Operation_Destroy;
}

void Offer_Operation_Destroy::Clear() {
  volumes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation_Destroy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Destroy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource volumes = 1;
      case 1: {
        if (tag == 10) {
         parse_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_volumes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_volumes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Destroy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Destroy)
  return false;
#undef DO_
}

void Offer_Operation_Destroy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Destroy)
  // repeated .mesos.Resource volumes = 1;
  for (int i = 0; i < this->volumes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->volumes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Destroy)
}

::google::protobuf::uint8* Offer_Operation_Destroy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Destroy)
  // repeated .mesos.Resource volumes = 1;
  for (int i = 0; i < this->volumes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->volumes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Destroy)
  return target;
}

int Offer_Operation_Destroy::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Resource volumes = 1;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Destroy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation_Destroy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation_Destroy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation_Destroy::MergeFrom(const Offer_Operation_Destroy& from) {
  GOOGLE_CHECK_NE(&from, this);
  volumes_.MergeFrom(from.volumes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation_Destroy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Destroy::CopyFrom(const Offer_Operation_Destroy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Destroy::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->volumes())) return false;
  return true;
}

void Offer_Operation_Destroy::Swap(Offer_Operation_Destroy* other) {
  if (other != this) {
    volumes_.Swap(&other->volumes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation_Destroy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Destroy_descriptor_;
  metadata.reflection = Offer_Operation_Destroy_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer_Operation::kTypeFieldNumber;
const int Offer_Operation::kLaunchFieldNumber;
const int Offer_Operation::kLaunchGroupFieldNumber;
const int Offer_Operation::kReserveFieldNumber;
const int Offer_Operation::kUnreserveFieldNumber;
const int Offer_Operation::kCreateFieldNumber;
const int Offer_Operation::kDestroyFieldNumber;
#endif  // !_MSC_VER

Offer_Operation::Offer_Operation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation)
}

void Offer_Operation::InitAsDefaultInstance() {
  launch_ = const_cast< ::mesos::Offer_Operation_Launch*>(&::mesos::Offer_Operation_Launch::default_instance());
  launch_group_ = const_cast< ::mesos::Offer_Operation_LaunchGroup*>(&::mesos::Offer_Operation_LaunchGroup::default_instance());
  reserve_ = const_cast< ::mesos::Offer_Operation_Reserve*>(&::mesos::Offer_Operation_Reserve::default_instance());
  unreserve_ = const_cast< ::mesos::Offer_Operation_Unreserve*>(&::mesos::Offer_Operation_Unreserve::default_instance());
  create_ = const_cast< ::mesos::Offer_Operation_Create*>(&::mesos::Offer_Operation_Create::default_instance());
  destroy_ = const_cast< ::mesos::Offer_Operation_Destroy*>(&::mesos::Offer_Operation_Destroy::default_instance());
}

Offer_Operation::Offer_Operation(const Offer_Operation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation)
}

void Offer_Operation::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  launch_ = NULL;
  launch_group_ = NULL;
  reserve_ = NULL;
  unreserve_ = NULL;
  create_ = NULL;
  destroy_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation::~Offer_Operation() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation)
  SharedDtor();
}

void Offer_Operation::SharedDtor() {
  if (this != default_instance_) {
    delete launch_;
    delete launch_group_;
    delete reserve_;
    delete unreserve_;
    delete create_;
    delete destroy_;
  }
}

void Offer_Operation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_descriptor_;
}

const Offer_Operation& Offer_Operation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation* Offer_Operation::default_instance_ = NULL;

Offer_Operation* Offer_Operation::New() const {
  return new Offer_Operation;
}

void Offer_Operation::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    type_ = 0;
    if (has_launch()) {
      if (launch_ != NULL) launch_->::mesos::Offer_Operation_Launch::Clear();
    }
    if (has_launch_group()) {
      if (launch_group_ != NULL) launch_group_->::mesos::Offer_Operation_LaunchGroup::Clear();
    }
    if (has_reserve()) {
      if (reserve_ != NULL) reserve_->::mesos::Offer_Operation_Reserve::Clear();
    }
    if (has_unreserve()) {
      if (unreserve_ != NULL) unreserve_->::mesos::Offer_Operation_Unreserve::Clear();
    }
    if (has_create()) {
      if (create_ != NULL) create_->::mesos::Offer_Operation_Create::Clear();
    }
    if (has_destroy()) {
      if (destroy_ != NULL) destroy_->::mesos::Offer_Operation_Destroy::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer_Operation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Offer.Operation.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Offer_Operation_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Offer_Operation_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_launch;
        break;
      }

      // optional .mesos.Offer.Operation.Launch launch = 2;
      case 2: {
        if (tag == 18) {
         parse_launch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_launch()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_reserve;
        break;
      }

      // optional .mesos.Offer.Operation.Reserve reserve = 3;
      case 3: {
        if (tag == 26) {
         parse_reserve:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reserve()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_unreserve;
        break;
      }

      // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
      case 4: {
        if (tag == 34) {
         parse_unreserve:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unreserve()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_create;
        break;
      }

      // optional .mesos.Offer.Operation.Create create = 5;
      case 5: {
        if (tag == 42) {
         parse_create:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_create()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_destroy;
        break;
      }

      // optional .mesos.Offer.Operation.Destroy destroy = 6;
      case 6: {
        if (tag == 50) {
         parse_destroy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_destroy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_launch_group;
        break;
      }

      // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
      case 7: {
        if (tag == 58) {
         parse_launch_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_launch_group()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation)
  return false;
#undef DO_
}

void Offer_Operation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation)
  // optional .mesos.Offer.Operation.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Offer.Operation.Launch launch = 2;
  if (has_launch()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->launch(), output);
  }

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->reserve(), output);
  }

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  if (has_unreserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->unreserve(), output);
  }

  // optional .mesos.Offer.Operation.Create create = 5;
  if (has_create()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->create(), output);
  }

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  if (has_destroy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->destroy(), output);
  }

  // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
  if (has_launch_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->launch_group(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation)
}

::google::protobuf::uint8* Offer_Operation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation)
  // optional .mesos.Offer.Operation.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Offer.Operation.Launch launch = 2;
  if (has_launch()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->launch(), target);
  }

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  if (has_reserve()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->reserve(), target);
  }

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  if (has_unreserve()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->unreserve(), target);
  }

  // optional .mesos.Offer.Operation.Create create = 5;
  if (has_create()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->create(), target);
  }

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  if (has_destroy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->destroy(), target);
  }

  // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
  if (has_launch_group()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->launch_group(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation)
  return target;
}

int Offer_Operation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Offer.Operation.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Offer.Operation.Launch launch = 2;
    if (has_launch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->launch());
    }

    // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
    if (has_launch_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->launch_group());
    }

    // optional .mesos.Offer.Operation.Reserve reserve = 3;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reserve());
    }

    // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
    if (has_unreserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unreserve());
    }

    // optional .mesos.Offer.Operation.Create create = 5;
    if (has_create()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->create());
    }

    // optional .mesos.Offer.Operation.Destroy destroy = 6;
    if (has_destroy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->destroy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer_Operation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer_Operation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer_Operation::MergeFrom(const Offer_Operation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_launch()) {
      mutable_launch()->::mesos::Offer_Operation_Launch::MergeFrom(from.launch());
    }
    if (from.has_launch_group()) {
      mutable_launch_group()->::mesos::Offer_Operation_LaunchGroup::MergeFrom(from.launch_group());
    }
    if (from.has_reserve()) {
      mutable_reserve()->::mesos::Offer_Operation_Reserve::MergeFrom(from.reserve());
    }
    if (from.has_unreserve()) {
      mutable_unreserve()->::mesos::Offer_Operation_Unreserve::MergeFrom(from.unreserve());
    }
    if (from.has_create()) {
      mutable_create()->::mesos::Offer_Operation_Create::MergeFrom(from.create());
    }
    if (from.has_destroy()) {
      mutable_destroy()->::mesos::Offer_Operation_Destroy::MergeFrom(from.destroy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer_Operation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation::CopyFrom(const Offer_Operation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation::IsInitialized() const {

  if (has_launch()) {
    if (!this->launch().IsInitialized()) return false;
  }
  if (has_launch_group()) {
    if (!this->launch_group().IsInitialized()) return false;
  }
  if (has_reserve()) {
    if (!this->reserve().IsInitialized()) return false;
  }
  if (has_unreserve()) {
    if (!this->unreserve().IsInitialized()) return false;
  }
  if (has_create()) {
    if (!this->create().IsInitialized()) return false;
  }
  if (has_destroy()) {
    if (!this->destroy().IsInitialized()) return false;
  }
  return true;
}

void Offer_Operation::Swap(Offer_Operation* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(launch_, other->launch_);
    std::swap(launch_group_, other->launch_group_);
    std::swap(reserve_, other->reserve_);
    std::swap(unreserve_, other->unreserve_);
    std::swap(create_, other->create_);
    std::swap(destroy_, other->destroy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer_Operation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_descriptor_;
  metadata.reflection = Offer_Operation_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Offer::kIdFieldNumber;
const int Offer::kFrameworkIdFieldNumber;
const int Offer::kSlaveIdFieldNumber;
const int Offer::kHostnameFieldNumber;
const int Offer::kUrlFieldNumber;
const int Offer::kResourcesFieldNumber;
const int Offer::kAttributesFieldNumber;
const int Offer::kExecutorIdsFieldNumber;
const int Offer::kUnavailabilityFieldNumber;
const int Offer::kAllocationInfoFieldNumber;
#endif  // !_MSC_VER

Offer::Offer()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer)
}

void Offer::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  url_ = const_cast< ::mesos::URL*>(&::mesos::URL::default_instance());
  unavailability_ = const_cast< ::mesos::Unavailability*>(&::mesos::Unavailability::default_instance());
  allocation_info_ = const_cast< ::mesos::Resource_AllocationInfo*>(&::mesos::Resource_AllocationInfo::default_instance());
}

Offer::Offer(const Offer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer)
}

void Offer::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = NULL;
  framework_id_ = NULL;
  slave_id_ = NULL;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  url_ = NULL;
  unavailability_ = NULL;
  allocation_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer::~Offer() {
  // @@protoc_insertion_point(destructor:mesos.Offer)
  SharedDtor();
}

void Offer::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (this != default_instance_) {
    delete id_;
    delete framework_id_;
    delete slave_id_;
    delete url_;
    delete unavailability_;
    delete allocation_info_;
  }
}

void Offer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_descriptor_;
}

const Offer& Offer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer* Offer::default_instance_ = NULL;

Offer* Offer::New() const {
  return new Offer;
}

void Offer::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::OfferID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    if (has_url()) {
      if (url_ != NULL) url_->::mesos::URL::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 768) {
    if (has_unavailability()) {
      if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
    }
    if (has_allocation_info()) {
      if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
    }
  }
  resources_.Clear();
  attributes_.Clear();
  executor_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Offer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 3;
      case 3: {
        if (tag == 26) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_hostname;
        break;
      }

      // required string hostname = 4;
      case 4: {
        if (tag == 34) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 5;
      case 5: {
        if (tag == 42) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        if (input->ExpectTag(50)) goto parse_executor_ids;
        break;
      }

      // repeated .mesos.ExecutorID executor_ids = 6;
      case 6: {
        if (tag == 50) {
         parse_executor_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_executor_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_executor_ids;
        if (input->ExpectTag(58)) goto parse_attributes;
        break;
      }

      // repeated .mesos.Attribute attributes = 7;
      case 7: {
        if (tag == 58) {
         parse_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attributes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_attributes;
        if (input->ExpectTag(66)) goto parse_url;
        break;
      }

      // optional .mesos.URL url = 8;
      case 8: {
        if (tag == 66) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_unavailability;
        break;
      }

      // optional .mesos.Unavailability unavailability = 9;
      case 9: {
        if (tag == 74) {
         parse_unavailability:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unavailability()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_allocation_info;
        break;
      }

      // optional .mesos.Resource.AllocationInfo allocation_info = 10;
      case 10: {
        if (tag == 82) {
         parse_allocation_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_allocation_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer)
  return false;
#undef DO_
}

void Offer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->slave_id(), output);
  }

  // required string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->hostname(), output);
  }

  // repeated .mesos.Resource resources = 5;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->resources(i), output);
  }

  // repeated .mesos.ExecutorID executor_ids = 6;
  for (int i = 0; i < this->executor_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->executor_ids(i), output);
  }

  // repeated .mesos.Attribute attributes = 7;
  for (int i = 0; i < this->attributes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->attributes(i), output);
  }

  // optional .mesos.URL url = 8;
  if (has_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->url(), output);
  }

  // optional .mesos.Unavailability unavailability = 9;
  if (has_unavailability()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->unavailability(), output);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 10;
  if (has_allocation_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->allocation_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer)
}

::google::protobuf::uint8* Offer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->slave_id(), target);
  }

  // required string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->hostname(), target);
  }

  // repeated .mesos.Resource resources = 5;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->resources(i), target);
  }

  // repeated .mesos.ExecutorID executor_ids = 6;
  for (int i = 0; i < this->executor_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->executor_ids(i), target);
  }

  // repeated .mesos.Attribute attributes = 7;
  for (int i = 0; i < this->attributes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->attributes(i), target);
  }

  // optional .mesos.URL url = 8;
  if (has_url()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->url(), target);
  }

  // optional .mesos.Unavailability unavailability = 9;
  if (has_unavailability()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->unavailability(), target);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 10;
  if (has_allocation_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->allocation_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer)
  return target;
}

int Offer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.SlaveID slave_id = 3;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required string hostname = 4;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional .mesos.URL url = 8;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->url());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.Unavailability unavailability = 9;
    if (has_unavailability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unavailability());
    }

    // optional .mesos.Resource.AllocationInfo allocation_info = 10;
    if (has_allocation_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->allocation_info());
    }

  }
  // repeated .mesos.Resource resources = 5;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.Attribute attributes = 7;
  total_size += 1 * this->attributes_size();
  for (int i = 0; i < this->attributes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attributes(i));
  }

  // repeated .mesos.ExecutorID executor_ids = 6;
  total_size += 1 * this->executor_ids_size();
  for (int i = 0; i < this->executor_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->executor_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Offer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Offer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Offer::MergeFrom(const Offer& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  attributes_.MergeFrom(from.attributes_);
  executor_ids_.MergeFrom(from.executor_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::mesos::OfferID::MergeFrom(from.id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_url()) {
      mutable_url()->::mesos::URL::MergeFrom(from.url());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_unavailability()) {
      mutable_unavailability()->::mesos::Unavailability::MergeFrom(from.unavailability());
    }
    if (from.has_allocation_info()) {
      mutable_allocation_info()->::mesos::Resource_AllocationInfo::MergeFrom(from.allocation_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Offer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer::CopyFrom(const Offer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_url()) {
    if (!this->url().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->attributes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->executor_ids())) return false;
  if (has_unavailability()) {
    if (!this->unavailability().IsInitialized()) return false;
  }
  return true;
}

void Offer::Swap(Offer* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(hostname_, other->hostname_);
    std::swap(url_, other->url_);
    resources_.Swap(&other->resources_);
    attributes_.Swap(&other->attributes_);
    executor_ids_.Swap(&other->executor_ids_);
    std::swap(unavailability_, other->unavailability_);
    std::swap(allocation_info_, other->allocation_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Offer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_descriptor_;
  metadata.reflection = Offer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InverseOffer::kIdFieldNumber;
const int InverseOffer::kUrlFieldNumber;
const int InverseOffer::kFrameworkIdFieldNumber;
const int InverseOffer::kSlaveIdFieldNumber;
const int InverseOffer::kUnavailabilityFieldNumber;
const int InverseOffer::kResourcesFieldNumber;
#endif  // !_MSC_VER

InverseOffer::InverseOffer()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.InverseOffer)
}

void InverseOffer::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
  url_ = const_cast< ::mesos::URL*>(&::mesos::URL::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  unavailability_ = const_cast< ::mesos::Unavailability*>(&::mesos::Unavailability::default_instance());
}

InverseOffer::InverseOffer(const InverseOffer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.InverseOffer)
}

void InverseOffer::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  url_ = NULL;
  framework_id_ = NULL;
  slave_id_ = NULL;
  unavailability_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InverseOffer::~InverseOffer() {
  // @@protoc_insertion_point(destructor:mesos.InverseOffer)
  SharedDtor();
}

void InverseOffer::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete url_;
    delete framework_id_;
    delete slave_id_;
    delete unavailability_;
  }
}

void InverseOffer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InverseOffer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InverseOffer_descriptor_;
}

const InverseOffer& InverseOffer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

InverseOffer* InverseOffer::default_instance_ = NULL;

InverseOffer* InverseOffer::New() const {
  return new InverseOffer;
}

void InverseOffer::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::OfferID::Clear();
    }
    if (has_url()) {
      if (url_ != NULL) url_->::mesos::URL::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_unavailability()) {
      if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InverseOffer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.InverseOffer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_url;
        break;
      }

      // optional .mesos.URL url = 2;
      case 2: {
        if (tag == 18) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (tag == 26) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 4;
      case 4: {
        if (tag == 34) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_unavailability;
        break;
      }

      // required .mesos.Unavailability unavailability = 5;
      case 5: {
        if (tag == 42) {
         parse_unavailability:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unavailability()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 6;
      case 6: {
        if (tag == 50) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.InverseOffer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.InverseOffer)
  return false;
#undef DO_
}

void InverseOffer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.InverseOffer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->id(), output);
  }

  // optional .mesos.URL url = 2;
  if (has_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->url(), output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework_id(), output);
  }

  // optional .mesos.SlaveID slave_id = 4;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->slave_id(), output);
  }

  // required .mesos.Unavailability unavailability = 5;
  if (has_unavailability()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->unavailability(), output);
  }

  // repeated .mesos.Resource resources = 6;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.InverseOffer)
}

::google::protobuf::uint8* InverseOffer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.InverseOffer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->id(), target);
  }

  // optional .mesos.URL url = 2;
  if (has_url()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->url(), target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework_id(), target);
  }

  // optional .mesos.SlaveID slave_id = 4;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->slave_id(), target);
  }

  // required .mesos.Unavailability unavailability = 5;
  if (has_unavailability()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->unavailability(), target);
  }

  // repeated .mesos.Resource resources = 6;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.InverseOffer)
  return target;
}

int InverseOffer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional .mesos.URL url = 2;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->url());
    }

    // required .mesos.FrameworkID framework_id = 3;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.SlaveID slave_id = 4;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.Unavailability unavailability = 5;
    if (has_unavailability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unavailability());
    }

  }
  // repeated .mesos.Resource resources = 6;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InverseOffer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InverseOffer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InverseOffer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InverseOffer::MergeFrom(const InverseOffer& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::mesos::OfferID::MergeFrom(from.id());
    }
    if (from.has_url()) {
      mutable_url()->::mesos::URL::MergeFrom(from.url());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_unavailability()) {
      mutable_unavailability()->::mesos::Unavailability::MergeFrom(from.unavailability());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InverseOffer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InverseOffer::CopyFrom(const InverseOffer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InverseOffer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000015) != 0x00000015) return false;

  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  if (has_url()) {
    if (!this->url().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_unavailability()) {
    if (!this->unavailability().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void InverseOffer::Swap(InverseOffer* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(url_, other->url_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(unavailability_, other->unavailability_);
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InverseOffer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InverseOffer_descriptor_;
  metadata.reflection = InverseOffer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskInfo::kNameFieldNumber;
const int TaskInfo::kTaskIdFieldNumber;
const int TaskInfo::kSlaveIdFieldNumber;
const int TaskInfo::kResourcesFieldNumber;
const int TaskInfo::kExecutorFieldNumber;
const int TaskInfo::kCommandFieldNumber;
const int TaskInfo::kContainerFieldNumber;
const int TaskInfo::kHealthCheckFieldNumber;
const int TaskInfo::kCheckFieldNumber;
const int TaskInfo::kKillPolicyFieldNumber;
const int TaskInfo::kDataFieldNumber;
const int TaskInfo::kLabelsFieldNumber;
const int TaskInfo::kDiscoveryFieldNumber;
#endif  // !_MSC_VER

TaskInfo::TaskInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskInfo)
}

void TaskInfo::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  container_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
  health_check_ = const_cast< ::mesos::HealthCheck*>(&::mesos::HealthCheck::default_instance());
  check_ = const_cast< ::mesos::CheckInfo*>(&::mesos::CheckInfo::default_instance());
  kill_policy_ = const_cast< ::mesos::KillPolicy*>(&::mesos::KillPolicy::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
}

TaskInfo::TaskInfo(const TaskInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskInfo)
}

void TaskInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_ = NULL;
  slave_id_ = NULL;
  executor_ = NULL;
  command_ = NULL;
  container_ = NULL;
  health_check_ = NULL;
  check_ = NULL;
  kill_policy_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  discovery_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskInfo::~TaskInfo() {
  // @@protoc_insertion_point(destructor:mesos.TaskInfo)
  SharedDtor();
}

void TaskInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
    delete task_id_;
    delete slave_id_;
    delete executor_;
    delete command_;
    delete container_;
    delete health_check_;
    delete check_;
    delete kill_policy_;
    delete labels_;
    delete discovery_;
  }
}

void TaskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskInfo_descriptor_;
}

const TaskInfo& TaskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskInfo* TaskInfo::default_instance_ = NULL;

TaskInfo* TaskInfo::New() const {
  return new TaskInfo;
}

void TaskInfo::Clear() {
  if (_has_bits_[0 / 32] & 247) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor()) {
      if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
    }
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
    }
    if (has_health_check()) {
      if (health_check_ != NULL) health_check_->::mesos::HealthCheck::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 7936) {
    if (has_check()) {
      if (check_ != NULL) check_->::mesos::CheckInfo::Clear();
    }
    if (has_kill_policy()) {
      if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 3;
      case 3: {
        if (tag == 26) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 4;
      case 4: {
        if (tag == 34) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_resources;
        if (input->ExpectTag(42)) goto parse_executor;
        break;
      }

      // optional .mesos.ExecutorInfo executor = 5;
      case 5: {
        if (tag == 42) {
         parse_executor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_data;
        break;
      }

      // optional bytes data = 6;
      case 6: {
        if (tag == 50) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 7;
      case 7: {
        if (tag == 58) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_health_check;
        break;
      }

      // optional .mesos.HealthCheck health_check = 8;
      case 8: {
        if (tag == 66) {
         parse_health_check:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_health_check()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_container;
        break;
      }

      // optional .mesos.ContainerInfo container = 9;
      case 9: {
        if (tag == 74) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 10;
      case 10: {
        if (tag == 82) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 11;
      case 11: {
        if (tag == 90) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_kill_policy;
        break;
      }

      // optional .mesos.KillPolicy kill_policy = 12;
      case 12: {
        if (tag == 98) {
         parse_kill_policy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kill_policy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_check;
        break;
      }

      // optional .mesos.CheckInfo check = 13;
      case 13: {
        if (tag == 106) {
         parse_check:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_check()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskInfo)
  return false;
#undef DO_
}

void TaskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->slave_id(), output);
  }

  // repeated .mesos.Resource resources = 4;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->resources(i), output);
  }

  // optional .mesos.ExecutorInfo executor = 5;
  if (has_executor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->executor(), output);
  }

  // optional bytes data = 6;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->data(), output);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->command(), output);
  }

  // optional .mesos.HealthCheck health_check = 8;
  if (has_health_check()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->health_check(), output);
  }

  // optional .mesos.ContainerInfo container = 9;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->container(), output);
  }

  // optional .mesos.Labels labels = 10;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->labels(), output);
  }

  // optional .mesos.DiscoveryInfo discovery = 11;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->discovery(), output);
  }

  // optional .mesos.KillPolicy kill_policy = 12;
  if (has_kill_policy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->kill_policy(), output);
  }

  // optional .mesos.CheckInfo check = 13;
  if (has_check()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->check(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskInfo)
}

::google::protobuf::uint8* TaskInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->slave_id(), target);
  }

  // repeated .mesos.Resource resources = 4;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->resources(i), target);
  }

  // optional .mesos.ExecutorInfo executor = 5;
  if (has_executor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->executor(), target);
  }

  // optional bytes data = 6;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->data(), target);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->command(), target);
  }

  // optional .mesos.HealthCheck health_check = 8;
  if (has_health_check()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->health_check(), target);
  }

  // optional .mesos.ContainerInfo container = 9;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->container(), target);
  }

  // optional .mesos.Labels labels = 10;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->labels(), target);
  }

  // optional .mesos.DiscoveryInfo discovery = 11;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->discovery(), target);
  }

  // optional .mesos.KillPolicy kill_policy = 12;
  if (has_kill_policy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->kill_policy(), target);
  }

  // optional .mesos.CheckInfo check = 13;
  if (has_check()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->check(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskInfo)
  return target;
}

int TaskInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .mesos.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required .mesos.SlaveID slave_id = 3;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.ExecutorInfo executor = 5;
    if (has_executor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor());
    }

    // optional .mesos.CommandInfo command = 7;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional .mesos.ContainerInfo container = 9;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container());
    }

    // optional .mesos.HealthCheck health_check = 8;
    if (has_health_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->health_check());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.CheckInfo check = 13;
    if (has_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->check());
    }

    // optional .mesos.KillPolicy kill_policy = 12;
    if (has_kill_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kill_policy());
    }

    // optional bytes data = 6;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .mesos.Labels labels = 10;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

    // optional .mesos.DiscoveryInfo discovery = 11;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->discovery());
    }

  }
  // repeated .mesos.Resource resources = 4;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskInfo::MergeFrom(const TaskInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor()) {
      mutable_executor()->::mesos::ExecutorInfo::MergeFrom(from.executor());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_container()) {
      mutable_container()->::mesos::ContainerInfo::MergeFrom(from.container());
    }
    if (from.has_health_check()) {
      mutable_health_check()->::mesos::HealthCheck::MergeFrom(from.health_check());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_check()) {
      mutable_check()->::mesos::CheckInfo::MergeFrom(from.check());
    }
    if (from.has_kill_policy()) {
      mutable_kill_policy()->::mesos::KillPolicy::MergeFrom(from.kill_policy());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskInfo::CopyFrom(const TaskInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_executor()) {
    if (!this->executor().IsInitialized()) return false;
  }
  if (has_command()) {
    if (!this->command().IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container().IsInitialized()) return false;
  }
  if (has_health_check()) {
    if (!this->health_check().IsInitialized()) return false;
  }
  if (has_check()) {
    if (!this->check().IsInitialized()) return false;
  }
  if (has_kill_policy()) {
    if (!this->kill_policy().IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  if (has_discovery()) {
    if (!this->discovery().IsInitialized()) return false;
  }
  return true;
}

void TaskInfo::Swap(TaskInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(task_id_, other->task_id_);
    std::swap(slave_id_, other->slave_id_);
    resources_.Swap(&other->resources_);
    std::swap(executor_, other->executor_);
    std::swap(command_, other->command_);
    std::swap(container_, other->container_);
    std::swap(health_check_, other->health_check_);
    std::swap(check_, other->check_);
    std::swap(kill_policy_, other->kill_policy_);
    std::swap(data_, other->data_);
    std::swap(labels_, other->labels_);
    std::swap(discovery_, other->discovery_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskInfo_descriptor_;
  metadata.reflection = TaskInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskGroupInfo::kTasksFieldNumber;
#endif  // !_MSC_VER

TaskGroupInfo::TaskGroupInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskGroupInfo)
}

void TaskGroupInfo::InitAsDefaultInstance() {
}

TaskGroupInfo::TaskGroupInfo(const TaskGroupInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskGroupInfo)
}

void TaskGroupInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskGroupInfo::~TaskGroupInfo() {
  // @@protoc_insertion_point(destructor:mesos.TaskGroupInfo)
  SharedDtor();
}

void TaskGroupInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TaskGroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskGroupInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskGroupInfo_descriptor_;
}

const TaskGroupInfo& TaskGroupInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskGroupInfo* TaskGroupInfo::default_instance_ = NULL;

TaskGroupInfo* TaskGroupInfo::New() const {
  return new TaskGroupInfo;
}

void TaskGroupInfo::Clear() {
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskGroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskGroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.TaskInfo tasks = 1;
      case 1: {
        if (tag == 10) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_tasks;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskGroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskGroupInfo)
  return false;
#undef DO_
}

void TaskGroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskGroupInfo)
  // repeated .mesos.TaskInfo tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskGroupInfo)
}

::google::protobuf::uint8* TaskGroupInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskGroupInfo)
  // repeated .mesos.TaskInfo tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskGroupInfo)
  return target;
}

int TaskGroupInfo::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.TaskInfo tasks = 1;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskGroupInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskGroupInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskGroupInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskGroupInfo::MergeFrom(const TaskGroupInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskGroupInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskGroupInfo::CopyFrom(const TaskGroupInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskGroupInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void TaskGroupInfo::Swap(TaskGroupInfo* other) {
  if (other != this) {
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskGroupInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskGroupInfo_descriptor_;
  metadata.reflection = TaskGroupInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Task::kNameFieldNumber;
const int Task::kTaskIdFieldNumber;
const int Task::kFrameworkIdFieldNumber;
const int Task::kExecutorIdFieldNumber;
const int Task::kSlaveIdFieldNumber;
const int Task::kStateFieldNumber;
const int Task::kResourcesFieldNumber;
const int Task::kStatusesFieldNumber;
const int Task::kStatusUpdateStateFieldNumber;
const int Task::kStatusUpdateUuidFieldNumber;
const int Task::kLabelsFieldNumber;
const int Task::kDiscoveryFieldNumber;
const int Task::kContainerFieldNumber;
const int Task::kUserFieldNumber;
#endif  // !_MSC_VER

Task::Task()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Task)
}

void Task::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
  container_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
}

Task::Task(const Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Task)
}

void Task::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  slave_id_ = NULL;
  state_ = 6;
  status_update_state_ = 6;
  status_update_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  discovery_ = NULL;
  container_ = NULL;
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Task::~Task() {
  // @@protoc_insertion_point(destructor:mesos.Task)
  SharedDtor();
}

void Task::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (status_update_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_update_uuid_;
  }
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (this != default_instance_) {
    delete task_id_;
    delete framework_id_;
    delete executor_id_;
    delete slave_id_;
    delete labels_;
    delete discovery_;
    delete container_;
  }
}

void Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Task_descriptor_;
}

const Task& Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Task* Task::default_instance_ = NULL;

Task* Task::New() const {
  return new Task;
}

void Task::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    state_ = 6;
  }
  if (_has_bits_[8 / 32] & 16128) {
    status_update_state_ = 6;
    if (has_status_update_uuid()) {
      if (status_update_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        status_update_uuid_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
    }
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_->clear();
      }
    }
  }
  resources_.Clear();
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Task)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (tag == 26) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 4;
      case 4: {
        if (tag == 34) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 5;
      case 5: {
        if (tag == 42) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }

      // required .mesos.TaskState state = 6;
      case 6: {
        if (tag == 48) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 7;
      case 7: {
        if (tag == 58) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_resources;
        if (input->ExpectTag(66)) goto parse_statuses;
        break;
      }

      // repeated .mesos.TaskStatus statuses = 8;
      case 8: {
        if (tag == 66) {
         parse_statuses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_statuses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_statuses;
        if (input->ExpectTag(72)) goto parse_status_update_state;
        break;
      }

      // optional .mesos.TaskState status_update_state = 9;
      case 9: {
        if (tag == 72) {
         parse_status_update_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_status_update_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_status_update_uuid;
        break;
      }

      // optional bytes status_update_uuid = 10;
      case 10: {
        if (tag == 82) {
         parse_status_update_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_status_update_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 11;
      case 11: {
        if (tag == 90) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 12;
      case 12: {
        if (tag == 98) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_container;
        break;
      }

      // optional .mesos.ContainerInfo container = 13;
      case 13: {
        if (tag == 106) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_user;
        break;
      }

      // optional string user = 14;
      case 14: {
        if (tag == 114) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Task)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Task)
  return false;
#undef DO_
}

void Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework_id(), output);
  }

  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->executor_id(), output);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->slave_id(), output);
  }

  // required .mesos.TaskState state = 6;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->state(), output);
  }

  // repeated .mesos.Resource resources = 7;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->resources(i), output);
  }

  // repeated .mesos.TaskStatus statuses = 8;
  for (int i = 0; i < this->statuses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->statuses(i), output);
  }

  // optional .mesos.TaskState status_update_state = 9;
  if (has_status_update_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->status_update_state(), output);
  }

  // optional bytes status_update_uuid = 10;
  if (has_status_update_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      10, this->status_update_uuid(), output);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->labels(), output);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->discovery(), output);
  }

  // optional .mesos.ContainerInfo container = 13;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->container(), output);
  }

  // optional string user = 14;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->user(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Task)
}

::google::protobuf::uint8* Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework_id(), target);
  }

  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->executor_id(), target);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->slave_id(), target);
  }

  // required .mesos.TaskState state = 6;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->state(), target);
  }

  // repeated .mesos.Resource resources = 7;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->resources(i), target);
  }

  // repeated .mesos.TaskStatus statuses = 8;
  for (int i = 0; i < this->statuses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->statuses(i), target);
  }

  // optional .mesos.TaskState status_update_state = 9;
  if (has_status_update_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->status_update_state(), target);
  }

  // optional bytes status_update_uuid = 10;
  if (has_status_update_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->status_update_uuid(), target);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->labels(), target);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->discovery(), target);
  }

  // optional .mesos.ContainerInfo container = 13;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->container(), target);
  }

  // optional string user = 14;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->user(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Task)
  return target;
}

int Task::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .mesos.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required .mesos.FrameworkID framework_id = 3;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.ExecutorID executor_id = 4;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required .mesos.SlaveID slave_id = 5;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.TaskState state = 6;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.TaskState status_update_state = 9;
    if (has_status_update_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_update_state());
    }

    // optional bytes status_update_uuid = 10;
    if (has_status_update_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->status_update_uuid());
    }

    // optional .mesos.Labels labels = 11;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

    // optional .mesos.DiscoveryInfo discovery = 12;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->discovery());
    }

    // optional .mesos.ContainerInfo container = 13;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container());
    }

    // optional string user = 14;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

  }
  // repeated .mesos.Resource resources = 7;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.TaskStatus statuses = 8;
  total_size += 1 * this->statuses_size();
  for (int i = 0; i < this->statuses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->statuses(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Task::MergeFrom(const Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_status_update_state()) {
      set_status_update_state(from.status_update_state());
    }
    if (from.has_status_update_uuid()) {
      set_status_update_uuid(from.status_update_uuid());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
    if (from.has_container()) {
      mutable_container()->::mesos::ContainerInfo::MergeFrom(from.container());
    }
    if (from.has_user()) {
      set_user(from.user());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Task::CopyFrom(const Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000037) != 0x00000037) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->statuses())) return false;
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  if (has_discovery()) {
    if (!this->discovery().IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container().IsInitialized()) return false;
  }
  return true;
}

void Task::Swap(Task* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(task_id_, other->task_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(state_, other->state_);
    resources_.Swap(&other->resources_);
    statuses_.Swap(&other->statuses_);
    std::swap(status_update_state_, other->status_update_state_);
    std::swap(status_update_uuid_, other->status_update_uuid_);
    std::swap(labels_, other->labels_);
    std::swap(discovery_, other->discovery_);
    std::swap(container_, other->container_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Task_descriptor_;
  metadata.reflection = Task_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckStatusInfo_Command::kExitCodeFieldNumber;
#endif  // !_MSC_VER

CheckStatusInfo_Command::CheckStatusInfo_Command()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo.Command)
}

void CheckStatusInfo_Command::InitAsDefaultInstance() {
}

CheckStatusInfo_Command::CheckStatusInfo_Command(const CheckStatusInfo_Command& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo.Command)
}

void CheckStatusInfo_Command::SharedCtor() {
  _cached_size_ = 0;
  exit_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo_Command::~CheckStatusInfo_Command() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo.Command)
  SharedDtor();
}

void CheckStatusInfo_Command::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckStatusInfo_Command::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo_Command::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_Command_descriptor_;
}

const CheckStatusInfo_Command& CheckStatusInfo_Command::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo_Command* CheckStatusInfo_Command::default_instance_ = NULL;

CheckStatusInfo_Command* CheckStatusInfo_Command::New() const {
  return new CheckStatusInfo_Command;
}

void CheckStatusInfo_Command::Clear() {
  exit_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckStatusInfo_Command::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo.Command)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 exit_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exit_code_)));
          set_has_exit_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo.Command)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo.Command)
  return false;
#undef DO_
}

void CheckStatusInfo_Command::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo.Command)
  // optional int32 exit_code = 1;
  if (has_exit_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->exit_code(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo.Command)
}

::google::protobuf::uint8* CheckStatusInfo_Command::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo.Command)
  // optional int32 exit_code = 1;
  if (has_exit_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->exit_code(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo.Command)
  return target;
}

int CheckStatusInfo_Command::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 exit_code = 1;
    if (has_exit_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exit_code());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo_Command::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckStatusInfo_Command* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckStatusInfo_Command*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckStatusInfo_Command::MergeFrom(const CheckStatusInfo_Command& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exit_code()) {
      set_exit_code(from.exit_code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckStatusInfo_Command::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo_Command::CopyFrom(const CheckStatusInfo_Command& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo_Command::IsInitialized() const {

  return true;
}

void CheckStatusInfo_Command::Swap(CheckStatusInfo_Command* other) {
  if (other != this) {
    std::swap(exit_code_, other->exit_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckStatusInfo_Command::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_Command_descriptor_;
  metadata.reflection = CheckStatusInfo_Command_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CheckStatusInfo_Http::kStatusCodeFieldNumber;
#endif  // !_MSC_VER

CheckStatusInfo_Http::CheckStatusInfo_Http()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo.Http)
}

void CheckStatusInfo_Http::InitAsDefaultInstance() {
}

CheckStatusInfo_Http::CheckStatusInfo_Http(const CheckStatusInfo_Http& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo.Http)
}

void CheckStatusInfo_Http::SharedCtor() {
  _cached_size_ = 0;
  status_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo_Http::~CheckStatusInfo_Http() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo.Http)
  SharedDtor();
}

void CheckStatusInfo_Http::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckStatusInfo_Http::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo_Http::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_Http_descriptor_;
}

const CheckStatusInfo_Http& CheckStatusInfo_Http::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo_Http* CheckStatusInfo_Http::default_instance_ = NULL;

CheckStatusInfo_Http* CheckStatusInfo_Http::New() const {
  return new CheckStatusInfo_Http;
}

void CheckStatusInfo_Http::Clear() {
  status_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckStatusInfo_Http::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo.Http)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 status_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_code_)));
          set_has_status_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo.Http)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo.Http)
  return false;
#undef DO_
}

void CheckStatusInfo_Http::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo.Http)
  // optional uint32 status_code = 1;
  if (has_status_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->status_code(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo.Http)
}

::google::protobuf::uint8* CheckStatusInfo_Http::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo.Http)
  // optional uint32 status_code = 1;
  if (has_status_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->status_code(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo.Http)
  return target;
}

int CheckStatusInfo_Http::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 status_code = 1;
    if (has_status_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status_code());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo_Http::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckStatusInfo_Http* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckStatusInfo_Http*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckStatusInfo_Http::MergeFrom(const CheckStatusInfo_Http& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status_code()) {
      set_status_code(from.status_code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckStatusInfo_Http::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo_Http::CopyFrom(const CheckStatusInfo_Http& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo_Http::IsInitialized() const {

  return true;
}

void CheckStatusInfo_Http::Swap(CheckStatusInfo_Http* other) {
  if (other != this) {
    std::swap(status_code_, other->status_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckStatusInfo_Http::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_Http_descriptor_;
  metadata.reflection = CheckStatusInfo_Http_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CheckStatusInfo_Tcp::kSucceededFieldNumber;
#endif  // !_MSC_VER

CheckStatusInfo_Tcp::CheckStatusInfo_Tcp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo.Tcp)
}

void CheckStatusInfo_Tcp::InitAsDefaultInstance() {
}

CheckStatusInfo_Tcp::CheckStatusInfo_Tcp(const CheckStatusInfo_Tcp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo.Tcp)
}

void CheckStatusInfo_Tcp::SharedCtor() {
  _cached_size_ = 0;
  succeeded_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo_Tcp::~CheckStatusInfo_Tcp() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo.Tcp)
  SharedDtor();
}

void CheckStatusInfo_Tcp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckStatusInfo_Tcp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo_Tcp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_Tcp_descriptor_;
}

const CheckStatusInfo_Tcp& CheckStatusInfo_Tcp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo_Tcp* CheckStatusInfo_Tcp::default_instance_ = NULL;

CheckStatusInfo_Tcp* CheckStatusInfo_Tcp::New() const {
  return new CheckStatusInfo_Tcp;
}

void CheckStatusInfo_Tcp::Clear() {
  succeeded_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckStatusInfo_Tcp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo.Tcp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool succeeded = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &succeeded_)));
          set_has_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo.Tcp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo.Tcp)
  return false;
#undef DO_
}

void CheckStatusInfo_Tcp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo.Tcp)
  // optional bool succeeded = 1;
  if (has_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->succeeded(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo.Tcp)
}

::google::protobuf::uint8* CheckStatusInfo_Tcp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo.Tcp)
  // optional bool succeeded = 1;
  if (has_succeeded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->succeeded(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo.Tcp)
  return target;
}

int CheckStatusInfo_Tcp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool succeeded = 1;
    if (has_succeeded()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo_Tcp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckStatusInfo_Tcp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckStatusInfo_Tcp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckStatusInfo_Tcp::MergeFrom(const CheckStatusInfo_Tcp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_succeeded()) {
      set_succeeded(from.succeeded());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckStatusInfo_Tcp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo_Tcp::CopyFrom(const CheckStatusInfo_Tcp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo_Tcp::IsInitialized() const {

  return true;
}

void CheckStatusInfo_Tcp::Swap(CheckStatusInfo_Tcp* other) {
  if (other != this) {
    std::swap(succeeded_, other->succeeded_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckStatusInfo_Tcp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_Tcp_descriptor_;
  metadata.reflection = CheckStatusInfo_Tcp_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CheckStatusInfo::kTypeFieldNumber;
const int CheckStatusInfo::kCommandFieldNumber;
const int CheckStatusInfo::kHttpFieldNumber;
const int CheckStatusInfo::kTcpFieldNumber;
#endif  // !_MSC_VER

CheckStatusInfo::CheckStatusInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo)
}

void CheckStatusInfo::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CheckStatusInfo_Command*>(&::mesos::CheckStatusInfo_Command::default_instance());
  http_ = const_cast< ::mesos::CheckStatusInfo_Http*>(&::mesos::CheckStatusInfo_Http::default_instance());
  tcp_ = const_cast< ::mesos::CheckStatusInfo_Tcp*>(&::mesos::CheckStatusInfo_Tcp::default_instance());
}

CheckStatusInfo::CheckStatusInfo(const CheckStatusInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo)
}

void CheckStatusInfo::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  command_ = NULL;
  http_ = NULL;
  tcp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo::~CheckStatusInfo() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo)
  SharedDtor();
}

void CheckStatusInfo::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
    delete http_;
    delete tcp_;
  }
}

void CheckStatusInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_descriptor_;
}

const CheckStatusInfo& CheckStatusInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo* CheckStatusInfo::default_instance_ = NULL;

CheckStatusInfo* CheckStatusInfo::New() const {
  return new CheckStatusInfo;
}

void CheckStatusInfo::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 0;
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CheckStatusInfo_Command::Clear();
    }
    if (has_http()) {
      if (http_ != NULL) http_->::mesos::CheckStatusInfo_Http::Clear();
    }
    if (has_tcp()) {
      if (tcp_ != NULL) tcp_->::mesos::CheckStatusInfo_Tcp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckStatusInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CheckInfo.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::CheckInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::CheckInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_command;
        break;
      }

      // optional .mesos.CheckStatusInfo.Command command = 2;
      case 2: {
        if (tag == 18) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_http;
        break;
      }

      // optional .mesos.CheckStatusInfo.Http http = 3;
      case 3: {
        if (tag == 26) {
         parse_http:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_http()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_tcp;
        break;
      }

      // optional .mesos.CheckStatusInfo.Tcp tcp = 4;
      case 4: {
        if (tag == 34) {
         parse_tcp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo)
  return false;
#undef DO_
}

void CheckStatusInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.CheckStatusInfo.Command command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->command(), output);
  }

  // optional .mesos.CheckStatusInfo.Http http = 3;
  if (has_http()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->http(), output);
  }

  // optional .mesos.CheckStatusInfo.Tcp tcp = 4;
  if (has_tcp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->tcp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo)
}

::google::protobuf::uint8* CheckStatusInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.CheckStatusInfo.Command command = 2;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->command(), target);
  }

  // optional .mesos.CheckStatusInfo.Http http = 3;
  if (has_http()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->http(), target);
  }

  // optional .mesos.CheckStatusInfo.Tcp tcp = 4;
  if (has_tcp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->tcp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo)
  return target;
}

int CheckStatusInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.CheckInfo.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.CheckStatusInfo.Command command = 2;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional .mesos.CheckStatusInfo.Http http = 3;
    if (has_http()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->http());
    }

    // optional .mesos.CheckStatusInfo.Tcp tcp = 4;
    if (has_tcp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckStatusInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckStatusInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckStatusInfo::MergeFrom(const CheckStatusInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CheckStatusInfo_Command::MergeFrom(from.command());
    }
    if (from.has_http()) {
      mutable_http()->::mesos::CheckStatusInfo_Http::MergeFrom(from.http());
    }
    if (from.has_tcp()) {
      mutable_tcp()->::mesos::CheckStatusInfo_Tcp::MergeFrom(from.tcp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckStatusInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo::CopyFrom(const CheckStatusInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo::IsInitialized() const {

  return true;
}

void CheckStatusInfo::Swap(CheckStatusInfo* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(command_, other->command_);
    std::swap(http_, other->http_);
    std::swap(tcp_, other->tcp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckStatusInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_descriptor_;
  metadata.reflection = CheckStatusInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskStatus_Source_descriptor_;
}
bool TaskStatus_Source_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TaskStatus_Source TaskStatus::SOURCE_MASTER;
const TaskStatus_Source TaskStatus::SOURCE_SLAVE;
const TaskStatus_Source TaskStatus::SOURCE_EXECUTOR;
const TaskStatus_Source TaskStatus::Source_MIN;
const TaskStatus_Source TaskStatus::Source_MAX;
const int TaskStatus::Source_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskStatus_Reason_descriptor_;
}
bool TaskStatus_Reason_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 30:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TaskStatus_Reason TaskStatus::REASON_COMMAND_EXECUTOR_FAILED;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LAUNCH_FAILED;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LIMITATION;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LIMITATION_DISK;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LIMITATION_MEMORY;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_PREEMPTED;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_UPDATE_FAILED;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_REGISTRATION_TIMEOUT;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_REREGISTRATION_TIMEOUT;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_TERMINATED;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_UNREGISTERED;
const TaskStatus_Reason TaskStatus::REASON_FRAMEWORK_REMOVED;
const TaskStatus_Reason TaskStatus::REASON_GC_ERROR;
const TaskStatus_Reason TaskStatus::REASON_INVALID_FRAMEWORKID;
const TaskStatus_Reason TaskStatus::REASON_INVALID_OFFERS;
const TaskStatus_Reason TaskStatus::REASON_IO_SWITCHBOARD_EXITED;
const TaskStatus_Reason TaskStatus::REASON_MASTER_DISCONNECTED;
const TaskStatus_Reason TaskStatus::REASON_RECONCILIATION;
const TaskStatus_Reason TaskStatus::REASON_RESOURCES_UNKNOWN;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_DISCONNECTED;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_REMOVED;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_RESTARTED;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_UNKNOWN;
const TaskStatus_Reason TaskStatus::REASON_TASK_KILLED_DURING_LAUNCH;
const TaskStatus_Reason TaskStatus::REASON_TASK_CHECK_STATUS_UPDATED;
const TaskStatus_Reason TaskStatus::REASON_TASK_GROUP_INVALID;
const TaskStatus_Reason TaskStatus::REASON_TASK_GROUP_UNAUTHORIZED;
const TaskStatus_Reason TaskStatus::REASON_TASK_INVALID;
const TaskStatus_Reason TaskStatus::REASON_TASK_UNAUTHORIZED;
const TaskStatus_Reason TaskStatus::REASON_TASK_UNKNOWN;
const TaskStatus_Reason TaskStatus::Reason_MIN;
const TaskStatus_Reason TaskStatus::Reason_MAX;
const int TaskStatus::Reason_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TaskStatus::kTaskIdFieldNumber;
const int TaskStatus::kStateFieldNumber;
const int TaskStatus::kMessageFieldNumber;
const int TaskStatus::kSourceFieldNumber;
const int TaskStatus::kReasonFieldNumber;
const int TaskStatus::kDataFieldNumber;
const int TaskStatus::kSlaveIdFieldNumber;
const int TaskStatus::kExecutorIdFieldNumber;
const int TaskStatus::kTimestampFieldNumber;
const int TaskStatus::kUuidFieldNumber;
const int TaskStatus::kHealthyFieldNumber;
const int TaskStatus::kCheckStatusFieldNumber;
const int TaskStatus::kLabelsFieldNumber;
const int TaskStatus::kContainerStatusFieldNumber;
const int TaskStatus::kUnreachableTimeFieldNumber;
#endif  // !_MSC_VER

TaskStatus::TaskStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskStatus)
}

void TaskStatus::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  check_status_ = const_cast< ::mesos::CheckStatusInfo*>(&::mesos::CheckStatusInfo::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  container_status_ = const_cast< ::mesos::ContainerStatus*>(&::mesos::ContainerStatus::default_instance());
  unreachable_time_ = const_cast< ::mesos::TimeInfo*>(&::mesos::TimeInfo::default_instance());
}

TaskStatus::TaskStatus(const TaskStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskStatus)
}

void TaskStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  task_id_ = NULL;
  state_ = 6;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = 0;
  reason_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  slave_id_ = NULL;
  executor_id_ = NULL;
  timestamp_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  healthy_ = false;
  check_status_ = NULL;
  labels_ = NULL;
  container_status_ = NULL;
  unreachable_time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskStatus::~TaskStatus() {
  // @@protoc_insertion_point(destructor:mesos.TaskStatus)
  SharedDtor();
}

void TaskStatus::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete task_id_;
    delete slave_id_;
    delete executor_id_;
    delete check_status_;
    delete labels_;
    delete container_status_;
    delete unreachable_time_;
  }
}

void TaskStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskStatus_descriptor_;
}

const TaskStatus& TaskStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskStatus* TaskStatus::default_instance_ = NULL;

TaskStatus* TaskStatus::New() const {
  return new TaskStatus;
}

void TaskStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TaskStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    state_ = 6;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_->clear();
      }
    }
    source_ = 0;
    reason_ = 0;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 32512) {
    ZR_(healthy_, timestamp_);
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
    if (has_check_status()) {
      if (check_status_ != NULL) check_status_->::mesos::CheckStatusInfo::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_container_status()) {
      if (container_status_ != NULL) container_status_->::mesos::ContainerStatus::Clear();
    }
    if (has_unreachable_time()) {
      if (unreachable_time_ != NULL) unreachable_time_->::mesos::TimeInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskID task_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required .mesos.TaskState state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // optional bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_message;
        break;
      }

      // optional string message = 4;
      case 4: {
        if (tag == 34) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 5;
      case 5: {
        if (tag == 42) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_timestamp;
        break;
      }

      // optional double timestamp = 6;
      case 6: {
        if (tag == 49) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 7;
      case 7: {
        if (tag == 58) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_healthy;
        break;
      }

      // optional bool healthy = 8;
      case 8: {
        if (tag == 64) {
         parse_healthy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &healthy_)));
          set_has_healthy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_source;
        break;
      }

      // optional .mesos.TaskStatus.Source source = 9;
      case 9: {
        if (tag == 72) {
         parse_source:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskStatus_Source_IsValid(value)) {
            set_source(static_cast< ::mesos::TaskStatus_Source >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_reason;
        break;
      }

      // optional .mesos.TaskStatus.Reason reason = 10;
      case 10: {
        if (tag == 80) {
         parse_reason:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskStatus_Reason_IsValid(value)) {
            set_reason(static_cast< ::mesos::TaskStatus_Reason >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_uuid;
        break;
      }

      // optional bytes uuid = 11;
      case 11: {
        if (tag == 90) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 12;
      case 12: {
        if (tag == 98) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_container_status;
        break;
      }

      // optional .mesos.ContainerStatus container_status = 13;
      case 13: {
        if (tag == 106) {
         parse_container_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_unreachable_time;
        break;
      }

      // optional .mesos.TimeInfo unreachable_time = 14;
      case 14: {
        if (tag == 114) {
         parse_unreachable_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unreachable_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_check_status;
        break;
      }

      // optional .mesos.CheckStatusInfo check_status = 15;
      case 15: {
        if (tag == 122) {
         parse_check_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_check_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskStatus)
  return false;
#undef DO_
}

void TaskStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskStatus)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // required .mesos.TaskState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  // optional bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  // optional string message = 4;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->message(), output);
  }

  // optional .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->slave_id(), output);
  }

  // optional double timestamp = 6;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->timestamp(), output);
  }

  // optional .mesos.ExecutorID executor_id = 7;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->executor_id(), output);
  }

  // optional bool healthy = 8;
  if (has_healthy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->healthy(), output);
  }

  // optional .mesos.TaskStatus.Source source = 9;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->source(), output);
  }

  // optional .mesos.TaskStatus.Reason reason = 10;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->reason(), output);
  }

  // optional bytes uuid = 11;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->uuid(), output);
  }

  // optional .mesos.Labels labels = 12;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->labels(), output);
  }

  // optional .mesos.ContainerStatus container_status = 13;
  if (has_container_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->container_status(), output);
  }

  // optional .mesos.TimeInfo unreachable_time = 14;
  if (has_unreachable_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->unreachable_time(), output);
  }

  // optional .mesos.CheckStatusInfo check_status = 15;
  if (has_check_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->check_status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskStatus)
}

::google::protobuf::uint8* TaskStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskStatus)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // required .mesos.TaskState state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }

  // optional bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  // optional string message = 4;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->message(), target);
  }

  // optional .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->slave_id(), target);
  }

  // optional double timestamp = 6;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->timestamp(), target);
  }

  // optional .mesos.ExecutorID executor_id = 7;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->executor_id(), target);
  }

  // optional bool healthy = 8;
  if (has_healthy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->healthy(), target);
  }

  // optional .mesos.TaskStatus.Source source = 9;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->source(), target);
  }

  // optional .mesos.TaskStatus.Reason reason = 10;
  if (has_reason()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->reason(), target);
  }

  // optional bytes uuid = 11;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->uuid(), target);
  }

  // optional .mesos.Labels labels = 12;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->labels(), target);
  }

  // optional .mesos.ContainerStatus container_status = 13;
  if (has_container_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->container_status(), target);
  }

  // optional .mesos.TimeInfo unreachable_time = 14;
  if (has_unreachable_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->unreachable_time(), target);
  }

  // optional .mesos.CheckStatusInfo check_status = 15;
  if (has_check_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->check_status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskStatus)
  return target;
}

int TaskStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required .mesos.TaskState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional string message = 4;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .mesos.TaskStatus.Source source = 9;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->source());
    }

    // optional .mesos.TaskStatus.Reason reason = 10;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reason());
    }

    // optional bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .mesos.SlaveID slave_id = 5;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.ExecutorID executor_id = 7;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double timestamp = 6;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional bytes uuid = 11;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional bool healthy = 8;
    if (has_healthy()) {
      total_size += 1 + 1;
    }

    // optional .mesos.CheckStatusInfo check_status = 15;
    if (has_check_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->check_status());
    }

    // optional .mesos.Labels labels = 12;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

    // optional .mesos.ContainerStatus container_status = 13;
    if (has_container_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container_status());
    }

    // optional .mesos.TimeInfo unreachable_time = 14;
    if (has_unreachable_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->unreachable_time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskStatus::MergeFrom(const TaskStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_healthy()) {
      set_healthy(from.healthy());
    }
    if (from.has_check_status()) {
      mutable_check_status()->::mesos::CheckStatusInfo::MergeFrom(from.check_status());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_container_status()) {
      mutable_container_status()->::mesos::ContainerStatus::MergeFrom(from.container_status());
    }
    if (from.has_unreachable_time()) {
      mutable_unreachable_time()->::mesos::TimeInfo::MergeFrom(from.unreachable_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskStatus::CopyFrom(const TaskStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  if (has_container_status()) {
    if (!this->container_status().IsInitialized()) return false;
  }
  if (has_unreachable_time()) {
    if (!this->unreachable_time().IsInitialized()) return false;
  }
  return true;
}

void TaskStatus::Swap(TaskStatus* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(state_, other->state_);
    std::swap(message_, other->message_);
    std::swap(source_, other->source_);
    std::swap(reason_, other->reason_);
    std::swap(data_, other->data_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uuid_, other->uuid_);
    std::swap(healthy_, other->healthy_);
    std::swap(check_status_, other->check_status_);
    std::swap(labels_, other->labels_);
    std::swap(container_status_, other->container_status_);
    std::swap(unreachable_time_, other->unreachable_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskStatus_descriptor_;
  metadata.reflection = TaskStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Filters::kRefuseSecondsFieldNumber;
#endif  // !_MSC_VER

Filters::Filters()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Filters)
}

void Filters::InitAsDefaultInstance() {
}

Filters::Filters(const Filters& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Filters)
}

void Filters::SharedCtor() {
  _cached_size_ = 0;
  refuse_seconds_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Filters::~Filters() {
  // @@protoc_insertion_point(destructor:mesos.Filters)
  SharedDtor();
}

void Filters::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Filters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Filters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Filters_descriptor_;
}

const Filters& Filters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Filters* Filters::default_instance_ = NULL;

Filters* Filters::New() const {
  return new Filters;
}

void Filters::Clear() {
  refuse_seconds_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Filters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Filters)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double refuse_seconds = 1 [default = 5];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &refuse_seconds_)));
          set_has_refuse_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Filters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Filters)
  return false;
#undef DO_
}

void Filters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Filters)
  // optional double refuse_seconds = 1 [default = 5];
  if (has_refuse_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->refuse_seconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Filters)
}

::google::protobuf::uint8* Filters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Filters)
  // optional double refuse_seconds = 1 [default = 5];
  if (has_refuse_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->refuse_seconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Filters)
  return target;
}

int Filters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double refuse_seconds = 1 [default = 5];
    if (has_refuse_seconds()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Filters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Filters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Filters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Filters::MergeFrom(const Filters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_refuse_seconds()) {
      set_refuse_seconds(from.refuse_seconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Filters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Filters::CopyFrom(const Filters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filters::IsInitialized() const {

  return true;
}

void Filters::Swap(Filters* other) {
  if (other != this) {
    std::swap(refuse_seconds_, other->refuse_seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Filters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Filters_descriptor_;
  metadata.reflection = Filters_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Environment_Variable_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_Variable_Type_descriptor_;
}
bool Environment_Variable_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Environment_Variable_Type Environment_Variable::UNKNOWN;
const Environment_Variable_Type Environment_Variable::VALUE;
const Environment_Variable_Type Environment_Variable::SECRET;
const Environment_Variable_Type Environment_Variable::Type_MIN;
const Environment_Variable_Type Environment_Variable::Type_MAX;
const int Environment_Variable::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Environment_Variable::kNameFieldNumber;
const int Environment_Variable::kTypeFieldNumber;
const int Environment_Variable::kValueFieldNumber;
const int Environment_Variable::kSecretFieldNumber;
#endif  // !_MSC_VER

Environment_Variable::Environment_Variable()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Environment.Variable)
}

void Environment_Variable::InitAsDefaultInstance() {
  secret_ = const_cast< ::mesos::Secret*>(&::mesos::Secret::default_instance());
}

Environment_Variable::Environment_Variable(const Environment_Variable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Environment.Variable)
}

void Environment_Variable::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  secret_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Environment_Variable::~Environment_Variable() {
  // @@protoc_insertion_point(destructor:mesos.Environment.Variable)
  SharedDtor();
}

void Environment_Variable::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
    delete secret_;
  }
}

void Environment_Variable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Environment_Variable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_Variable_descriptor_;
}

const Environment_Variable& Environment_Variable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Environment_Variable* Environment_Variable::default_instance_ = NULL;

Environment_Variable* Environment_Variable::New() const {
  return new Environment_Variable;
}

void Environment_Variable::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    type_ = 1;
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
    if (has_secret()) {
      if (secret_ != NULL) secret_->::mesos::Secret::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Environment_Variable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Environment.Variable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Environment_Variable_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Environment_Variable_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_secret;
        break;
      }

      // optional .mesos.Secret secret = 4;
      case 4: {
        if (tag == 34) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Environment.Variable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Environment.Variable)
  return false;
#undef DO_
}

void Environment_Variable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Environment.Variable)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional .mesos.Secret secret = 4;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->secret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Environment.Variable)
}

::google::protobuf::uint8* Environment_Variable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Environment.Variable)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional .mesos.Secret secret = 4;
  if (has_secret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->secret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Environment.Variable)
  return target;
}

int Environment_Variable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional .mesos.Secret secret = 4;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Environment_Variable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Environment_Variable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Environment_Variable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Environment_Variable::MergeFrom(const Environment_Variable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_secret()) {
      mutable_secret()->::mesos::Secret::MergeFrom(from.secret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Environment_Variable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Environment_Variable::CopyFrom(const Environment_Variable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Environment_Variable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_secret()) {
    if (!this->secret().IsInitialized()) return false;
  }
  return true;
}

void Environment_Variable::Swap(Environment_Variable* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(value_, other->value_);
    std::swap(secret_, other->secret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Environment_Variable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Environment_Variable_descriptor_;
  metadata.reflection = Environment_Variable_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Environment::kVariablesFieldNumber;
#endif  // !_MSC_VER

Environment::Environment()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Environment)
}

void Environment::InitAsDefaultInstance() {
}

Environment::Environment(const Environment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Environment)
}

void Environment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Environment::~Environment() {
  // @@protoc_insertion_point(destructor:mesos.Environment)
  SharedDtor();
}

void Environment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Environment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Environment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_descriptor_;
}

const Environment& Environment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Environment* Environment::default_instance_ = NULL;

Environment* Environment::New() const {
  return new Environment;
}

void Environment::Clear() {
  variables_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Environment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Environment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Environment.Variable variables = 1;
      case 1: {
        if (tag == 10) {
         parse_variables:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_variables()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_variables;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Environment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Environment)
  return false;
#undef DO_
}

void Environment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Environment)
  // repeated .mesos.Environment.Variable variables = 1;
  for (int i = 0; i < this->variables_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->variables(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Environment)
}

::google::protobuf::uint8* Environment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Environment)
  // repeated .mesos.Environment.Variable variables = 1;
  for (int i = 0; i < this->variables_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->variables(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Environment)
  return target;
}

int Environment::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Environment.Variable variables = 1;
  total_size += 1 * this->variables_size();
  for (int i = 0; i < this->variables_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->variables(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Environment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Environment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Environment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Environment::MergeFrom(const Environment& from) {
  GOOGLE_CHECK_NE(&from, this);
  variables_.MergeFrom(from.variables_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Environment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Environment::CopyFrom(const Environment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Environment::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->variables())) return false;
  return true;
}

void Environment::Swap(Environment* other) {
  if (other != this) {
    variables_.Swap(&other->variables_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Environment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Environment_descriptor_;
  metadata.reflection = Environment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Parameter::kKeyFieldNumber;
const int Parameter::kValueFieldNumber;
#endif  // !_MSC_VER

Parameter::Parameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Parameter)
}

void Parameter::InitAsDefaultInstance() {
}

Parameter::Parameter(const Parameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Parameter)
}

void Parameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Parameter::~Parameter() {
  // @@protoc_insertion_point(destructor:mesos.Parameter)
  SharedDtor();
}

void Parameter::SharedDtor() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void Parameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Parameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Parameter_descriptor_;
}

const Parameter& Parameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Parameter* Parameter::default_instance_ = NULL;

Parameter* Parameter::New() const {
  return new Parameter;
}

void Parameter::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Parameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Parameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Parameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Parameter)
  return false;
#undef DO_
}

void Parameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Parameter)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Parameter)
}

::google::protobuf::uint8* Parameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Parameter)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Parameter)
  return target;
}

int Parameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Parameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Parameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Parameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Parameter::MergeFrom(const Parameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Parameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Parameter::CopyFrom(const Parameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Parameter::Swap(Parameter* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Parameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Parameter_descriptor_;
  metadata.reflection = Parameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Parameters::kParameterFieldNumber;
#endif  // !_MSC_VER

Parameters::Parameters()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Parameters)
}

void Parameters::InitAsDefaultInstance() {
}

Parameters::Parameters(const Parameters& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Parameters)
}

void Parameters::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Parameters::~Parameters() {
  // @@protoc_insertion_point(destructor:mesos.Parameters)
  SharedDtor();
}

void Parameters::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Parameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Parameters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Parameters_descriptor_;
}

const Parameters& Parameters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Parameters* Parameters::default_instance_ = NULL;

Parameters* Parameters::New() const {
  return new Parameters;
}

void Parameters::Clear() {
  parameter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Parameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Parameters)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Parameter parameter = 1;
      case 1: {
        if (tag == 10) {
         parse_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_parameter;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Parameters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Parameters)
  return false;
#undef DO_
}

void Parameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Parameters)
  // repeated .mesos.Parameter parameter = 1;
  for (int i = 0; i < this->parameter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->parameter(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Parameters)
}

::google::protobuf::uint8* Parameters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Parameters)
  // repeated .mesos.Parameter parameter = 1;
  for (int i = 0; i < this->parameter_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->parameter(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Parameters)
  return target;
}

int Parameters::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Parameter parameter = 1;
  total_size += 1 * this->parameter_size();
  for (int i = 0; i < this->parameter_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->parameter(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Parameters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Parameters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Parameters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Parameters::MergeFrom(const Parameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  parameter_.MergeFrom(from.parameter_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Parameters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Parameters::CopyFrom(const Parameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameters::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->parameter())) return false;
  return true;
}

void Parameters::Swap(Parameters* other) {
  if (other != this) {
    parameter_.Swap(&other->parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Parameters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Parameters_descriptor_;
  metadata.reflection = Parameters_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Credential::kPrincipalFieldNumber;
const int Credential::kSecretFieldNumber;
#endif  // !_MSC_VER

Credential::Credential()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Credential)
}

void Credential::InitAsDefaultInstance() {
}

Credential::Credential(const Credential& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Credential)
}

void Credential::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Credential::~Credential() {
  // @@protoc_insertion_point(destructor:mesos.Credential)
  SharedDtor();
}

void Credential::SharedDtor() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  if (this != default_instance_) {
  }
}

void Credential::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Credential::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Credential_descriptor_;
}

const Credential& Credential::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Credential* Credential::default_instance_ = NULL;

Credential* Credential::New() const {
  return new Credential;
}

void Credential::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_principal()) {
      if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        principal_->clear();
      }
    }
    if (has_secret()) {
      if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        secret_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Credential::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Credential)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string principal = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_secret;
        break;
      }

      // optional string secret = 2;
      case 2: {
        if (tag == 18) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_secret()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->secret().data(), this->secret().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "secret");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Credential)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Credential)
  return false;
#undef DO_
}

void Credential::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Credential)
  // required string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->principal(), output);
  }

  // optional string secret = 2;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "secret");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->secret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Credential)
}

::google::protobuf::uint8* Credential::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Credential)
  // required string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->principal(), target);
  }

  // optional string secret = 2;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "secret");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->secret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Credential)
  return target;
}

int Credential::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string principal = 1;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

    // optional string secret = 2;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->secret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Credential::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Credential* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Credential*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Credential::MergeFrom(const Credential& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_principal()) {
      set_principal(from.principal());
    }
    if (from.has_secret()) {
      set_secret(from.secret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Credential::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Credential::CopyFrom(const Credential& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Credential::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Credential::Swap(Credential* other) {
  if (other != this) {
    std::swap(principal_, other->principal_);
    std::swap(secret_, other->secret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Credential::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Credential_descriptor_;
  metadata.reflection = Credential_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Credentials::kCredentialsFieldNumber;
#endif  // !_MSC_VER

Credentials::Credentials()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Credentials)
}

void Credentials::InitAsDefaultInstance() {
}

Credentials::Credentials(const Credentials& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Credentials)
}

void Credentials::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Credentials::~Credentials() {
  // @@protoc_insertion_point(destructor:mesos.Credentials)
  SharedDtor();
}

void Credentials::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Credentials::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Credentials::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Credentials_descriptor_;
}

const Credentials& Credentials::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Credentials* Credentials::default_instance_ = NULL;

Credentials* Credentials::New() const {
  return new Credentials;
}

void Credentials::Clear() {
  credentials_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Credentials::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Credentials)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Credential credentials = 1;
      case 1: {
        if (tag == 10) {
         parse_credentials:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_credentials()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_credentials;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Credentials)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Credentials)
  return false;
#undef DO_
}

void Credentials::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Credentials)
  // repeated .mesos.Credential credentials = 1;
  for (int i = 0; i < this->credentials_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->credentials(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Credentials)
}

::google::protobuf::uint8* Credentials::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Credentials)
  // repeated .mesos.Credential credentials = 1;
  for (int i = 0; i < this->credentials_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->credentials(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Credentials)
  return target;
}

int Credentials::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Credential credentials = 1;
  total_size += 1 * this->credentials_size();
  for (int i = 0; i < this->credentials_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->credentials(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Credentials::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Credentials* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Credentials*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Credentials::MergeFrom(const Credentials& from) {
  GOOGLE_CHECK_NE(&from, this);
  credentials_.MergeFrom(from.credentials_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Credentials::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Credentials::CopyFrom(const Credentials& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Credentials::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->credentials())) return false;
  return true;
}

void Credentials::Swap(Credentials* other) {
  if (other != this) {
    credentials_.Swap(&other->credentials_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Credentials::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Credentials_descriptor_;
  metadata.reflection = Credentials_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Secret_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_Type_descriptor_;
}
bool Secret_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Secret_Type Secret::UNKNOWN;
const Secret_Type Secret::REFERENCE;
const Secret_Type Secret::VALUE;
const Secret_Type Secret::Type_MIN;
const Secret_Type Secret::Type_MAX;
const int Secret::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Secret_Reference::kNameFieldNumber;
const int Secret_Reference::kKeyFieldNumber;
#endif  // !_MSC_VER

Secret_Reference::Secret_Reference()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Secret.Reference)
}

void Secret_Reference::InitAsDefaultInstance() {
}

Secret_Reference::Secret_Reference(const Secret_Reference& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Secret.Reference)
}

void Secret_Reference::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret_Reference::~Secret_Reference() {
  // @@protoc_insertion_point(destructor:mesos.Secret.Reference)
  SharedDtor();
}

void Secret_Reference::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void Secret_Reference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Secret_Reference::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_Reference_descriptor_;
}

const Secret_Reference& Secret_Reference::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Secret_Reference* Secret_Reference::default_instance_ = NULL;

Secret_Reference* Secret_Reference::New() const {
  return new Secret_Reference;
}

void Secret_Reference::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Secret_Reference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Secret.Reference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Secret.Reference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Secret.Reference)
  return false;
#undef DO_
}

void Secret_Reference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Secret.Reference)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Secret.Reference)
}

::google::protobuf::uint8* Secret_Reference::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Secret.Reference)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Secret.Reference)
  return target;
}

int Secret_Reference::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret_Reference::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Secret_Reference* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Secret_Reference*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Secret_Reference::MergeFrom(const Secret_Reference& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Secret_Reference::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Secret_Reference::CopyFrom(const Secret_Reference& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret_Reference::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Secret_Reference::Swap(Secret_Reference* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Secret_Reference::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Secret_Reference_descriptor_;
  metadata.reflection = Secret_Reference_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Secret_Value::kDataFieldNumber;
#endif  // !_MSC_VER

Secret_Value::Secret_Value()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Secret.Value)
}

void Secret_Value::InitAsDefaultInstance() {
}

Secret_Value::Secret_Value(const Secret_Value& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Secret.Value)
}

void Secret_Value::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret_Value::~Secret_Value() {
  // @@protoc_insertion_point(destructor:mesos.Secret.Value)
  SharedDtor();
}

void Secret_Value::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void Secret_Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Secret_Value::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_Value_descriptor_;
}

const Secret_Value& Secret_Value::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Secret_Value* Secret_Value::default_instance_ = NULL;

Secret_Value* Secret_Value::New() const {
  return new Secret_Value;
}

void Secret_Value::Clear() {
  if (has_data()) {
    if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      data_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Secret_Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Secret.Value)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Secret.Value)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Secret.Value)
  return false;
#undef DO_
}

void Secret_Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Secret.Value)
  // required bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Secret.Value)
}

::google::protobuf::uint8* Secret_Value::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Secret.Value)
  // required bytes data = 1;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Secret.Value)
  return target;
}

int Secret_Value::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret_Value::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Secret_Value* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Secret_Value*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Secret_Value::MergeFrom(const Secret_Value& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Secret_Value::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Secret_Value::CopyFrom(const Secret_Value& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret_Value::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Secret_Value::Swap(Secret_Value* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Secret_Value::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Secret_Value_descriptor_;
  metadata.reflection = Secret_Value_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Secret::kTypeFieldNumber;
const int Secret::kReferenceFieldNumber;
const int Secret::kValueFieldNumber;
#endif  // !_MSC_VER

Secret::Secret()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Secret)
}

void Secret::InitAsDefaultInstance() {
  reference_ = const_cast< ::mesos::Secret_Reference*>(&::mesos::Secret_Reference::default_instance());
  value_ = const_cast< ::mesos::Secret_Value*>(&::mesos::Secret_Value::default_instance());
}

Secret::Secret(const Secret& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Secret)
}

void Secret::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  reference_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret::~Secret() {
  // @@protoc_insertion_point(destructor:mesos.Secret)
  SharedDtor();
}

void Secret::SharedDtor() {
  if (this != default_instance_) {
    delete reference_;
    delete value_;
  }
}

void Secret::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Secret::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_descriptor_;
}

const Secret& Secret::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Secret* Secret::default_instance_ = NULL;

Secret* Secret::New() const {
  return new Secret;
}

void Secret::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 0;
    if (has_reference()) {
      if (reference_ != NULL) reference_->::mesos::Secret_Reference::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::mesos::Secret_Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Secret::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Secret)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Secret.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Secret_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Secret_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reference;
        break;
      }

      // optional .mesos.Secret.Reference reference = 2;
      case 2: {
        if (tag == 18) {
         parse_reference:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reference()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional .mesos.Secret.Value value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Secret)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Secret)
  return false;
#undef DO_
}

void Secret::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Secret)
  // optional .mesos.Secret.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Secret.Reference reference = 2;
  if (has_reference()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reference(), output);
  }

  // optional .mesos.Secret.Value value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Secret)
}

::google::protobuf::uint8* Secret::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Secret)
  // optional .mesos.Secret.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Secret.Reference reference = 2;
  if (has_reference()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reference(), target);
  }

  // optional .mesos.Secret.Value value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Secret)
  return target;
}

int Secret::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Secret.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Secret.Reference reference = 2;
    if (has_reference()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reference());
    }

    // optional .mesos.Secret.Value value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Secret* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Secret*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Secret::MergeFrom(const Secret& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_reference()) {
      mutable_reference()->::mesos::Secret_Reference::MergeFrom(from.reference());
    }
    if (from.has_value()) {
      mutable_value()->::mesos::Secret_Value::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Secret::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Secret::CopyFrom(const Secret& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret::IsInitialized() const {

  if (has_reference()) {
    if (!this->reference().IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  return true;
}

void Secret::Swap(Secret* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(reference_, other->reference_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Secret::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Secret_descriptor_;
  metadata.reflection = Secret_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RateLimit::kQpsFieldNumber;
const int RateLimit::kPrincipalFieldNumber;
const int RateLimit::kCapacityFieldNumber;
#endif  // !_MSC_VER

RateLimit::RateLimit()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RateLimit)
}

void RateLimit::InitAsDefaultInstance() {
}

RateLimit::RateLimit(const RateLimit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RateLimit)
}

void RateLimit::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  qps_ = 0;
  principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  capacity_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RateLimit::~RateLimit() {
  // @@protoc_insertion_point(destructor:mesos.RateLimit)
  SharedDtor();
}

void RateLimit::SharedDtor() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (this != default_instance_) {
  }
}

void RateLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RateLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RateLimit_descriptor_;
}

const RateLimit& RateLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RateLimit* RateLimit::default_instance_ = NULL;

RateLimit* RateLimit::New() const {
  return new RateLimit;
}

void RateLimit::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    qps_ = 0;
    if (has_principal()) {
      if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        principal_->clear();
      }
    }
    capacity_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RateLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RateLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double qps = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &qps_)));
          set_has_qps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_principal;
        break;
      }

      // required string principal = 2;
      case 2: {
        if (tag == 18) {
         parse_principal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_capacity;
        break;
      }

      // optional uint64 capacity = 3;
      case 3: {
        if (tag == 24) {
         parse_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RateLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RateLimit)
  return false;
#undef DO_
}

void RateLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RateLimit)
  // optional double qps = 1;
  if (has_qps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->qps(), output);
  }

  // required string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->principal(), output);
  }

  // optional uint64 capacity = 3;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->capacity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RateLimit)
}

::google::protobuf::uint8* RateLimit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RateLimit)
  // optional double qps = 1;
  if (has_qps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->qps(), target);
  }

  // required string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->principal(), target);
  }

  // optional uint64 capacity = 3;
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->capacity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RateLimit)
  return target;
}

int RateLimit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double qps = 1;
    if (has_qps()) {
      total_size += 1 + 8;
    }

    // required string principal = 2;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

    // optional uint64 capacity = 3;
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capacity());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RateLimit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RateLimit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RateLimit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RateLimit::MergeFrom(const RateLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_qps()) {
      set_qps(from.qps());
    }
    if (from.has_principal()) {
      set_principal(from.principal());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RateLimit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RateLimit::CopyFrom(const RateLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RateLimit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void RateLimit::Swap(RateLimit* other) {
  if (other != this) {
    std::swap(qps_, other->qps_);
    std::swap(principal_, other->principal_);
    std::swap(capacity_, other->capacity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RateLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RateLimit_descriptor_;
  metadata.reflection = RateLimit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RateLimits::kLimitsFieldNumber;
const int RateLimits::kAggregateDefaultQpsFieldNumber;
const int RateLimits::kAggregateDefaultCapacityFieldNumber;
#endif  // !_MSC_VER

RateLimits::RateLimits()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RateLimits)
}

void RateLimits::InitAsDefaultInstance() {
}

RateLimits::RateLimits(const RateLimits& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RateLimits)
}

void RateLimits::SharedCtor() {
  _cached_size_ = 0;
  aggregate_default_qps_ = 0;
  aggregate_default_capacity_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RateLimits::~RateLimits() {
  // @@protoc_insertion_point(destructor:mesos.RateLimits)
  SharedDtor();
}

void RateLimits::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RateLimits::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RateLimits::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RateLimits_descriptor_;
}

const RateLimits& RateLimits::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RateLimits* RateLimits::default_instance_ = NULL;

RateLimits* RateLimits::New() const {
  return new RateLimits;
}

void RateLimits::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RateLimits*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(aggregate_default_qps_, aggregate_default_capacity_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  limits_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RateLimits::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RateLimits)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.RateLimit limits = 1;
      case 1: {
        if (tag == 10) {
         parse_limits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_limits()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_limits;
        if (input->ExpectTag(17)) goto parse_aggregate_default_qps;
        break;
      }

      // optional double aggregate_default_qps = 2;
      case 2: {
        if (tag == 17) {
         parse_aggregate_default_qps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &aggregate_default_qps_)));
          set_has_aggregate_default_qps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_aggregate_default_capacity;
        break;
      }

      // optional uint64 aggregate_default_capacity = 3;
      case 3: {
        if (tag == 24) {
         parse_aggregate_default_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &aggregate_default_capacity_)));
          set_has_aggregate_default_capacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RateLimits)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RateLimits)
  return false;
#undef DO_
}

void RateLimits::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RateLimits)
  // repeated .mesos.RateLimit limits = 1;
  for (int i = 0; i < this->limits_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->limits(i), output);
  }

  // optional double aggregate_default_qps = 2;
  if (has_aggregate_default_qps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->aggregate_default_qps(), output);
  }

  // optional uint64 aggregate_default_capacity = 3;
  if (has_aggregate_default_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->aggregate_default_capacity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RateLimits)
}

::google::protobuf::uint8* RateLimits::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RateLimits)
  // repeated .mesos.RateLimit limits = 1;
  for (int i = 0; i < this->limits_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->limits(i), target);
  }

  // optional double aggregate_default_qps = 2;
  if (has_aggregate_default_qps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->aggregate_default_qps(), target);
  }

  // optional uint64 aggregate_default_capacity = 3;
  if (has_aggregate_default_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->aggregate_default_capacity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RateLimits)
  return target;
}

int RateLimits::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional double aggregate_default_qps = 2;
    if (has_aggregate_default_qps()) {
      total_size += 1 + 8;
    }

    // optional uint64 aggregate_default_capacity = 3;
    if (has_aggregate_default_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->aggregate_default_capacity());
    }

  }
  // repeated .mesos.RateLimit limits = 1;
  total_size += 1 * this->limits_size();
  for (int i = 0; i < this->limits_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->limits(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RateLimits::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RateLimits* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RateLimits*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RateLimits::MergeFrom(const RateLimits& from) {
  GOOGLE_CHECK_NE(&from, this);
  limits_.MergeFrom(from.limits_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_aggregate_default_qps()) {
      set_aggregate_default_qps(from.aggregate_default_qps());
    }
    if (from.has_aggregate_default_capacity()) {
      set_aggregate_default_capacity(from.aggregate_default_capacity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RateLimits::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RateLimits::CopyFrom(const RateLimits& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RateLimits::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->limits())) return false;
  return true;
}

void RateLimits::Swap(RateLimits* other) {
  if (other != this) {
    limits_.Swap(&other->limits_);
    std::swap(aggregate_default_qps_, other->aggregate_default_qps_);
    std::swap(aggregate_default_capacity_, other->aggregate_default_capacity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RateLimits::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RateLimits_descriptor_;
  metadata.reflection = RateLimits_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Image_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Type_descriptor_;
}
bool Image_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Image_Type Image::APPC;
const Image_Type Image::DOCKER;
const Image_Type Image::Type_MIN;
const Image_Type Image::Type_MAX;
const int Image::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Image_Appc::kNameFieldNumber;
const int Image_Appc::kIdFieldNumber;
const int Image_Appc::kLabelsFieldNumber;
#endif  // !_MSC_VER

Image_Appc::Image_Appc()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Image.Appc)
}

void Image_Appc::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

Image_Appc::Image_Appc(const Image_Appc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Image.Appc)
}

void Image_Appc::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image_Appc::~Image_Appc() {
  // @@protoc_insertion_point(destructor:mesos.Image.Appc)
  SharedDtor();
}

void Image_Appc::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (this != default_instance_) {
    delete labels_;
  }
}

void Image_Appc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image_Appc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Appc_descriptor_;
}

const Image_Appc& Image_Appc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Image_Appc* Image_Appc::default_instance_ = NULL;

Image_Appc* Image_Appc::New() const {
  return new Image_Appc;
}

void Image_Appc::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        id_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Image_Appc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Image.Appc)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // optional string id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 3;
      case 3: {
        if (tag == 26) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Image.Appc)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Image.Appc)
  return false;
#undef DO_
}

void Image_Appc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Image.Appc)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->id(), output);
  }

  // optional .mesos.Labels labels = 3;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->labels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Image.Appc)
}

::google::protobuf::uint8* Image_Appc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Image.Appc)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->id(), target);
  }

  // optional .mesos.Labels labels = 3;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->labels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Image.Appc)
  return target;
}

int Image_Appc::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional .mesos.Labels labels = 3;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image_Appc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Image_Appc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Image_Appc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Image_Appc::MergeFrom(const Image_Appc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Image_Appc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image_Appc::CopyFrom(const Image_Appc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image_Appc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void Image_Appc::Swap(Image_Appc* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(id_, other->id_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Image_Appc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_Appc_descriptor_;
  metadata.reflection = Image_Appc_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Image_Docker::kNameFieldNumber;
const int Image_Docker::kCredentialFieldNumber;
const int Image_Docker::kConfigFieldNumber;
#endif  // !_MSC_VER

Image_Docker::Image_Docker()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Image.Docker)
}

void Image_Docker::InitAsDefaultInstance() {
  credential_ = const_cast< ::mesos::Credential*>(&::mesos::Credential::default_instance());
  config_ = const_cast< ::mesos::Secret*>(&::mesos::Secret::default_instance());
}

Image_Docker::Image_Docker(const Image_Docker& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Image.Docker)
}

void Image_Docker::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  credential_ = NULL;
  config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image_Docker::~Image_Docker() {
  // @@protoc_insertion_point(destructor:mesos.Image.Docker)
  SharedDtor();
}

void Image_Docker::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete credential_;
    delete config_;
  }
}

void Image_Docker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image_Docker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Docker_descriptor_;
}

const Image_Docker& Image_Docker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Image_Docker* Image_Docker::default_instance_ = NULL;

Image_Docker* Image_Docker::New() const {
  return new Image_Docker;
}

void Image_Docker::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_credential()) {
      if (credential_ != NULL) credential_->::mesos::Credential::Clear();
    }
    if (has_config()) {
      if (config_ != NULL) config_->::mesos::Secret::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Image_Docker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Image.Docker)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_credential;
        break;
      }

      // optional .mesos.Credential credential = 2 [deprecated = true];
      case 2: {
        if (tag == 18) {
         parse_credential:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_credential()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_config;
        break;
      }

      // optional .mesos.Secret config = 3;
      case 3: {
        if (tag == 26) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Image.Docker)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Image.Docker)
  return false;
#undef DO_
}

void Image_Docker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Image.Docker)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .mesos.Credential credential = 2 [deprecated = true];
  if (has_credential()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->credential(), output);
  }

  // optional .mesos.Secret config = 3;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->config(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Image.Docker)
}

::google::protobuf::uint8* Image_Docker::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Image.Docker)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .mesos.Credential credential = 2 [deprecated = true];
  if (has_credential()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->credential(), target);
  }

  // optional .mesos.Secret config = 3;
  if (has_config()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->config(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Image.Docker)
  return target;
}

int Image_Docker::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mesos.Credential credential = 2 [deprecated = true];
    if (has_credential()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->credential());
    }

    // optional .mesos.Secret config = 3;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image_Docker::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Image_Docker* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Image_Docker*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Image_Docker::MergeFrom(const Image_Docker& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_credential()) {
      mutable_credential()->::mesos::Credential::MergeFrom(from.credential());
    }
    if (from.has_config()) {
      mutable_config()->::mesos::Secret::MergeFrom(from.config());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Image_Docker::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image_Docker::CopyFrom(const Image_Docker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image_Docker::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_credential()) {
    if (!this->credential().IsInitialized()) return false;
  }
  if (has_config()) {
    if (!this->config().IsInitialized()) return false;
  }
  return true;
}

void Image_Docker::Swap(Image_Docker* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(credential_, other->credential_);
    std::swap(config_, other->config_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Image_Docker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_Docker_descriptor_;
  metadata.reflection = Image_Docker_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Image::kTypeFieldNumber;
const int Image::kAppcFieldNumber;
const int Image::kDockerFieldNumber;
const int Image::kCachedFieldNumber;
#endif  // !_MSC_VER

Image::Image()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Image)
}

void Image::InitAsDefaultInstance() {
  appc_ = const_cast< ::mesos::Image_Appc*>(&::mesos::Image_Appc::default_instance());
  docker_ = const_cast< ::mesos::Image_Docker*>(&::mesos::Image_Docker::default_instance());
}

Image::Image(const Image& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Image)
}

void Image::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  appc_ = NULL;
  docker_ = NULL;
  cached_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:mesos.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  if (this != default_instance_) {
    delete appc_;
    delete docker_;
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New() const {
  return new Image;
}

void Image::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 1;
    if (has_appc()) {
      if (appc_ != NULL) appc_->::mesos::Image_Appc::Clear();
    }
    if (has_docker()) {
      if (docker_ != NULL) docker_->::mesos::Image_Docker::Clear();
    }
    cached_ = true;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Image.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Image_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Image_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_appc;
        break;
      }

      // optional .mesos.Image.Appc appc = 2;
      case 2: {
        if (tag == 18) {
         parse_appc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_appc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_docker;
        break;
      }

      // optional .mesos.Image.Docker docker = 3;
      case 3: {
        if (tag == 26) {
         parse_docker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cached;
        break;
      }

      // optional bool cached = 4 [default = true];
      case 4: {
        if (tag == 32) {
         parse_cached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cached_)));
          set_has_cached();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Image)
  // required .mesos.Image.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Image.Appc appc = 2;
  if (has_appc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->appc(), output);
  }

  // optional .mesos.Image.Docker docker = 3;
  if (has_docker()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->docker(), output);
  }

  // optional bool cached = 4 [default = true];
  if (has_cached()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->cached(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Image)
}

::google::protobuf::uint8* Image::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Image)
  // required .mesos.Image.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Image.Appc appc = 2;
  if (has_appc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->appc(), target);
  }

  // optional .mesos.Image.Docker docker = 3;
  if (has_docker()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->docker(), target);
  }

  // optional bool cached = 4 [default = true];
  if (has_cached()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->cached(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Image)
  return target;
}

int Image::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.Image.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Image.Appc appc = 2;
    if (has_appc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->appc());
    }

    // optional .mesos.Image.Docker docker = 3;
    if (has_docker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->docker());
    }

    // optional bool cached = 4 [default = true];
    if (has_cached()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Image* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Image*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_appc()) {
      mutable_appc()->::mesos::Image_Appc::MergeFrom(from.appc());
    }
    if (from.has_docker()) {
      mutable_docker()->::mesos::Image_Docker::MergeFrom(from.docker());
    }
    if (from.has_cached()) {
      set_cached(from.cached());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_appc()) {
    if (!this->appc().IsInitialized()) return false;
  }
  if (has_docker()) {
    if (!this->docker().IsInitialized()) return false;
  }
  return true;
}

void Image::Swap(Image* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(appc_, other->appc_);
    std::swap(docker_, other->docker_);
    std::swap(cached_, other->cached_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_descriptor_;
  metadata.reflection = Image_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Mode_descriptor_;
}
bool Volume_Mode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Volume_Mode Volume::RW;
const Volume_Mode Volume::RO;
const Volume_Mode Volume::Mode_MIN;
const Volume_Mode Volume::Mode_MAX;
const int Volume::Mode_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Volume_Source_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_Type_descriptor_;
}
bool Volume_Source_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Volume_Source_Type Volume_Source::UNKNOWN;
const Volume_Source_Type Volume_Source::DOCKER_VOLUME;
const Volume_Source_Type Volume_Source::SANDBOX_PATH;
const Volume_Source_Type Volume_Source::SECRET;
const Volume_Source_Type Volume_Source::Type_MIN;
const Volume_Source_Type Volume_Source::Type_MAX;
const int Volume_Source::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Volume_Source_DockerVolume::kDriverFieldNumber;
const int Volume_Source_DockerVolume::kNameFieldNumber;
const int Volume_Source_DockerVolume::kDriverOptionsFieldNumber;
#endif  // !_MSC_VER

Volume_Source_DockerVolume::Volume_Source_DockerVolume()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume.Source.DockerVolume)
}

void Volume_Source_DockerVolume::InitAsDefaultInstance() {
  driver_options_ = const_cast< ::mesos::Parameters*>(&::mesos::Parameters::default_instance());
}

Volume_Source_DockerVolume::Volume_Source_DockerVolume(const Volume_Source_DockerVolume& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume.Source.DockerVolume)
}

void Volume_Source_DockerVolume::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  driver_options_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume_Source_DockerVolume::~Volume_Source_DockerVolume() {
  // @@protoc_insertion_point(destructor:mesos.Volume.Source.DockerVolume)
  SharedDtor();
}

void Volume_Source_DockerVolume::SharedDtor() {
  if (driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete driver_;
  }
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete driver_options_;
  }
}

void Volume_Source_DockerVolume::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume_Source_DockerVolume::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_DockerVolume_descriptor_;
}

const Volume_Source_DockerVolume& Volume_Source_DockerVolume::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume_Source_DockerVolume* Volume_Source_DockerVolume::default_instance_ = NULL;

Volume_Source_DockerVolume* Volume_Source_DockerVolume::New() const {
  return new Volume_Source_DockerVolume;
}

void Volume_Source_DockerVolume::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_driver()) {
      if (driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        driver_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_driver_options()) {
      if (driver_options_ != NULL) driver_options_->::mesos::Parameters::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Volume_Source_DockerVolume::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume.Source.DockerVolume)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string driver = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_driver()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->driver().data(), this->driver().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "driver");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_driver_options;
        break;
      }

      // optional .mesos.Parameters driver_options = 3;
      case 3: {
        if (tag == 26) {
         parse_driver_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_driver_options()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume.Source.DockerVolume)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume.Source.DockerVolume)
  return false;
#undef DO_
}

void Volume_Source_DockerVolume::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume.Source.DockerVolume)
  // optional string driver = 1;
  if (has_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->driver().data(), this->driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "driver");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->driver(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional .mesos.Parameters driver_options = 3;
  if (has_driver_options()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->driver_options(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume.Source.DockerVolume)
}

::google::protobuf::uint8* Volume_Source_DockerVolume::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume.Source.DockerVolume)
  // optional string driver = 1;
  if (has_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->driver().data(), this->driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "driver");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->driver(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional .mesos.Parameters driver_options = 3;
  if (has_driver_options()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->driver_options(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume.Source.DockerVolume)
  return target;
}

int Volume_Source_DockerVolume::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string driver = 1;
    if (has_driver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->driver());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mesos.Parameters driver_options = 3;
    if (has_driver_options()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->driver_options());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume_Source_DockerVolume::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Volume_Source_DockerVolume* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Volume_Source_DockerVolume*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Volume_Source_DockerVolume::MergeFrom(const Volume_Source_DockerVolume& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_driver()) {
      set_driver(from.driver());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_driver_options()) {
      mutable_driver_options()->::mesos::Parameters::MergeFrom(from.driver_options());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Volume_Source_DockerVolume::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume_Source_DockerVolume::CopyFrom(const Volume_Source_DockerVolume& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume_Source_DockerVolume::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_driver_options()) {
    if (!this->driver_options().IsInitialized()) return false;
  }
  return true;
}

void Volume_Source_DockerVolume::Swap(Volume_Source_DockerVolume* other) {
  if (other != this) {
    std::swap(driver_, other->driver_);
    std::swap(name_, other->name_);
    std::swap(driver_options_, other->driver_options_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Volume_Source_DockerVolume::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_Source_DockerVolume_descriptor_;
  metadata.reflection = Volume_Source_DockerVolume_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* Volume_Source_SandboxPath_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_SandboxPath_Type_descriptor_;
}
bool Volume_Source_SandboxPath_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::UNKNOWN;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::SELF;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::PARENT;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::Type_MIN;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::Type_MAX;
const int Volume_Source_SandboxPath::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Volume_Source_SandboxPath::kTypeFieldNumber;
const int Volume_Source_SandboxPath::kPathFieldNumber;
#endif  // !_MSC_VER

Volume_Source_SandboxPath::Volume_Source_SandboxPath()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume.Source.SandboxPath)
}

void Volume_Source_SandboxPath::InitAsDefaultInstance() {
}

Volume_Source_SandboxPath::Volume_Source_SandboxPath(const Volume_Source_SandboxPath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume.Source.SandboxPath)
}

void Volume_Source_SandboxPath::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume_Source_SandboxPath::~Volume_Source_SandboxPath() {
  // @@protoc_insertion_point(destructor:mesos.Volume.Source.SandboxPath)
  SharedDtor();
}

void Volume_Source_SandboxPath::SharedDtor() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void Volume_Source_SandboxPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume_Source_SandboxPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_SandboxPath_descriptor_;
}

const Volume_Source_SandboxPath& Volume_Source_SandboxPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume_Source_SandboxPath* Volume_Source_SandboxPath::default_instance_ = NULL;

Volume_Source_SandboxPath* Volume_Source_SandboxPath::New() const {
  return new Volume_Source_SandboxPath;
}

void Volume_Source_SandboxPath::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    type_ = 0;
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Volume_Source_SandboxPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume.Source.SandboxPath)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Volume_Source_SandboxPath_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Volume_Source_SandboxPath_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // required string path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume.Source.SandboxPath)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume.Source.SandboxPath)
  return false;
#undef DO_
}

void Volume_Source_SandboxPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume.Source.SandboxPath)
  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume.Source.SandboxPath)
}

::google::protobuf::uint8* Volume_Source_SandboxPath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume.Source.SandboxPath)
  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume.Source.SandboxPath)
  return target;
}

int Volume_Source_SandboxPath::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume_Source_SandboxPath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Volume_Source_SandboxPath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Volume_Source_SandboxPath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Volume_Source_SandboxPath::MergeFrom(const Volume_Source_SandboxPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Volume_Source_SandboxPath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume_Source_SandboxPath::CopyFrom(const Volume_Source_SandboxPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume_Source_SandboxPath::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void Volume_Source_SandboxPath::Swap(Volume_Source_SandboxPath* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Volume_Source_SandboxPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_Source_SandboxPath_descriptor_;
  metadata.reflection = Volume_Source_SandboxPath_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Volume_Source::kTypeFieldNumber;
const int Volume_Source::kDockerVolumeFieldNumber;
const int Volume_Source::kSandboxPathFieldNumber;
const int Volume_Source::kSecretFieldNumber;
#endif  // !_MSC_VER

Volume_Source::Volume_Source()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume.Source)
}

void Volume_Source::InitAsDefaultInstance() {
  docker_volume_ = const_cast< ::mesos::Volume_Source_DockerVolume*>(&::mesos::Volume_Source_DockerVolume::default_instance());
  sandbox_path_ = const_cast< ::mesos::Volume_Source_SandboxPath*>(&::mesos::Volume_Source_SandboxPath::default_instance());
  secret_ = const_cast< ::mesos::Secret*>(&::mesos::Secret::default_instance());
}

Volume_Source::Volume_Source(const Volume_Source& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume.Source)
}

void Volume_Source::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  docker_volume_ = NULL;
  sandbox_path_ = NULL;
  secret_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume_Source::~Volume_Source() {
  // @@protoc_insertion_point(destructor:mesos.Volume.Source)
  SharedDtor();
}

void Volume_Source::SharedDtor() {
  if (this != default_instance_) {
    delete docker_volume_;
    delete sandbox_path_;
    delete secret_;
  }
}

void Volume_Source::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume_Source::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_descriptor_;
}

const Volume_Source& Volume_Source::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume_Source* Volume_Source::default_instance_ = NULL;

Volume_Source* Volume_Source::New() const {
  return new Volume_Source;
}

void Volume_Source::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 0;
    if (has_docker_volume()) {
      if (docker_volume_ != NULL) docker_volume_->::mesos::Volume_Source_DockerVolume::Clear();
    }
    if (has_sandbox_path()) {
      if (sandbox_path_ != NULL) sandbox_path_->::mesos::Volume_Source_SandboxPath::Clear();
    }
    if (has_secret()) {
      if (secret_ != NULL) secret_->::mesos::Secret::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Volume_Source::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume.Source)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Volume.Source.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Volume_Source_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Volume_Source_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_docker_volume;
        break;
      }

      // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
      case 2: {
        if (tag == 18) {
         parse_docker_volume:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker_volume()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_sandbox_path;
        break;
      }

      // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
      case 3: {
        if (tag == 26) {
         parse_sandbox_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sandbox_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_secret;
        break;
      }

      // optional .mesos.Secret secret = 4;
      case 4: {
        if (tag == 34) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume.Source)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume.Source)
  return false;
#undef DO_
}

void Volume_Source::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume.Source)
  // optional .mesos.Volume.Source.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
  if (has_docker_volume()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->docker_volume(), output);
  }

  // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
  if (has_sandbox_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sandbox_path(), output);
  }

  // optional .mesos.Secret secret = 4;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->secret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume.Source)
}

::google::protobuf::uint8* Volume_Source::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume.Source)
  // optional .mesos.Volume.Source.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
  if (has_docker_volume()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->docker_volume(), target);
  }

  // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
  if (has_sandbox_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sandbox_path(), target);
  }

  // optional .mesos.Secret secret = 4;
  if (has_secret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->secret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume.Source)
  return target;
}

int Volume_Source::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Volume.Source.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
    if (has_docker_volume()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->docker_volume());
    }

    // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
    if (has_sandbox_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sandbox_path());
    }

    // optional .mesos.Secret secret = 4;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume_Source::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Volume_Source* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Volume_Source*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Volume_Source::MergeFrom(const Volume_Source& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_docker_volume()) {
      mutable_docker_volume()->::mesos::Volume_Source_DockerVolume::MergeFrom(from.docker_volume());
    }
    if (from.has_sandbox_path()) {
      mutable_sandbox_path()->::mesos::Volume_Source_SandboxPath::MergeFrom(from.sandbox_path());
    }
    if (from.has_secret()) {
      mutable_secret()->::mesos::Secret::MergeFrom(from.secret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Volume_Source::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume_Source::CopyFrom(const Volume_Source& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume_Source::IsInitialized() const {

  if (has_docker_volume()) {
    if (!this->docker_volume().IsInitialized()) return false;
  }
  if (has_sandbox_path()) {
    if (!this->sandbox_path().IsInitialized()) return false;
  }
  if (has_secret()) {
    if (!this->secret().IsInitialized()) return false;
  }
  return true;
}

void Volume_Source::Swap(Volume_Source* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(docker_volume_, other->docker_volume_);
    std::swap(sandbox_path_, other->sandbox_path_);
    std::swap(secret_, other->secret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Volume_Source::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_Source_descriptor_;
  metadata.reflection = Volume_Source_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Volume::kModeFieldNumber;
const int Volume::kContainerPathFieldNumber;
const int Volume::kHostPathFieldNumber;
const int Volume::kImageFieldNumber;
const int Volume::kSourceFieldNumber;
#endif  // !_MSC_VER

Volume::Volume()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume)
}

void Volume::InitAsDefaultInstance() {
  image_ = const_cast< ::mesos::Image*>(&::mesos::Image::default_instance());
  source_ = const_cast< ::mesos::Volume_Source*>(&::mesos::Volume_Source::default_instance());
}

Volume::Volume(const Volume& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume)
}

void Volume::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mode_ = 1;
  container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  host_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  image_ = NULL;
  source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume::~Volume() {
  // @@protoc_insertion_point(destructor:mesos.Volume)
  SharedDtor();
}

void Volume::SharedDtor() {
  if (container_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete container_path_;
  }
  if (host_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_path_;
  }
  if (this != default_instance_) {
    delete image_;
    delete source_;
  }
}

void Volume::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_descriptor_;
}

const Volume& Volume::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume* Volume::default_instance_ = NULL;

Volume* Volume::New() const {
  return new Volume;
}

void Volume::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    mode_ = 1;
    if (has_container_path()) {
      if (container_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        container_path_->clear();
      }
    }
    if (has_host_path()) {
      if (host_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        host_path_->clear();
      }
    }
    if (has_image()) {
      if (image_ != NULL) image_->::mesos::Image::Clear();
    }
    if (has_source()) {
      if (source_ != NULL) source_->::mesos::Volume_Source::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Volume::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string container_path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_container_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->container_path().data(), this->container_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "container_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_host_path;
        break;
      }

      // optional string host_path = 2;
      case 2: {
        if (tag == 18) {
         parse_host_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->host_path().data(), this->host_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "host_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mode;
        break;
      }

      // required .mesos.Volume.Mode mode = 3;
      case 3: {
        if (tag == 24) {
         parse_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Volume_Mode_IsValid(value)) {
            set_mode(static_cast< ::mesos::Volume_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_image;
        break;
      }

      // optional .mesos.Image image = 4;
      case 4: {
        if (tag == 34) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_source;
        break;
      }

      // optional .mesos.Volume.Source source = 5;
      case 5: {
        if (tag == 42) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume)
  return false;
#undef DO_
}

void Volume::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume)
  // required string container_path = 1;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "container_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->container_path(), output);
  }

  // optional string host_path = 2;
  if (has_host_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host_path().data(), this->host_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "host_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->host_path(), output);
  }

  // required .mesos.Volume.Mode mode = 3;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->mode(), output);
  }

  // optional .mesos.Image image = 4;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->image(), output);
  }

  // optional .mesos.Volume.Source source = 5;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->source(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume)
}

::google::protobuf::uint8* Volume::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume)
  // required string container_path = 1;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "container_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->container_path(), target);
  }

  // optional string host_path = 2;
  if (has_host_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host_path().data(), this->host_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "host_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->host_path(), target);
  }

  // required .mesos.Volume.Mode mode = 3;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->mode(), target);
  }

  // optional .mesos.Image image = 4;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->image(), target);
  }

  // optional .mesos.Volume.Source source = 5;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->source(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume)
  return target;
}

int Volume::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.Volume.Mode mode = 3;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // required string container_path = 1;
    if (has_container_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->container_path());
    }

    // optional string host_path = 2;
    if (has_host_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host_path());
    }

    // optional .mesos.Image image = 4;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image());
    }

    // optional .mesos.Volume.Source source = 5;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->source());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Volume* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Volume*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Volume::MergeFrom(const Volume& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_container_path()) {
      set_container_path(from.container_path());
    }
    if (from.has_host_path()) {
      set_host_path(from.host_path());
    }
    if (from.has_image()) {
      mutable_image()->::mesos::Image::MergeFrom(from.image());
    }
    if (from.has_source()) {
      mutable_source()->::mesos::Volume_Source::MergeFrom(from.source());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Volume::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume::CopyFrom(const Volume& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  if (has_source()) {
    if (!this->source().IsInitialized()) return false;
  }
  return true;
}

void Volume::Swap(Volume* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(container_path_, other->container_path_);
    std::swap(host_path_, other->host_path_);
    std::swap(image_, other->image_);
    std::swap(source_, other->source_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Volume::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_descriptor_;
  metadata.reflection = Volume_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* NetworkInfo_Protocol_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_Protocol_descriptor_;
}
bool NetworkInfo_Protocol_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const NetworkInfo_Protocol NetworkInfo::IPv4;
const NetworkInfo_Protocol NetworkInfo::IPv6;
const NetworkInfo_Protocol NetworkInfo::Protocol_MIN;
const NetworkInfo_Protocol NetworkInfo::Protocol_MAX;
const int NetworkInfo::Protocol_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int NetworkInfo_IPAddress::kProtocolFieldNumber;
const int NetworkInfo_IPAddress::kIpAddressFieldNumber;
#endif  // !_MSC_VER

NetworkInfo_IPAddress::NetworkInfo_IPAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.NetworkInfo.IPAddress)
}

void NetworkInfo_IPAddress::InitAsDefaultInstance() {
}

NetworkInfo_IPAddress::NetworkInfo_IPAddress(const NetworkInfo_IPAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.NetworkInfo.IPAddress)
}

void NetworkInfo_IPAddress::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  protocol_ = 1;
  ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkInfo_IPAddress::~NetworkInfo_IPAddress() {
  // @@protoc_insertion_point(destructor:mesos.NetworkInfo.IPAddress)
  SharedDtor();
}

void NetworkInfo_IPAddress::SharedDtor() {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (this != default_instance_) {
  }
}

void NetworkInfo_IPAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkInfo_IPAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_IPAddress_descriptor_;
}

const NetworkInfo_IPAddress& NetworkInfo_IPAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

NetworkInfo_IPAddress* NetworkInfo_IPAddress::default_instance_ = NULL;

NetworkInfo_IPAddress* NetworkInfo_IPAddress::New() const {
  return new NetworkInfo_IPAddress;
}

void NetworkInfo_IPAddress::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    protocol_ = 1;
    if (has_ip_address()) {
      if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_address_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetworkInfo_IPAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.NetworkInfo.IPAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.NetworkInfo.Protocol protocol = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::NetworkInfo_Protocol_IsValid(value)) {
            set_protocol(static_cast< ::mesos::NetworkInfo_Protocol >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip_address;
        break;
      }

      // optional string ip_address = 2;
      case 2: {
        if (tag == 18) {
         parse_ip_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip_address().data(), this->ip_address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip_address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.NetworkInfo.IPAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.NetworkInfo.IPAddress)
  return false;
#undef DO_
}

void NetworkInfo_IPAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.NetworkInfo.IPAddress)
  // optional .mesos.NetworkInfo.Protocol protocol = 1;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->protocol(), output);
  }

  // optional string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip_address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.NetworkInfo.IPAddress)
}

::google::protobuf::uint8* NetworkInfo_IPAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.NetworkInfo.IPAddress)
  // optional .mesos.NetworkInfo.Protocol protocol = 1;
  if (has_protocol()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->protocol(), target);
  }

  // optional string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip_address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.NetworkInfo.IPAddress)
  return target;
}

int NetworkInfo_IPAddress::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.NetworkInfo.Protocol protocol = 1;
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->protocol());
    }

    // optional string ip_address = 2;
    if (has_ip_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip_address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkInfo_IPAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetworkInfo_IPAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetworkInfo_IPAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetworkInfo_IPAddress::MergeFrom(const NetworkInfo_IPAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
    if (from.has_ip_address()) {
      set_ip_address(from.ip_address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetworkInfo_IPAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkInfo_IPAddress::CopyFrom(const NetworkInfo_IPAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInfo_IPAddress::IsInitialized() const {

  return true;
}

void NetworkInfo_IPAddress::Swap(NetworkInfo_IPAddress* other) {
  if (other != this) {
    std::swap(protocol_, other->protocol_);
    std::swap(ip_address_, other->ip_address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetworkInfo_IPAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkInfo_IPAddress_descriptor_;
  metadata.reflection = NetworkInfo_IPAddress_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int NetworkInfo_PortMapping::kHostPortFieldNumber;
const int NetworkInfo_PortMapping::kContainerPortFieldNumber;
const int NetworkInfo_PortMapping::kProtocolFieldNumber;
#endif  // !_MSC_VER

NetworkInfo_PortMapping::NetworkInfo_PortMapping()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.NetworkInfo.PortMapping)
}

void NetworkInfo_PortMapping::InitAsDefaultInstance() {
}

NetworkInfo_PortMapping::NetworkInfo_PortMapping(const NetworkInfo_PortMapping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.NetworkInfo.PortMapping)
}

void NetworkInfo_PortMapping::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_port_ = 0u;
  container_port_ = 0u;
  protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkInfo_PortMapping::~NetworkInfo_PortMapping() {
  // @@protoc_insertion_point(destructor:mesos.NetworkInfo.PortMapping)
  SharedDtor();
}

void NetworkInfo_PortMapping::SharedDtor() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (this != default_instance_) {
  }
}

void NetworkInfo_PortMapping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkInfo_PortMapping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_PortMapping_descriptor_;
}

const NetworkInfo_PortMapping& NetworkInfo_PortMapping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

NetworkInfo_PortMapping* NetworkInfo_PortMapping::default_instance_ = NULL;

NetworkInfo_PortMapping* NetworkInfo_PortMapping::New() const {
  return new NetworkInfo_PortMapping;
}

void NetworkInfo_PortMapping::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NetworkInfo_PortMapping*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(host_port_, container_port_);
    if (has_protocol()) {
      if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        protocol_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetworkInfo_PortMapping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.NetworkInfo.PortMapping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_port_)));
          set_has_host_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_container_port;
        break;
      }

      // required uint32 container_port = 2;
      case 2: {
        if (tag == 16) {
         parse_container_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &container_port_)));
          set_has_container_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_protocol;
        break;
      }

      // optional string protocol = 3;
      case 3: {
        if (tag == 26) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->protocol().data(), this->protocol().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.NetworkInfo.PortMapping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.NetworkInfo.PortMapping)
  return false;
#undef DO_
}

void NetworkInfo_PortMapping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.NetworkInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_port(), output);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->container_port(), output);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->protocol(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.NetworkInfo.PortMapping)
}

::google::protobuf::uint8* NetworkInfo_PortMapping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.NetworkInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->host_port(), target);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->container_port(), target);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->protocol(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.NetworkInfo.PortMapping)
  return target;
}

int NetworkInfo_PortMapping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 host_port = 1;
    if (has_host_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->host_port());
    }

    // required uint32 container_port = 2;
    if (has_container_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->container_port());
    }

    // optional string protocol = 3;
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->protocol());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkInfo_PortMapping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetworkInfo_PortMapping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetworkInfo_PortMapping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetworkInfo_PortMapping::MergeFrom(const NetworkInfo_PortMapping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_port()) {
      set_host_port(from.host_port());
    }
    if (from.has_container_port()) {
      set_container_port(from.container_port());
    }
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetworkInfo_PortMapping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkInfo_PortMapping::CopyFrom(const NetworkInfo_PortMapping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInfo_PortMapping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NetworkInfo_PortMapping::Swap(NetworkInfo_PortMapping* other) {
  if (other != this) {
    std::swap(host_port_, other->host_port_);
    std::swap(container_port_, other->container_port_);
    std::swap(protocol_, other->protocol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetworkInfo_PortMapping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkInfo_PortMapping_descriptor_;
  metadata.reflection = NetworkInfo_PortMapping_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int NetworkInfo::kIpAddressesFieldNumber;
const int NetworkInfo::kNameFieldNumber;
const int NetworkInfo::kGroupsFieldNumber;
const int NetworkInfo::kLabelsFieldNumber;
const int NetworkInfo::kPortMappingsFieldNumber;
#endif  // !_MSC_VER

NetworkInfo::NetworkInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.NetworkInfo)
}

void NetworkInfo::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

NetworkInfo::NetworkInfo(const NetworkInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.NetworkInfo)
}

void NetworkInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkInfo::~NetworkInfo() {
  // @@protoc_insertion_point(destructor:mesos.NetworkInfo)
  SharedDtor();
}

void NetworkInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete labels_;
  }
}

void NetworkInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_descriptor_;
}

const NetworkInfo& NetworkInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

NetworkInfo* NetworkInfo::default_instance_ = NULL;

NetworkInfo* NetworkInfo::New() const {
  return new NetworkInfo;
}

void NetworkInfo::Clear() {
  if (_has_bits_[0 / 32] & 10) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ip_addresses_.Clear();
  groups_.Clear();
  port_mappings_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetworkInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.NetworkInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string groups = 3;
      case 3: {
        if (tag == 26) {
         parse_groups:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_groups()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->groups(this->groups_size() - 1).data(),
            this->groups(this->groups_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "groups");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_groups;
        if (input->ExpectTag(34)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 4;
      case 4: {
        if (tag == 34) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ip_addresses;
        break;
      }

      // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
      case 5: {
        if (tag == 42) {
         parse_ip_addresses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addresses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ip_addresses;
        if (input->ExpectTag(50)) goto parse_name;
        break;
      }

      // optional string name = 6;
      case 6: {
        if (tag == 50) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_port_mappings;
        break;
      }

      // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
      case 7: {
        if (tag == 58) {
         parse_port_mappings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_port_mappings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_port_mappings;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.NetworkInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.NetworkInfo)
  return false;
#undef DO_
}

void NetworkInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.NetworkInfo)
  // repeated string groups = 3;
  for (int i = 0; i < this->groups_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->groups(i).data(), this->groups(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "groups");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->groups(i), output);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->labels(), output);
  }

  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  for (int i = 0; i < this->ip_addresses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->ip_addresses(i), output);
  }

  // optional string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->name(), output);
  }

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  for (int i = 0; i < this->port_mappings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->port_mappings(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.NetworkInfo)
}

::google::protobuf::uint8* NetworkInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.NetworkInfo)
  // repeated string groups = 3;
  for (int i = 0; i < this->groups_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->groups(i).data(), this->groups(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "groups");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->groups(i), target);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->labels(), target);
  }

  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  for (int i = 0; i < this->ip_addresses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->ip_addresses(i), target);
  }

  // optional string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->name(), target);
  }

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  for (int i = 0; i < this->port_mappings_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->port_mappings(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.NetworkInfo)
  return target;
}

int NetworkInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string name = 6;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mesos.Labels labels = 4;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  total_size += 1 * this->ip_addresses_size();
  for (int i = 0; i < this->ip_addresses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addresses(i));
  }

  // repeated string groups = 3;
  total_size += 1 * this->groups_size();
  for (int i = 0; i < this->groups_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->groups(i));
  }

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  total_size += 1 * this->port_mappings_size();
  for (int i = 0; i < this->port_mappings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port_mappings(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetworkInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetworkInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetworkInfo::MergeFrom(const NetworkInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  ip_addresses_.MergeFrom(from.ip_addresses_);
  groups_.MergeFrom(from.groups_);
  port_mappings_.MergeFrom(from.port_mappings_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetworkInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkInfo::CopyFrom(const NetworkInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInfo::IsInitialized() const {

  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->port_mappings())) return false;
  return true;
}

void NetworkInfo::Swap(NetworkInfo* other) {
  if (other != this) {
    ip_addresses_.Swap(&other->ip_addresses_);
    std::swap(name_, other->name_);
    groups_.Swap(&other->groups_);
    std::swap(labels_, other->labels_);
    port_mappings_.Swap(&other->port_mappings_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetworkInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkInfo_descriptor_;
  metadata.reflection = NetworkInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* CapabilityInfo_Capability_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CapabilityInfo_Capability_descriptor_;
}
bool CapabilityInfo_Capability_IsValid(int value) {
  switch(value) {
    case 0:
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
    case 1006:
    case 1007:
    case 1008:
    case 1009:
    case 1010:
    case 1011:
    case 1012:
    case 1013:
    case 1014:
    case 1015:
    case 1016:
    case 1017:
    case 1018:
    case 1019:
    case 1020:
    case 1021:
    case 1022:
    case 1023:
    case 1024:
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
    case 1036:
    case 1037:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CapabilityInfo_Capability CapabilityInfo::UNKNOWN;
const CapabilityInfo_Capability CapabilityInfo::CHOWN;
const CapabilityInfo_Capability CapabilityInfo::DAC_OVERRIDE;
const CapabilityInfo_Capability CapabilityInfo::DAC_READ_SEARCH;
const CapabilityInfo_Capability CapabilityInfo::FOWNER;
const CapabilityInfo_Capability CapabilityInfo::FSETID;
const CapabilityInfo_Capability CapabilityInfo::KILL;
const CapabilityInfo_Capability CapabilityInfo::SETGID;
const CapabilityInfo_Capability CapabilityInfo::SETUID;
const CapabilityInfo_Capability CapabilityInfo::SETPCAP;
const CapabilityInfo_Capability CapabilityInfo::LINUX_IMMUTABLE;
const CapabilityInfo_Capability CapabilityInfo::NET_BIND_SERVICE;
const CapabilityInfo_Capability CapabilityInfo::NET_BROADCAST;
const CapabilityInfo_Capability CapabilityInfo::NET_ADMIN;
const CapabilityInfo_Capability CapabilityInfo::NET_RAW;
const CapabilityInfo_Capability CapabilityInfo::IPC_LOCK;
const CapabilityInfo_Capability CapabilityInfo::IPC_OWNER;
const CapabilityInfo_Capability CapabilityInfo::SYS_MODULE;
const CapabilityInfo_Capability CapabilityInfo::SYS_RAWIO;
const CapabilityInfo_Capability CapabilityInfo::SYS_CHROOT;
const CapabilityInfo_Capability CapabilityInfo::SYS_PTRACE;
const CapabilityInfo_Capability CapabilityInfo::SYS_PACCT;
const CapabilityInfo_Capability CapabilityInfo::SYS_ADMIN;
const CapabilityInfo_Capability CapabilityInfo::SYS_BOOT;
const CapabilityInfo_Capability CapabilityInfo::SYS_NICE;
const CapabilityInfo_Capability CapabilityInfo::SYS_RESOURCE;
const CapabilityInfo_Capability CapabilityInfo::SYS_TIME;
const CapabilityInfo_Capability CapabilityInfo::SYS_TTY_CONFIG;
const CapabilityInfo_Capability CapabilityInfo::MKNOD;
const CapabilityInfo_Capability CapabilityInfo::LEASE;
const CapabilityInfo_Capability CapabilityInfo::AUDIT_WRITE;
const CapabilityInfo_Capability CapabilityInfo::AUDIT_CONTROL;
const CapabilityInfo_Capability CapabilityInfo::SETFCAP;
const CapabilityInfo_Capability CapabilityInfo::MAC_OVERRIDE;
const CapabilityInfo_Capability CapabilityInfo::MAC_ADMIN;
const CapabilityInfo_Capability CapabilityInfo::SYSLOG;
const CapabilityInfo_Capability CapabilityInfo::WAKE_ALARM;
const CapabilityInfo_Capability CapabilityInfo::BLOCK_SUSPEND;
const CapabilityInfo_Capability CapabilityInfo::AUDIT_READ;
const CapabilityInfo_Capability CapabilityInfo::Capability_MIN;
const CapabilityInfo_Capability CapabilityInfo::Capability_MAX;
const int CapabilityInfo::Capability_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CapabilityInfo::kCapabilitiesFieldNumber;
#endif  // !_MSC_VER

CapabilityInfo::CapabilityInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CapabilityInfo)
}

void CapabilityInfo::InitAsDefaultInstance() {
}

CapabilityInfo::CapabilityInfo(const CapabilityInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CapabilityInfo)
}

void CapabilityInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CapabilityInfo::~CapabilityInfo() {
  // @@protoc_insertion_point(destructor:mesos.CapabilityInfo)
  SharedDtor();
}

void CapabilityInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CapabilityInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CapabilityInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CapabilityInfo_descriptor_;
}

const CapabilityInfo& CapabilityInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CapabilityInfo* CapabilityInfo::default_instance_ = NULL;

CapabilityInfo* CapabilityInfo::New() const {
  return new CapabilityInfo;
}

void CapabilityInfo::Clear() {
  capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CapabilityInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CapabilityInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
      case 1: {
        if (tag == 8) {
         parse_capabilities:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::CapabilityInfo_Capability_IsValid(value)) {
            add_capabilities(static_cast< ::mesos::CapabilityInfo_Capability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::mesos::CapabilityInfo_Capability_IsValid,
                 this->mutable_capabilities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_capabilities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CapabilityInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CapabilityInfo)
  return false;
#undef DO_
}

void CapabilityInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CapabilityInfo)
  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  for (int i = 0; i < this->capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->capabilities(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CapabilityInfo)
}

::google::protobuf::uint8* CapabilityInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CapabilityInfo)
  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  for (int i = 0; i < this->capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->capabilities(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CapabilityInfo)
  return target;
}

int CapabilityInfo::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->capabilities_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->capabilities(i));
    }
    total_size += 1 * this->capabilities_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CapabilityInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CapabilityInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CapabilityInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CapabilityInfo::MergeFrom(const CapabilityInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  capabilities_.MergeFrom(from.capabilities_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CapabilityInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CapabilityInfo::CopyFrom(const CapabilityInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityInfo::IsInitialized() const {

  return true;
}

void CapabilityInfo::Swap(CapabilityInfo* other) {
  if (other != this) {
    capabilities_.Swap(&other->capabilities_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CapabilityInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CapabilityInfo_descriptor_;
  metadata.reflection = CapabilityInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LinuxInfo::kCapabilityInfoFieldNumber;
#endif  // !_MSC_VER

LinuxInfo::LinuxInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.LinuxInfo)
}

void LinuxInfo::InitAsDefaultInstance() {
  capability_info_ = const_cast< ::mesos::CapabilityInfo*>(&::mesos::CapabilityInfo::default_instance());
}

LinuxInfo::LinuxInfo(const LinuxInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.LinuxInfo)
}

void LinuxInfo::SharedCtor() {
  _cached_size_ = 0;
  capability_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinuxInfo::~LinuxInfo() {
  // @@protoc_insertion_point(destructor:mesos.LinuxInfo)
  SharedDtor();
}

void LinuxInfo::SharedDtor() {
  if (this != default_instance_) {
    delete capability_info_;
  }
}

void LinuxInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LinuxInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LinuxInfo_descriptor_;
}

const LinuxInfo& LinuxInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

LinuxInfo* LinuxInfo::default_instance_ = NULL;

LinuxInfo* LinuxInfo::New() const {
  return new LinuxInfo;
}

void LinuxInfo::Clear() {
  if (has_capability_info()) {
    if (capability_info_ != NULL) capability_info_->::mesos::CapabilityInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LinuxInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.LinuxInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CapabilityInfo capability_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_capability_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.LinuxInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.LinuxInfo)
  return false;
#undef DO_
}

void LinuxInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.LinuxInfo)
  // optional .mesos.CapabilityInfo capability_info = 1;
  if (has_capability_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->capability_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.LinuxInfo)
}

::google::protobuf::uint8* LinuxInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.LinuxInfo)
  // optional .mesos.CapabilityInfo capability_info = 1;
  if (has_capability_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->capability_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.LinuxInfo)
  return target;
}

int LinuxInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.CapabilityInfo capability_info = 1;
    if (has_capability_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->capability_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinuxInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LinuxInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LinuxInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LinuxInfo::MergeFrom(const LinuxInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_capability_info()) {
      mutable_capability_info()->::mesos::CapabilityInfo::MergeFrom(from.capability_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LinuxInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LinuxInfo::CopyFrom(const LinuxInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinuxInfo::IsInitialized() const {

  return true;
}

void LinuxInfo::Swap(LinuxInfo* other) {
  if (other != this) {
    std::swap(capability_info_, other->capability_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LinuxInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LinuxInfo_descriptor_;
  metadata.reflection = LinuxInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* RLimitInfo_RLimit_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RLimitInfo_RLimit_Type_descriptor_;
}
bool RLimitInfo_RLimit_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::UNKNOWN;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_AS;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_CORE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_CPU;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_DATA;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_FSIZE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_LOCKS;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_MEMLOCK;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_MSGQUEUE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_NICE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_NOFILE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_NPROC;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_RSS;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_RTPRIO;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_RTTIME;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_SIGPENDING;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_STACK;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::Type_MIN;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::Type_MAX;
const int RLimitInfo_RLimit::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RLimitInfo_RLimit::kTypeFieldNumber;
const int RLimitInfo_RLimit::kHardFieldNumber;
const int RLimitInfo_RLimit::kSoftFieldNumber;
#endif  // !_MSC_VER

RLimitInfo_RLimit::RLimitInfo_RLimit()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RLimitInfo.RLimit)
}

void RLimitInfo_RLimit::InitAsDefaultInstance() {
}

RLimitInfo_RLimit::RLimitInfo_RLimit(const RLimitInfo_RLimit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RLimitInfo.RLimit)
}

void RLimitInfo_RLimit::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  hard_ = GOOGLE_ULONGLONG(0);
  soft_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RLimitInfo_RLimit::~RLimitInfo_RLimit() {
  // @@protoc_insertion_point(destructor:mesos.RLimitInfo.RLimit)
  SharedDtor();
}

void RLimitInfo_RLimit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RLimitInfo_RLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RLimitInfo_RLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RLimitInfo_RLimit_descriptor_;
}

const RLimitInfo_RLimit& RLimitInfo_RLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RLimitInfo_RLimit* RLimitInfo_RLimit::default_instance_ = NULL;

RLimitInfo_RLimit* RLimitInfo_RLimit::New() const {
  return new RLimitInfo_RLimit;
}

void RLimitInfo_RLimit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RLimitInfo_RLimit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(hard_, type_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RLimitInfo_RLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RLimitInfo.RLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.RLimitInfo.RLimit.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::RLimitInfo_RLimit_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::RLimitInfo_RLimit_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_hard;
        break;
      }

      // optional uint64 hard = 2;
      case 2: {
        if (tag == 16) {
         parse_hard:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &hard_)));
          set_has_hard();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_soft;
        break;
      }

      // optional uint64 soft = 3;
      case 3: {
        if (tag == 24) {
         parse_soft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &soft_)));
          set_has_soft();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RLimitInfo.RLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RLimitInfo.RLimit)
  return false;
#undef DO_
}

void RLimitInfo_RLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RLimitInfo.RLimit)
  // optional .mesos.RLimitInfo.RLimit.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 hard = 2;
  if (has_hard()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->hard(), output);
  }

  // optional uint64 soft = 3;
  if (has_soft()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->soft(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RLimitInfo.RLimit)
}

::google::protobuf::uint8* RLimitInfo_RLimit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RLimitInfo.RLimit)
  // optional .mesos.RLimitInfo.RLimit.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint64 hard = 2;
  if (has_hard()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->hard(), target);
  }

  // optional uint64 soft = 3;
  if (has_soft()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->soft(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RLimitInfo.RLimit)
  return target;
}

int RLimitInfo_RLimit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.RLimitInfo.RLimit.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 hard = 2;
    if (has_hard()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->hard());
    }

    // optional uint64 soft = 3;
    if (has_soft()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->soft());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RLimitInfo_RLimit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RLimitInfo_RLimit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RLimitInfo_RLimit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RLimitInfo_RLimit::MergeFrom(const RLimitInfo_RLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_hard()) {
      set_hard(from.hard());
    }
    if (from.has_soft()) {
      set_soft(from.soft());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RLimitInfo_RLimit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RLimitInfo_RLimit::CopyFrom(const RLimitInfo_RLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RLimitInfo_RLimit::IsInitialized() const {

  return true;
}

void RLimitInfo_RLimit::Swap(RLimitInfo_RLimit* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(hard_, other->hard_);
    std::swap(soft_, other->soft_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RLimitInfo_RLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RLimitInfo_RLimit_descriptor_;
  metadata.reflection = RLimitInfo_RLimit_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RLimitInfo::kRlimitsFieldNumber;
#endif  // !_MSC_VER

RLimitInfo::RLimitInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RLimitInfo)
}

void RLimitInfo::InitAsDefaultInstance() {
}

RLimitInfo::RLimitInfo(const RLimitInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RLimitInfo)
}

void RLimitInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RLimitInfo::~RLimitInfo() {
  // @@protoc_insertion_point(destructor:mesos.RLimitInfo)
  SharedDtor();
}

void RLimitInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RLimitInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RLimitInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RLimitInfo_descriptor_;
}

const RLimitInfo& RLimitInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RLimitInfo* RLimitInfo::default_instance_ = NULL;

RLimitInfo* RLimitInfo::New() const {
  return new RLimitInfo;
}

void RLimitInfo::Clear() {
  rlimits_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RLimitInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RLimitInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
      case 1: {
        if (tag == 10) {
         parse_rlimits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rlimits()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_rlimits;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RLimitInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RLimitInfo)
  return false;
#undef DO_
}

void RLimitInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RLimitInfo)
  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  for (int i = 0; i < this->rlimits_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rlimits(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RLimitInfo)
}

::google::protobuf::uint8* RLimitInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RLimitInfo)
  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  for (int i = 0; i < this->rlimits_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rlimits(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RLimitInfo)
  return target;
}

int RLimitInfo::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  total_size += 1 * this->rlimits_size();
  for (int i = 0; i < this->rlimits_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rlimits(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RLimitInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RLimitInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RLimitInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RLimitInfo::MergeFrom(const RLimitInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  rlimits_.MergeFrom(from.rlimits_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RLimitInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RLimitInfo::CopyFrom(const RLimitInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RLimitInfo::IsInitialized() const {

  return true;
}

void RLimitInfo::Swap(RLimitInfo* other) {
  if (other != this) {
    rlimits_.Swap(&other->rlimits_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RLimitInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RLimitInfo_descriptor_;
  metadata.reflection = RLimitInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TTYInfo_WindowSize::kRowsFieldNumber;
const int TTYInfo_WindowSize::kColumnsFieldNumber;
#endif  // !_MSC_VER

TTYInfo_WindowSize::TTYInfo_WindowSize()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TTYInfo.WindowSize)
}

void TTYInfo_WindowSize::InitAsDefaultInstance() {
}

TTYInfo_WindowSize::TTYInfo_WindowSize(const TTYInfo_WindowSize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TTYInfo.WindowSize)
}

void TTYInfo_WindowSize::SharedCtor() {
  _cached_size_ = 0;
  rows_ = 0u;
  columns_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TTYInfo_WindowSize::~TTYInfo_WindowSize() {
  // @@protoc_insertion_point(destructor:mesos.TTYInfo.WindowSize)
  SharedDtor();
}

void TTYInfo_WindowSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TTYInfo_WindowSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TTYInfo_WindowSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TTYInfo_WindowSize_descriptor_;
}

const TTYInfo_WindowSize& TTYInfo_WindowSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TTYInfo_WindowSize* TTYInfo_WindowSize::default_instance_ = NULL;

TTYInfo_WindowSize* TTYInfo_WindowSize::New() const {
  return new TTYInfo_WindowSize;
}

void TTYInfo_WindowSize::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TTYInfo_WindowSize*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(rows_, columns_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TTYInfo_WindowSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TTYInfo.WindowSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rows = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rows_)));
          set_has_rows();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_columns;
        break;
      }

      // required uint32 columns = 2;
      case 2: {
        if (tag == 16) {
         parse_columns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &columns_)));
          set_has_columns();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TTYInfo.WindowSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TTYInfo.WindowSize)
  return false;
#undef DO_
}

void TTYInfo_WindowSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TTYInfo.WindowSize)
  // required uint32 rows = 1;
  if (has_rows()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rows(), output);
  }

  // required uint32 columns = 2;
  if (has_columns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->columns(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TTYInfo.WindowSize)
}

::google::protobuf::uint8* TTYInfo_WindowSize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TTYInfo.WindowSize)
  // required uint32 rows = 1;
  if (has_rows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rows(), target);
  }

  // required uint32 columns = 2;
  if (has_columns()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->columns(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TTYInfo.WindowSize)
  return target;
}

int TTYInfo_WindowSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 rows = 1;
    if (has_rows()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rows());
    }

    // required uint32 columns = 2;
    if (has_columns()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->columns());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TTYInfo_WindowSize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TTYInfo_WindowSize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TTYInfo_WindowSize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TTYInfo_WindowSize::MergeFrom(const TTYInfo_WindowSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rows()) {
      set_rows(from.rows());
    }
    if (from.has_columns()) {
      set_columns(from.columns());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TTYInfo_WindowSize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TTYInfo_WindowSize::CopyFrom(const TTYInfo_WindowSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTYInfo_WindowSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TTYInfo_WindowSize::Swap(TTYInfo_WindowSize* other) {
  if (other != this) {
    std::swap(rows_, other->rows_);
    std::swap(columns_, other->columns_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TTYInfo_WindowSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TTYInfo_WindowSize_descriptor_;
  metadata.reflection = TTYInfo_WindowSize_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TTYInfo::kWindowSizeFieldNumber;
#endif  // !_MSC_VER

TTYInfo::TTYInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TTYInfo)
}

void TTYInfo::InitAsDefaultInstance() {
  window_size_ = const_cast< ::mesos::TTYInfo_WindowSize*>(&::mesos::TTYInfo_WindowSize::default_instance());
}

TTYInfo::TTYInfo(const TTYInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TTYInfo)
}

void TTYInfo::SharedCtor() {
  _cached_size_ = 0;
  window_size_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TTYInfo::~TTYInfo() {
  // @@protoc_insertion_point(destructor:mesos.TTYInfo)
  SharedDtor();
}

void TTYInfo::SharedDtor() {
  if (this != default_instance_) {
    delete window_size_;
  }
}

void TTYInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TTYInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TTYInfo_descriptor_;
}

const TTYInfo& TTYInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TTYInfo* TTYInfo::default_instance_ = NULL;

TTYInfo* TTYInfo::New() const {
  return new TTYInfo;
}

void TTYInfo::Clear() {
  if (has_window_size()) {
    if (window_size_ != NULL) window_size_->::mesos::TTYInfo_WindowSize::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TTYInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TTYInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.TTYInfo.WindowSize window_size = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_window_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TTYInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TTYInfo)
  return false;
#undef DO_
}

void TTYInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TTYInfo)
  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  if (has_window_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->window_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TTYInfo)
}

::google::protobuf::uint8* TTYInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TTYInfo)
  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  if (has_window_size()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->window_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TTYInfo)
  return target;
}

int TTYInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.TTYInfo.WindowSize window_size = 1;
    if (has_window_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->window_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TTYInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TTYInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TTYInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TTYInfo::MergeFrom(const TTYInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_window_size()) {
      mutable_window_size()->::mesos::TTYInfo_WindowSize::MergeFrom(from.window_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TTYInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TTYInfo::CopyFrom(const TTYInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTYInfo::IsInitialized() const {

  if (has_window_size()) {
    if (!this->window_size().IsInitialized()) return false;
  }
  return true;
}

void TTYInfo::Swap(TTYInfo* other) {
  if (other != this) {
    std::swap(window_size_, other->window_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TTYInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TTYInfo_descriptor_;
  metadata.reflection = TTYInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_Type_descriptor_;
}
bool ContainerInfo_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ContainerInfo_Type ContainerInfo::DOCKER;
const ContainerInfo_Type ContainerInfo::MESOS;
const ContainerInfo_Type ContainerInfo::Type_MIN;
const ContainerInfo_Type ContainerInfo::Type_MAX;
const int ContainerInfo::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_DockerInfo_Network_descriptor_;
}
bool ContainerInfo_DockerInfo_Network_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::HOST;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::BRIDGE;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::NONE;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::USER;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::Network_MIN;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::Network_MAX;
const int ContainerInfo_DockerInfo::Network_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ContainerInfo_DockerInfo_PortMapping::kHostPortFieldNumber;
const int ContainerInfo_DockerInfo_PortMapping::kContainerPortFieldNumber;
const int ContainerInfo_DockerInfo_PortMapping::kProtocolFieldNumber;
#endif  // !_MSC_VER

ContainerInfo_DockerInfo_PortMapping::ContainerInfo_DockerInfo_PortMapping()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo.DockerInfo.PortMapping)
}

void ContainerInfo_DockerInfo_PortMapping::InitAsDefaultInstance() {
}

ContainerInfo_DockerInfo_PortMapping::ContainerInfo_DockerInfo_PortMapping(const ContainerInfo_DockerInfo_PortMapping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo.DockerInfo.PortMapping)
}

void ContainerInfo_DockerInfo_PortMapping::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_port_ = 0u;
  container_port_ = 0u;
  protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo_DockerInfo_PortMapping::~ContainerInfo_DockerInfo_PortMapping() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo.DockerInfo.PortMapping)
  SharedDtor();
}

void ContainerInfo_DockerInfo_PortMapping::SharedDtor() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (this != default_instance_) {
  }
}

void ContainerInfo_DockerInfo_PortMapping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo_PortMapping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_DockerInfo_PortMapping_descriptor_;
}

const ContainerInfo_DockerInfo_PortMapping& ContainerInfo_DockerInfo_PortMapping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo_PortMapping::default_instance_ = NULL;

ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo_PortMapping::New() const {
  return new ContainerInfo_DockerInfo_PortMapping;
}

void ContainerInfo_DockerInfo_PortMapping::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ContainerInfo_DockerInfo_PortMapping*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(host_port_, container_port_);
    if (has_protocol()) {
      if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        protocol_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerInfo_DockerInfo_PortMapping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_port_)));
          set_has_host_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_container_port;
        break;
      }

      // required uint32 container_port = 2;
      case 2: {
        if (tag == 16) {
         parse_container_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &container_port_)));
          set_has_container_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_protocol;
        break;
      }

      // optional string protocol = 3;
      case 3: {
        if (tag == 26) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->protocol().data(), this->protocol().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo.DockerInfo.PortMapping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo.DockerInfo.PortMapping)
  return false;
#undef DO_
}

void ContainerInfo_DockerInfo_PortMapping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_port(), output);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->container_port(), output);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->protocol(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo.DockerInfo.PortMapping)
}

::google::protobuf::uint8* ContainerInfo_DockerInfo_PortMapping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->host_port(), target);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->container_port(), target);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->protocol(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo.DockerInfo.PortMapping)
  return target;
}

int ContainerInfo_DockerInfo_PortMapping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 host_port = 1;
    if (has_host_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->host_port());
    }

    // required uint32 container_port = 2;
    if (has_container_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->container_port());
    }

    // optional string protocol = 3;
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->protocol());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo_DockerInfo_PortMapping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerInfo_DockerInfo_PortMapping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerInfo_DockerInfo_PortMapping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerInfo_DockerInfo_PortMapping::MergeFrom(const ContainerInfo_DockerInfo_PortMapping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_port()) {
      set_host_port(from.host_port());
    }
    if (from.has_container_port()) {
      set_container_port(from.container_port());
    }
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerInfo_DockerInfo_PortMapping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo_DockerInfo_PortMapping::CopyFrom(const ContainerInfo_DockerInfo_PortMapping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo_DockerInfo_PortMapping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ContainerInfo_DockerInfo_PortMapping::Swap(ContainerInfo_DockerInfo_PortMapping* other) {
  if (other != this) {
    std::swap(host_port_, other->host_port_);
    std::swap(container_port_, other->container_port_);
    std::swap(protocol_, other->protocol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerInfo_DockerInfo_PortMapping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_DockerInfo_PortMapping_descriptor_;
  metadata.reflection = ContainerInfo_DockerInfo_PortMapping_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ContainerInfo_DockerInfo::kImageFieldNumber;
const int ContainerInfo_DockerInfo::kNetworkFieldNumber;
const int ContainerInfo_DockerInfo::kPortMappingsFieldNumber;
const int ContainerInfo_DockerInfo::kPrivilegedFieldNumber;
const int ContainerInfo_DockerInfo::kParametersFieldNumber;
const int ContainerInfo_DockerInfo::kForcePullImageFieldNumber;
const int ContainerInfo_DockerInfo::kVolumeDriverFieldNumber;
#endif  // !_MSC_VER

ContainerInfo_DockerInfo::ContainerInfo_DockerInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo.DockerInfo)
}

void ContainerInfo_DockerInfo::InitAsDefaultInstance() {
}

ContainerInfo_DockerInfo::ContainerInfo_DockerInfo(const ContainerInfo_DockerInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo.DockerInfo)
}

void ContainerInfo_DockerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  network_ = 1;
  privileged_ = false;
  force_pull_image_ = false;
  volume_driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo_DockerInfo::~ContainerInfo_DockerInfo() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo.DockerInfo)
  SharedDtor();
}

void ContainerInfo_DockerInfo::SharedDtor() {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_;
  }
  if (volume_driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete volume_driver_;
  }
  if (this != default_instance_) {
  }
}

void ContainerInfo_DockerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_DockerInfo_descriptor_;
}

const ContainerInfo_DockerInfo& ContainerInfo_DockerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo_DockerInfo* ContainerInfo_DockerInfo::default_instance_ = NULL;

ContainerInfo_DockerInfo* ContainerInfo_DockerInfo::New() const {
  return new ContainerInfo_DockerInfo;
}

void ContainerInfo_DockerInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ContainerInfo_DockerInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 107) {
    ZR_(privileged_, force_pull_image_);
    if (has_image()) {
      if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        image_->clear();
      }
    }
    network_ = 1;
    if (has_volume_driver()) {
      if (volume_driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        volume_driver_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  port_mappings_.Clear();
  parameters_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerInfo_DockerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo.DockerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string image = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->image().data(), this->image().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "image");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_network;
        break;
      }

      // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
      case 2: {
        if (tag == 16) {
         parse_network:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::ContainerInfo_DockerInfo_Network_IsValid(value)) {
            set_network(static_cast< ::mesos::ContainerInfo_DockerInfo_Network >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_port_mappings;
        break;
      }

      // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
      case 3: {
        if (tag == 26) {
         parse_port_mappings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_port_mappings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_port_mappings;
        if (input->ExpectTag(32)) goto parse_privileged;
        break;
      }

      // optional bool privileged = 4 [default = false];
      case 4: {
        if (tag == 32) {
         parse_privileged:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &privileged_)));
          set_has_privileged();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_parameters;
        break;
      }

      // repeated .mesos.Parameter parameters = 5;
      case 5: {
        if (tag == 42) {
         parse_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_parameters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_parameters;
        if (input->ExpectTag(48)) goto parse_force_pull_image;
        break;
      }

      // optional bool force_pull_image = 6;
      case 6: {
        if (tag == 48) {
         parse_force_pull_image:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &force_pull_image_)));
          set_has_force_pull_image();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_volume_driver;
        break;
      }

      // optional string volume_driver = 7 [deprecated = true];
      case 7: {
        if (tag == 58) {
         parse_volume_driver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_volume_driver()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->volume_driver().data(), this->volume_driver().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "volume_driver");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo.DockerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo.DockerInfo)
  return false;
#undef DO_
}

void ContainerInfo_DockerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo.DockerInfo)
  // required string image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->image().data(), this->image().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "image");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->image(), output);
  }

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  if (has_network()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->network(), output);
  }

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  for (int i = 0; i < this->port_mappings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->port_mappings(i), output);
  }

  // optional bool privileged = 4 [default = false];
  if (has_privileged()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->privileged(), output);
  }

  // repeated .mesos.Parameter parameters = 5;
  for (int i = 0; i < this->parameters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->parameters(i), output);
  }

  // optional bool force_pull_image = 6;
  if (has_force_pull_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->force_pull_image(), output);
  }

  // optional string volume_driver = 7 [deprecated = true];
  if (has_volume_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->volume_driver().data(), this->volume_driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "volume_driver");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->volume_driver(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo.DockerInfo)
}

::google::protobuf::uint8* ContainerInfo_DockerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo.DockerInfo)
  // required string image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->image().data(), this->image().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "image");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->image(), target);
  }

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  if (has_network()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->network(), target);
  }

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  for (int i = 0; i < this->port_mappings_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->port_mappings(i), target);
  }

  // optional bool privileged = 4 [default = false];
  if (has_privileged()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->privileged(), target);
  }

  // repeated .mesos.Parameter parameters = 5;
  for (int i = 0; i < this->parameters_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->parameters(i), target);
  }

  // optional bool force_pull_image = 6;
  if (has_force_pull_image()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->force_pull_image(), target);
  }

  // optional string volume_driver = 7 [deprecated = true];
  if (has_volume_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->volume_driver().data(), this->volume_driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "volume_driver");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->volume_driver(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo.DockerInfo)
  return target;
}

int ContainerInfo_DockerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string image = 1;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image());
    }

    // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
    if (has_network()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->network());
    }

    // optional bool privileged = 4 [default = false];
    if (has_privileged()) {
      total_size += 1 + 1;
    }

    // optional bool force_pull_image = 6;
    if (has_force_pull_image()) {
      total_size += 1 + 1;
    }

    // optional string volume_driver = 7 [deprecated = true];
    if (has_volume_driver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->volume_driver());
    }

  }
  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  total_size += 1 * this->port_mappings_size();
  for (int i = 0; i < this->port_mappings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port_mappings(i));
  }

  // repeated .mesos.Parameter parameters = 5;
  total_size += 1 * this->parameters_size();
  for (int i = 0; i < this->parameters_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->parameters(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo_DockerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerInfo_DockerInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerInfo_DockerInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerInfo_DockerInfo::MergeFrom(const ContainerInfo_DockerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  port_mappings_.MergeFrom(from.port_mappings_);
  parameters_.MergeFrom(from.parameters_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      set_image(from.image());
    }
    if (from.has_network()) {
      set_network(from.network());
    }
    if (from.has_privileged()) {
      set_privileged(from.privileged());
    }
    if (from.has_force_pull_image()) {
      set_force_pull_image(from.force_pull_image());
    }
    if (from.has_volume_driver()) {
      set_volume_driver(from.volume_driver());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerInfo_DockerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo_DockerInfo::CopyFrom(const ContainerInfo_DockerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo_DockerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->port_mappings())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->parameters())) return false;
  return true;
}

void ContainerInfo_DockerInfo::Swap(ContainerInfo_DockerInfo* other) {
  if (other != this) {
    std::swap(image_, other->image_);
    std::swap(network_, other->network_);
    port_mappings_.Swap(&other->port_mappings_);
    std::swap(privileged_, other->privileged_);
    parameters_.Swap(&other->parameters_);
    std::swap(force_pull_image_, other->force_pull_image_);
    std::swap(volume_driver_, other->volume_driver_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerInfo_DockerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_DockerInfo_descriptor_;
  metadata.reflection = ContainerInfo_DockerInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ContainerInfo_MesosInfo::kImageFieldNumber;
#endif  // !_MSC_VER

ContainerInfo_MesosInfo::ContainerInfo_MesosInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo.MesosInfo)
}

void ContainerInfo_MesosInfo::InitAsDefaultInstance() {
  image_ = const_cast< ::mesos::Image*>(&::mesos::Image::default_instance());
}

ContainerInfo_MesosInfo::ContainerInfo_MesosInfo(const ContainerInfo_MesosInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo.MesosInfo)
}

void ContainerInfo_MesosInfo::SharedCtor() {
  _cached_size_ = 0;
  image_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo_MesosInfo::~ContainerInfo_MesosInfo() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo.MesosInfo)
  SharedDtor();
}

void ContainerInfo_MesosInfo::SharedDtor() {
  if (this != default_instance_) {
    delete image_;
  }
}

void ContainerInfo_MesosInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo_MesosInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_MesosInfo_descriptor_;
}

const ContainerInfo_MesosInfo& ContainerInfo_MesosInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo_MesosInfo* ContainerInfo_MesosInfo::default_instance_ = NULL;

ContainerInfo_MesosInfo* ContainerInfo_MesosInfo::New() const {
  return new ContainerInfo_MesosInfo;
}

void ContainerInfo_MesosInfo::Clear() {
  if (has_image()) {
    if (image_ != NULL) image_->::mesos::Image::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerInfo_MesosInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo.MesosInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Image image = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo.MesosInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo.MesosInfo)
  return false;
#undef DO_
}

void ContainerInfo_MesosInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo.MesosInfo)
  // optional .mesos.Image image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->image(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo.MesosInfo)
}

::google::protobuf::uint8* ContainerInfo_MesosInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo.MesosInfo)
  // optional .mesos.Image image = 1;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->image(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo.MesosInfo)
  return target;
}

int ContainerInfo_MesosInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.Image image = 1;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo_MesosInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerInfo_MesosInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerInfo_MesosInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerInfo_MesosInfo::MergeFrom(const ContainerInfo_MesosInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      mutable_image()->::mesos::Image::MergeFrom(from.image());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerInfo_MesosInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo_MesosInfo::CopyFrom(const ContainerInfo_MesosInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo_MesosInfo::IsInitialized() const {

  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  return true;
}

void ContainerInfo_MesosInfo::Swap(ContainerInfo_MesosInfo* other) {
  if (other != this) {
    std::swap(image_, other->image_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerInfo_MesosInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_MesosInfo_descriptor_;
  metadata.reflection = ContainerInfo_MesosInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ContainerInfo::kTypeFieldNumber;
const int ContainerInfo::kVolumesFieldNumber;
const int ContainerInfo::kHostnameFieldNumber;
const int ContainerInfo::kDockerFieldNumber;
const int ContainerInfo::kMesosFieldNumber;
const int ContainerInfo::kNetworkInfosFieldNumber;
const int ContainerInfo::kLinuxInfoFieldNumber;
const int ContainerInfo::kRlimitInfoFieldNumber;
const int ContainerInfo::kTtyInfoFieldNumber;
#endif  // !_MSC_VER

ContainerInfo::ContainerInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo)
}

void ContainerInfo::InitAsDefaultInstance() {
  docker_ = const_cast< ::mesos::ContainerInfo_DockerInfo*>(&::mesos::ContainerInfo_DockerInfo::default_instance());
  mesos_ = const_cast< ::mesos::ContainerInfo_MesosInfo*>(&::mesos::ContainerInfo_MesosInfo::default_instance());
  linux_info_ = const_cast< ::mesos::LinuxInfo*>(&::mesos::LinuxInfo::default_instance());
  rlimit_info_ = const_cast< ::mesos::RLimitInfo*>(&::mesos::RLimitInfo::default_instance());
  tty_info_ = const_cast< ::mesos::TTYInfo*>(&::mesos::TTYInfo::default_instance());
}

ContainerInfo::ContainerInfo(const ContainerInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo)
}

void ContainerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  docker_ = NULL;
  mesos_ = NULL;
  linux_info_ = NULL;
  rlimit_info_ = NULL;
  tty_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo::~ContainerInfo() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo)
  SharedDtor();
}

void ContainerInfo::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (this != default_instance_) {
    delete docker_;
    delete mesos_;
    delete linux_info_;
    delete rlimit_info_;
    delete tty_info_;
  }
}

void ContainerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_descriptor_;
}

const ContainerInfo& ContainerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo* ContainerInfo::default_instance_ = NULL;

ContainerInfo* ContainerInfo::New() const {
  return new ContainerInfo;
}

void ContainerInfo::Clear() {
  if (_has_bits_[0 / 32] & 221) {
    type_ = 1;
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hostname_->clear();
      }
    }
    if (has_docker()) {
      if (docker_ != NULL) docker_->::mesos::ContainerInfo_DockerInfo::Clear();
    }
    if (has_mesos()) {
      if (mesos_ != NULL) mesos_->::mesos::ContainerInfo_MesosInfo::Clear();
    }
    if (has_linux_info()) {
      if (linux_info_ != NULL) linux_info_->::mesos::LinuxInfo::Clear();
    }
    if (has_rlimit_info()) {
      if (rlimit_info_ != NULL) rlimit_info_->::mesos::RLimitInfo::Clear();
    }
  }
  if (has_tty_info()) {
    if (tty_info_ != NULL) tty_info_->::mesos::TTYInfo::Clear();
  }
  volumes_.Clear();
  network_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ContainerInfo.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::ContainerInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::ContainerInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_volumes;
        break;
      }

      // repeated .mesos.Volume volumes = 2;
      case 2: {
        if (tag == 18) {
         parse_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_volumes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_volumes;
        if (input->ExpectTag(26)) goto parse_docker;
        break;
      }

      // optional .mesos.ContainerInfo.DockerInfo docker = 3;
      case 3: {
        if (tag == 26) {
         parse_docker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_hostname;
        break;
      }

      // optional string hostname = 4;
      case 4: {
        if (tag == 34) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mesos;
        break;
      }

      // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
      case 5: {
        if (tag == 42) {
         parse_mesos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mesos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_network_infos;
        break;
      }

      // repeated .mesos.NetworkInfo network_infos = 7;
      case 7: {
        if (tag == 58) {
         parse_network_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_network_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_network_infos;
        if (input->ExpectTag(66)) goto parse_linux_info;
        break;
      }

      // optional .mesos.LinuxInfo linux_info = 8;
      case 8: {
        if (tag == 66) {
         parse_linux_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linux_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_rlimit_info;
        break;
      }

      // optional .mesos.RLimitInfo rlimit_info = 9;
      case 9: {
        if (tag == 74) {
         parse_rlimit_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rlimit_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_tty_info;
        break;
      }

      // optional .mesos.TTYInfo tty_info = 10;
      case 10: {
        if (tag == 82) {
         parse_tty_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tty_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo)
  return false;
#undef DO_
}

void ContainerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo)
  // required .mesos.ContainerInfo.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // repeated .mesos.Volume volumes = 2;
  for (int i = 0; i < this->volumes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->volumes(i), output);
  }

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  if (has_docker()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->docker(), output);
  }

  // optional string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->hostname(), output);
  }

  // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
  if (has_mesos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->mesos(), output);
  }

  // repeated .mesos.NetworkInfo network_infos = 7;
  for (int i = 0; i < this->network_infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->network_infos(i), output);
  }

  // optional .mesos.LinuxInfo linux_info = 8;
  if (has_linux_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->linux_info(), output);
  }

  // optional .mesos.RLimitInfo rlimit_info = 9;
  if (has_rlimit_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->rlimit_info(), output);
  }

  // optional .mesos.TTYInfo tty_info = 10;
  if (has_tty_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->tty_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo)
}

::google::protobuf::uint8* ContainerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo)
  // required .mesos.ContainerInfo.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // repeated .mesos.Volume volumes = 2;
  for (int i = 0; i < this->volumes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->volumes(i), target);
  }

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  if (has_docker()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->docker(), target);
  }

  // optional string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->hostname(), target);
  }

  // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
  if (has_mesos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->mesos(), target);
  }

  // repeated .mesos.NetworkInfo network_infos = 7;
  for (int i = 0; i < this->network_infos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->network_infos(i), target);
  }

  // optional .mesos.LinuxInfo linux_info = 8;
  if (has_linux_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->linux_info(), target);
  }

  // optional .mesos.RLimitInfo rlimit_info = 9;
  if (has_rlimit_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->rlimit_info(), target);
  }

  // optional .mesos.TTYInfo tty_info = 10;
  if (has_tty_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->tty_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo)
  return target;
}

int ContainerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ContainerInfo.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string hostname = 4;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional .mesos.ContainerInfo.DockerInfo docker = 3;
    if (has_docker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->docker());
    }

    // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
    if (has_mesos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mesos());
    }

    // optional .mesos.LinuxInfo linux_info = 8;
    if (has_linux_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->linux_info());
    }

    // optional .mesos.RLimitInfo rlimit_info = 9;
    if (has_rlimit_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rlimit_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.TTYInfo tty_info = 10;
    if (has_tty_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tty_info());
    }

  }
  // repeated .mesos.Volume volumes = 2;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  // repeated .mesos.NetworkInfo network_infos = 7;
  total_size += 1 * this->network_infos_size();
  for (int i = 0; i < this->network_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->network_infos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerInfo::MergeFrom(const ContainerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  volumes_.MergeFrom(from.volumes_);
  network_infos_.MergeFrom(from.network_infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_docker()) {
      mutable_docker()->::mesos::ContainerInfo_DockerInfo::MergeFrom(from.docker());
    }
    if (from.has_mesos()) {
      mutable_mesos()->::mesos::ContainerInfo_MesosInfo::MergeFrom(from.mesos());
    }
    if (from.has_linux_info()) {
      mutable_linux_info()->::mesos::LinuxInfo::MergeFrom(from.linux_info());
    }
    if (from.has_rlimit_info()) {
      mutable_rlimit_info()->::mesos::RLimitInfo::MergeFrom(from.rlimit_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tty_info()) {
      mutable_tty_info()->::mesos::TTYInfo::MergeFrom(from.tty_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo::CopyFrom(const ContainerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->volumes())) return false;
  if (has_docker()) {
    if (!this->docker().IsInitialized()) return false;
  }
  if (has_mesos()) {
    if (!this->mesos().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->network_infos())) return false;
  if (has_tty_info()) {
    if (!this->tty_info().IsInitialized()) return false;
  }
  return true;
}

void ContainerInfo::Swap(ContainerInfo* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    volumes_.Swap(&other->volumes_);
    std::swap(hostname_, other->hostname_);
    std::swap(docker_, other->docker_);
    std::swap(mesos_, other->mesos_);
    network_infos_.Swap(&other->network_infos_);
    std::swap(linux_info_, other->linux_info_);
    std::swap(rlimit_info_, other->rlimit_info_);
    std::swap(tty_info_, other->tty_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_descriptor_;
  metadata.reflection = ContainerInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContainerStatus::kContainerIdFieldNumber;
const int ContainerStatus::kNetworkInfosFieldNumber;
const int ContainerStatus::kCgroupInfoFieldNumber;
const int ContainerStatus::kExecutorPidFieldNumber;
#endif  // !_MSC_VER

ContainerStatus::ContainerStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerStatus)
}

void ContainerStatus::InitAsDefaultInstance() {
  container_id_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
  cgroup_info_ = const_cast< ::mesos::CgroupInfo*>(&::mesos::CgroupInfo::default_instance());
}

ContainerStatus::ContainerStatus(const ContainerStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerStatus)
}

void ContainerStatus::SharedCtor() {
  _cached_size_ = 0;
  container_id_ = NULL;
  cgroup_info_ = NULL;
  executor_pid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerStatus::~ContainerStatus() {
  // @@protoc_insertion_point(destructor:mesos.ContainerStatus)
  SharedDtor();
}

void ContainerStatus::SharedDtor() {
  if (this != default_instance_) {
    delete container_id_;
    delete cgroup_info_;
  }
}

void ContainerStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerStatus_descriptor_;
}

const ContainerStatus& ContainerStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerStatus* ContainerStatus::default_instance_ = NULL;

ContainerStatus* ContainerStatus::New() const {
  return new ContainerStatus;
}

void ContainerStatus::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    if (has_container_id()) {
      if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
    }
    if (has_cgroup_info()) {
      if (cgroup_info_ != NULL) cgroup_info_->::mesos::CgroupInfo::Clear();
    }
    executor_pid_ = 0u;
  }
  network_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContainerStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.NetworkInfo network_infos = 1;
      case 1: {
        if (tag == 10) {
         parse_network_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_network_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_network_infos;
        if (input->ExpectTag(18)) goto parse_cgroup_info;
        break;
      }

      // optional .mesos.CgroupInfo cgroup_info = 2;
      case 2: {
        if (tag == 18) {
         parse_cgroup_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cgroup_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_executor_pid;
        break;
      }

      // optional uint32 executor_pid = 3;
      case 3: {
        if (tag == 24) {
         parse_executor_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &executor_pid_)));
          set_has_executor_pid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_container_id;
        break;
      }

      // optional .mesos.ContainerID container_id = 4;
      case 4: {
        if (tag == 34) {
         parse_container_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerStatus)
  return false;
#undef DO_
}

void ContainerStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerStatus)
  // repeated .mesos.NetworkInfo network_infos = 1;
  for (int i = 0; i < this->network_infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->network_infos(i), output);
  }

  // optional .mesos.CgroupInfo cgroup_info = 2;
  if (has_cgroup_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cgroup_info(), output);
  }

  // optional uint32 executor_pid = 3;
  if (has_executor_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->executor_pid(), output);
  }

  // optional .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->container_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerStatus)
}

::google::protobuf::uint8* ContainerStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerStatus)
  // repeated .mesos.NetworkInfo network_infos = 1;
  for (int i = 0; i < this->network_infos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->network_infos(i), target);
  }

  // optional .mesos.CgroupInfo cgroup_info = 2;
  if (has_cgroup_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cgroup_info(), target);
  }

  // optional uint32 executor_pid = 3;
  if (has_executor_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->executor_pid(), target);
  }

  // optional .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->container_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerStatus)
  return target;
}

int ContainerStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ContainerID container_id = 4;
    if (has_container_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container_id());
    }

    // optional .mesos.CgroupInfo cgroup_info = 2;
    if (has_cgroup_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cgroup_info());
    }

    // optional uint32 executor_pid = 3;
    if (has_executor_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->executor_pid());
    }

  }
  // repeated .mesos.NetworkInfo network_infos = 1;
  total_size += 1 * this->network_infos_size();
  for (int i = 0; i < this->network_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->network_infos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContainerStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContainerStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContainerStatus::MergeFrom(const ContainerStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  network_infos_.MergeFrom(from.network_infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_container_id()) {
      mutable_container_id()->::mesos::ContainerID::MergeFrom(from.container_id());
    }
    if (from.has_cgroup_info()) {
      mutable_cgroup_info()->::mesos::CgroupInfo::MergeFrom(from.cgroup_info());
    }
    if (from.has_executor_pid()) {
      set_executor_pid(from.executor_pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContainerStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerStatus::CopyFrom(const ContainerStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerStatus::IsInitialized() const {

  if (has_container_id()) {
    if (!this->container_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->network_infos())) return false;
  return true;
}

void ContainerStatus::Swap(ContainerStatus* other) {
  if (other != this) {
    std::swap(container_id_, other->container_id_);
    network_infos_.Swap(&other->network_infos_);
    std::swap(cgroup_info_, other->cgroup_info_);
    std::swap(executor_pid_, other->executor_pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContainerStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerStatus_descriptor_;
  metadata.reflection = ContainerStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CgroupInfo_NetCls::kClassidFieldNumber;
#endif  // !_MSC_VER

CgroupInfo_NetCls::CgroupInfo_NetCls()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CgroupInfo.NetCls)
}

void CgroupInfo_NetCls::InitAsDefaultInstance() {
}

CgroupInfo_NetCls::CgroupInfo_NetCls(const CgroupInfo_NetCls& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CgroupInfo.NetCls)
}

void CgroupInfo_NetCls::SharedCtor() {
  _cached_size_ = 0;
  classid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CgroupInfo_NetCls::~CgroupInfo_NetCls() {
  // @@protoc_insertion_point(destructor:mesos.CgroupInfo.NetCls)
  SharedDtor();
}

void CgroupInfo_NetCls::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CgroupInfo_NetCls::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CgroupInfo_NetCls::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CgroupInfo_NetCls_descriptor_;
}

const CgroupInfo_NetCls& CgroupInfo_NetCls::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CgroupInfo_NetCls* CgroupInfo_NetCls::default_instance_ = NULL;

CgroupInfo_NetCls* CgroupInfo_NetCls::New() const {
  return new CgroupInfo_NetCls;
}

void CgroupInfo_NetCls::Clear() {
  classid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CgroupInfo_NetCls::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CgroupInfo.NetCls)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 classid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &classid_)));
          set_has_classid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CgroupInfo.NetCls)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CgroupInfo.NetCls)
  return false;
#undef DO_
}

void CgroupInfo_NetCls::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CgroupInfo.NetCls)
  // optional uint32 classid = 1;
  if (has_classid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->classid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CgroupInfo.NetCls)
}

::google::protobuf::uint8* CgroupInfo_NetCls::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CgroupInfo.NetCls)
  // optional uint32 classid = 1;
  if (has_classid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->classid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CgroupInfo.NetCls)
  return target;
}

int CgroupInfo_NetCls::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 classid = 1;
    if (has_classid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->classid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CgroupInfo_NetCls::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CgroupInfo_NetCls* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CgroupInfo_NetCls*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CgroupInfo_NetCls::MergeFrom(const CgroupInfo_NetCls& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_classid()) {
      set_classid(from.classid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CgroupInfo_NetCls::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CgroupInfo_NetCls::CopyFrom(const CgroupInfo_NetCls& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CgroupInfo_NetCls::IsInitialized() const {

  return true;
}

void CgroupInfo_NetCls::Swap(CgroupInfo_NetCls* other) {
  if (other != this) {
    std::swap(classid_, other->classid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CgroupInfo_NetCls::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CgroupInfo_NetCls_descriptor_;
  metadata.reflection = CgroupInfo_NetCls_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CgroupInfo::kNetClsFieldNumber;
#endif  // !_MSC_VER

CgroupInfo::CgroupInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CgroupInfo)
}

void CgroupInfo::InitAsDefaultInstance() {
  net_cls_ = const_cast< ::mesos::CgroupInfo_NetCls*>(&::mesos::CgroupInfo_NetCls::default_instance());
}

CgroupInfo::CgroupInfo(const CgroupInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CgroupInfo)
}

void CgroupInfo::SharedCtor() {
  _cached_size_ = 0;
  net_cls_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CgroupInfo::~CgroupInfo() {
  // @@protoc_insertion_point(destructor:mesos.CgroupInfo)
  SharedDtor();
}

void CgroupInfo::SharedDtor() {
  if (this != default_instance_) {
    delete net_cls_;
  }
}

void CgroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CgroupInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CgroupInfo_descriptor_;
}

const CgroupInfo& CgroupInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CgroupInfo* CgroupInfo::default_instance_ = NULL;

CgroupInfo* CgroupInfo::New() const {
  return new CgroupInfo;
}

void CgroupInfo::Clear() {
  if (has_net_cls()) {
    if (net_cls_ != NULL) net_cls_->::mesos::CgroupInfo_NetCls::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CgroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CgroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CgroupInfo.NetCls net_cls = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_net_cls()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CgroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CgroupInfo)
  return false;
#undef DO_
}

void CgroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CgroupInfo)
  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  if (has_net_cls()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->net_cls(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CgroupInfo)
}

::google::protobuf::uint8* CgroupInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CgroupInfo)
  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  if (has_net_cls()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->net_cls(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CgroupInfo)
  return target;
}

int CgroupInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.CgroupInfo.NetCls net_cls = 1;
    if (has_net_cls()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->net_cls());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CgroupInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CgroupInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CgroupInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CgroupInfo::MergeFrom(const CgroupInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_net_cls()) {
      mutable_net_cls()->::mesos::CgroupInfo_NetCls::MergeFrom(from.net_cls());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CgroupInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CgroupInfo::CopyFrom(const CgroupInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CgroupInfo::IsInitialized() const {

  return true;
}

void CgroupInfo::Swap(CgroupInfo* other) {
  if (other != this) {
    std::swap(net_cls_, other->net_cls_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CgroupInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CgroupInfo_descriptor_;
  metadata.reflection = CgroupInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Labels::kLabelsFieldNumber;
#endif  // !_MSC_VER

Labels::Labels()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Labels)
}

void Labels::InitAsDefaultInstance() {
}

Labels::Labels(const Labels& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Labels)
}

void Labels::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Labels::~Labels() {
  // @@protoc_insertion_point(destructor:mesos.Labels)
  SharedDtor();
}

void Labels::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Labels::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Labels::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Labels_descriptor_;
}

const Labels& Labels::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Labels* Labels::default_instance_ = NULL;

Labels* Labels::New() const {
  return new Labels;
}

void Labels::Clear() {
  labels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Labels::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Labels)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Label labels = 1;
      case 1: {
        if (tag == 10) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_labels;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Labels)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Labels)
  return false;
#undef DO_
}

void Labels::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Labels)
  // repeated .mesos.Label labels = 1;
  for (int i = 0; i < this->labels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->labels(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Labels)
}

::google::protobuf::uint8* Labels::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Labels)
  // repeated .mesos.Label labels = 1;
  for (int i = 0; i < this->labels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->labels(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Labels)
  return target;
}

int Labels::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Label labels = 1;
  total_size += 1 * this->labels_size();
  for (int i = 0; i < this->labels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->labels(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Labels::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Labels* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Labels*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Labels::MergeFrom(const Labels& from) {
  GOOGLE_CHECK_NE(&from, this);
  labels_.MergeFrom(from.labels_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Labels::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Labels::CopyFrom(const Labels& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Labels::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->labels())) return false;
  return true;
}

void Labels::Swap(Labels* other) {
  if (other != this) {
    labels_.Swap(&other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Labels::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Labels_descriptor_;
  metadata.reflection = Labels_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Label::kKeyFieldNumber;
const int Label::kValueFieldNumber;
#endif  // !_MSC_VER

Label::Label()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Label)
}

void Label::InitAsDefaultInstance() {
}

Label::Label(const Label& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Label)
}

void Label::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Label::~Label() {
  // @@protoc_insertion_point(destructor:mesos.Label)
  SharedDtor();
}

void Label::SharedDtor() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void Label::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Label::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Label_descriptor_;
}

const Label& Label::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Label* Label::default_instance_ = NULL;

Label* Label::New() const {
  return new Label;
}

void Label::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Label::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Label)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Label)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Label)
  return false;
#undef DO_
}

void Label::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Label)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Label)
}

::google::protobuf::uint8* Label::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Label)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Label)
  return target;
}

int Label::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Label::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Label* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Label*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Label::MergeFrom(const Label& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Label::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Label::CopyFrom(const Label& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Label::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Label::Swap(Label* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Label::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Label_descriptor_;
  metadata.reflection = Label_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Port::kNumberFieldNumber;
const int Port::kNameFieldNumber;
const int Port::kProtocolFieldNumber;
const int Port::kVisibilityFieldNumber;
const int Port::kLabelsFieldNumber;
#endif  // !_MSC_VER

Port::Port()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Port)
}

void Port::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

Port::Port(const Port& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Port)
}

void Port::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  number_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  visibility_ = 0;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Port::~Port() {
  // @@protoc_insertion_point(destructor:mesos.Port)
  SharedDtor();
}

void Port::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (this != default_instance_) {
    delete labels_;
  }
}

void Port::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Port::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Port_descriptor_;
}

const Port& Port::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Port* Port::default_instance_ = NULL;

Port* Port::New() const {
  return new Port;
}

void Port::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Port*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(number_, visibility_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_protocol()) {
      if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        protocol_->clear();
      }
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Port::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Port)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_protocol;
        break;
      }

      // optional string protocol = 3;
      case 3: {
        if (tag == 26) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->protocol().data(), this->protocol().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_visibility;
        break;
      }

      // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
      case 4: {
        if (tag == 32) {
         parse_visibility:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::DiscoveryInfo_Visibility_IsValid(value)) {
            set_visibility(static_cast< ::mesos::DiscoveryInfo_Visibility >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 5;
      case 5: {
        if (tag == 42) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Port)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Port)
  return false;
#undef DO_
}

void Port::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Port)
  // required uint32 number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->number(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->protocol(), output);
  }

  // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->visibility(), output);
  }

  // optional .mesos.Labels labels = 5;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->labels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Port)
}

::google::protobuf::uint8* Port::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Port)
  // required uint32 number = 1;
  if (has_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->number(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->protocol(), target);
  }

  // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
  if (has_visibility()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->visibility(), target);
  }

  // optional .mesos.Labels labels = 5;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->labels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Port)
  return target;
}

int Port::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 number = 1;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string protocol = 3;
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->protocol());
    }

    // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
    if (has_visibility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visibility());
    }

    // optional .mesos.Labels labels = 5;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Port::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Port* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Port*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Port::MergeFrom(const Port& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Port::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Port::CopyFrom(const Port& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Port::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void Port::Swap(Port* other) {
  if (other != this) {
    std::swap(number_, other->number_);
    std::swap(name_, other->name_);
    std::swap(protocol_, other->protocol_);
    std::swap(visibility_, other->visibility_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Port::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Port_descriptor_;
  metadata.reflection = Port_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Ports::kPortsFieldNumber;
#endif  // !_MSC_VER

Ports::Ports()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Ports)
}

void Ports::InitAsDefaultInstance() {
}

Ports::Ports(const Ports& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Ports)
}

void Ports::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ports::~Ports() {
  // @@protoc_insertion_point(destructor:mesos.Ports)
  SharedDtor();
}

void Ports::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Ports::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ports::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ports_descriptor_;
}

const Ports& Ports::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Ports* Ports::default_instance_ = NULL;

Ports* Ports::New() const {
  return new Ports;
}

void Ports::Clear() {
  ports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ports::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Ports)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Port ports = 1;
      case 1: {
        if (tag == 10) {
         parse_ports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ports;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Ports)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Ports)
  return false;
#undef DO_
}

void Ports::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Ports)
  // repeated .mesos.Port ports = 1;
  for (int i = 0; i < this->ports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ports(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Ports)
}

::google::protobuf::uint8* Ports::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Ports)
  // repeated .mesos.Port ports = 1;
  for (int i = 0; i < this->ports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ports(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Ports)
  return target;
}

int Ports::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Port ports = 1;
  total_size += 1 * this->ports_size();
  for (int i = 0; i < this->ports_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ports(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ports::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ports* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ports*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ports::MergeFrom(const Ports& from) {
  GOOGLE_CHECK_NE(&from, this);
  ports_.MergeFrom(from.ports_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ports::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ports::CopyFrom(const Ports& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ports::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->ports())) return false;
  return true;
}

void Ports::Swap(Ports* other) {
  if (other != this) {
    ports_.Swap(&other->ports_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ports::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ports_descriptor_;
  metadata.reflection = Ports_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiscoveryInfo_Visibility_descriptor_;
}
bool DiscoveryInfo_Visibility_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DiscoveryInfo_Visibility DiscoveryInfo::FRAMEWORK;
const DiscoveryInfo_Visibility DiscoveryInfo::CLUSTER;
const DiscoveryInfo_Visibility DiscoveryInfo::EXTERNAL;
const DiscoveryInfo_Visibility DiscoveryInfo::Visibility_MIN;
const DiscoveryInfo_Visibility DiscoveryInfo::Visibility_MAX;
const int DiscoveryInfo::Visibility_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DiscoveryInfo::kVisibilityFieldNumber;
const int DiscoveryInfo::kNameFieldNumber;
const int DiscoveryInfo::kEnvironmentFieldNumber;
const int DiscoveryInfo::kLocationFieldNumber;
const int DiscoveryInfo::kVersionFieldNumber;
const int DiscoveryInfo::kPortsFieldNumber;
const int DiscoveryInfo::kLabelsFieldNumber;
#endif  // !_MSC_VER

DiscoveryInfo::DiscoveryInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DiscoveryInfo)
}

void DiscoveryInfo::InitAsDefaultInstance() {
  ports_ = const_cast< ::mesos::Ports*>(&::mesos::Ports::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

DiscoveryInfo::DiscoveryInfo(const DiscoveryInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DiscoveryInfo)
}

void DiscoveryInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  visibility_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  environment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ports_ = NULL;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiscoveryInfo::~DiscoveryInfo() {
  // @@protoc_insertion_point(destructor:mesos.DiscoveryInfo)
  SharedDtor();
}

void DiscoveryInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (environment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete environment_;
  }
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete location_;
  }
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (this != default_instance_) {
    delete ports_;
    delete labels_;
  }
}

void DiscoveryInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DiscoveryInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiscoveryInfo_descriptor_;
}

const DiscoveryInfo& DiscoveryInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DiscoveryInfo* DiscoveryInfo::default_instance_ = NULL;

DiscoveryInfo* DiscoveryInfo::New() const {
  return new DiscoveryInfo;
}

void DiscoveryInfo::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    visibility_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_environment()) {
      if (environment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        environment_->clear();
      }
    }
    if (has_location()) {
      if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        location_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
    if (has_ports()) {
      if (ports_ != NULL) ports_->::mesos::Ports::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DiscoveryInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DiscoveryInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.DiscoveryInfo.Visibility visibility = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::DiscoveryInfo_Visibility_IsValid(value)) {
            set_visibility(static_cast< ::mesos::DiscoveryInfo_Visibility >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_environment;
        break;
      }

      // optional string environment = 3;
      case 3: {
        if (tag == 26) {
         parse_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_environment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->environment().data(), this->environment().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "environment");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // optional string location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->location().data(), this->location().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "location");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_version;
        break;
      }

      // optional string version = 5;
      case 5: {
        if (tag == 42) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ports;
        break;
      }

      // optional .mesos.Ports ports = 6;
      case 6: {
        if (tag == 50) {
         parse_ports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 7;
      case 7: {
        if (tag == 58) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DiscoveryInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DiscoveryInfo)
  return false;
#undef DO_
}

void DiscoveryInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DiscoveryInfo)
  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->visibility(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string environment = 3;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->environment().data(), this->environment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "environment");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->environment(), output);
  }

  // optional string location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "location");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->location(), output);
  }

  // optional string version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->version(), output);
  }

  // optional .mesos.Ports ports = 6;
  if (has_ports()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->ports(), output);
  }

  // optional .mesos.Labels labels = 7;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->labels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DiscoveryInfo)
}

::google::protobuf::uint8* DiscoveryInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DiscoveryInfo)
  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  if (has_visibility()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->visibility(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional string environment = 3;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->environment().data(), this->environment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "environment");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->environment(), target);
  }

  // optional string location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "location");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->location(), target);
  }

  // optional string version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->version(), target);
  }

  // optional .mesos.Ports ports = 6;
  if (has_ports()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->ports(), target);
  }

  // optional .mesos.Labels labels = 7;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->labels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DiscoveryInfo)
  return target;
}

int DiscoveryInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.DiscoveryInfo.Visibility visibility = 1;
    if (has_visibility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visibility());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string environment = 3;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->environment());
    }

    // optional string location = 4;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->location());
    }

    // optional string version = 5;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .mesos.Ports ports = 6;
    if (has_ports()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ports());
    }

    // optional .mesos.Labels labels = 7;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labels());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiscoveryInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DiscoveryInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DiscoveryInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DiscoveryInfo::MergeFrom(const DiscoveryInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_environment()) {
      set_environment(from.environment());
    }
    if (from.has_location()) {
      set_location(from.location());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_ports()) {
      mutable_ports()->::mesos::Ports::MergeFrom(from.ports());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DiscoveryInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DiscoveryInfo::CopyFrom(const DiscoveryInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscoveryInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_ports()) {
    if (!this->ports().IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels().IsInitialized()) return false;
  }
  return true;
}

void DiscoveryInfo::Swap(DiscoveryInfo* other) {
  if (other != this) {
    std::swap(visibility_, other->visibility_);
    std::swap(name_, other->name_);
    std::swap(environment_, other->environment_);
    std::swap(location_, other->location_);
    std::swap(version_, other->version_);
    std::swap(ports_, other->ports_);
    std::swap(labels_, other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DiscoveryInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DiscoveryInfo_descriptor_;
  metadata.reflection = DiscoveryInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WeightInfo::kWeightFieldNumber;
const int WeightInfo::kRoleFieldNumber;
#endif  // !_MSC_VER

WeightInfo::WeightInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.WeightInfo)
}

void WeightInfo::InitAsDefaultInstance() {
}

WeightInfo::WeightInfo(const WeightInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.WeightInfo)
}

void WeightInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  weight_ = 0;
  role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WeightInfo::~WeightInfo() {
  // @@protoc_insertion_point(destructor:mesos.WeightInfo)
  SharedDtor();
}

void WeightInfo::SharedDtor() {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_;
  }
  if (this != default_instance_) {
  }
}

void WeightInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WeightInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WeightInfo_descriptor_;
}

const WeightInfo& WeightInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

WeightInfo* WeightInfo::default_instance_ = NULL;

WeightInfo* WeightInfo::New() const {
  return new WeightInfo;
}

void WeightInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    weight_ = 0;
    if (has_role()) {
      if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        role_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WeightInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.WeightInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double weight = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &weight_)));
          set_has_weight();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_role;
        break;
      }

      // optional string role = 2;
      case 2: {
        if (tag == 18) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.WeightInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.WeightInfo)
  return false;
#undef DO_
}

void WeightInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.WeightInfo)
  // required double weight = 1;
  if (has_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->weight(), output);
  }

  // optional string role = 2;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->role(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.WeightInfo)
}

::google::protobuf::uint8* WeightInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.WeightInfo)
  // required double weight = 1;
  if (has_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->weight(), target);
  }

  // optional string role = 2;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->role(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.WeightInfo)
  return target;
}

int WeightInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double weight = 1;
    if (has_weight()) {
      total_size += 1 + 8;
    }

    // optional string role = 2;
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WeightInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WeightInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WeightInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WeightInfo::MergeFrom(const WeightInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_weight()) {
      set_weight(from.weight());
    }
    if (from.has_role()) {
      set_role(from.role());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WeightInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WeightInfo::CopyFrom(const WeightInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeightInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WeightInfo::Swap(WeightInfo* other) {
  if (other != this) {
    std::swap(weight_, other->weight_);
    std::swap(role_, other->role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WeightInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WeightInfo_descriptor_;
  metadata.reflection = WeightInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VersionInfo::kVersionFieldNumber;
const int VersionInfo::kBuildDateFieldNumber;
const int VersionInfo::kBuildTimeFieldNumber;
const int VersionInfo::kBuildUserFieldNumber;
const int VersionInfo::kGitShaFieldNumber;
const int VersionInfo::kGitBranchFieldNumber;
const int VersionInfo::kGitTagFieldNumber;
#endif  // !_MSC_VER

VersionInfo::VersionInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.VersionInfo)
}

void VersionInfo::InitAsDefaultInstance() {
}

VersionInfo::VersionInfo(const VersionInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.VersionInfo)
}

void VersionInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_time_ = 0;
  build_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionInfo::~VersionInfo() {
  // @@protoc_insertion_point(destructor:mesos.VersionInfo)
  SharedDtor();
}

void VersionInfo::SharedDtor() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (build_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete build_date_;
  }
  if (build_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete build_user_;
  }
  if (git_sha_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete git_sha_;
  }
  if (git_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete git_branch_;
  }
  if (git_tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete git_tag_;
  }
  if (this != default_instance_) {
  }
}

void VersionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionInfo_descriptor_;
}

const VersionInfo& VersionInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

VersionInfo* VersionInfo::default_instance_ = NULL;

VersionInfo* VersionInfo::New() const {
  return new VersionInfo;
}

void VersionInfo::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
    if (has_build_date()) {
      if (build_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        build_date_->clear();
      }
    }
    build_time_ = 0;
    if (has_build_user()) {
      if (build_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        build_user_->clear();
      }
    }
    if (has_git_sha()) {
      if (git_sha_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        git_sha_->clear();
      }
    }
    if (has_git_branch()) {
      if (git_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        git_branch_->clear();
      }
    }
    if (has_git_tag()) {
      if (git_tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        git_tag_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.VersionInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_build_date;
        break;
      }

      // optional string build_date = 2;
      case 2: {
        if (tag == 18) {
         parse_build_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->build_date().data(), this->build_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "build_date");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_build_time;
        break;
      }

      // optional double build_time = 3;
      case 3: {
        if (tag == 25) {
         parse_build_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &build_time_)));
          set_has_build_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_build_user;
        break;
      }

      // optional string build_user = 4;
      case 4: {
        if (tag == 34) {
         parse_build_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->build_user().data(), this->build_user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "build_user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_git_sha;
        break;
      }

      // optional string git_sha = 5;
      case 5: {
        if (tag == 42) {
         parse_git_sha:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_git_sha()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->git_sha().data(), this->git_sha().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "git_sha");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_git_branch;
        break;
      }

      // optional string git_branch = 6;
      case 6: {
        if (tag == 50) {
         parse_git_branch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_git_branch()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->git_branch().data(), this->git_branch().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "git_branch");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_git_tag;
        break;
      }

      // optional string git_tag = 7;
      case 7: {
        if (tag == 58) {
         parse_git_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_git_tag()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->git_tag().data(), this->git_tag().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "git_tag");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.VersionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.VersionInfo)
  return false;
#undef DO_
}

void VersionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.VersionInfo)
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->version(), output);
  }

  // optional string build_date = 2;
  if (has_build_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_date().data(), this->build_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "build_date");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->build_date(), output);
  }

  // optional double build_time = 3;
  if (has_build_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->build_time(), output);
  }

  // optional string build_user = 4;
  if (has_build_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_user().data(), this->build_user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "build_user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->build_user(), output);
  }

  // optional string git_sha = 5;
  if (has_git_sha()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_sha().data(), this->git_sha().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "git_sha");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->git_sha(), output);
  }

  // optional string git_branch = 6;
  if (has_git_branch()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_branch().data(), this->git_branch().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "git_branch");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->git_branch(), output);
  }

  // optional string git_tag = 7;
  if (has_git_tag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_tag().data(), this->git_tag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "git_tag");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->git_tag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.VersionInfo)
}

::google::protobuf::uint8* VersionInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.VersionInfo)
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }

  // optional string build_date = 2;
  if (has_build_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_date().data(), this->build_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "build_date");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->build_date(), target);
  }

  // optional double build_time = 3;
  if (has_build_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->build_time(), target);
  }

  // optional string build_user = 4;
  if (has_build_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_user().data(), this->build_user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "build_user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->build_user(), target);
  }

  // optional string git_sha = 5;
  if (has_git_sha()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_sha().data(), this->git_sha().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "git_sha");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->git_sha(), target);
  }

  // optional string git_branch = 6;
  if (has_git_branch()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_branch().data(), this->git_branch().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "git_branch");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->git_branch(), target);
  }

  // optional string git_tag = 7;
  if (has_git_tag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_tag().data(), this->git_tag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "git_tag");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->git_tag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.VersionInfo)
  return target;
}

int VersionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string build_date = 2;
    if (has_build_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_date());
    }

    // optional double build_time = 3;
    if (has_build_time()) {
      total_size += 1 + 8;
    }

    // optional string build_user = 4;
    if (has_build_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_user());
    }

    // optional string git_sha = 5;
    if (has_git_sha()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->git_sha());
    }

    // optional string git_branch = 6;
    if (has_git_branch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->git_branch());
    }

    // optional string git_tag = 7;
    if (has_git_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->git_tag());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionInfo::MergeFrom(const VersionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_build_date()) {
      set_build_date(from.build_date());
    }
    if (from.has_build_time()) {
      set_build_time(from.build_time());
    }
    if (from.has_build_user()) {
      set_build_user(from.build_user());
    }
    if (from.has_git_sha()) {
      set_git_sha(from.git_sha());
    }
    if (from.has_git_branch()) {
      set_git_branch(from.git_branch());
    }
    if (from.has_git_tag()) {
      set_git_tag(from.git_tag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionInfo::CopyFrom(const VersionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void VersionInfo::Swap(VersionInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(build_date_, other->build_date_);
    std::swap(build_time_, other->build_time_);
    std::swap(build_user_, other->build_user_);
    std::swap(git_sha_, other->git_sha_);
    std::swap(git_branch_, other->git_branch_);
    std::swap(git_tag_, other->git_tag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionInfo_descriptor_;
  metadata.reflection = VersionInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Flag::kNameFieldNumber;
const int Flag::kValueFieldNumber;
#endif  // !_MSC_VER

Flag::Flag()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Flag)
}

void Flag::InitAsDefaultInstance() {
}

Flag::Flag(const Flag& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Flag)
}

void Flag::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Flag::~Flag() {
  // @@protoc_insertion_point(destructor:mesos.Flag)
  SharedDtor();
}

void Flag::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void Flag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Flag::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Flag_descriptor_;
}

const Flag& Flag::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Flag* Flag::default_instance_ = NULL;

Flag* Flag::New() const {
  return new Flag;
}

void Flag::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Flag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Flag)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Flag)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Flag)
  return false;
#undef DO_
}

void Flag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Flag)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Flag)
}

::google::protobuf::uint8* Flag::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Flag)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Flag)
  return target;
}

int Flag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Flag::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Flag* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Flag*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Flag::MergeFrom(const Flag& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Flag::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Flag::CopyFrom(const Flag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Flag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Flag::Swap(Flag* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Flag::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Flag_descriptor_;
  metadata.reflection = Flag_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Role::kNameFieldNumber;
const int Role::kWeightFieldNumber;
const int Role::kFrameworksFieldNumber;
const int Role::kResourcesFieldNumber;
#endif  // !_MSC_VER

Role::Role()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Role)
}

void Role::InitAsDefaultInstance() {
}

Role::Role(const Role& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Role)
}

void Role::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Role::~Role() {
  // @@protoc_insertion_point(destructor:mesos.Role)
  SharedDtor();
}

void Role::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Role::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Role::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Role_descriptor_;
}

const Role& Role::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Role* Role::default_instance_ = NULL;

Role* Role::New() const {
  return new Role;
}

void Role::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    weight_ = 0;
  }
  frameworks_.Clear();
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Role::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Role)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_weight;
        break;
      }

      // required double weight = 2;
      case 2: {
        if (tag == 17) {
         parse_weight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &weight_)));
          set_has_weight();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_frameworks;
        break;
      }

      // repeated .mesos.FrameworkID frameworks = 3;
      case 3: {
        if (tag == 26) {
         parse_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frameworks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_frameworks;
        if (input->ExpectTag(34)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 4;
      case 4: {
        if (tag == 34) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Role)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Role)
  return false;
#undef DO_
}

void Role::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Role)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required double weight = 2;
  if (has_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->weight(), output);
  }

  // repeated .mesos.FrameworkID frameworks = 3;
  for (int i = 0; i < this->frameworks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->frameworks(i), output);
  }

  // repeated .mesos.Resource resources = 4;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Role)
}

::google::protobuf::uint8* Role::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Role)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required double weight = 2;
  if (has_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->weight(), target);
  }

  // repeated .mesos.FrameworkID frameworks = 3;
  for (int i = 0; i < this->frameworks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->frameworks(i), target);
  }

  // repeated .mesos.Resource resources = 4;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Role)
  return target;
}

int Role::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required double weight = 2;
    if (has_weight()) {
      total_size += 1 + 8;
    }

  }
  // repeated .mesos.FrameworkID frameworks = 3;
  total_size += 1 * this->frameworks_size();
  for (int i = 0; i < this->frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frameworks(i));
  }

  // repeated .mesos.Resource resources = 4;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Role::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Role* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Role*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Role::MergeFrom(const Role& from) {
  GOOGLE_CHECK_NE(&from, this);
  frameworks_.MergeFrom(from.frameworks_);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_weight()) {
      set_weight(from.weight());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Role::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Role::CopyFrom(const Role& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Role::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->frameworks())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Role::Swap(Role* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(weight_, other->weight_);
    frameworks_.Swap(&other->frameworks_);
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Role::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Role_descriptor_;
  metadata.reflection = Role_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Metric::kNameFieldNumber;
const int Metric::kValueFieldNumber;
#endif  // !_MSC_VER

Metric::Metric()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Metric)
}

void Metric::InitAsDefaultInstance() {
}

Metric::Metric(const Metric& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Metric)
}

void Metric::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Metric::~Metric() {
  // @@protoc_insertion_point(destructor:mesos.Metric)
  SharedDtor();
}

void Metric::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Metric::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Metric::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Metric_descriptor_;
}

const Metric& Metric::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Metric* Metric::default_instance_ = NULL;

Metric* Metric::New() const {
  return new Metric;
}

void Metric::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    value_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Metric::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Metric)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_value;
        break;
      }

      // optional double value = 2;
      case 2: {
        if (tag == 17) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Metric)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Metric)
  return false;
#undef DO_
}

void Metric::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Metric)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional double value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Metric)
}

::google::protobuf::uint8* Metric::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Metric)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional double value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Metric)
  return target;
}

int Metric::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional double value = 2;
    if (has_value()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Metric::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Metric* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Metric*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Metric::MergeFrom(const Metric& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Metric::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Metric::CopyFrom(const Metric& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metric::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Metric::Swap(Metric* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Metric::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Metric_descriptor_;
  metadata.reflection = Metric_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileInfo::kPathFieldNumber;
const int FileInfo::kNlinkFieldNumber;
const int FileInfo::kSizeFieldNumber;
const int FileInfo::kMtimeFieldNumber;
const int FileInfo::kModeFieldNumber;
const int FileInfo::kUidFieldNumber;
const int FileInfo::kGidFieldNumber;
#endif  // !_MSC_VER

FileInfo::FileInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FileInfo)
}

void FileInfo::InitAsDefaultInstance() {
  mtime_ = const_cast< ::mesos::TimeInfo*>(&::mesos::TimeInfo::default_instance());
}

FileInfo::FileInfo(const FileInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FileInfo)
}

void FileInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlink_ = 0;
  size_ = GOOGLE_ULONGLONG(0);
  mtime_ = NULL;
  mode_ = 0u;
  uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileInfo::~FileInfo() {
  // @@protoc_insertion_point(destructor:mesos.FileInfo)
  SharedDtor();
}

void FileInfo::SharedDtor() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (uid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uid_;
  }
  if (gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gid_;
  }
  if (this != default_instance_) {
    delete mtime_;
  }
}

void FileInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileInfo_descriptor_;
}

const FileInfo& FileInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FileInfo* FileInfo::default_instance_ = NULL;

FileInfo* FileInfo::New() const {
  return new FileInfo;
}

void FileInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FileInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(size_, mode_);
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
    if (has_mtime()) {
      if (mtime_ != NULL) mtime_->::mesos::TimeInfo::Clear();
    }
    if (has_uid()) {
      if (uid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uid_->clear();
      }
    }
    if (has_gid()) {
      if (gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        gid_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FileInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_nlink;
        break;
      }

      // optional int32 nlink = 2;
      case 2: {
        if (tag == 16) {
         parse_nlink:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nlink_)));
          set_has_nlink();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // optional uint64 size = 3;
      case 3: {
        if (tag == 24) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mtime;
        break;
      }

      // optional .mesos.TimeInfo mtime = 4;
      case 4: {
        if (tag == 34) {
         parse_mtime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mtime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mode;
        break;
      }

      // optional uint32 mode = 5;
      case 5: {
        if (tag == 40) {
         parse_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_uid;
        break;
      }

      // optional string uid = 6;
      case 6: {
        if (tag == 50) {
         parse_uid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->uid().data(), this->uid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "uid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_gid;
        break;
      }

      // optional string gid = 7;
      case 7: {
        if (tag == 58) {
         parse_gid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->gid().data(), this->gid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "gid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FileInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FileInfo)
  return false;
#undef DO_
}

void FileInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FileInfo)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  // optional int32 nlink = 2;
  if (has_nlink()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nlink(), output);
  }

  // optional uint64 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->size(), output);
  }

  // optional .mesos.TimeInfo mtime = 4;
  if (has_mtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->mtime(), output);
  }

  // optional uint32 mode = 5;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->mode(), output);
  }

  // optional string uid = 6;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uid().data(), this->uid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "uid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->uid(), output);
  }

  // optional string gid = 7;
  if (has_gid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gid().data(), this->gid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "gid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->gid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FileInfo)
}

::google::protobuf::uint8* FileInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FileInfo)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->path(), target);
  }

  // optional int32 nlink = 2;
  if (has_nlink()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nlink(), target);
  }

  // optional uint64 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->size(), target);
  }

  // optional .mesos.TimeInfo mtime = 4;
  if (has_mtime()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->mtime(), target);
  }

  // optional uint32 mode = 5;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->mode(), target);
  }

  // optional string uid = 6;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uid().data(), this->uid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "uid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->uid(), target);
  }

  // optional string gid = 7;
  if (has_gid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gid().data(), this->gid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "gid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->gid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FileInfo)
  return target;
}

int FileInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // optional int32 nlink = 2;
    if (has_nlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nlink());
    }

    // optional uint64 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

    // optional .mesos.TimeInfo mtime = 4;
    if (has_mtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mtime());
    }

    // optional uint32 mode = 5;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

    // optional string uid = 6;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uid());
    }

    // optional string gid = 7;
    if (has_gid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileInfo::MergeFrom(const FileInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_nlink()) {
      set_nlink(from.nlink());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_mtime()) {
      mutable_mtime()->::mesos::TimeInfo::MergeFrom(from.mtime());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_gid()) {
      set_gid(from.gid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileInfo::CopyFrom(const FileInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_mtime()) {
    if (!this->mtime().IsInitialized()) return false;
  }
  return true;
}

void FileInfo::Swap(FileInfo* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(nlink_, other->nlink_);
    std::swap(size_, other->size_);
    std::swap(mtime_, other->mtime_);
    std::swap(mode_, other->mode_);
    std::swap(uid_, other->uid_);
    std::swap(gid_, other->gid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileInfo_descriptor_;
  metadata.reflection = FileInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Device::kPathFieldNumber;
#endif  // !_MSC_VER

Device::Device()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Device)
}

void Device::InitAsDefaultInstance() {
}

Device::Device(const Device& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Device)
}

void Device::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Device::~Device() {
  // @@protoc_insertion_point(destructor:mesos.Device)
  SharedDtor();
}

void Device::SharedDtor() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void Device::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Device::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Device_descriptor_;
}

const Device& Device::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Device* Device::default_instance_ = NULL;

Device* Device::New() const {
  return new Device;
}

void Device::Clear() {
  if (has_path()) {
    if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      path_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Device::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Device)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Device)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Device)
  return false;
#undef DO_
}

void Device::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Device)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Device)
}

::google::protobuf::uint8* Device::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Device)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->path(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Device)
  return target;
}

int Device::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Device::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Device* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Device*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Device::MergeFrom(const Device& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Device::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Device::CopyFrom(const Device& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Device::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Device::Swap(Device* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Device::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Device_descriptor_;
  metadata.reflection = Device_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceAccess_Access::kReadFieldNumber;
const int DeviceAccess_Access::kWriteFieldNumber;
const int DeviceAccess_Access::kMknodFieldNumber;
#endif  // !_MSC_VER

DeviceAccess_Access::DeviceAccess_Access()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DeviceAccess.Access)
}

void DeviceAccess_Access::InitAsDefaultInstance() {
}

DeviceAccess_Access::DeviceAccess_Access(const DeviceAccess_Access& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DeviceAccess.Access)
}

void DeviceAccess_Access::SharedCtor() {
  _cached_size_ = 0;
  read_ = false;
  write_ = false;
  mknod_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceAccess_Access::~DeviceAccess_Access() {
  // @@protoc_insertion_point(destructor:mesos.DeviceAccess.Access)
  SharedDtor();
}

void DeviceAccess_Access::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DeviceAccess_Access::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeviceAccess_Access::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeviceAccess_Access_descriptor_;
}

const DeviceAccess_Access& DeviceAccess_Access::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DeviceAccess_Access* DeviceAccess_Access::default_instance_ = NULL;

DeviceAccess_Access* DeviceAccess_Access::New() const {
  return new DeviceAccess_Access;
}

void DeviceAccess_Access::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DeviceAccess_Access*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(read_, mknod_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeviceAccess_Access::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DeviceAccess.Access)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool read = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &read_)));
          set_has_read();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_write;
        break;
      }

      // optional bool write = 2;
      case 2: {
        if (tag == 16) {
         parse_write:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &write_)));
          set_has_write();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mknod;
        break;
      }

      // optional bool mknod = 3;
      case 3: {
        if (tag == 24) {
         parse_mknod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mknod_)));
          set_has_mknod();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DeviceAccess.Access)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DeviceAccess.Access)
  return false;
#undef DO_
}

void DeviceAccess_Access::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DeviceAccess.Access)
  // optional bool read = 1;
  if (has_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->read(), output);
  }

  // optional bool write = 2;
  if (has_write()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->write(), output);
  }

  // optional bool mknod = 3;
  if (has_mknod()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->mknod(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DeviceAccess.Access)
}

::google::protobuf::uint8* DeviceAccess_Access::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DeviceAccess.Access)
  // optional bool read = 1;
  if (has_read()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->read(), target);
  }

  // optional bool write = 2;
  if (has_write()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->write(), target);
  }

  // optional bool mknod = 3;
  if (has_mknod()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->mknod(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DeviceAccess.Access)
  return target;
}

int DeviceAccess_Access::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool read = 1;
    if (has_read()) {
      total_size += 1 + 1;
    }

    // optional bool write = 2;
    if (has_write()) {
      total_size += 1 + 1;
    }

    // optional bool mknod = 3;
    if (has_mknod()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceAccess_Access::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeviceAccess_Access* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeviceAccess_Access*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeviceAccess_Access::MergeFrom(const DeviceAccess_Access& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_read()) {
      set_read(from.read());
    }
    if (from.has_write()) {
      set_write(from.write());
    }
    if (from.has_mknod()) {
      set_mknod(from.mknod());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeviceAccess_Access::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceAccess_Access::CopyFrom(const DeviceAccess_Access& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAccess_Access::IsInitialized() const {

  return true;
}

void DeviceAccess_Access::Swap(DeviceAccess_Access* other) {
  if (other != this) {
    std::swap(read_, other->read_);
    std::swap(write_, other->write_);
    std::swap(mknod_, other->mknod_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeviceAccess_Access::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeviceAccess_Access_descriptor_;
  metadata.reflection = DeviceAccess_Access_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int DeviceAccess::kDeviceFieldNumber;
const int DeviceAccess::kAccessFieldNumber;
#endif  // !_MSC_VER

DeviceAccess::DeviceAccess()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DeviceAccess)
}

void DeviceAccess::InitAsDefaultInstance() {
  device_ = const_cast< ::mesos::Device*>(&::mesos::Device::default_instance());
  access_ = const_cast< ::mesos::DeviceAccess_Access*>(&::mesos::DeviceAccess_Access::default_instance());
}

DeviceAccess::DeviceAccess(const DeviceAccess& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DeviceAccess)
}

void DeviceAccess::SharedCtor() {
  _cached_size_ = 0;
  device_ = NULL;
  access_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceAccess::~DeviceAccess() {
  // @@protoc_insertion_point(destructor:mesos.DeviceAccess)
  SharedDtor();
}

void DeviceAccess::SharedDtor() {
  if (this != default_instance_) {
    delete device_;
    delete access_;
  }
}

void DeviceAccess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeviceAccess::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeviceAccess_descriptor_;
}

const DeviceAccess& DeviceAccess::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DeviceAccess* DeviceAccess::default_instance_ = NULL;

DeviceAccess* DeviceAccess::New() const {
  return new DeviceAccess;
}

void DeviceAccess::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_device()) {
      if (device_ != NULL) device_->::mesos::Device::Clear();
    }
    if (has_access()) {
      if (access_ != NULL) access_->::mesos::DeviceAccess_Access::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeviceAccess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DeviceAccess)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Device device = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_access;
        break;
      }

      // required .mesos.DeviceAccess.Access access = 2;
      case 2: {
        if (tag == 18) {
         parse_access:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_access()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DeviceAccess)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DeviceAccess)
  return false;
#undef DO_
}

void DeviceAccess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DeviceAccess)
  // required .mesos.Device device = 1;
  if (has_device()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->device(), output);
  }

  // required .mesos.DeviceAccess.Access access = 2;
  if (has_access()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->access(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DeviceAccess)
}

::google::protobuf::uint8* DeviceAccess::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DeviceAccess)
  // required .mesos.Device device = 1;
  if (has_device()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->device(), target);
  }

  // required .mesos.DeviceAccess.Access access = 2;
  if (has_access()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->access(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DeviceAccess)
  return target;
}

int DeviceAccess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.Device device = 1;
    if (has_device()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->device());
    }

    // required .mesos.DeviceAccess.Access access = 2;
    if (has_access()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->access());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceAccess::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeviceAccess* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeviceAccess*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeviceAccess::MergeFrom(const DeviceAccess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device()) {
      mutable_device()->::mesos::Device::MergeFrom(from.device());
    }
    if (from.has_access()) {
      mutable_access()->::mesos::DeviceAccess_Access::MergeFrom(from.access());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeviceAccess::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceAccess::CopyFrom(const DeviceAccess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAccess::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_device()) {
    if (!this->device().IsInitialized()) return false;
  }
  return true;
}

void DeviceAccess::Swap(DeviceAccess* other) {
  if (other != this) {
    std::swap(device_, other->device_);
    std::swap(access_, other->access_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeviceAccess::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeviceAccess_descriptor_;
  metadata.reflection = DeviceAccess_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceWhitelist::kAllowedDevicesFieldNumber;
#endif  // !_MSC_VER

DeviceWhitelist::DeviceWhitelist()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DeviceWhitelist)
}

void DeviceWhitelist::InitAsDefaultInstance() {
}

DeviceWhitelist::DeviceWhitelist(const DeviceWhitelist& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DeviceWhitelist)
}

void DeviceWhitelist::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceWhitelist::~DeviceWhitelist() {
  // @@protoc_insertion_point(destructor:mesos.DeviceWhitelist)
  SharedDtor();
}

void DeviceWhitelist::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DeviceWhitelist::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeviceWhitelist::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeviceWhitelist_descriptor_;
}

const DeviceWhitelist& DeviceWhitelist::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DeviceWhitelist* DeviceWhitelist::default_instance_ = NULL;

DeviceWhitelist* DeviceWhitelist::New() const {
  return new DeviceWhitelist;
}

void DeviceWhitelist::Clear() {
  allowed_devices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeviceWhitelist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DeviceWhitelist)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.DeviceAccess allowed_devices = 1;
      case 1: {
        if (tag == 10) {
         parse_allowed_devices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_allowed_devices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_allowed_devices;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DeviceWhitelist)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DeviceWhitelist)
  return false;
#undef DO_
}

void DeviceWhitelist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DeviceWhitelist)
  // repeated .mesos.DeviceAccess allowed_devices = 1;
  for (int i = 0; i < this->allowed_devices_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->allowed_devices(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DeviceWhitelist)
}

::google::protobuf::uint8* DeviceWhitelist::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DeviceWhitelist)
  // repeated .mesos.DeviceAccess allowed_devices = 1;
  for (int i = 0; i < this->allowed_devices_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->allowed_devices(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DeviceWhitelist)
  return target;
}

int DeviceWhitelist::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.DeviceAccess allowed_devices = 1;
  total_size += 1 * this->allowed_devices_size();
  for (int i = 0; i < this->allowed_devices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->allowed_devices(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceWhitelist::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeviceWhitelist* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeviceWhitelist*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeviceWhitelist::MergeFrom(const DeviceWhitelist& from) {
  GOOGLE_CHECK_NE(&from, this);
  allowed_devices_.MergeFrom(from.allowed_devices_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeviceWhitelist::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceWhitelist::CopyFrom(const DeviceWhitelist& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceWhitelist::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->allowed_devices())) return false;
  return true;
}

void DeviceWhitelist::Swap(DeviceWhitelist* other) {
  if (other != this) {
    allowed_devices_.Swap(&other->allowed_devices_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeviceWhitelist::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeviceWhitelist_descriptor_;
  metadata.reflection = DeviceWhitelist_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

// @@protoc_insertion_point(global_scope)
