// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos.proto

#ifndef PROTOBUF_mesos_2eproto__INCLUDED
#define PROTOBUF_mesos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mesos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2eproto();
void protobuf_AssignDesc_mesos_2eproto();
void protobuf_ShutdownFile_mesos_2eproto();

class FrameworkID;
class OfferID;
class SlaveID;
class TaskID;
class ExecutorID;
class ContainerID;
class ResourceProviderID;
class TimeInfo;
class DurationInfo;
class Address;
class URL;
class Unavailability;
class MachineID;
class MachineInfo;
class FrameworkInfo;
class FrameworkInfo_Capability;
class CheckInfo;
class CheckInfo_Command;
class CheckInfo_Http;
class CheckInfo_Tcp;
class HealthCheck;
class HealthCheck_HTTPCheckInfo;
class HealthCheck_TCPCheckInfo;
class KillPolicy;
class CommandInfo;
class CommandInfo_URI;
class ExecutorInfo;
class MasterInfo;
class SlaveInfo;
class SlaveInfo_Capability;
class Value;
class Value_Scalar;
class Value_Range;
class Value_Ranges;
class Value_Set;
class Value_Text;
class Attribute;
class Resource;
class Resource_AllocationInfo;
class Resource_ReservationInfo;
class Resource_DiskInfo;
class Resource_DiskInfo_Persistence;
class Resource_DiskInfo_Source;
class Resource_DiskInfo_Source_Path;
class Resource_DiskInfo_Source_Mount;
class Resource_RevocableInfo;
class Resource_SharedInfo;
class TrafficControlStatistics;
class IpStatistics;
class IcmpStatistics;
class TcpStatistics;
class UdpStatistics;
class SNMPStatistics;
class DiskStatistics;
class ResourceStatistics;
class ResourceUsage;
class ResourceUsage_Executor;
class ResourceUsage_Executor_Task;
class PerfStatistics;
class Request;
class Offer;
class Offer_Operation;
class Offer_Operation_Launch;
class Offer_Operation_LaunchGroup;
class Offer_Operation_Reserve;
class Offer_Operation_Unreserve;
class Offer_Operation_Create;
class Offer_Operation_Destroy;
class InverseOffer;
class TaskInfo;
class TaskGroupInfo;
class Task;
class CheckStatusInfo;
class CheckStatusInfo_Command;
class CheckStatusInfo_Http;
class CheckStatusInfo_Tcp;
class TaskStatus;
class Filters;
class Environment;
class Environment_Variable;
class Parameter;
class Parameters;
class Credential;
class Credentials;
class Secret;
class Secret_Reference;
class Secret_Value;
class RateLimit;
class RateLimits;
class Image;
class Image_Appc;
class Image_Docker;
class Volume;
class Volume_Source;
class Volume_Source_DockerVolume;
class Volume_Source_SandboxPath;
class NetworkInfo;
class NetworkInfo_IPAddress;
class NetworkInfo_PortMapping;
class CapabilityInfo;
class LinuxInfo;
class RLimitInfo;
class RLimitInfo_RLimit;
class TTYInfo;
class TTYInfo_WindowSize;
class ContainerInfo;
class ContainerInfo_DockerInfo;
class ContainerInfo_DockerInfo_PortMapping;
class ContainerInfo_MesosInfo;
class ContainerStatus;
class CgroupInfo;
class CgroupInfo_NetCls;
class Labels;
class Label;
class Port;
class Ports;
class DiscoveryInfo;
class WeightInfo;
class VersionInfo;
class Flag;
class Role;
class Metric;
class FileInfo;
class Device;
class DeviceAccess;
class DeviceAccess_Access;
class DeviceWhitelist;

enum MachineInfo_Mode {
  MachineInfo_Mode_UP = 1,
  MachineInfo_Mode_DRAINING = 2,
  MachineInfo_Mode_DOWN = 3
};
bool MachineInfo_Mode_IsValid(int value);
const MachineInfo_Mode MachineInfo_Mode_Mode_MIN = MachineInfo_Mode_UP;
const MachineInfo_Mode MachineInfo_Mode_Mode_MAX = MachineInfo_Mode_DOWN;
const int MachineInfo_Mode_Mode_ARRAYSIZE = MachineInfo_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MachineInfo_Mode_descriptor();
inline const ::std::string& MachineInfo_Mode_Name(MachineInfo_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MachineInfo_Mode_descriptor(), value);
}
inline bool MachineInfo_Mode_Parse(
    const ::std::string& name, MachineInfo_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MachineInfo_Mode>(
    MachineInfo_Mode_descriptor(), name, value);
}
enum FrameworkInfo_Capability_Type {
  FrameworkInfo_Capability_Type_UNKNOWN = 0,
  FrameworkInfo_Capability_Type_REVOCABLE_RESOURCES = 1,
  FrameworkInfo_Capability_Type_TASK_KILLING_STATE = 2,
  FrameworkInfo_Capability_Type_GPU_RESOURCES = 3,
  FrameworkInfo_Capability_Type_SHARED_RESOURCES = 4,
  FrameworkInfo_Capability_Type_PARTITION_AWARE = 5,
  FrameworkInfo_Capability_Type_MULTI_ROLE = 6
};
bool FrameworkInfo_Capability_Type_IsValid(int value);
const FrameworkInfo_Capability_Type FrameworkInfo_Capability_Type_Type_MIN = FrameworkInfo_Capability_Type_UNKNOWN;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability_Type_Type_MAX = FrameworkInfo_Capability_Type_MULTI_ROLE;
const int FrameworkInfo_Capability_Type_Type_ARRAYSIZE = FrameworkInfo_Capability_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* FrameworkInfo_Capability_Type_descriptor();
inline const ::std::string& FrameworkInfo_Capability_Type_Name(FrameworkInfo_Capability_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    FrameworkInfo_Capability_Type_descriptor(), value);
}
inline bool FrameworkInfo_Capability_Type_Parse(
    const ::std::string& name, FrameworkInfo_Capability_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FrameworkInfo_Capability_Type>(
    FrameworkInfo_Capability_Type_descriptor(), name, value);
}
enum CheckInfo_Type {
  CheckInfo_Type_UNKNOWN = 0,
  CheckInfo_Type_COMMAND = 1,
  CheckInfo_Type_HTTP = 2,
  CheckInfo_Type_TCP = 3
};
bool CheckInfo_Type_IsValid(int value);
const CheckInfo_Type CheckInfo_Type_Type_MIN = CheckInfo_Type_UNKNOWN;
const CheckInfo_Type CheckInfo_Type_Type_MAX = CheckInfo_Type_TCP;
const int CheckInfo_Type_Type_ARRAYSIZE = CheckInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CheckInfo_Type_descriptor();
inline const ::std::string& CheckInfo_Type_Name(CheckInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CheckInfo_Type_descriptor(), value);
}
inline bool CheckInfo_Type_Parse(
    const ::std::string& name, CheckInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CheckInfo_Type>(
    CheckInfo_Type_descriptor(), name, value);
}
enum HealthCheck_Type {
  HealthCheck_Type_UNKNOWN = 0,
  HealthCheck_Type_COMMAND = 1,
  HealthCheck_Type_HTTP = 2,
  HealthCheck_Type_TCP = 3
};
bool HealthCheck_Type_IsValid(int value);
const HealthCheck_Type HealthCheck_Type_Type_MIN = HealthCheck_Type_UNKNOWN;
const HealthCheck_Type HealthCheck_Type_Type_MAX = HealthCheck_Type_TCP;
const int HealthCheck_Type_Type_ARRAYSIZE = HealthCheck_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* HealthCheck_Type_descriptor();
inline const ::std::string& HealthCheck_Type_Name(HealthCheck_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    HealthCheck_Type_descriptor(), value);
}
inline bool HealthCheck_Type_Parse(
    const ::std::string& name, HealthCheck_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HealthCheck_Type>(
    HealthCheck_Type_descriptor(), name, value);
}
enum ExecutorInfo_Type {
  ExecutorInfo_Type_UNKNOWN = 0,
  ExecutorInfo_Type_DEFAULT = 1,
  ExecutorInfo_Type_CUSTOM = 2
};
bool ExecutorInfo_Type_IsValid(int value);
const ExecutorInfo_Type ExecutorInfo_Type_Type_MIN = ExecutorInfo_Type_UNKNOWN;
const ExecutorInfo_Type ExecutorInfo_Type_Type_MAX = ExecutorInfo_Type_CUSTOM;
const int ExecutorInfo_Type_Type_ARRAYSIZE = ExecutorInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecutorInfo_Type_descriptor();
inline const ::std::string& ExecutorInfo_Type_Name(ExecutorInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecutorInfo_Type_descriptor(), value);
}
inline bool ExecutorInfo_Type_Parse(
    const ::std::string& name, ExecutorInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecutorInfo_Type>(
    ExecutorInfo_Type_descriptor(), name, value);
}
enum SlaveInfo_Capability_Type {
  SlaveInfo_Capability_Type_UNKNOWN = 0,
  SlaveInfo_Capability_Type_MULTI_ROLE = 1
};
bool SlaveInfo_Capability_Type_IsValid(int value);
const SlaveInfo_Capability_Type SlaveInfo_Capability_Type_Type_MIN = SlaveInfo_Capability_Type_UNKNOWN;
const SlaveInfo_Capability_Type SlaveInfo_Capability_Type_Type_MAX = SlaveInfo_Capability_Type_MULTI_ROLE;
const int SlaveInfo_Capability_Type_Type_ARRAYSIZE = SlaveInfo_Capability_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveInfo_Capability_Type_descriptor();
inline const ::std::string& SlaveInfo_Capability_Type_Name(SlaveInfo_Capability_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveInfo_Capability_Type_descriptor(), value);
}
inline bool SlaveInfo_Capability_Type_Parse(
    const ::std::string& name, SlaveInfo_Capability_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveInfo_Capability_Type>(
    SlaveInfo_Capability_Type_descriptor(), name, value);
}
enum Value_Type {
  Value_Type_SCALAR = 0,
  Value_Type_RANGES = 1,
  Value_Type_SET = 2,
  Value_Type_TEXT = 3
};
bool Value_Type_IsValid(int value);
const Value_Type Value_Type_Type_MIN = Value_Type_SCALAR;
const Value_Type Value_Type_Type_MAX = Value_Type_TEXT;
const int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor();
inline const ::std::string& Value_Type_Name(Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Value_Type_descriptor(), value);
}
inline bool Value_Type_Parse(
    const ::std::string& name, Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Value_Type>(
    Value_Type_descriptor(), name, value);
}
enum Resource_DiskInfo_Source_Type {
  Resource_DiskInfo_Source_Type_UNKNOWN = 0,
  Resource_DiskInfo_Source_Type_PATH = 1,
  Resource_DiskInfo_Source_Type_MOUNT = 2
};
bool Resource_DiskInfo_Source_Type_IsValid(int value);
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source_Type_Type_MIN = Resource_DiskInfo_Source_Type_UNKNOWN;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source_Type_Type_MAX = Resource_DiskInfo_Source_Type_MOUNT;
const int Resource_DiskInfo_Source_Type_Type_ARRAYSIZE = Resource_DiskInfo_Source_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Resource_DiskInfo_Source_Type_descriptor();
inline const ::std::string& Resource_DiskInfo_Source_Type_Name(Resource_DiskInfo_Source_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Resource_DiskInfo_Source_Type_descriptor(), value);
}
inline bool Resource_DiskInfo_Source_Type_Parse(
    const ::std::string& name, Resource_DiskInfo_Source_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Resource_DiskInfo_Source_Type>(
    Resource_DiskInfo_Source_Type_descriptor(), name, value);
}
enum Offer_Operation_Type {
  Offer_Operation_Type_UNKNOWN = 0,
  Offer_Operation_Type_LAUNCH = 1,
  Offer_Operation_Type_LAUNCH_GROUP = 6,
  Offer_Operation_Type_RESERVE = 2,
  Offer_Operation_Type_UNRESERVE = 3,
  Offer_Operation_Type_CREATE = 4,
  Offer_Operation_Type_DESTROY = 5
};
bool Offer_Operation_Type_IsValid(int value);
const Offer_Operation_Type Offer_Operation_Type_Type_MIN = Offer_Operation_Type_UNKNOWN;
const Offer_Operation_Type Offer_Operation_Type_Type_MAX = Offer_Operation_Type_LAUNCH_GROUP;
const int Offer_Operation_Type_Type_ARRAYSIZE = Offer_Operation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor();
inline const ::std::string& Offer_Operation_Type_Name(Offer_Operation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Offer_Operation_Type_descriptor(), value);
}
inline bool Offer_Operation_Type_Parse(
    const ::std::string& name, Offer_Operation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Offer_Operation_Type>(
    Offer_Operation_Type_descriptor(), name, value);
}
enum TaskStatus_Source {
  TaskStatus_Source_SOURCE_MASTER = 0,
  TaskStatus_Source_SOURCE_SLAVE = 1,
  TaskStatus_Source_SOURCE_EXECUTOR = 2
};
bool TaskStatus_Source_IsValid(int value);
const TaskStatus_Source TaskStatus_Source_Source_MIN = TaskStatus_Source_SOURCE_MASTER;
const TaskStatus_Source TaskStatus_Source_Source_MAX = TaskStatus_Source_SOURCE_EXECUTOR;
const int TaskStatus_Source_Source_ARRAYSIZE = TaskStatus_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor();
inline const ::std::string& TaskStatus_Source_Name(TaskStatus_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_Source_descriptor(), value);
}
inline bool TaskStatus_Source_Parse(
    const ::std::string& name, TaskStatus_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus_Source>(
    TaskStatus_Source_descriptor(), name, value);
}
enum TaskStatus_Reason {
  TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED = 0,
  TaskStatus_Reason_REASON_CONTAINER_LAUNCH_FAILED = 21,
  TaskStatus_Reason_REASON_CONTAINER_LIMITATION = 19,
  TaskStatus_Reason_REASON_CONTAINER_LIMITATION_DISK = 20,
  TaskStatus_Reason_REASON_CONTAINER_LIMITATION_MEMORY = 8,
  TaskStatus_Reason_REASON_CONTAINER_PREEMPTED = 17,
  TaskStatus_Reason_REASON_CONTAINER_UPDATE_FAILED = 22,
  TaskStatus_Reason_REASON_EXECUTOR_REGISTRATION_TIMEOUT = 23,
  TaskStatus_Reason_REASON_EXECUTOR_REREGISTRATION_TIMEOUT = 24,
  TaskStatus_Reason_REASON_EXECUTOR_TERMINATED = 1,
  TaskStatus_Reason_REASON_EXECUTOR_UNREGISTERED = 2,
  TaskStatus_Reason_REASON_FRAMEWORK_REMOVED = 3,
  TaskStatus_Reason_REASON_GC_ERROR = 4,
  TaskStatus_Reason_REASON_INVALID_FRAMEWORKID = 5,
  TaskStatus_Reason_REASON_INVALID_OFFERS = 6,
  TaskStatus_Reason_REASON_IO_SWITCHBOARD_EXITED = 27,
  TaskStatus_Reason_REASON_MASTER_DISCONNECTED = 7,
  TaskStatus_Reason_REASON_RECONCILIATION = 9,
  TaskStatus_Reason_REASON_RESOURCES_UNKNOWN = 18,
  TaskStatus_Reason_REASON_SLAVE_DISCONNECTED = 10,
  TaskStatus_Reason_REASON_SLAVE_REMOVED = 11,
  TaskStatus_Reason_REASON_SLAVE_RESTARTED = 12,
  TaskStatus_Reason_REASON_SLAVE_UNKNOWN = 13,
  TaskStatus_Reason_REASON_TASK_KILLED_DURING_LAUNCH = 30,
  TaskStatus_Reason_REASON_TASK_CHECK_STATUS_UPDATED = 28,
  TaskStatus_Reason_REASON_TASK_GROUP_INVALID = 25,
  TaskStatus_Reason_REASON_TASK_GROUP_UNAUTHORIZED = 26,
  TaskStatus_Reason_REASON_TASK_INVALID = 14,
  TaskStatus_Reason_REASON_TASK_UNAUTHORIZED = 15,
  TaskStatus_Reason_REASON_TASK_UNKNOWN = 16
};
bool TaskStatus_Reason_IsValid(int value);
const TaskStatus_Reason TaskStatus_Reason_Reason_MIN = TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED;
const TaskStatus_Reason TaskStatus_Reason_Reason_MAX = TaskStatus_Reason_REASON_TASK_KILLED_DURING_LAUNCH;
const int TaskStatus_Reason_Reason_ARRAYSIZE = TaskStatus_Reason_Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor();
inline const ::std::string& TaskStatus_Reason_Name(TaskStatus_Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_Reason_descriptor(), value);
}
inline bool TaskStatus_Reason_Parse(
    const ::std::string& name, TaskStatus_Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus_Reason>(
    TaskStatus_Reason_descriptor(), name, value);
}
enum Environment_Variable_Type {
  Environment_Variable_Type_UNKNOWN = 0,
  Environment_Variable_Type_VALUE = 1,
  Environment_Variable_Type_SECRET = 2
};
bool Environment_Variable_Type_IsValid(int value);
const Environment_Variable_Type Environment_Variable_Type_Type_MIN = Environment_Variable_Type_UNKNOWN;
const Environment_Variable_Type Environment_Variable_Type_Type_MAX = Environment_Variable_Type_SECRET;
const int Environment_Variable_Type_Type_ARRAYSIZE = Environment_Variable_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Environment_Variable_Type_descriptor();
inline const ::std::string& Environment_Variable_Type_Name(Environment_Variable_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Environment_Variable_Type_descriptor(), value);
}
inline bool Environment_Variable_Type_Parse(
    const ::std::string& name, Environment_Variable_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Environment_Variable_Type>(
    Environment_Variable_Type_descriptor(), name, value);
}
enum Secret_Type {
  Secret_Type_UNKNOWN = 0,
  Secret_Type_REFERENCE = 1,
  Secret_Type_VALUE = 2
};
bool Secret_Type_IsValid(int value);
const Secret_Type Secret_Type_Type_MIN = Secret_Type_UNKNOWN;
const Secret_Type Secret_Type_Type_MAX = Secret_Type_VALUE;
const int Secret_Type_Type_ARRAYSIZE = Secret_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Secret_Type_descriptor();
inline const ::std::string& Secret_Type_Name(Secret_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Secret_Type_descriptor(), value);
}
inline bool Secret_Type_Parse(
    const ::std::string& name, Secret_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Secret_Type>(
    Secret_Type_descriptor(), name, value);
}
enum Image_Type {
  Image_Type_APPC = 1,
  Image_Type_DOCKER = 2
};
bool Image_Type_IsValid(int value);
const Image_Type Image_Type_Type_MIN = Image_Type_APPC;
const Image_Type Image_Type_Type_MAX = Image_Type_DOCKER;
const int Image_Type_Type_ARRAYSIZE = Image_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Image_Type_descriptor();
inline const ::std::string& Image_Type_Name(Image_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Image_Type_descriptor(), value);
}
inline bool Image_Type_Parse(
    const ::std::string& name, Image_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Image_Type>(
    Image_Type_descriptor(), name, value);
}
enum Volume_Source_SandboxPath_Type {
  Volume_Source_SandboxPath_Type_UNKNOWN = 0,
  Volume_Source_SandboxPath_Type_SELF = 1,
  Volume_Source_SandboxPath_Type_PARENT = 2
};
bool Volume_Source_SandboxPath_Type_IsValid(int value);
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath_Type_Type_MIN = Volume_Source_SandboxPath_Type_UNKNOWN;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath_Type_Type_MAX = Volume_Source_SandboxPath_Type_PARENT;
const int Volume_Source_SandboxPath_Type_Type_ARRAYSIZE = Volume_Source_SandboxPath_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Source_SandboxPath_Type_descriptor();
inline const ::std::string& Volume_Source_SandboxPath_Type_Name(Volume_Source_SandboxPath_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Source_SandboxPath_Type_descriptor(), value);
}
inline bool Volume_Source_SandboxPath_Type_Parse(
    const ::std::string& name, Volume_Source_SandboxPath_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Source_SandboxPath_Type>(
    Volume_Source_SandboxPath_Type_descriptor(), name, value);
}
enum Volume_Source_Type {
  Volume_Source_Type_UNKNOWN = 0,
  Volume_Source_Type_DOCKER_VOLUME = 1,
  Volume_Source_Type_SANDBOX_PATH = 2,
  Volume_Source_Type_SECRET = 3
};
bool Volume_Source_Type_IsValid(int value);
const Volume_Source_Type Volume_Source_Type_Type_MIN = Volume_Source_Type_UNKNOWN;
const Volume_Source_Type Volume_Source_Type_Type_MAX = Volume_Source_Type_SECRET;
const int Volume_Source_Type_Type_ARRAYSIZE = Volume_Source_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Source_Type_descriptor();
inline const ::std::string& Volume_Source_Type_Name(Volume_Source_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Source_Type_descriptor(), value);
}
inline bool Volume_Source_Type_Parse(
    const ::std::string& name, Volume_Source_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Source_Type>(
    Volume_Source_Type_descriptor(), name, value);
}
enum Volume_Mode {
  Volume_Mode_RW = 1,
  Volume_Mode_RO = 2
};
bool Volume_Mode_IsValid(int value);
const Volume_Mode Volume_Mode_Mode_MIN = Volume_Mode_RW;
const Volume_Mode Volume_Mode_Mode_MAX = Volume_Mode_RO;
const int Volume_Mode_Mode_ARRAYSIZE = Volume_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor();
inline const ::std::string& Volume_Mode_Name(Volume_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Volume_Mode_descriptor(), value);
}
inline bool Volume_Mode_Parse(
    const ::std::string& name, Volume_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Volume_Mode>(
    Volume_Mode_descriptor(), name, value);
}
enum NetworkInfo_Protocol {
  NetworkInfo_Protocol_IPv4 = 1,
  NetworkInfo_Protocol_IPv6 = 2
};
bool NetworkInfo_Protocol_IsValid(int value);
const NetworkInfo_Protocol NetworkInfo_Protocol_Protocol_MIN = NetworkInfo_Protocol_IPv4;
const NetworkInfo_Protocol NetworkInfo_Protocol_Protocol_MAX = NetworkInfo_Protocol_IPv6;
const int NetworkInfo_Protocol_Protocol_ARRAYSIZE = NetworkInfo_Protocol_Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkInfo_Protocol_descriptor();
inline const ::std::string& NetworkInfo_Protocol_Name(NetworkInfo_Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkInfo_Protocol_descriptor(), value);
}
inline bool NetworkInfo_Protocol_Parse(
    const ::std::string& name, NetworkInfo_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkInfo_Protocol>(
    NetworkInfo_Protocol_descriptor(), name, value);
}
enum CapabilityInfo_Capability {
  CapabilityInfo_Capability_UNKNOWN = 0,
  CapabilityInfo_Capability_CHOWN = 1000,
  CapabilityInfo_Capability_DAC_OVERRIDE = 1001,
  CapabilityInfo_Capability_DAC_READ_SEARCH = 1002,
  CapabilityInfo_Capability_FOWNER = 1003,
  CapabilityInfo_Capability_FSETID = 1004,
  CapabilityInfo_Capability_KILL = 1005,
  CapabilityInfo_Capability_SETGID = 1006,
  CapabilityInfo_Capability_SETUID = 1007,
  CapabilityInfo_Capability_SETPCAP = 1008,
  CapabilityInfo_Capability_LINUX_IMMUTABLE = 1009,
  CapabilityInfo_Capability_NET_BIND_SERVICE = 1010,
  CapabilityInfo_Capability_NET_BROADCAST = 1011,
  CapabilityInfo_Capability_NET_ADMIN = 1012,
  CapabilityInfo_Capability_NET_RAW = 1013,
  CapabilityInfo_Capability_IPC_LOCK = 1014,
  CapabilityInfo_Capability_IPC_OWNER = 1015,
  CapabilityInfo_Capability_SYS_MODULE = 1016,
  CapabilityInfo_Capability_SYS_RAWIO = 1017,
  CapabilityInfo_Capability_SYS_CHROOT = 1018,
  CapabilityInfo_Capability_SYS_PTRACE = 1019,
  CapabilityInfo_Capability_SYS_PACCT = 1020,
  CapabilityInfo_Capability_SYS_ADMIN = 1021,
  CapabilityInfo_Capability_SYS_BOOT = 1022,
  CapabilityInfo_Capability_SYS_NICE = 1023,
  CapabilityInfo_Capability_SYS_RESOURCE = 1024,
  CapabilityInfo_Capability_SYS_TIME = 1025,
  CapabilityInfo_Capability_SYS_TTY_CONFIG = 1026,
  CapabilityInfo_Capability_MKNOD = 1027,
  CapabilityInfo_Capability_LEASE = 1028,
  CapabilityInfo_Capability_AUDIT_WRITE = 1029,
  CapabilityInfo_Capability_AUDIT_CONTROL = 1030,
  CapabilityInfo_Capability_SETFCAP = 1031,
  CapabilityInfo_Capability_MAC_OVERRIDE = 1032,
  CapabilityInfo_Capability_MAC_ADMIN = 1033,
  CapabilityInfo_Capability_SYSLOG = 1034,
  CapabilityInfo_Capability_WAKE_ALARM = 1035,
  CapabilityInfo_Capability_BLOCK_SUSPEND = 1036,
  CapabilityInfo_Capability_AUDIT_READ = 1037
};
bool CapabilityInfo_Capability_IsValid(int value);
const CapabilityInfo_Capability CapabilityInfo_Capability_Capability_MIN = CapabilityInfo_Capability_UNKNOWN;
const CapabilityInfo_Capability CapabilityInfo_Capability_Capability_MAX = CapabilityInfo_Capability_AUDIT_READ;
const int CapabilityInfo_Capability_Capability_ARRAYSIZE = CapabilityInfo_Capability_Capability_MAX + 1;

const ::google::protobuf::EnumDescriptor* CapabilityInfo_Capability_descriptor();
inline const ::std::string& CapabilityInfo_Capability_Name(CapabilityInfo_Capability value) {
  return ::google::protobuf::internal::NameOfEnum(
    CapabilityInfo_Capability_descriptor(), value);
}
inline bool CapabilityInfo_Capability_Parse(
    const ::std::string& name, CapabilityInfo_Capability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CapabilityInfo_Capability>(
    CapabilityInfo_Capability_descriptor(), name, value);
}
enum RLimitInfo_RLimit_Type {
  RLimitInfo_RLimit_Type_UNKNOWN = 0,
  RLimitInfo_RLimit_Type_RLMT_AS = 1,
  RLimitInfo_RLimit_Type_RLMT_CORE = 2,
  RLimitInfo_RLimit_Type_RLMT_CPU = 3,
  RLimitInfo_RLimit_Type_RLMT_DATA = 4,
  RLimitInfo_RLimit_Type_RLMT_FSIZE = 5,
  RLimitInfo_RLimit_Type_RLMT_LOCKS = 6,
  RLimitInfo_RLimit_Type_RLMT_MEMLOCK = 7,
  RLimitInfo_RLimit_Type_RLMT_MSGQUEUE = 8,
  RLimitInfo_RLimit_Type_RLMT_NICE = 9,
  RLimitInfo_RLimit_Type_RLMT_NOFILE = 10,
  RLimitInfo_RLimit_Type_RLMT_NPROC = 11,
  RLimitInfo_RLimit_Type_RLMT_RSS = 12,
  RLimitInfo_RLimit_Type_RLMT_RTPRIO = 13,
  RLimitInfo_RLimit_Type_RLMT_RTTIME = 14,
  RLimitInfo_RLimit_Type_RLMT_SIGPENDING = 15,
  RLimitInfo_RLimit_Type_RLMT_STACK = 16
};
bool RLimitInfo_RLimit_Type_IsValid(int value);
const RLimitInfo_RLimit_Type RLimitInfo_RLimit_Type_Type_MIN = RLimitInfo_RLimit_Type_UNKNOWN;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit_Type_Type_MAX = RLimitInfo_RLimit_Type_RLMT_STACK;
const int RLimitInfo_RLimit_Type_Type_ARRAYSIZE = RLimitInfo_RLimit_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RLimitInfo_RLimit_Type_descriptor();
inline const ::std::string& RLimitInfo_RLimit_Type_Name(RLimitInfo_RLimit_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RLimitInfo_RLimit_Type_descriptor(), value);
}
inline bool RLimitInfo_RLimit_Type_Parse(
    const ::std::string& name, RLimitInfo_RLimit_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RLimitInfo_RLimit_Type>(
    RLimitInfo_RLimit_Type_descriptor(), name, value);
}
enum ContainerInfo_DockerInfo_Network {
  ContainerInfo_DockerInfo_Network_HOST = 1,
  ContainerInfo_DockerInfo_Network_BRIDGE = 2,
  ContainerInfo_DockerInfo_Network_NONE = 3,
  ContainerInfo_DockerInfo_Network_USER = 4
};
bool ContainerInfo_DockerInfo_Network_IsValid(int value);
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network_Network_MIN = ContainerInfo_DockerInfo_Network_HOST;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network_Network_MAX = ContainerInfo_DockerInfo_Network_USER;
const int ContainerInfo_DockerInfo_Network_Network_ARRAYSIZE = ContainerInfo_DockerInfo_Network_Network_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor();
inline const ::std::string& ContainerInfo_DockerInfo_Network_Name(ContainerInfo_DockerInfo_Network value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerInfo_DockerInfo_Network_descriptor(), value);
}
inline bool ContainerInfo_DockerInfo_Network_Parse(
    const ::std::string& name, ContainerInfo_DockerInfo_Network* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerInfo_DockerInfo_Network>(
    ContainerInfo_DockerInfo_Network_descriptor(), name, value);
}
enum ContainerInfo_Type {
  ContainerInfo_Type_DOCKER = 1,
  ContainerInfo_Type_MESOS = 2
};
bool ContainerInfo_Type_IsValid(int value);
const ContainerInfo_Type ContainerInfo_Type_Type_MIN = ContainerInfo_Type_DOCKER;
const ContainerInfo_Type ContainerInfo_Type_Type_MAX = ContainerInfo_Type_MESOS;
const int ContainerInfo_Type_Type_ARRAYSIZE = ContainerInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor();
inline const ::std::string& ContainerInfo_Type_Name(ContainerInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerInfo_Type_descriptor(), value);
}
inline bool ContainerInfo_Type_Parse(
    const ::std::string& name, ContainerInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerInfo_Type>(
    ContainerInfo_Type_descriptor(), name, value);
}
enum DiscoveryInfo_Visibility {
  DiscoveryInfo_Visibility_FRAMEWORK = 0,
  DiscoveryInfo_Visibility_CLUSTER = 1,
  DiscoveryInfo_Visibility_EXTERNAL = 2
};
bool DiscoveryInfo_Visibility_IsValid(int value);
const DiscoveryInfo_Visibility DiscoveryInfo_Visibility_Visibility_MIN = DiscoveryInfo_Visibility_FRAMEWORK;
const DiscoveryInfo_Visibility DiscoveryInfo_Visibility_Visibility_MAX = DiscoveryInfo_Visibility_EXTERNAL;
const int DiscoveryInfo_Visibility_Visibility_ARRAYSIZE = DiscoveryInfo_Visibility_Visibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor();
inline const ::std::string& DiscoveryInfo_Visibility_Name(DiscoveryInfo_Visibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscoveryInfo_Visibility_descriptor(), value);
}
inline bool DiscoveryInfo_Visibility_Parse(
    const ::std::string& name, DiscoveryInfo_Visibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscoveryInfo_Visibility>(
    DiscoveryInfo_Visibility_descriptor(), name, value);
}
enum Status {
  DRIVER_NOT_STARTED = 1,
  DRIVER_RUNNING = 2,
  DRIVER_ABORTED = 3,
  DRIVER_STOPPED = 4
};
bool Status_IsValid(int value);
const Status Status_MIN = DRIVER_NOT_STARTED;
const Status Status_MAX = DRIVER_STOPPED;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum TaskState {
  TASK_STAGING = 6,
  TASK_STARTING = 0,
  TASK_RUNNING = 1,
  TASK_KILLING = 8,
  TASK_FINISHED = 2,
  TASK_FAILED = 3,
  TASK_KILLED = 4,
  TASK_ERROR = 7,
  TASK_LOST = 5,
  TASK_DROPPED = 9,
  TASK_UNREACHABLE = 10,
  TASK_GONE = 11,
  TASK_GONE_BY_OPERATOR = 12,
  TASK_UNKNOWN = 13
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_STARTING;
const TaskState TaskState_MAX = TASK_UNKNOWN;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
// ===================================================================

class FrameworkID : public ::google::protobuf::Message {
 public:
  FrameworkID();
  virtual ~FrameworkID();

  FrameworkID(const FrameworkID& from);

  inline FrameworkID& operator=(const FrameworkID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkID& default_instance();

  void Swap(FrameworkID* other);

  // implements Message ----------------------------------------------

  FrameworkID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkID& from);
  void MergeFrom(const FrameworkID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkID* default_instance_;
};
// -------------------------------------------------------------------

class OfferID : public ::google::protobuf::Message {
 public:
  OfferID();
  virtual ~OfferID();

  OfferID(const OfferID& from);

  inline OfferID& operator=(const OfferID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferID& default_instance();

  void Swap(OfferID* other);

  // implements Message ----------------------------------------------

  OfferID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferID& from);
  void MergeFrom(const OfferID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.OfferID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static OfferID* default_instance_;
};
// -------------------------------------------------------------------

class SlaveID : public ::google::protobuf::Message {
 public:
  SlaveID();
  virtual ~SlaveID();

  SlaveID(const SlaveID& from);

  inline SlaveID& operator=(const SlaveID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveID& default_instance();

  void Swap(SlaveID* other);

  // implements Message ----------------------------------------------

  SlaveID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveID& from);
  void MergeFrom(const SlaveID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveID* default_instance_;
};
// -------------------------------------------------------------------

class TaskID : public ::google::protobuf::Message {
 public:
  TaskID();
  virtual ~TaskID();

  TaskID(const TaskID& from);

  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskID& default_instance();

  void Swap(TaskID* other);

  // implements Message ----------------------------------------------

  TaskID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskID& from);
  void MergeFrom(const TaskID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.TaskID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskID* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorID : public ::google::protobuf::Message {
 public:
  ExecutorID();
  virtual ~ExecutorID();

  ExecutorID(const ExecutorID& from);

  inline ExecutorID& operator=(const ExecutorID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorID& default_instance();

  void Swap(ExecutorID* other);

  // implements Message ----------------------------------------------

  ExecutorID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorID& from);
  void MergeFrom(const ExecutorID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ExecutorID* default_instance_;
};
// -------------------------------------------------------------------

class ContainerID : public ::google::protobuf::Message {
 public:
  ContainerID();
  virtual ~ContainerID();

  ContainerID(const ContainerID& from);

  inline ContainerID& operator=(const ContainerID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerID& default_instance();

  void Swap(ContainerID* other);

  // implements Message ----------------------------------------------

  ContainerID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerID& from);
  void MergeFrom(const ContainerID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .mesos.ContainerID parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline const ::mesos::ContainerID& parent() const;
  inline ::mesos::ContainerID* mutable_parent();
  inline ::mesos::ContainerID* release_parent();
  inline void set_allocated_parent(::mesos::ContainerID* parent);

  // @@protoc_insertion_point(class_scope:mesos.ContainerID)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::mesos::ContainerID* parent_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerID* default_instance_;
};
// -------------------------------------------------------------------

class ResourceProviderID : public ::google::protobuf::Message {
 public:
  ResourceProviderID();
  virtual ~ResourceProviderID();

  ResourceProviderID(const ResourceProviderID& from);

  inline ResourceProviderID& operator=(const ResourceProviderID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceProviderID& default_instance();

  void Swap(ResourceProviderID* other);

  // implements Message ----------------------------------------------

  ResourceProviderID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceProviderID& from);
  void MergeFrom(const ResourceProviderID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ResourceProviderID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceProviderID* default_instance_;
};
// -------------------------------------------------------------------

class TimeInfo : public ::google::protobuf::Message {
 public:
  TimeInfo();
  virtual ~TimeInfo();

  TimeInfo(const TimeInfo& from);

  inline TimeInfo& operator=(const TimeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeInfo& default_instance();

  void Swap(TimeInfo* other);

  // implements Message ----------------------------------------------

  TimeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeInfo& from);
  void MergeFrom(const TimeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 nanoseconds = 1;
  inline bool has_nanoseconds() const;
  inline void clear_nanoseconds();
  static const int kNanosecondsFieldNumber = 1;
  inline ::google::protobuf::int64 nanoseconds() const;
  inline void set_nanoseconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.TimeInfo)
 private:
  inline void set_has_nanoseconds();
  inline void clear_has_nanoseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 nanoseconds_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TimeInfo* default_instance_;
};
// -------------------------------------------------------------------

class DurationInfo : public ::google::protobuf::Message {
 public:
  DurationInfo();
  virtual ~DurationInfo();

  DurationInfo(const DurationInfo& from);

  inline DurationInfo& operator=(const DurationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DurationInfo& default_instance();

  void Swap(DurationInfo* other);

  // implements Message ----------------------------------------------

  DurationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DurationInfo& from);
  void MergeFrom(const DurationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 nanoseconds = 1;
  inline bool has_nanoseconds() const;
  inline void clear_nanoseconds();
  static const int kNanosecondsFieldNumber = 1;
  inline ::google::protobuf::int64 nanoseconds() const;
  inline void set_nanoseconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.DurationInfo)
 private:
  inline void set_has_nanoseconds();
  inline void clear_has_nanoseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 nanoseconds_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static DurationInfo* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.Address)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hostname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class URL : public ::google::protobuf::Message {
 public:
  URL();
  virtual ~URL();

  URL(const URL& from);

  inline URL& operator=(const URL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const URL& default_instance();

  void Swap(URL* other);

  // implements Message ----------------------------------------------

  URL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const URL& from);
  void MergeFrom(const URL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string scheme = 1;
  inline bool has_scheme() const;
  inline void clear_scheme();
  static const int kSchemeFieldNumber = 1;
  inline const ::std::string& scheme() const;
  inline void set_scheme(const ::std::string& value);
  inline void set_scheme(const char* value);
  inline void set_scheme(const char* value, size_t size);
  inline ::std::string* mutable_scheme();
  inline ::std::string* release_scheme();
  inline void set_allocated_scheme(::std::string* scheme);

  // required .mesos.Address address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::mesos::Address& address() const;
  inline ::mesos::Address* mutable_address();
  inline ::mesos::Address* release_address();
  inline void set_allocated_address(::mesos::Address* address);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated .mesos.Parameter query = 4;
  inline int query_size() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 4;
  inline const ::mesos::Parameter& query(int index) const;
  inline ::mesos::Parameter* mutable_query(int index);
  inline ::mesos::Parameter* add_query();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      query() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_query();

  // optional string fragment = 5;
  inline bool has_fragment() const;
  inline void clear_fragment();
  static const int kFragmentFieldNumber = 5;
  inline const ::std::string& fragment() const;
  inline void set_fragment(const ::std::string& value);
  inline void set_fragment(const char* value);
  inline void set_fragment(const char* value, size_t size);
  inline ::std::string* mutable_fragment();
  inline ::std::string* release_fragment();
  inline void set_allocated_fragment(::std::string* fragment);

  // @@protoc_insertion_point(class_scope:mesos.URL)
 private:
  inline void set_has_scheme();
  inline void clear_has_scheme();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_fragment();
  inline void clear_has_fragment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* scheme_;
  ::mesos::Address* address_;
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > query_;
  ::std::string* fragment_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static URL* default_instance_;
};
// -------------------------------------------------------------------

class Unavailability : public ::google::protobuf::Message {
 public:
  Unavailability();
  virtual ~Unavailability();

  Unavailability(const Unavailability& from);

  inline Unavailability& operator=(const Unavailability& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Unavailability& default_instance();

  void Swap(Unavailability* other);

  // implements Message ----------------------------------------------

  Unavailability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Unavailability& from);
  void MergeFrom(const Unavailability& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TimeInfo start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::mesos::TimeInfo& start() const;
  inline ::mesos::TimeInfo* mutable_start();
  inline ::mesos::TimeInfo* release_start();
  inline void set_allocated_start(::mesos::TimeInfo* start);

  // optional .mesos.DurationInfo duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline const ::mesos::DurationInfo& duration() const;
  inline ::mesos::DurationInfo* mutable_duration();
  inline ::mesos::DurationInfo* release_duration();
  inline void set_allocated_duration(::mesos::DurationInfo* duration);

  // @@protoc_insertion_point(class_scope:mesos.Unavailability)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::TimeInfo* start_;
  ::mesos::DurationInfo* duration_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Unavailability* default_instance_;
};
// -------------------------------------------------------------------

class MachineID : public ::google::protobuf::Message {
 public:
  MachineID();
  virtual ~MachineID();

  MachineID(const MachineID& from);

  inline MachineID& operator=(const MachineID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineID& default_instance();

  void Swap(MachineID* other);

  // implements Message ----------------------------------------------

  MachineID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineID& from);
  void MergeFrom(const MachineID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:mesos.MachineID)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hostname_;
  ::std::string* ip_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static MachineID* default_instance_;
};
// -------------------------------------------------------------------

class MachineInfo : public ::google::protobuf::Message {
 public:
  MachineInfo();
  virtual ~MachineInfo();

  MachineInfo(const MachineInfo& from);

  inline MachineInfo& operator=(const MachineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInfo& default_instance();

  void Swap(MachineInfo* other);

  // implements Message ----------------------------------------------

  MachineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineInfo& from);
  void MergeFrom(const MachineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MachineInfo_Mode Mode;
  static const Mode UP = MachineInfo_Mode_UP;
  static const Mode DRAINING = MachineInfo_Mode_DRAINING;
  static const Mode DOWN = MachineInfo_Mode_DOWN;
  static inline bool Mode_IsValid(int value) {
    return MachineInfo_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MachineInfo_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MachineInfo_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MachineInfo_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MachineInfo_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MachineInfo_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MachineInfo_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.MachineID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::MachineID& id() const;
  inline ::mesos::MachineID* mutable_id();
  inline ::mesos::MachineID* release_id();
  inline void set_allocated_id(::mesos::MachineID* id);

  // optional .mesos.MachineInfo.Mode mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::mesos::MachineInfo_Mode mode() const;
  inline void set_mode(::mesos::MachineInfo_Mode value);

  // optional .mesos.Unavailability unavailability = 3;
  inline bool has_unavailability() const;
  inline void clear_unavailability();
  static const int kUnavailabilityFieldNumber = 3;
  inline const ::mesos::Unavailability& unavailability() const;
  inline ::mesos::Unavailability* mutable_unavailability();
  inline ::mesos::Unavailability* release_unavailability();
  inline void set_allocated_unavailability(::mesos::Unavailability* unavailability);

  // @@protoc_insertion_point(class_scope:mesos.MachineInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_unavailability();
  inline void clear_has_unavailability();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::MachineID* id_;
  ::mesos::Unavailability* unavailability_;
  int mode_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static MachineInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInfo_Capability : public ::google::protobuf::Message {
 public:
  FrameworkInfo_Capability();
  virtual ~FrameworkInfo_Capability();

  FrameworkInfo_Capability(const FrameworkInfo_Capability& from);

  inline FrameworkInfo_Capability& operator=(const FrameworkInfo_Capability& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo_Capability& default_instance();

  void Swap(FrameworkInfo_Capability* other);

  // implements Message ----------------------------------------------

  FrameworkInfo_Capability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInfo_Capability& from);
  void MergeFrom(const FrameworkInfo_Capability& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FrameworkInfo_Capability_Type Type;
  static const Type UNKNOWN = FrameworkInfo_Capability_Type_UNKNOWN;
  static const Type REVOCABLE_RESOURCES = FrameworkInfo_Capability_Type_REVOCABLE_RESOURCES;
  static const Type TASK_KILLING_STATE = FrameworkInfo_Capability_Type_TASK_KILLING_STATE;
  static const Type GPU_RESOURCES = FrameworkInfo_Capability_Type_GPU_RESOURCES;
  static const Type SHARED_RESOURCES = FrameworkInfo_Capability_Type_SHARED_RESOURCES;
  static const Type PARTITION_AWARE = FrameworkInfo_Capability_Type_PARTITION_AWARE;
  static const Type MULTI_ROLE = FrameworkInfo_Capability_Type_MULTI_ROLE;
  static inline bool Type_IsValid(int value) {
    return FrameworkInfo_Capability_Type_IsValid(value);
  }
  static const Type Type_MIN =
    FrameworkInfo_Capability_Type_Type_MIN;
  static const Type Type_MAX =
    FrameworkInfo_Capability_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    FrameworkInfo_Capability_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return FrameworkInfo_Capability_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return FrameworkInfo_Capability_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return FrameworkInfo_Capability_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::FrameworkInfo_Capability_Type type() const;
  inline void set_type(::mesos::FrameworkInfo_Capability_Type value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo.Capability)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInfo_Capability* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInfo : public ::google::protobuf::Message {
 public:
  FrameworkInfo();
  virtual ~FrameworkInfo();

  FrameworkInfo(const FrameworkInfo& from);

  inline FrameworkInfo& operator=(const FrameworkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo& default_instance();

  void Swap(FrameworkInfo* other);

  // implements Message ----------------------------------------------

  FrameworkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInfo& from);
  void MergeFrom(const FrameworkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FrameworkInfo_Capability Capability;

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mesos.FrameworkID id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& id() const;
  inline ::mesos::FrameworkID* mutable_id();
  inline ::mesos::FrameworkID* release_id();
  inline void set_allocated_id(::mesos::FrameworkID* id);

  // optional double failover_timeout = 4 [default = 0];
  inline bool has_failover_timeout() const;
  inline void clear_failover_timeout();
  static const int kFailoverTimeoutFieldNumber = 4;
  inline double failover_timeout() const;
  inline void set_failover_timeout(double value);

  // optional bool checkpoint = 5 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 5;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);

  // optional string role = 6 [default = "*", deprecated = true];
  inline bool has_role() const PROTOBUF_DEPRECATED;
  inline void clear_role() PROTOBUF_DEPRECATED;
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const PROTOBUF_DEPRECATED;
  inline void set_role(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_role(const char* value) PROTOBUF_DEPRECATED;
  inline void set_role(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_role() PROTOBUF_DEPRECATED;
  inline ::std::string* release_role() PROTOBUF_DEPRECATED;
  inline void set_allocated_role(::std::string* role) PROTOBUF_DEPRECATED;

  // repeated string roles = 12;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 12;
  inline const ::std::string& roles(int index) const;
  inline ::std::string* mutable_roles(int index);
  inline void set_roles(int index, const ::std::string& value);
  inline void set_roles(int index, const char* value);
  inline void set_roles(int index, const char* value, size_t size);
  inline ::std::string* add_roles();
  inline void add_roles(const ::std::string& value);
  inline void add_roles(const char* value);
  inline void add_roles(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // optional string hostname = 7;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 7;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string principal = 8;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 8;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional string webui_url = 9;
  inline bool has_webui_url() const;
  inline void clear_webui_url();
  static const int kWebuiUrlFieldNumber = 9;
  inline const ::std::string& webui_url() const;
  inline void set_webui_url(const ::std::string& value);
  inline void set_webui_url(const char* value);
  inline void set_webui_url(const char* value, size_t size);
  inline ::std::string* mutable_webui_url();
  inline ::std::string* release_webui_url();
  inline void set_allocated_webui_url(::std::string* webui_url);

  // repeated .mesos.FrameworkInfo.Capability capabilities = 10;
  inline int capabilities_size() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 10;
  inline const ::mesos::FrameworkInfo_Capability& capabilities(int index) const;
  inline ::mesos::FrameworkInfo_Capability* mutable_capabilities(int index);
  inline ::mesos::FrameworkInfo_Capability* add_capabilities();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >&
      capabilities() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >*
      mutable_capabilities();

  // optional .mesos.Labels labels = 11;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 11;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_failover_timeout();
  inline void clear_has_failover_timeout();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_webui_url();
  inline void clear_has_webui_url();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_;
  ::std::string* name_;
  ::mesos::FrameworkID* id_;
  double failover_timeout_;
  static ::std::string* _default_role_;
  ::std::string* role_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  ::std::string* hostname_;
  ::std::string* principal_;
  ::std::string* webui_url_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability > capabilities_;
  ::mesos::Labels* labels_;
  bool checkpoint_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInfo* default_instance_;
};
// -------------------------------------------------------------------

class CheckInfo_Command : public ::google::protobuf::Message {
 public:
  CheckInfo_Command();
  virtual ~CheckInfo_Command();

  CheckInfo_Command(const CheckInfo_Command& from);

  inline CheckInfo_Command& operator=(const CheckInfo_Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo_Command& default_instance();

  void Swap(CheckInfo_Command* other);

  // implements Message ----------------------------------------------

  CheckInfo_Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckInfo_Command& from);
  void MergeFrom(const CheckInfo_Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.CommandInfo command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo.Command)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::CommandInfo* command_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckInfo_Command* default_instance_;
};
// -------------------------------------------------------------------

class CheckInfo_Http : public ::google::protobuf::Message {
 public:
  CheckInfo_Http();
  virtual ~CheckInfo_Http();

  CheckInfo_Http(const CheckInfo_Http& from);

  inline CheckInfo_Http& operator=(const CheckInfo_Http& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo_Http& default_instance();

  void Swap(CheckInfo_Http* other);

  // implements Message ----------------------------------------------

  CheckInfo_Http* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckInfo_Http& from);
  void MergeFrom(const CheckInfo_Http& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo.Http)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckInfo_Http* default_instance_;
};
// -------------------------------------------------------------------

class CheckInfo_Tcp : public ::google::protobuf::Message {
 public:
  CheckInfo_Tcp();
  virtual ~CheckInfo_Tcp();

  CheckInfo_Tcp(const CheckInfo_Tcp& from);

  inline CheckInfo_Tcp& operator=(const CheckInfo_Tcp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo_Tcp& default_instance();

  void Swap(CheckInfo_Tcp* other);

  // implements Message ----------------------------------------------

  CheckInfo_Tcp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckInfo_Tcp& from);
  void MergeFrom(const CheckInfo_Tcp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo.Tcp)
 private:
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckInfo_Tcp* default_instance_;
};
// -------------------------------------------------------------------

class CheckInfo : public ::google::protobuf::Message {
 public:
  CheckInfo();
  virtual ~CheckInfo();

  CheckInfo(const CheckInfo& from);

  inline CheckInfo& operator=(const CheckInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckInfo& default_instance();

  void Swap(CheckInfo* other);

  // implements Message ----------------------------------------------

  CheckInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckInfo& from);
  void MergeFrom(const CheckInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CheckInfo_Command Command;
  typedef CheckInfo_Http Http;
  typedef CheckInfo_Tcp Tcp;

  typedef CheckInfo_Type Type;
  static const Type UNKNOWN = CheckInfo_Type_UNKNOWN;
  static const Type COMMAND = CheckInfo_Type_COMMAND;
  static const Type HTTP = CheckInfo_Type_HTTP;
  static const Type TCP = CheckInfo_Type_TCP;
  static inline bool Type_IsValid(int value) {
    return CheckInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CheckInfo_Type_Type_MIN;
  static const Type Type_MAX =
    CheckInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CheckInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return CheckInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return CheckInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return CheckInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.CheckInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::CheckInfo_Type type() const;
  inline void set_type(::mesos::CheckInfo_Type value);

  // optional .mesos.CheckInfo.Command command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::mesos::CheckInfo_Command& command() const;
  inline ::mesos::CheckInfo_Command* mutable_command();
  inline ::mesos::CheckInfo_Command* release_command();
  inline void set_allocated_command(::mesos::CheckInfo_Command* command);

  // optional .mesos.CheckInfo.Http http = 3;
  inline bool has_http() const;
  inline void clear_http();
  static const int kHttpFieldNumber = 3;
  inline const ::mesos::CheckInfo_Http& http() const;
  inline ::mesos::CheckInfo_Http* mutable_http();
  inline ::mesos::CheckInfo_Http* release_http();
  inline void set_allocated_http(::mesos::CheckInfo_Http* http);

  // optional .mesos.CheckInfo.Tcp tcp = 7;
  inline bool has_tcp() const;
  inline void clear_tcp();
  static const int kTcpFieldNumber = 7;
  inline const ::mesos::CheckInfo_Tcp& tcp() const;
  inline ::mesos::CheckInfo_Tcp* mutable_tcp();
  inline ::mesos::CheckInfo_Tcp* release_tcp();
  inline void set_allocated_tcp(::mesos::CheckInfo_Tcp* tcp);

  // optional double delay_seconds = 4 [default = 15];
  inline bool has_delay_seconds() const;
  inline void clear_delay_seconds();
  static const int kDelaySecondsFieldNumber = 4;
  inline double delay_seconds() const;
  inline void set_delay_seconds(double value);

  // optional double interval_seconds = 5 [default = 10];
  inline bool has_interval_seconds() const;
  inline void clear_interval_seconds();
  static const int kIntervalSecondsFieldNumber = 5;
  inline double interval_seconds() const;
  inline void set_interval_seconds(double value);

  // optional double timeout_seconds = 6 [default = 20];
  inline bool has_timeout_seconds() const;
  inline void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 6;
  inline double timeout_seconds() const;
  inline void set_timeout_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.CheckInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_tcp();
  inline void clear_has_tcp();
  inline void set_has_delay_seconds();
  inline void clear_has_delay_seconds();
  inline void set_has_interval_seconds();
  inline void clear_has_interval_seconds();
  inline void set_has_timeout_seconds();
  inline void clear_has_timeout_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::CheckInfo_Command* command_;
  ::mesos::CheckInfo_Http* http_;
  ::mesos::CheckInfo_Tcp* tcp_;
  double delay_seconds_;
  double interval_seconds_;
  double timeout_seconds_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckInfo* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck_HTTPCheckInfo : public ::google::protobuf::Message {
 public:
  HealthCheck_HTTPCheckInfo();
  virtual ~HealthCheck_HTTPCheckInfo();

  HealthCheck_HTTPCheckInfo(const HealthCheck_HTTPCheckInfo& from);

  inline HealthCheck_HTTPCheckInfo& operator=(const HealthCheck_HTTPCheckInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck_HTTPCheckInfo& default_instance();

  void Swap(HealthCheck_HTTPCheckInfo* other);

  // implements Message ----------------------------------------------

  HealthCheck_HTTPCheckInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck_HTTPCheckInfo& from);
  void MergeFrom(const HealthCheck_HTTPCheckInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string scheme = 3;
  inline bool has_scheme() const;
  inline void clear_scheme();
  static const int kSchemeFieldNumber = 3;
  inline const ::std::string& scheme() const;
  inline void set_scheme(const ::std::string& value);
  inline void set_scheme(const char* value);
  inline void set_scheme(const char* value, size_t size);
  inline ::std::string* mutable_scheme();
  inline ::std::string* release_scheme();
  inline void set_allocated_scheme(::std::string* scheme);

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated uint32 statuses = 4;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 4;
  inline ::google::protobuf::uint32 statuses(int index) const;
  inline void set_statuses(int index, ::google::protobuf::uint32 value);
  inline void add_statuses(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      statuses() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_statuses();

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck.HTTPCheckInfo)
 private:
  inline void set_has_scheme();
  inline void clear_has_scheme();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* scheme_;
  ::std::string* path_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > statuses_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck_HTTPCheckInfo* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck_TCPCheckInfo : public ::google::protobuf::Message {
 public:
  HealthCheck_TCPCheckInfo();
  virtual ~HealthCheck_TCPCheckInfo();

  HealthCheck_TCPCheckInfo(const HealthCheck_TCPCheckInfo& from);

  inline HealthCheck_TCPCheckInfo& operator=(const HealthCheck_TCPCheckInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck_TCPCheckInfo& default_instance();

  void Swap(HealthCheck_TCPCheckInfo* other);

  // implements Message ----------------------------------------------

  HealthCheck_TCPCheckInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck_TCPCheckInfo& from);
  void MergeFrom(const HealthCheck_TCPCheckInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck.TCPCheckInfo)
 private:
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck_TCPCheckInfo* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck : public ::google::protobuf::Message {
 public:
  HealthCheck();
  virtual ~HealthCheck();

  HealthCheck(const HealthCheck& from);

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck& default_instance();

  void Swap(HealthCheck* other);

  // implements Message ----------------------------------------------

  HealthCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck& from);
  void MergeFrom(const HealthCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HealthCheck_HTTPCheckInfo HTTPCheckInfo;
  typedef HealthCheck_TCPCheckInfo TCPCheckInfo;

  typedef HealthCheck_Type Type;
  static const Type UNKNOWN = HealthCheck_Type_UNKNOWN;
  static const Type COMMAND = HealthCheck_Type_COMMAND;
  static const Type HTTP = HealthCheck_Type_HTTP;
  static const Type TCP = HealthCheck_Type_TCP;
  static inline bool Type_IsValid(int value) {
    return HealthCheck_Type_IsValid(value);
  }
  static const Type Type_MIN =
    HealthCheck_Type_Type_MIN;
  static const Type Type_MAX =
    HealthCheck_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    HealthCheck_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return HealthCheck_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return HealthCheck_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return HealthCheck_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double delay_seconds = 2 [default = 15];
  inline bool has_delay_seconds() const;
  inline void clear_delay_seconds();
  static const int kDelaySecondsFieldNumber = 2;
  inline double delay_seconds() const;
  inline void set_delay_seconds(double value);

  // optional double interval_seconds = 3 [default = 10];
  inline bool has_interval_seconds() const;
  inline void clear_interval_seconds();
  static const int kIntervalSecondsFieldNumber = 3;
  inline double interval_seconds() const;
  inline void set_interval_seconds(double value);

  // optional double timeout_seconds = 4 [default = 20];
  inline bool has_timeout_seconds() const;
  inline void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 4;
  inline double timeout_seconds() const;
  inline void set_timeout_seconds(double value);

  // optional uint32 consecutive_failures = 5 [default = 3];
  inline bool has_consecutive_failures() const;
  inline void clear_consecutive_failures();
  static const int kConsecutiveFailuresFieldNumber = 5;
  inline ::google::protobuf::uint32 consecutive_failures() const;
  inline void set_consecutive_failures(::google::protobuf::uint32 value);

  // optional double grace_period_seconds = 6 [default = 10];
  inline bool has_grace_period_seconds() const;
  inline void clear_grace_period_seconds();
  static const int kGracePeriodSecondsFieldNumber = 6;
  inline double grace_period_seconds() const;
  inline void set_grace_period_seconds(double value);

  // optional .mesos.HealthCheck.Type type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::mesos::HealthCheck_Type type() const;
  inline void set_type(::mesos::HealthCheck_Type value);

  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
  inline bool has_http() const;
  inline void clear_http();
  static const int kHttpFieldNumber = 1;
  inline const ::mesos::HealthCheck_HTTPCheckInfo& http() const;
  inline ::mesos::HealthCheck_HTTPCheckInfo* mutable_http();
  inline ::mesos::HealthCheck_HTTPCheckInfo* release_http();
  inline void set_allocated_http(::mesos::HealthCheck_HTTPCheckInfo* http);

  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  inline bool has_tcp() const;
  inline void clear_tcp();
  static const int kTcpFieldNumber = 9;
  inline const ::mesos::HealthCheck_TCPCheckInfo& tcp() const;
  inline ::mesos::HealthCheck_TCPCheckInfo* mutable_tcp();
  inline ::mesos::HealthCheck_TCPCheckInfo* release_tcp();
  inline void set_allocated_tcp(::mesos::HealthCheck_TCPCheckInfo* tcp);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck)
 private:
  inline void set_has_delay_seconds();
  inline void clear_has_delay_seconds();
  inline void set_has_interval_seconds();
  inline void clear_has_interval_seconds();
  inline void set_has_timeout_seconds();
  inline void clear_has_timeout_seconds();
  inline void set_has_consecutive_failures();
  inline void clear_has_consecutive_failures();
  inline void set_has_grace_period_seconds();
  inline void clear_has_grace_period_seconds();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_tcp();
  inline void clear_has_tcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double delay_seconds_;
  double interval_seconds_;
  double timeout_seconds_;
  double grace_period_seconds_;
  ::google::protobuf::uint32 consecutive_failures_;
  int type_;
  ::mesos::CommandInfo* command_;
  ::mesos::HealthCheck_HTTPCheckInfo* http_;
  ::mesos::HealthCheck_TCPCheckInfo* tcp_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck* default_instance_;
};
// -------------------------------------------------------------------

class KillPolicy : public ::google::protobuf::Message {
 public:
  KillPolicy();
  virtual ~KillPolicy();

  KillPolicy(const KillPolicy& from);

  inline KillPolicy& operator=(const KillPolicy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KillPolicy& default_instance();

  void Swap(KillPolicy* other);

  // implements Message ----------------------------------------------

  KillPolicy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KillPolicy& from);
  void MergeFrom(const KillPolicy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.DurationInfo grace_period = 1;
  inline bool has_grace_period() const;
  inline void clear_grace_period();
  static const int kGracePeriodFieldNumber = 1;
  inline const ::mesos::DurationInfo& grace_period() const;
  inline ::mesos::DurationInfo* mutable_grace_period();
  inline ::mesos::DurationInfo* release_grace_period();
  inline void set_allocated_grace_period(::mesos::DurationInfo* grace_period);

  // @@protoc_insertion_point(class_scope:mesos.KillPolicy)
 private:
  inline void set_has_grace_period();
  inline void clear_has_grace_period();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::DurationInfo* grace_period_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static KillPolicy* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo_URI : public ::google::protobuf::Message {
 public:
  CommandInfo_URI();
  virtual ~CommandInfo_URI();

  CommandInfo_URI(const CommandInfo_URI& from);

  inline CommandInfo_URI& operator=(const CommandInfo_URI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_URI& default_instance();

  void Swap(CommandInfo_URI* other);

  // implements Message ----------------------------------------------

  CommandInfo_URI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo_URI& from);
  void MergeFrom(const CommandInfo_URI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bool executable = 2;
  inline bool has_executable() const;
  inline void clear_executable();
  static const int kExecutableFieldNumber = 2;
  inline bool executable() const;
  inline void set_executable(bool value);

  // optional bool extract = 3 [default = true];
  inline bool has_extract() const;
  inline void clear_extract();
  static const int kExtractFieldNumber = 3;
  inline bool extract() const;
  inline void set_extract(bool value);

  // optional bool cache = 4;
  inline bool has_cache() const;
  inline void clear_cache();
  static const int kCacheFieldNumber = 4;
  inline bool cache() const;
  inline void set_cache(bool value);

  // optional string output_file = 5;
  inline bool has_output_file() const;
  inline void clear_output_file();
  static const int kOutputFileFieldNumber = 5;
  inline const ::std::string& output_file() const;
  inline void set_output_file(const ::std::string& value);
  inline void set_output_file(const char* value);
  inline void set_output_file(const char* value, size_t size);
  inline ::std::string* mutable_output_file();
  inline ::std::string* release_output_file();
  inline void set_allocated_output_file(::std::string* output_file);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.URI)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_executable();
  inline void clear_has_executable();
  inline void set_has_extract();
  inline void clear_has_extract();
  inline void set_has_cache();
  inline void clear_has_cache();
  inline void set_has_output_file();
  inline void clear_has_output_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::std::string* output_file_;
  bool executable_;
  bool extract_;
  bool cache_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo_URI* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo : public ::google::protobuf::Message {
 public:
  CommandInfo();
  virtual ~CommandInfo();

  CommandInfo(const CommandInfo& from);

  inline CommandInfo& operator=(const CommandInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo& default_instance();

  void Swap(CommandInfo* other);

  // implements Message ----------------------------------------------

  CommandInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo& from);
  void MergeFrom(const CommandInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandInfo_URI URI;

  // accessors -------------------------------------------------------

  // repeated .mesos.CommandInfo.URI uris = 1;
  inline int uris_size() const;
  inline void clear_uris();
  static const int kUrisFieldNumber = 1;
  inline const ::mesos::CommandInfo_URI& uris(int index) const;
  inline ::mesos::CommandInfo_URI* mutable_uris(int index);
  inline ::mesos::CommandInfo_URI* add_uris();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
      uris() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
      mutable_uris();

  // optional .mesos.Environment environment = 2;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  inline const ::mesos::Environment& environment() const;
  inline ::mesos::Environment* mutable_environment();
  inline ::mesos::Environment* release_environment();
  inline void set_allocated_environment(::mesos::Environment* environment);

  // optional bool shell = 6 [default = true];
  inline bool has_shell() const;
  inline void clear_shell();
  static const int kShellFieldNumber = 6;
  inline bool shell() const;
  inline void set_shell(bool value);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated string arguments = 7;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 7;
  inline const ::std::string& arguments(int index) const;
  inline ::std::string* mutable_arguments(int index);
  inline void set_arguments(int index, const ::std::string& value);
  inline void set_arguments(int index, const char* value);
  inline void set_arguments(int index, const char* value, size_t size);
  inline ::std::string* add_arguments();
  inline void add_arguments(const ::std::string& value);
  inline void add_arguments(const char* value);
  inline void add_arguments(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_arguments();

  // optional string user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo)
 private:
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_shell();
  inline void clear_has_shell();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI > uris_;
  ::mesos::Environment* environment_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> arguments_;
  ::std::string* user_;
  bool shell_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorInfo : public ::google::protobuf::Message {
 public:
  ExecutorInfo();
  virtual ~ExecutorInfo();

  ExecutorInfo(const ExecutorInfo& from);

  inline ExecutorInfo& operator=(const ExecutorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorInfo& default_instance();

  void Swap(ExecutorInfo* other);

  // implements Message ----------------------------------------------

  ExecutorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorInfo& from);
  void MergeFrom(const ExecutorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExecutorInfo_Type Type;
  static const Type UNKNOWN = ExecutorInfo_Type_UNKNOWN;
  static const Type DEFAULT = ExecutorInfo_Type_DEFAULT;
  static const Type CUSTOM = ExecutorInfo_Type_CUSTOM;
  static inline bool Type_IsValid(int value) {
    return ExecutorInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExecutorInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ExecutorInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExecutorInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExecutorInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExecutorInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExecutorInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.ExecutorInfo.Type type = 15;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 15;
  inline ::mesos::ExecutorInfo_Type type() const;
  inline void set_type(::mesos::ExecutorInfo_Type value);

  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional .mesos.FrameworkID framework_id = 8;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 8;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 11;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 11;
  inline const ::mesos::ContainerInfo& container() const;
  inline ::mesos::ContainerInfo* mutable_container();
  inline ::mesos::ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::ContainerInfo* container);

  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional string name = 9;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 9;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string source = 10 [deprecated = true];
  inline bool has_source() const PROTOBUF_DEPRECATED;
  inline void clear_source() PROTOBUF_DEPRECATED;
  static const int kSourceFieldNumber = 10;
  inline const ::std::string& source() const PROTOBUF_DEPRECATED;
  inline void set_source(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_source(const char* value) PROTOBUF_DEPRECATED;
  inline void set_source(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_source() PROTOBUF_DEPRECATED;
  inline ::std::string* release_source() PROTOBUF_DEPRECATED;
  inline void set_allocated_source(::std::string* source) PROTOBUF_DEPRECATED;

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.DiscoveryInfo discovery = 12;
  inline bool has_discovery() const;
  inline void clear_discovery();
  static const int kDiscoveryFieldNumber = 12;
  inline const ::mesos::DiscoveryInfo& discovery() const;
  inline ::mesos::DiscoveryInfo* mutable_discovery();
  inline ::mesos::DiscoveryInfo* release_discovery();
  inline void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);

  // optional .mesos.DurationInfo shutdown_grace_period = 13;
  inline bool has_shutdown_grace_period() const;
  inline void clear_shutdown_grace_period();
  static const int kShutdownGracePeriodFieldNumber = 13;
  inline const ::mesos::DurationInfo& shutdown_grace_period() const;
  inline ::mesos::DurationInfo* mutable_shutdown_grace_period();
  inline ::mesos::DurationInfo* release_shutdown_grace_period();
  inline void set_allocated_shutdown_grace_period(::mesos::DurationInfo* shutdown_grace_period);

  // optional .mesos.Labels labels = 14;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 14;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_discovery();
  inline void clear_has_discovery();
  inline void set_has_shutdown_grace_period();
  inline void clear_has_shutdown_grace_period();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::std::string* name_;
  ::std::string* source_;
  ::std::string* data_;
  ::mesos::DiscoveryInfo* discovery_;
  ::mesos::DurationInfo* shutdown_grace_period_;
  ::mesos::Labels* labels_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ExecutorInfo* default_instance_;
};
// -------------------------------------------------------------------

class MasterInfo : public ::google::protobuf::Message {
 public:
  MasterInfo();
  virtual ~MasterInfo();

  MasterInfo(const MasterInfo& from);

  inline MasterInfo& operator=(const MasterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfo& default_instance();

  void Swap(MasterInfo* other);

  // implements Message ----------------------------------------------

  MasterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterInfo& from);
  void MergeFrom(const MasterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 3 [default = 5050];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string pid = 4;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 4;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .mesos.Address address = 7;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 7;
  inline const ::mesos::Address& address() const;
  inline ::mesos::Address* mutable_address();
  inline ::mesos::Address* release_address();
  inline void set_allocated_address(::mesos::Address* address);

  // @@protoc_insertion_point(class_scope:mesos.MasterInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* pid_;
  ::std::string* hostname_;
  ::std::string* version_;
  ::mesos::Address* address_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static MasterInfo* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo_Capability : public ::google::protobuf::Message {
 public:
  SlaveInfo_Capability();
  virtual ~SlaveInfo_Capability();

  SlaveInfo_Capability(const SlaveInfo_Capability& from);

  inline SlaveInfo_Capability& operator=(const SlaveInfo_Capability& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo_Capability& default_instance();

  void Swap(SlaveInfo_Capability* other);

  // implements Message ----------------------------------------------

  SlaveInfo_Capability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo_Capability& from);
  void MergeFrom(const SlaveInfo_Capability& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveInfo_Capability_Type Type;
  static const Type UNKNOWN = SlaveInfo_Capability_Type_UNKNOWN;
  static const Type MULTI_ROLE = SlaveInfo_Capability_Type_MULTI_ROLE;
  static inline bool Type_IsValid(int value) {
    return SlaveInfo_Capability_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SlaveInfo_Capability_Type_Type_MIN;
  static const Type Type_MAX =
    SlaveInfo_Capability_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SlaveInfo_Capability_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SlaveInfo_Capability_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SlaveInfo_Capability_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SlaveInfo_Capability_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::SlaveInfo_Capability_Type type() const;
  inline void set_type(::mesos::SlaveInfo_Capability_Type value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo.Capability)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveInfo_Capability* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();

  SlaveInfo(const SlaveInfo& from);

  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();

  void Swap(SlaveInfo* other);

  // implements Message ----------------------------------------------

  SlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveInfo_Capability Capability;

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 port = 8 [default = 5051];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 8;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.Attribute attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();

  // optional .mesos.SlaveID id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::mesos::SlaveID& id() const;
  inline ::mesos::SlaveID* mutable_id();
  inline ::mesos::SlaveID* release_id();
  inline void set_allocated_id(::mesos::SlaveID* id);

  // optional bool checkpoint = 7 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 7;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::int32 port_;
  bool checkpoint_;
  ::mesos::SlaveID* id_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class Value_Scalar : public ::google::protobuf::Message {
 public:
  Value_Scalar();
  virtual ~Value_Scalar();

  Value_Scalar(const Value_Scalar& from);

  inline Value_Scalar& operator=(const Value_Scalar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Scalar& default_instance();

  void Swap(Value_Scalar* other);

  // implements Message ----------------------------------------------

  Value_Scalar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Scalar& from);
  void MergeFrom(const Value_Scalar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Scalar)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Scalar* default_instance_;
};
// -------------------------------------------------------------------

class Value_Range : public ::google::protobuf::Message {
 public:
  Value_Range();
  virtual ~Value_Range();

  Value_Range(const Value_Range& from);

  inline Value_Range& operator=(const Value_Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Range& default_instance();

  void Swap(Value_Range* other);

  // implements Message ----------------------------------------------

  Value_Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Range& from);
  void MergeFrom(const Value_Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::uint64 begin() const;
  inline void set_begin(::google::protobuf::uint64 value);

  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Range)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 begin_;
  ::google::protobuf::uint64 end_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Range* default_instance_;
};
// -------------------------------------------------------------------

class Value_Ranges : public ::google::protobuf::Message {
 public:
  Value_Ranges();
  virtual ~Value_Ranges();

  Value_Ranges(const Value_Ranges& from);

  inline Value_Ranges& operator=(const Value_Ranges& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Ranges& default_instance();

  void Swap(Value_Ranges* other);

  // implements Message ----------------------------------------------

  Value_Ranges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Ranges& from);
  void MergeFrom(const Value_Ranges& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Value.Range range = 1;
  inline int range_size() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline const ::mesos::Value_Range& range(int index) const;
  inline ::mesos::Value_Range* mutable_range(int index);
  inline ::mesos::Value_Range* add_range();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
      range() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
      mutable_range();

  // @@protoc_insertion_point(class_scope:mesos.Value.Ranges)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range > range_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Ranges* default_instance_;
};
// -------------------------------------------------------------------

class Value_Set : public ::google::protobuf::Message {
 public:
  Value_Set();
  virtual ~Value_Set();

  Value_Set(const Value_Set& from);

  inline Value_Set& operator=(const Value_Set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Set& default_instance();

  void Swap(Value_Set* other);

  // implements Message ----------------------------------------------

  Value_Set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Set& from);
  void MergeFrom(const Value_Set& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::std::string& item(int index) const;
  inline ::std::string* mutable_item(int index);
  inline void set_item(int index, const ::std::string& value);
  inline void set_item(int index, const char* value);
  inline void set_item(int index, const char* value, size_t size);
  inline ::std::string* add_item();
  inline void add_item(const ::std::string& value);
  inline void add_item(const char* value);
  inline void add_item(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();

  // @@protoc_insertion_point(class_scope:mesos.Value.Set)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Set* default_instance_;
};
// -------------------------------------------------------------------

class Value_Text : public ::google::protobuf::Message {
 public:
  Value_Text();
  virtual ~Value_Text();

  Value_Text(const Value_Text& from);

  inline Value_Text& operator=(const Value_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Text& default_instance();

  void Swap(Value_Text* other);

  // implements Message ----------------------------------------------

  Value_Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Text& from);
  void MergeFrom(const Value_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Text)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Text* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Value_Scalar Scalar;
  typedef Value_Range Range;
  typedef Value_Ranges Ranges;
  typedef Value_Set Set;
  typedef Value_Text Text;

  typedef Value_Type Type;
  static const Type SCALAR = Value_Type_SCALAR;
  static const Type RANGES = Value_Type_RANGES;
  static const Type SET = Value_Type_SET;
  static const Type TEXT = Value_Type_TEXT;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Value_Type_Type_MIN;
  static const Type Type_MAX =
    Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 2;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 2;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 3;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 3;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 4;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 4;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  inline void set_allocated_text(::mesos::Value_Text* text);

  // @@protoc_insertion_point(class_scope:mesos.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  void Swap(Attribute* other);

  // implements Message ----------------------------------------------

  Attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 6;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 6;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  inline void set_allocated_text(::mesos::Value_Text* text);

  // @@protoc_insertion_point(class_scope:mesos.Attribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Resource_AllocationInfo : public ::google::protobuf::Message {
 public:
  Resource_AllocationInfo();
  virtual ~Resource_AllocationInfo();

  Resource_AllocationInfo(const Resource_AllocationInfo& from);

  inline Resource_AllocationInfo& operator=(const Resource_AllocationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_AllocationInfo& default_instance();

  void Swap(Resource_AllocationInfo* other);

  // implements Message ----------------------------------------------

  Resource_AllocationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_AllocationInfo& from);
  void MergeFrom(const Resource_AllocationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // @@protoc_insertion_point(class_scope:mesos.Resource.AllocationInfo)
 private:
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* role_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_AllocationInfo* default_instance_;
};
// -------------------------------------------------------------------

class Resource_ReservationInfo : public ::google::protobuf::Message {
 public:
  Resource_ReservationInfo();
  virtual ~Resource_ReservationInfo();

  Resource_ReservationInfo(const Resource_ReservationInfo& from);

  inline Resource_ReservationInfo& operator=(const Resource_ReservationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_ReservationInfo& default_instance();

  void Swap(Resource_ReservationInfo* other);

  // implements Message ----------------------------------------------

  Resource_ReservationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_ReservationInfo& from);
  void MergeFrom(const Resource_ReservationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string principal = 1;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional .mesos.Labels labels = 2;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 2;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.Resource.ReservationInfo)
 private:
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* principal_;
  ::mesos::Labels* labels_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_ReservationInfo* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Persistence : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo_Persistence();
  virtual ~Resource_DiskInfo_Persistence();

  Resource_DiskInfo_Persistence(const Resource_DiskInfo_Persistence& from);

  inline Resource_DiskInfo_Persistence& operator=(const Resource_DiskInfo_Persistence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Persistence& default_instance();

  void Swap(Resource_DiskInfo_Persistence* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo_Persistence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo_Persistence& from);
  void MergeFrom(const Resource_DiskInfo_Persistence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string principal = 2;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 2;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Persistence)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_principal();
  inline void clear_has_principal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* principal_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo_Persistence* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Source_Path : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo_Source_Path();
  virtual ~Resource_DiskInfo_Source_Path();

  Resource_DiskInfo_Source_Path(const Resource_DiskInfo_Source_Path& from);

  inline Resource_DiskInfo_Source_Path& operator=(const Resource_DiskInfo_Source_Path& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Source_Path& default_instance();

  void Swap(Resource_DiskInfo_Source_Path* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo_Source_Path* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo_Source_Path& from);
  void MergeFrom(const Resource_DiskInfo_Source_Path& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string root = 1;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 1;
  inline const ::std::string& root() const;
  inline void set_root(const ::std::string& value);
  inline void set_root(const char* value);
  inline void set_root(const char* value, size_t size);
  inline ::std::string* mutable_root();
  inline ::std::string* release_root();
  inline void set_allocated_root(::std::string* root);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Source.Path)
 private:
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* root_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo_Source_Path* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Source_Mount : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo_Source_Mount();
  virtual ~Resource_DiskInfo_Source_Mount();

  Resource_DiskInfo_Source_Mount(const Resource_DiskInfo_Source_Mount& from);

  inline Resource_DiskInfo_Source_Mount& operator=(const Resource_DiskInfo_Source_Mount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Source_Mount& default_instance();

  void Swap(Resource_DiskInfo_Source_Mount* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo_Source_Mount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo_Source_Mount& from);
  void MergeFrom(const Resource_DiskInfo_Source_Mount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string root = 1;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 1;
  inline const ::std::string& root() const;
  inline void set_root(const ::std::string& value);
  inline void set_root(const char* value);
  inline void set_root(const char* value, size_t size);
  inline ::std::string* mutable_root();
  inline ::std::string* release_root();
  inline void set_allocated_root(::std::string* root);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Source.Mount)
 private:
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* root_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo_Source_Mount* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo_Source : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo_Source();
  virtual ~Resource_DiskInfo_Source();

  Resource_DiskInfo_Source(const Resource_DiskInfo_Source& from);

  inline Resource_DiskInfo_Source& operator=(const Resource_DiskInfo_Source& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo_Source& default_instance();

  void Swap(Resource_DiskInfo_Source* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo_Source* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo_Source& from);
  void MergeFrom(const Resource_DiskInfo_Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Resource_DiskInfo_Source_Path Path;
  typedef Resource_DiskInfo_Source_Mount Mount;

  typedef Resource_DiskInfo_Source_Type Type;
  static const Type UNKNOWN = Resource_DiskInfo_Source_Type_UNKNOWN;
  static const Type PATH = Resource_DiskInfo_Source_Type_PATH;
  static const Type MOUNT = Resource_DiskInfo_Source_Type_MOUNT;
  static inline bool Type_IsValid(int value) {
    return Resource_DiskInfo_Source_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Resource_DiskInfo_Source_Type_Type_MIN;
  static const Type Type_MAX =
    Resource_DiskInfo_Source_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Resource_DiskInfo_Source_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Resource_DiskInfo_Source_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Resource_DiskInfo_Source_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Resource_DiskInfo_Source_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Resource_DiskInfo_Source_Type type() const;
  inline void set_type(::mesos::Resource_DiskInfo_Source_Type value);

  // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::mesos::Resource_DiskInfo_Source_Path& path() const;
  inline ::mesos::Resource_DiskInfo_Source_Path* mutable_path();
  inline ::mesos::Resource_DiskInfo_Source_Path* release_path();
  inline void set_allocated_path(::mesos::Resource_DiskInfo_Source_Path* path);

  // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
  inline bool has_mount() const;
  inline void clear_mount();
  static const int kMountFieldNumber = 3;
  inline const ::mesos::Resource_DiskInfo_Source_Mount& mount() const;
  inline ::mesos::Resource_DiskInfo_Source_Mount* mutable_mount();
  inline ::mesos::Resource_DiskInfo_Source_Mount* release_mount();
  inline void set_allocated_mount(::mesos::Resource_DiskInfo_Source_Mount* mount);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo.Source)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_mount();
  inline void clear_has_mount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Resource_DiskInfo_Source_Path* path_;
  ::mesos::Resource_DiskInfo_Source_Mount* mount_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo_Source* default_instance_;
};
// -------------------------------------------------------------------

class Resource_DiskInfo : public ::google::protobuf::Message {
 public:
  Resource_DiskInfo();
  virtual ~Resource_DiskInfo();

  Resource_DiskInfo(const Resource_DiskInfo& from);

  inline Resource_DiskInfo& operator=(const Resource_DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_DiskInfo& default_instance();

  void Swap(Resource_DiskInfo* other);

  // implements Message ----------------------------------------------

  Resource_DiskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_DiskInfo& from);
  void MergeFrom(const Resource_DiskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Resource_DiskInfo_Persistence Persistence;
  typedef Resource_DiskInfo_Source Source;

  // accessors -------------------------------------------------------

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  inline bool has_persistence() const;
  inline void clear_persistence();
  static const int kPersistenceFieldNumber = 1;
  inline const ::mesos::Resource_DiskInfo_Persistence& persistence() const;
  inline ::mesos::Resource_DiskInfo_Persistence* mutable_persistence();
  inline ::mesos::Resource_DiskInfo_Persistence* release_persistence();
  inline void set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence);

  // optional .mesos.Volume volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline const ::mesos::Volume& volume() const;
  inline ::mesos::Volume* mutable_volume();
  inline ::mesos::Volume* release_volume();
  inline void set_allocated_volume(::mesos::Volume* volume);

  // optional .mesos.Resource.DiskInfo.Source source = 3;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline const ::mesos::Resource_DiskInfo_Source& source() const;
  inline ::mesos::Resource_DiskInfo_Source* mutable_source();
  inline ::mesos::Resource_DiskInfo_Source* release_source();
  inline void set_allocated_source(::mesos::Resource_DiskInfo_Source* source);

  // @@protoc_insertion_point(class_scope:mesos.Resource.DiskInfo)
 private:
  inline void set_has_persistence();
  inline void clear_has_persistence();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Resource_DiskInfo_Persistence* persistence_;
  ::mesos::Volume* volume_;
  ::mesos::Resource_DiskInfo_Source* source_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_DiskInfo* default_instance_;
};
// -------------------------------------------------------------------

class Resource_RevocableInfo : public ::google::protobuf::Message {
 public:
  Resource_RevocableInfo();
  virtual ~Resource_RevocableInfo();

  Resource_RevocableInfo(const Resource_RevocableInfo& from);

  inline Resource_RevocableInfo& operator=(const Resource_RevocableInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_RevocableInfo& default_instance();

  void Swap(Resource_RevocableInfo* other);

  // implements Message ----------------------------------------------

  Resource_RevocableInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_RevocableInfo& from);
  void MergeFrom(const Resource_RevocableInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.Resource.RevocableInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_RevocableInfo* default_instance_;
};
// -------------------------------------------------------------------

class Resource_SharedInfo : public ::google::protobuf::Message {
 public:
  Resource_SharedInfo();
  virtual ~Resource_SharedInfo();

  Resource_SharedInfo(const Resource_SharedInfo& from);

  inline Resource_SharedInfo& operator=(const Resource_SharedInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource_SharedInfo& default_instance();

  void Swap(Resource_SharedInfo* other);

  // implements Message ----------------------------------------------

  Resource_SharedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource_SharedInfo& from);
  void MergeFrom(const Resource_SharedInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.Resource.SharedInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource_SharedInfo* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  void Swap(Resource* other);

  // implements Message ----------------------------------------------

  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Resource_AllocationInfo AllocationInfo;
  typedef Resource_ReservationInfo ReservationInfo;
  typedef Resource_DiskInfo DiskInfo;
  typedef Resource_RevocableInfo RevocableInfo;
  typedef Resource_SharedInfo SharedInfo;

  // accessors -------------------------------------------------------

  // optional .mesos.ResourceProviderID provider_id = 12;
  inline bool has_provider_id() const;
  inline void clear_provider_id();
  static const int kProviderIdFieldNumber = 12;
  inline const ::mesos::ResourceProviderID& provider_id() const;
  inline ::mesos::ResourceProviderID* mutable_provider_id();
  inline ::mesos::ResourceProviderID* release_provider_id();
  inline void set_allocated_provider_id(::mesos::ResourceProviderID* provider_id);

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 5;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 5;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional string role = 6 [default = "*"];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // optional .mesos.Resource.AllocationInfo allocation_info = 11;
  inline bool has_allocation_info() const;
  inline void clear_allocation_info();
  static const int kAllocationInfoFieldNumber = 11;
  inline const ::mesos::Resource_AllocationInfo& allocation_info() const;
  inline ::mesos::Resource_AllocationInfo* mutable_allocation_info();
  inline ::mesos::Resource_AllocationInfo* release_allocation_info();
  inline void set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info);

  // optional .mesos.Resource.ReservationInfo reservation = 8;
  inline bool has_reservation() const;
  inline void clear_reservation();
  static const int kReservationFieldNumber = 8;
  inline const ::mesos::Resource_ReservationInfo& reservation() const;
  inline ::mesos::Resource_ReservationInfo* mutable_reservation();
  inline ::mesos::Resource_ReservationInfo* release_reservation();
  inline void set_allocated_reservation(::mesos::Resource_ReservationInfo* reservation);

  // optional .mesos.Resource.DiskInfo disk = 7;
  inline bool has_disk() const;
  inline void clear_disk();
  static const int kDiskFieldNumber = 7;
  inline const ::mesos::Resource_DiskInfo& disk() const;
  inline ::mesos::Resource_DiskInfo* mutable_disk();
  inline ::mesos::Resource_DiskInfo* release_disk();
  inline void set_allocated_disk(::mesos::Resource_DiskInfo* disk);

  // optional .mesos.Resource.RevocableInfo revocable = 9;
  inline bool has_revocable() const;
  inline void clear_revocable();
  static const int kRevocableFieldNumber = 9;
  inline const ::mesos::Resource_RevocableInfo& revocable() const;
  inline ::mesos::Resource_RevocableInfo* mutable_revocable();
  inline ::mesos::Resource_RevocableInfo* release_revocable();
  inline void set_allocated_revocable(::mesos::Resource_RevocableInfo* revocable);

  // optional .mesos.Resource.SharedInfo shared = 10;
  inline bool has_shared() const;
  inline void clear_shared();
  static const int kSharedFieldNumber = 10;
  inline const ::mesos::Resource_SharedInfo& shared() const;
  inline ::mesos::Resource_SharedInfo* mutable_shared();
  inline ::mesos::Resource_SharedInfo* release_shared();
  inline void set_allocated_shared(::mesos::Resource_SharedInfo* shared);

  // @@protoc_insertion_point(class_scope:mesos.Resource)
 private:
  inline void set_has_provider_id();
  inline void clear_has_provider_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_allocation_info();
  inline void clear_has_allocation_info();
  inline void set_has_reservation();
  inline void clear_has_reservation();
  inline void set_has_disk();
  inline void clear_has_disk();
  inline void set_has_revocable();
  inline void clear_has_revocable();
  inline void set_has_shared();
  inline void clear_has_shared();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ResourceProviderID* provider_id_;
  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  static ::std::string* _default_role_;
  ::std::string* role_;
  ::mesos::Resource_AllocationInfo* allocation_info_;
  ::mesos::Resource_ReservationInfo* reservation_;
  ::mesos::Resource_DiskInfo* disk_;
  ::mesos::Resource_RevocableInfo* revocable_;
  ::mesos::Resource_SharedInfo* shared_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class TrafficControlStatistics : public ::google::protobuf::Message {
 public:
  TrafficControlStatistics();
  virtual ~TrafficControlStatistics();

  TrafficControlStatistics(const TrafficControlStatistics& from);

  inline TrafficControlStatistics& operator=(const TrafficControlStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficControlStatistics& default_instance();

  void Swap(TrafficControlStatistics* other);

  // implements Message ----------------------------------------------

  TrafficControlStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrafficControlStatistics& from);
  void MergeFrom(const TrafficControlStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint64 backlog = 2;
  inline bool has_backlog() const;
  inline void clear_backlog();
  static const int kBacklogFieldNumber = 2;
  inline ::google::protobuf::uint64 backlog() const;
  inline void set_backlog(::google::protobuf::uint64 value);

  // optional uint64 bytes = 3;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 bytes() const;
  inline void set_bytes(::google::protobuf::uint64 value);

  // optional uint64 drops = 4;
  inline bool has_drops() const;
  inline void clear_drops();
  static const int kDropsFieldNumber = 4;
  inline ::google::protobuf::uint64 drops() const;
  inline void set_drops(::google::protobuf::uint64 value);

  // optional uint64 overlimits = 5;
  inline bool has_overlimits() const;
  inline void clear_overlimits();
  static const int kOverlimitsFieldNumber = 5;
  inline ::google::protobuf::uint64 overlimits() const;
  inline void set_overlimits(::google::protobuf::uint64 value);

  // optional uint64 packets = 6;
  inline bool has_packets() const;
  inline void clear_packets();
  static const int kPacketsFieldNumber = 6;
  inline ::google::protobuf::uint64 packets() const;
  inline void set_packets(::google::protobuf::uint64 value);

  // optional uint64 qlen = 7;
  inline bool has_qlen() const;
  inline void clear_qlen();
  static const int kQlenFieldNumber = 7;
  inline ::google::protobuf::uint64 qlen() const;
  inline void set_qlen(::google::protobuf::uint64 value);

  // optional uint64 ratebps = 8;
  inline bool has_ratebps() const;
  inline void clear_ratebps();
  static const int kRatebpsFieldNumber = 8;
  inline ::google::protobuf::uint64 ratebps() const;
  inline void set_ratebps(::google::protobuf::uint64 value);

  // optional uint64 ratepps = 9;
  inline bool has_ratepps() const;
  inline void clear_ratepps();
  static const int kRateppsFieldNumber = 9;
  inline ::google::protobuf::uint64 ratepps() const;
  inline void set_ratepps(::google::protobuf::uint64 value);

  // optional uint64 requeues = 10;
  inline bool has_requeues() const;
  inline void clear_requeues();
  static const int kRequeuesFieldNumber = 10;
  inline ::google::protobuf::uint64 requeues() const;
  inline void set_requeues(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.TrafficControlStatistics)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_backlog();
  inline void clear_has_backlog();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  inline void set_has_drops();
  inline void clear_has_drops();
  inline void set_has_overlimits();
  inline void clear_has_overlimits();
  inline void set_has_packets();
  inline void clear_has_packets();
  inline void set_has_qlen();
  inline void clear_has_qlen();
  inline void set_has_ratebps();
  inline void clear_has_ratebps();
  inline void set_has_ratepps();
  inline void clear_has_ratepps();
  inline void set_has_requeues();
  inline void clear_has_requeues();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::uint64 backlog_;
  ::google::protobuf::uint64 bytes_;
  ::google::protobuf::uint64 drops_;
  ::google::protobuf::uint64 overlimits_;
  ::google::protobuf::uint64 packets_;
  ::google::protobuf::uint64 qlen_;
  ::google::protobuf::uint64 ratebps_;
  ::google::protobuf::uint64 ratepps_;
  ::google::protobuf::uint64 requeues_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TrafficControlStatistics* default_instance_;
};
// -------------------------------------------------------------------

class IpStatistics : public ::google::protobuf::Message {
 public:
  IpStatistics();
  virtual ~IpStatistics();

  IpStatistics(const IpStatistics& from);

  inline IpStatistics& operator=(const IpStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpStatistics& default_instance();

  void Swap(IpStatistics* other);

  // implements Message ----------------------------------------------

  IpStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpStatistics& from);
  void MergeFrom(const IpStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 Forwarding = 1;
  inline bool has_forwarding() const;
  inline void clear_forwarding();
  static const int kForwardingFieldNumber = 1;
  inline ::google::protobuf::int64 forwarding() const;
  inline void set_forwarding(::google::protobuf::int64 value);

  // optional int64 DefaultTTL = 2;
  inline bool has_defaultttl() const;
  inline void clear_defaultttl();
  static const int kDefaultTTLFieldNumber = 2;
  inline ::google::protobuf::int64 defaultttl() const;
  inline void set_defaultttl(::google::protobuf::int64 value);

  // optional int64 InReceives = 3;
  inline bool has_inreceives() const;
  inline void clear_inreceives();
  static const int kInReceivesFieldNumber = 3;
  inline ::google::protobuf::int64 inreceives() const;
  inline void set_inreceives(::google::protobuf::int64 value);

  // optional int64 InHdrErrors = 4;
  inline bool has_inhdrerrors() const;
  inline void clear_inhdrerrors();
  static const int kInHdrErrorsFieldNumber = 4;
  inline ::google::protobuf::int64 inhdrerrors() const;
  inline void set_inhdrerrors(::google::protobuf::int64 value);

  // optional int64 InAddrErrors = 5;
  inline bool has_inaddrerrors() const;
  inline void clear_inaddrerrors();
  static const int kInAddrErrorsFieldNumber = 5;
  inline ::google::protobuf::int64 inaddrerrors() const;
  inline void set_inaddrerrors(::google::protobuf::int64 value);

  // optional int64 ForwDatagrams = 6;
  inline bool has_forwdatagrams() const;
  inline void clear_forwdatagrams();
  static const int kForwDatagramsFieldNumber = 6;
  inline ::google::protobuf::int64 forwdatagrams() const;
  inline void set_forwdatagrams(::google::protobuf::int64 value);

  // optional int64 InUnknownProtos = 7;
  inline bool has_inunknownprotos() const;
  inline void clear_inunknownprotos();
  static const int kInUnknownProtosFieldNumber = 7;
  inline ::google::protobuf::int64 inunknownprotos() const;
  inline void set_inunknownprotos(::google::protobuf::int64 value);

  // optional int64 InDiscards = 8;
  inline bool has_indiscards() const;
  inline void clear_indiscards();
  static const int kInDiscardsFieldNumber = 8;
  inline ::google::protobuf::int64 indiscards() const;
  inline void set_indiscards(::google::protobuf::int64 value);

  // optional int64 InDelivers = 9;
  inline bool has_indelivers() const;
  inline void clear_indelivers();
  static const int kInDeliversFieldNumber = 9;
  inline ::google::protobuf::int64 indelivers() const;
  inline void set_indelivers(::google::protobuf::int64 value);

  // optional int64 OutRequests = 10;
  inline bool has_outrequests() const;
  inline void clear_outrequests();
  static const int kOutRequestsFieldNumber = 10;
  inline ::google::protobuf::int64 outrequests() const;
  inline void set_outrequests(::google::protobuf::int64 value);

  // optional int64 OutDiscards = 11;
  inline bool has_outdiscards() const;
  inline void clear_outdiscards();
  static const int kOutDiscardsFieldNumber = 11;
  inline ::google::protobuf::int64 outdiscards() const;
  inline void set_outdiscards(::google::protobuf::int64 value);

  // optional int64 OutNoRoutes = 12;
  inline bool has_outnoroutes() const;
  inline void clear_outnoroutes();
  static const int kOutNoRoutesFieldNumber = 12;
  inline ::google::protobuf::int64 outnoroutes() const;
  inline void set_outnoroutes(::google::protobuf::int64 value);

  // optional int64 ReasmTimeout = 13;
  inline bool has_reasmtimeout() const;
  inline void clear_reasmtimeout();
  static const int kReasmTimeoutFieldNumber = 13;
  inline ::google::protobuf::int64 reasmtimeout() const;
  inline void set_reasmtimeout(::google::protobuf::int64 value);

  // optional int64 ReasmReqds = 14;
  inline bool has_reasmreqds() const;
  inline void clear_reasmreqds();
  static const int kReasmReqdsFieldNumber = 14;
  inline ::google::protobuf::int64 reasmreqds() const;
  inline void set_reasmreqds(::google::protobuf::int64 value);

  // optional int64 ReasmOKs = 15;
  inline bool has_reasmoks() const;
  inline void clear_reasmoks();
  static const int kReasmOKsFieldNumber = 15;
  inline ::google::protobuf::int64 reasmoks() const;
  inline void set_reasmoks(::google::protobuf::int64 value);

  // optional int64 ReasmFails = 16;
  inline bool has_reasmfails() const;
  inline void clear_reasmfails();
  static const int kReasmFailsFieldNumber = 16;
  inline ::google::protobuf::int64 reasmfails() const;
  inline void set_reasmfails(::google::protobuf::int64 value);

  // optional int64 FragOKs = 17;
  inline bool has_fragoks() const;
  inline void clear_fragoks();
  static const int kFragOKsFieldNumber = 17;
  inline ::google::protobuf::int64 fragoks() const;
  inline void set_fragoks(::google::protobuf::int64 value);

  // optional int64 FragFails = 18;
  inline bool has_fragfails() const;
  inline void clear_fragfails();
  static const int kFragFailsFieldNumber = 18;
  inline ::google::protobuf::int64 fragfails() const;
  inline void set_fragfails(::google::protobuf::int64 value);

  // optional int64 FragCreates = 19;
  inline bool has_fragcreates() const;
  inline void clear_fragcreates();
  static const int kFragCreatesFieldNumber = 19;
  inline ::google::protobuf::int64 fragcreates() const;
  inline void set_fragcreates(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.IpStatistics)
 private:
  inline void set_has_forwarding();
  inline void clear_has_forwarding();
  inline void set_has_defaultttl();
  inline void clear_has_defaultttl();
  inline void set_has_inreceives();
  inline void clear_has_inreceives();
  inline void set_has_inhdrerrors();
  inline void clear_has_inhdrerrors();
  inline void set_has_inaddrerrors();
  inline void clear_has_inaddrerrors();
  inline void set_has_forwdatagrams();
  inline void clear_has_forwdatagrams();
  inline void set_has_inunknownprotos();
  inline void clear_has_inunknownprotos();
  inline void set_has_indiscards();
  inline void clear_has_indiscards();
  inline void set_has_indelivers();
  inline void clear_has_indelivers();
  inline void set_has_outrequests();
  inline void clear_has_outrequests();
  inline void set_has_outdiscards();
  inline void clear_has_outdiscards();
  inline void set_has_outnoroutes();
  inline void clear_has_outnoroutes();
  inline void set_has_reasmtimeout();
  inline void clear_has_reasmtimeout();
  inline void set_has_reasmreqds();
  inline void clear_has_reasmreqds();
  inline void set_has_reasmoks();
  inline void clear_has_reasmoks();
  inline void set_has_reasmfails();
  inline void clear_has_reasmfails();
  inline void set_has_fragoks();
  inline void clear_has_fragoks();
  inline void set_has_fragfails();
  inline void clear_has_fragfails();
  inline void set_has_fragcreates();
  inline void clear_has_fragcreates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 forwarding_;
  ::google::protobuf::int64 defaultttl_;
  ::google::protobuf::int64 inreceives_;
  ::google::protobuf::int64 inhdrerrors_;
  ::google::protobuf::int64 inaddrerrors_;
  ::google::protobuf::int64 forwdatagrams_;
  ::google::protobuf::int64 inunknownprotos_;
  ::google::protobuf::int64 indiscards_;
  ::google::protobuf::int64 indelivers_;
  ::google::protobuf::int64 outrequests_;
  ::google::protobuf::int64 outdiscards_;
  ::google::protobuf::int64 outnoroutes_;
  ::google::protobuf::int64 reasmtimeout_;
  ::google::protobuf::int64 reasmreqds_;
  ::google::protobuf::int64 reasmoks_;
  ::google::protobuf::int64 reasmfails_;
  ::google::protobuf::int64 fragoks_;
  ::google::protobuf::int64 fragfails_;
  ::google::protobuf::int64 fragcreates_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static IpStatistics* default_instance_;
};
// -------------------------------------------------------------------

class IcmpStatistics : public ::google::protobuf::Message {
 public:
  IcmpStatistics();
  virtual ~IcmpStatistics();

  IcmpStatistics(const IcmpStatistics& from);

  inline IcmpStatistics& operator=(const IcmpStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IcmpStatistics& default_instance();

  void Swap(IcmpStatistics* other);

  // implements Message ----------------------------------------------

  IcmpStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IcmpStatistics& from);
  void MergeFrom(const IcmpStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 InMsgs = 1;
  inline bool has_inmsgs() const;
  inline void clear_inmsgs();
  static const int kInMsgsFieldNumber = 1;
  inline ::google::protobuf::int64 inmsgs() const;
  inline void set_inmsgs(::google::protobuf::int64 value);

  // optional int64 InErrors = 2;
  inline bool has_inerrors() const;
  inline void clear_inerrors();
  static const int kInErrorsFieldNumber = 2;
  inline ::google::protobuf::int64 inerrors() const;
  inline void set_inerrors(::google::protobuf::int64 value);

  // optional int64 InCsumErrors = 3;
  inline bool has_incsumerrors() const;
  inline void clear_incsumerrors();
  static const int kInCsumErrorsFieldNumber = 3;
  inline ::google::protobuf::int64 incsumerrors() const;
  inline void set_incsumerrors(::google::protobuf::int64 value);

  // optional int64 InDestUnreachs = 4;
  inline bool has_indestunreachs() const;
  inline void clear_indestunreachs();
  static const int kInDestUnreachsFieldNumber = 4;
  inline ::google::protobuf::int64 indestunreachs() const;
  inline void set_indestunreachs(::google::protobuf::int64 value);

  // optional int64 InTimeExcds = 5;
  inline bool has_intimeexcds() const;
  inline void clear_intimeexcds();
  static const int kInTimeExcdsFieldNumber = 5;
  inline ::google::protobuf::int64 intimeexcds() const;
  inline void set_intimeexcds(::google::protobuf::int64 value);

  // optional int64 InParmProbs = 6;
  inline bool has_inparmprobs() const;
  inline void clear_inparmprobs();
  static const int kInParmProbsFieldNumber = 6;
  inline ::google::protobuf::int64 inparmprobs() const;
  inline void set_inparmprobs(::google::protobuf::int64 value);

  // optional int64 InSrcQuenchs = 7;
  inline bool has_insrcquenchs() const;
  inline void clear_insrcquenchs();
  static const int kInSrcQuenchsFieldNumber = 7;
  inline ::google::protobuf::int64 insrcquenchs() const;
  inline void set_insrcquenchs(::google::protobuf::int64 value);

  // optional int64 InRedirects = 8;
  inline bool has_inredirects() const;
  inline void clear_inredirects();
  static const int kInRedirectsFieldNumber = 8;
  inline ::google::protobuf::int64 inredirects() const;
  inline void set_inredirects(::google::protobuf::int64 value);

  // optional int64 InEchos = 9;
  inline bool has_inechos() const;
  inline void clear_inechos();
  static const int kInEchosFieldNumber = 9;
  inline ::google::protobuf::int64 inechos() const;
  inline void set_inechos(::google::protobuf::int64 value);

  // optional int64 InEchoReps = 10;
  inline bool has_inechoreps() const;
  inline void clear_inechoreps();
  static const int kInEchoRepsFieldNumber = 10;
  inline ::google::protobuf::int64 inechoreps() const;
  inline void set_inechoreps(::google::protobuf::int64 value);

  // optional int64 InTimestamps = 11;
  inline bool has_intimestamps() const;
  inline void clear_intimestamps();
  static const int kInTimestampsFieldNumber = 11;
  inline ::google::protobuf::int64 intimestamps() const;
  inline void set_intimestamps(::google::protobuf::int64 value);

  // optional int64 InTimestampReps = 12;
  inline bool has_intimestampreps() const;
  inline void clear_intimestampreps();
  static const int kInTimestampRepsFieldNumber = 12;
  inline ::google::protobuf::int64 intimestampreps() const;
  inline void set_intimestampreps(::google::protobuf::int64 value);

  // optional int64 InAddrMasks = 13;
  inline bool has_inaddrmasks() const;
  inline void clear_inaddrmasks();
  static const int kInAddrMasksFieldNumber = 13;
  inline ::google::protobuf::int64 inaddrmasks() const;
  inline void set_inaddrmasks(::google::protobuf::int64 value);

  // optional int64 InAddrMaskReps = 14;
  inline bool has_inaddrmaskreps() const;
  inline void clear_inaddrmaskreps();
  static const int kInAddrMaskRepsFieldNumber = 14;
  inline ::google::protobuf::int64 inaddrmaskreps() const;
  inline void set_inaddrmaskreps(::google::protobuf::int64 value);

  // optional int64 OutMsgs = 15;
  inline bool has_outmsgs() const;
  inline void clear_outmsgs();
  static const int kOutMsgsFieldNumber = 15;
  inline ::google::protobuf::int64 outmsgs() const;
  inline void set_outmsgs(::google::protobuf::int64 value);

  // optional int64 OutErrors = 16;
  inline bool has_outerrors() const;
  inline void clear_outerrors();
  static const int kOutErrorsFieldNumber = 16;
  inline ::google::protobuf::int64 outerrors() const;
  inline void set_outerrors(::google::protobuf::int64 value);

  // optional int64 OutDestUnreachs = 17;
  inline bool has_outdestunreachs() const;
  inline void clear_outdestunreachs();
  static const int kOutDestUnreachsFieldNumber = 17;
  inline ::google::protobuf::int64 outdestunreachs() const;
  inline void set_outdestunreachs(::google::protobuf::int64 value);

  // optional int64 OutTimeExcds = 18;
  inline bool has_outtimeexcds() const;
  inline void clear_outtimeexcds();
  static const int kOutTimeExcdsFieldNumber = 18;
  inline ::google::protobuf::int64 outtimeexcds() const;
  inline void set_outtimeexcds(::google::protobuf::int64 value);

  // optional int64 OutParmProbs = 19;
  inline bool has_outparmprobs() const;
  inline void clear_outparmprobs();
  static const int kOutParmProbsFieldNumber = 19;
  inline ::google::protobuf::int64 outparmprobs() const;
  inline void set_outparmprobs(::google::protobuf::int64 value);

  // optional int64 OutSrcQuenchs = 20;
  inline bool has_outsrcquenchs() const;
  inline void clear_outsrcquenchs();
  static const int kOutSrcQuenchsFieldNumber = 20;
  inline ::google::protobuf::int64 outsrcquenchs() const;
  inline void set_outsrcquenchs(::google::protobuf::int64 value);

  // optional int64 OutRedirects = 21;
  inline bool has_outredirects() const;
  inline void clear_outredirects();
  static const int kOutRedirectsFieldNumber = 21;
  inline ::google::protobuf::int64 outredirects() const;
  inline void set_outredirects(::google::protobuf::int64 value);

  // optional int64 OutEchos = 22;
  inline bool has_outechos() const;
  inline void clear_outechos();
  static const int kOutEchosFieldNumber = 22;
  inline ::google::protobuf::int64 outechos() const;
  inline void set_outechos(::google::protobuf::int64 value);

  // optional int64 OutEchoReps = 23;
  inline bool has_outechoreps() const;
  inline void clear_outechoreps();
  static const int kOutEchoRepsFieldNumber = 23;
  inline ::google::protobuf::int64 outechoreps() const;
  inline void set_outechoreps(::google::protobuf::int64 value);

  // optional int64 OutTimestamps = 24;
  inline bool has_outtimestamps() const;
  inline void clear_outtimestamps();
  static const int kOutTimestampsFieldNumber = 24;
  inline ::google::protobuf::int64 outtimestamps() const;
  inline void set_outtimestamps(::google::protobuf::int64 value);

  // optional int64 OutTimestampReps = 25;
  inline bool has_outtimestampreps() const;
  inline void clear_outtimestampreps();
  static const int kOutTimestampRepsFieldNumber = 25;
  inline ::google::protobuf::int64 outtimestampreps() const;
  inline void set_outtimestampreps(::google::protobuf::int64 value);

  // optional int64 OutAddrMasks = 26;
  inline bool has_outaddrmasks() const;
  inline void clear_outaddrmasks();
  static const int kOutAddrMasksFieldNumber = 26;
  inline ::google::protobuf::int64 outaddrmasks() const;
  inline void set_outaddrmasks(::google::protobuf::int64 value);

  // optional int64 OutAddrMaskReps = 27;
  inline bool has_outaddrmaskreps() const;
  inline void clear_outaddrmaskreps();
  static const int kOutAddrMaskRepsFieldNumber = 27;
  inline ::google::protobuf::int64 outaddrmaskreps() const;
  inline void set_outaddrmaskreps(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.IcmpStatistics)
 private:
  inline void set_has_inmsgs();
  inline void clear_has_inmsgs();
  inline void set_has_inerrors();
  inline void clear_has_inerrors();
  inline void set_has_incsumerrors();
  inline void clear_has_incsumerrors();
  inline void set_has_indestunreachs();
  inline void clear_has_indestunreachs();
  inline void set_has_intimeexcds();
  inline void clear_has_intimeexcds();
  inline void set_has_inparmprobs();
  inline void clear_has_inparmprobs();
  inline void set_has_insrcquenchs();
  inline void clear_has_insrcquenchs();
  inline void set_has_inredirects();
  inline void clear_has_inredirects();
  inline void set_has_inechos();
  inline void clear_has_inechos();
  inline void set_has_inechoreps();
  inline void clear_has_inechoreps();
  inline void set_has_intimestamps();
  inline void clear_has_intimestamps();
  inline void set_has_intimestampreps();
  inline void clear_has_intimestampreps();
  inline void set_has_inaddrmasks();
  inline void clear_has_inaddrmasks();
  inline void set_has_inaddrmaskreps();
  inline void clear_has_inaddrmaskreps();
  inline void set_has_outmsgs();
  inline void clear_has_outmsgs();
  inline void set_has_outerrors();
  inline void clear_has_outerrors();
  inline void set_has_outdestunreachs();
  inline void clear_has_outdestunreachs();
  inline void set_has_outtimeexcds();
  inline void clear_has_outtimeexcds();
  inline void set_has_outparmprobs();
  inline void clear_has_outparmprobs();
  inline void set_has_outsrcquenchs();
  inline void clear_has_outsrcquenchs();
  inline void set_has_outredirects();
  inline void clear_has_outredirects();
  inline void set_has_outechos();
  inline void clear_has_outechos();
  inline void set_has_outechoreps();
  inline void clear_has_outechoreps();
  inline void set_has_outtimestamps();
  inline void clear_has_outtimestamps();
  inline void set_has_outtimestampreps();
  inline void clear_has_outtimestampreps();
  inline void set_has_outaddrmasks();
  inline void clear_has_outaddrmasks();
  inline void set_has_outaddrmaskreps();
  inline void clear_has_outaddrmaskreps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 inmsgs_;
  ::google::protobuf::int64 inerrors_;
  ::google::protobuf::int64 incsumerrors_;
  ::google::protobuf::int64 indestunreachs_;
  ::google::protobuf::int64 intimeexcds_;
  ::google::protobuf::int64 inparmprobs_;
  ::google::protobuf::int64 insrcquenchs_;
  ::google::protobuf::int64 inredirects_;
  ::google::protobuf::int64 inechos_;
  ::google::protobuf::int64 inechoreps_;
  ::google::protobuf::int64 intimestamps_;
  ::google::protobuf::int64 intimestampreps_;
  ::google::protobuf::int64 inaddrmasks_;
  ::google::protobuf::int64 inaddrmaskreps_;
  ::google::protobuf::int64 outmsgs_;
  ::google::protobuf::int64 outerrors_;
  ::google::protobuf::int64 outdestunreachs_;
  ::google::protobuf::int64 outtimeexcds_;
  ::google::protobuf::int64 outparmprobs_;
  ::google::protobuf::int64 outsrcquenchs_;
  ::google::protobuf::int64 outredirects_;
  ::google::protobuf::int64 outechos_;
  ::google::protobuf::int64 outechoreps_;
  ::google::protobuf::int64 outtimestamps_;
  ::google::protobuf::int64 outtimestampreps_;
  ::google::protobuf::int64 outaddrmasks_;
  ::google::protobuf::int64 outaddrmaskreps_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static IcmpStatistics* default_instance_;
};
// -------------------------------------------------------------------

class TcpStatistics : public ::google::protobuf::Message {
 public:
  TcpStatistics();
  virtual ~TcpStatistics();

  TcpStatistics(const TcpStatistics& from);

  inline TcpStatistics& operator=(const TcpStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpStatistics& default_instance();

  void Swap(TcpStatistics* other);

  // implements Message ----------------------------------------------

  TcpStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TcpStatistics& from);
  void MergeFrom(const TcpStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 RtoAlgorithm = 1;
  inline bool has_rtoalgorithm() const;
  inline void clear_rtoalgorithm();
  static const int kRtoAlgorithmFieldNumber = 1;
  inline ::google::protobuf::int64 rtoalgorithm() const;
  inline void set_rtoalgorithm(::google::protobuf::int64 value);

  // optional int64 RtoMin = 2;
  inline bool has_rtomin() const;
  inline void clear_rtomin();
  static const int kRtoMinFieldNumber = 2;
  inline ::google::protobuf::int64 rtomin() const;
  inline void set_rtomin(::google::protobuf::int64 value);

  // optional int64 RtoMax = 3;
  inline bool has_rtomax() const;
  inline void clear_rtomax();
  static const int kRtoMaxFieldNumber = 3;
  inline ::google::protobuf::int64 rtomax() const;
  inline void set_rtomax(::google::protobuf::int64 value);

  // optional int64 MaxConn = 4;
  inline bool has_maxconn() const;
  inline void clear_maxconn();
  static const int kMaxConnFieldNumber = 4;
  inline ::google::protobuf::int64 maxconn() const;
  inline void set_maxconn(::google::protobuf::int64 value);

  // optional int64 ActiveOpens = 5;
  inline bool has_activeopens() const;
  inline void clear_activeopens();
  static const int kActiveOpensFieldNumber = 5;
  inline ::google::protobuf::int64 activeopens() const;
  inline void set_activeopens(::google::protobuf::int64 value);

  // optional int64 PassiveOpens = 6;
  inline bool has_passiveopens() const;
  inline void clear_passiveopens();
  static const int kPassiveOpensFieldNumber = 6;
  inline ::google::protobuf::int64 passiveopens() const;
  inline void set_passiveopens(::google::protobuf::int64 value);

  // optional int64 AttemptFails = 7;
  inline bool has_attemptfails() const;
  inline void clear_attemptfails();
  static const int kAttemptFailsFieldNumber = 7;
  inline ::google::protobuf::int64 attemptfails() const;
  inline void set_attemptfails(::google::protobuf::int64 value);

  // optional int64 EstabResets = 8;
  inline bool has_estabresets() const;
  inline void clear_estabresets();
  static const int kEstabResetsFieldNumber = 8;
  inline ::google::protobuf::int64 estabresets() const;
  inline void set_estabresets(::google::protobuf::int64 value);

  // optional int64 CurrEstab = 9;
  inline bool has_currestab() const;
  inline void clear_currestab();
  static const int kCurrEstabFieldNumber = 9;
  inline ::google::protobuf::int64 currestab() const;
  inline void set_currestab(::google::protobuf::int64 value);

  // optional int64 InSegs = 10;
  inline bool has_insegs() const;
  inline void clear_insegs();
  static const int kInSegsFieldNumber = 10;
  inline ::google::protobuf::int64 insegs() const;
  inline void set_insegs(::google::protobuf::int64 value);

  // optional int64 OutSegs = 11;
  inline bool has_outsegs() const;
  inline void clear_outsegs();
  static const int kOutSegsFieldNumber = 11;
  inline ::google::protobuf::int64 outsegs() const;
  inline void set_outsegs(::google::protobuf::int64 value);

  // optional int64 RetransSegs = 12;
  inline bool has_retranssegs() const;
  inline void clear_retranssegs();
  static const int kRetransSegsFieldNumber = 12;
  inline ::google::protobuf::int64 retranssegs() const;
  inline void set_retranssegs(::google::protobuf::int64 value);

  // optional int64 InErrs = 13;
  inline bool has_inerrs() const;
  inline void clear_inerrs();
  static const int kInErrsFieldNumber = 13;
  inline ::google::protobuf::int64 inerrs() const;
  inline void set_inerrs(::google::protobuf::int64 value);

  // optional int64 OutRsts = 14;
  inline bool has_outrsts() const;
  inline void clear_outrsts();
  static const int kOutRstsFieldNumber = 14;
  inline ::google::protobuf::int64 outrsts() const;
  inline void set_outrsts(::google::protobuf::int64 value);

  // optional int64 InCsumErrors = 15;
  inline bool has_incsumerrors() const;
  inline void clear_incsumerrors();
  static const int kInCsumErrorsFieldNumber = 15;
  inline ::google::protobuf::int64 incsumerrors() const;
  inline void set_incsumerrors(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.TcpStatistics)
 private:
  inline void set_has_rtoalgorithm();
  inline void clear_has_rtoalgorithm();
  inline void set_has_rtomin();
  inline void clear_has_rtomin();
  inline void set_has_rtomax();
  inline void clear_has_rtomax();
  inline void set_has_maxconn();
  inline void clear_has_maxconn();
  inline void set_has_activeopens();
  inline void clear_has_activeopens();
  inline void set_has_passiveopens();
  inline void clear_has_passiveopens();
  inline void set_has_attemptfails();
  inline void clear_has_attemptfails();
  inline void set_has_estabresets();
  inline void clear_has_estabresets();
  inline void set_has_currestab();
  inline void clear_has_currestab();
  inline void set_has_insegs();
  inline void clear_has_insegs();
  inline void set_has_outsegs();
  inline void clear_has_outsegs();
  inline void set_has_retranssegs();
  inline void clear_has_retranssegs();
  inline void set_has_inerrs();
  inline void clear_has_inerrs();
  inline void set_has_outrsts();
  inline void clear_has_outrsts();
  inline void set_has_incsumerrors();
  inline void clear_has_incsumerrors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 rtoalgorithm_;
  ::google::protobuf::int64 rtomin_;
  ::google::protobuf::int64 rtomax_;
  ::google::protobuf::int64 maxconn_;
  ::google::protobuf::int64 activeopens_;
  ::google::protobuf::int64 passiveopens_;
  ::google::protobuf::int64 attemptfails_;
  ::google::protobuf::int64 estabresets_;
  ::google::protobuf::int64 currestab_;
  ::google::protobuf::int64 insegs_;
  ::google::protobuf::int64 outsegs_;
  ::google::protobuf::int64 retranssegs_;
  ::google::protobuf::int64 inerrs_;
  ::google::protobuf::int64 outrsts_;
  ::google::protobuf::int64 incsumerrors_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TcpStatistics* default_instance_;
};
// -------------------------------------------------------------------

class UdpStatistics : public ::google::protobuf::Message {
 public:
  UdpStatistics();
  virtual ~UdpStatistics();

  UdpStatistics(const UdpStatistics& from);

  inline UdpStatistics& operator=(const UdpStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdpStatistics& default_instance();

  void Swap(UdpStatistics* other);

  // implements Message ----------------------------------------------

  UdpStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdpStatistics& from);
  void MergeFrom(const UdpStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 InDatagrams = 1;
  inline bool has_indatagrams() const;
  inline void clear_indatagrams();
  static const int kInDatagramsFieldNumber = 1;
  inline ::google::protobuf::int64 indatagrams() const;
  inline void set_indatagrams(::google::protobuf::int64 value);

  // optional int64 NoPorts = 2;
  inline bool has_noports() const;
  inline void clear_noports();
  static const int kNoPortsFieldNumber = 2;
  inline ::google::protobuf::int64 noports() const;
  inline void set_noports(::google::protobuf::int64 value);

  // optional int64 InErrors = 3;
  inline bool has_inerrors() const;
  inline void clear_inerrors();
  static const int kInErrorsFieldNumber = 3;
  inline ::google::protobuf::int64 inerrors() const;
  inline void set_inerrors(::google::protobuf::int64 value);

  // optional int64 OutDatagrams = 4;
  inline bool has_outdatagrams() const;
  inline void clear_outdatagrams();
  static const int kOutDatagramsFieldNumber = 4;
  inline ::google::protobuf::int64 outdatagrams() const;
  inline void set_outdatagrams(::google::protobuf::int64 value);

  // optional int64 RcvbufErrors = 5;
  inline bool has_rcvbuferrors() const;
  inline void clear_rcvbuferrors();
  static const int kRcvbufErrorsFieldNumber = 5;
  inline ::google::protobuf::int64 rcvbuferrors() const;
  inline void set_rcvbuferrors(::google::protobuf::int64 value);

  // optional int64 SndbufErrors = 6;
  inline bool has_sndbuferrors() const;
  inline void clear_sndbuferrors();
  static const int kSndbufErrorsFieldNumber = 6;
  inline ::google::protobuf::int64 sndbuferrors() const;
  inline void set_sndbuferrors(::google::protobuf::int64 value);

  // optional int64 InCsumErrors = 7;
  inline bool has_incsumerrors() const;
  inline void clear_incsumerrors();
  static const int kInCsumErrorsFieldNumber = 7;
  inline ::google::protobuf::int64 incsumerrors() const;
  inline void set_incsumerrors(::google::protobuf::int64 value);

  // optional int64 IgnoredMulti = 8;
  inline bool has_ignoredmulti() const;
  inline void clear_ignoredmulti();
  static const int kIgnoredMultiFieldNumber = 8;
  inline ::google::protobuf::int64 ignoredmulti() const;
  inline void set_ignoredmulti(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mesos.UdpStatistics)
 private:
  inline void set_has_indatagrams();
  inline void clear_has_indatagrams();
  inline void set_has_noports();
  inline void clear_has_noports();
  inline void set_has_inerrors();
  inline void clear_has_inerrors();
  inline void set_has_outdatagrams();
  inline void clear_has_outdatagrams();
  inline void set_has_rcvbuferrors();
  inline void clear_has_rcvbuferrors();
  inline void set_has_sndbuferrors();
  inline void clear_has_sndbuferrors();
  inline void set_has_incsumerrors();
  inline void clear_has_incsumerrors();
  inline void set_has_ignoredmulti();
  inline void clear_has_ignoredmulti();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 indatagrams_;
  ::google::protobuf::int64 noports_;
  ::google::protobuf::int64 inerrors_;
  ::google::protobuf::int64 outdatagrams_;
  ::google::protobuf::int64 rcvbuferrors_;
  ::google::protobuf::int64 sndbuferrors_;
  ::google::protobuf::int64 incsumerrors_;
  ::google::protobuf::int64 ignoredmulti_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static UdpStatistics* default_instance_;
};
// -------------------------------------------------------------------

class SNMPStatistics : public ::google::protobuf::Message {
 public:
  SNMPStatistics();
  virtual ~SNMPStatistics();

  SNMPStatistics(const SNMPStatistics& from);

  inline SNMPStatistics& operator=(const SNMPStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SNMPStatistics& default_instance();

  void Swap(SNMPStatistics* other);

  // implements Message ----------------------------------------------

  SNMPStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SNMPStatistics& from);
  void MergeFrom(const SNMPStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.IpStatistics ip_stats = 1;
  inline bool has_ip_stats() const;
  inline void clear_ip_stats();
  static const int kIpStatsFieldNumber = 1;
  inline const ::mesos::IpStatistics& ip_stats() const;
  inline ::mesos::IpStatistics* mutable_ip_stats();
  inline ::mesos::IpStatistics* release_ip_stats();
  inline void set_allocated_ip_stats(::mesos::IpStatistics* ip_stats);

  // optional .mesos.IcmpStatistics icmp_stats = 2;
  inline bool has_icmp_stats() const;
  inline void clear_icmp_stats();
  static const int kIcmpStatsFieldNumber = 2;
  inline const ::mesos::IcmpStatistics& icmp_stats() const;
  inline ::mesos::IcmpStatistics* mutable_icmp_stats();
  inline ::mesos::IcmpStatistics* release_icmp_stats();
  inline void set_allocated_icmp_stats(::mesos::IcmpStatistics* icmp_stats);

  // optional .mesos.TcpStatistics tcp_stats = 3;
  inline bool has_tcp_stats() const;
  inline void clear_tcp_stats();
  static const int kTcpStatsFieldNumber = 3;
  inline const ::mesos::TcpStatistics& tcp_stats() const;
  inline ::mesos::TcpStatistics* mutable_tcp_stats();
  inline ::mesos::TcpStatistics* release_tcp_stats();
  inline void set_allocated_tcp_stats(::mesos::TcpStatistics* tcp_stats);

  // optional .mesos.UdpStatistics udp_stats = 4;
  inline bool has_udp_stats() const;
  inline void clear_udp_stats();
  static const int kUdpStatsFieldNumber = 4;
  inline const ::mesos::UdpStatistics& udp_stats() const;
  inline ::mesos::UdpStatistics* mutable_udp_stats();
  inline ::mesos::UdpStatistics* release_udp_stats();
  inline void set_allocated_udp_stats(::mesos::UdpStatistics* udp_stats);

  // @@protoc_insertion_point(class_scope:mesos.SNMPStatistics)
 private:
  inline void set_has_ip_stats();
  inline void clear_has_ip_stats();
  inline void set_has_icmp_stats();
  inline void clear_has_icmp_stats();
  inline void set_has_tcp_stats();
  inline void clear_has_tcp_stats();
  inline void set_has_udp_stats();
  inline void clear_has_udp_stats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::IpStatistics* ip_stats_;
  ::mesos::IcmpStatistics* icmp_stats_;
  ::mesos::TcpStatistics* tcp_stats_;
  ::mesos::UdpStatistics* udp_stats_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static SNMPStatistics* default_instance_;
};
// -------------------------------------------------------------------

class DiskStatistics : public ::google::protobuf::Message {
 public:
  DiskStatistics();
  virtual ~DiskStatistics();

  DiskStatistics(const DiskStatistics& from);

  inline DiskStatistics& operator=(const DiskStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskStatistics& default_instance();

  void Swap(DiskStatistics* other);

  // implements Message ----------------------------------------------

  DiskStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskStatistics& from);
  void MergeFrom(const DiskStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.Resource.DiskInfo.Source source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::mesos::Resource_DiskInfo_Source& source() const;
  inline ::mesos::Resource_DiskInfo_Source* mutable_source();
  inline ::mesos::Resource_DiskInfo_Source* release_source();
  inline void set_allocated_source(::mesos::Resource_DiskInfo_Source* source);

  // optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
  inline bool has_persistence() const;
  inline void clear_persistence();
  static const int kPersistenceFieldNumber = 2;
  inline const ::mesos::Resource_DiskInfo_Persistence& persistence() const;
  inline ::mesos::Resource_DiskInfo_Persistence* mutable_persistence();
  inline ::mesos::Resource_DiskInfo_Persistence* release_persistence();
  inline void set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence);

  // optional uint64 limit_bytes = 3;
  inline bool has_limit_bytes() const;
  inline void clear_limit_bytes();
  static const int kLimitBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 limit_bytes() const;
  inline void set_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 used_bytes = 4;
  inline bool has_used_bytes() const;
  inline void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 used_bytes() const;
  inline void set_used_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.DiskStatistics)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_persistence();
  inline void clear_has_persistence();
  inline void set_has_limit_bytes();
  inline void clear_has_limit_bytes();
  inline void set_has_used_bytes();
  inline void clear_has_used_bytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Resource_DiskInfo_Source* source_;
  ::mesos::Resource_DiskInfo_Persistence* persistence_;
  ::google::protobuf::uint64 limit_bytes_;
  ::google::protobuf::uint64 used_bytes_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static DiskStatistics* default_instance_;
};
// -------------------------------------------------------------------

class ResourceStatistics : public ::google::protobuf::Message {
 public:
  ResourceStatistics();
  virtual ~ResourceStatistics();

  ResourceStatistics(const ResourceStatistics& from);

  inline ResourceStatistics& operator=(const ResourceStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceStatistics& default_instance();

  void Swap(ResourceStatistics* other);

  // implements Message ----------------------------------------------

  ResourceStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceStatistics& from);
  void MergeFrom(const ResourceStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional uint32 processes = 30;
  inline bool has_processes() const;
  inline void clear_processes();
  static const int kProcessesFieldNumber = 30;
  inline ::google::protobuf::uint32 processes() const;
  inline void set_processes(::google::protobuf::uint32 value);

  // optional uint32 threads = 31;
  inline bool has_threads() const;
  inline void clear_threads();
  static const int kThreadsFieldNumber = 31;
  inline ::google::protobuf::uint32 threads() const;
  inline void set_threads(::google::protobuf::uint32 value);

  // optional double cpus_user_time_secs = 2;
  inline bool has_cpus_user_time_secs() const;
  inline void clear_cpus_user_time_secs();
  static const int kCpusUserTimeSecsFieldNumber = 2;
  inline double cpus_user_time_secs() const;
  inline void set_cpus_user_time_secs(double value);

  // optional double cpus_system_time_secs = 3;
  inline bool has_cpus_system_time_secs() const;
  inline void clear_cpus_system_time_secs();
  static const int kCpusSystemTimeSecsFieldNumber = 3;
  inline double cpus_system_time_secs() const;
  inline void set_cpus_system_time_secs(double value);

  // optional double cpus_limit = 4;
  inline bool has_cpus_limit() const;
  inline void clear_cpus_limit();
  static const int kCpusLimitFieldNumber = 4;
  inline double cpus_limit() const;
  inline void set_cpus_limit(double value);

  // optional uint32 cpus_nr_periods = 7;
  inline bool has_cpus_nr_periods() const;
  inline void clear_cpus_nr_periods();
  static const int kCpusNrPeriodsFieldNumber = 7;
  inline ::google::protobuf::uint32 cpus_nr_periods() const;
  inline void set_cpus_nr_periods(::google::protobuf::uint32 value);

  // optional uint32 cpus_nr_throttled = 8;
  inline bool has_cpus_nr_throttled() const;
  inline void clear_cpus_nr_throttled();
  static const int kCpusNrThrottledFieldNumber = 8;
  inline ::google::protobuf::uint32 cpus_nr_throttled() const;
  inline void set_cpus_nr_throttled(::google::protobuf::uint32 value);

  // optional double cpus_throttled_time_secs = 9;
  inline bool has_cpus_throttled_time_secs() const;
  inline void clear_cpus_throttled_time_secs();
  static const int kCpusThrottledTimeSecsFieldNumber = 9;
  inline double cpus_throttled_time_secs() const;
  inline void set_cpus_throttled_time_secs(double value);

  // optional uint64 mem_total_bytes = 36;
  inline bool has_mem_total_bytes() const;
  inline void clear_mem_total_bytes();
  static const int kMemTotalBytesFieldNumber = 36;
  inline ::google::protobuf::uint64 mem_total_bytes() const;
  inline void set_mem_total_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_total_memsw_bytes = 37;
  inline bool has_mem_total_memsw_bytes() const;
  inline void clear_mem_total_memsw_bytes();
  static const int kMemTotalMemswBytesFieldNumber = 37;
  inline ::google::protobuf::uint64 mem_total_memsw_bytes() const;
  inline void set_mem_total_memsw_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_limit_bytes = 6;
  inline bool has_mem_limit_bytes() const;
  inline void clear_mem_limit_bytes();
  static const int kMemLimitBytesFieldNumber = 6;
  inline ::google::protobuf::uint64 mem_limit_bytes() const;
  inline void set_mem_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_soft_limit_bytes = 38;
  inline bool has_mem_soft_limit_bytes() const;
  inline void clear_mem_soft_limit_bytes();
  static const int kMemSoftLimitBytesFieldNumber = 38;
  inline ::google::protobuf::uint64 mem_soft_limit_bytes() const;
  inline void set_mem_soft_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_file_bytes = 10;
  inline bool has_mem_file_bytes() const;
  inline void clear_mem_file_bytes();
  static const int kMemFileBytesFieldNumber = 10;
  inline ::google::protobuf::uint64 mem_file_bytes() const;
  inline void set_mem_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_anon_bytes = 11;
  inline bool has_mem_anon_bytes() const;
  inline void clear_mem_anon_bytes();
  static const int kMemAnonBytesFieldNumber = 11;
  inline ::google::protobuf::uint64 mem_anon_bytes() const;
  inline void set_mem_anon_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_cache_bytes = 39;
  inline bool has_mem_cache_bytes() const;
  inline void clear_mem_cache_bytes();
  static const int kMemCacheBytesFieldNumber = 39;
  inline ::google::protobuf::uint64 mem_cache_bytes() const;
  inline void set_mem_cache_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_rss_bytes = 5;
  inline bool has_mem_rss_bytes() const;
  inline void clear_mem_rss_bytes();
  static const int kMemRssBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 mem_rss_bytes() const;
  inline void set_mem_rss_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_mapped_file_bytes = 12;
  inline bool has_mem_mapped_file_bytes() const;
  inline void clear_mem_mapped_file_bytes();
  static const int kMemMappedFileBytesFieldNumber = 12;
  inline ::google::protobuf::uint64 mem_mapped_file_bytes() const;
  inline void set_mem_mapped_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_swap_bytes = 40;
  inline bool has_mem_swap_bytes() const;
  inline void clear_mem_swap_bytes();
  static const int kMemSwapBytesFieldNumber = 40;
  inline ::google::protobuf::uint64 mem_swap_bytes() const;
  inline void set_mem_swap_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_unevictable_bytes = 41;
  inline bool has_mem_unevictable_bytes() const;
  inline void clear_mem_unevictable_bytes();
  static const int kMemUnevictableBytesFieldNumber = 41;
  inline ::google::protobuf::uint64 mem_unevictable_bytes() const;
  inline void set_mem_unevictable_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_low_pressure_counter = 32;
  inline bool has_mem_low_pressure_counter() const;
  inline void clear_mem_low_pressure_counter();
  static const int kMemLowPressureCounterFieldNumber = 32;
  inline ::google::protobuf::uint64 mem_low_pressure_counter() const;
  inline void set_mem_low_pressure_counter(::google::protobuf::uint64 value);

  // optional uint64 mem_medium_pressure_counter = 33;
  inline bool has_mem_medium_pressure_counter() const;
  inline void clear_mem_medium_pressure_counter();
  static const int kMemMediumPressureCounterFieldNumber = 33;
  inline ::google::protobuf::uint64 mem_medium_pressure_counter() const;
  inline void set_mem_medium_pressure_counter(::google::protobuf::uint64 value);

  // optional uint64 mem_critical_pressure_counter = 34;
  inline bool has_mem_critical_pressure_counter() const;
  inline void clear_mem_critical_pressure_counter();
  static const int kMemCriticalPressureCounterFieldNumber = 34;
  inline ::google::protobuf::uint64 mem_critical_pressure_counter() const;
  inline void set_mem_critical_pressure_counter(::google::protobuf::uint64 value);

  // optional uint64 disk_limit_bytes = 26;
  inline bool has_disk_limit_bytes() const;
  inline void clear_disk_limit_bytes();
  static const int kDiskLimitBytesFieldNumber = 26;
  inline ::google::protobuf::uint64 disk_limit_bytes() const;
  inline void set_disk_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 disk_used_bytes = 27;
  inline bool has_disk_used_bytes() const;
  inline void clear_disk_used_bytes();
  static const int kDiskUsedBytesFieldNumber = 27;
  inline ::google::protobuf::uint64 disk_used_bytes() const;
  inline void set_disk_used_bytes(::google::protobuf::uint64 value);

  // repeated .mesos.DiskStatistics disk_statistics = 43;
  inline int disk_statistics_size() const;
  inline void clear_disk_statistics();
  static const int kDiskStatisticsFieldNumber = 43;
  inline const ::mesos::DiskStatistics& disk_statistics(int index) const;
  inline ::mesos::DiskStatistics* mutable_disk_statistics(int index);
  inline ::mesos::DiskStatistics* add_disk_statistics();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >&
      disk_statistics() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >*
      mutable_disk_statistics();

  // optional .mesos.PerfStatistics perf = 13;
  inline bool has_perf() const;
  inline void clear_perf();
  static const int kPerfFieldNumber = 13;
  inline const ::mesos::PerfStatistics& perf() const;
  inline ::mesos::PerfStatistics* mutable_perf();
  inline ::mesos::PerfStatistics* release_perf();
  inline void set_allocated_perf(::mesos::PerfStatistics* perf);

  // optional uint64 net_rx_packets = 14;
  inline bool has_net_rx_packets() const;
  inline void clear_net_rx_packets();
  static const int kNetRxPacketsFieldNumber = 14;
  inline ::google::protobuf::uint64 net_rx_packets() const;
  inline void set_net_rx_packets(::google::protobuf::uint64 value);

  // optional uint64 net_rx_bytes = 15;
  inline bool has_net_rx_bytes() const;
  inline void clear_net_rx_bytes();
  static const int kNetRxBytesFieldNumber = 15;
  inline ::google::protobuf::uint64 net_rx_bytes() const;
  inline void set_net_rx_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_rx_errors = 16;
  inline bool has_net_rx_errors() const;
  inline void clear_net_rx_errors();
  static const int kNetRxErrorsFieldNumber = 16;
  inline ::google::protobuf::uint64 net_rx_errors() const;
  inline void set_net_rx_errors(::google::protobuf::uint64 value);

  // optional uint64 net_rx_dropped = 17;
  inline bool has_net_rx_dropped() const;
  inline void clear_net_rx_dropped();
  static const int kNetRxDroppedFieldNumber = 17;
  inline ::google::protobuf::uint64 net_rx_dropped() const;
  inline void set_net_rx_dropped(::google::protobuf::uint64 value);

  // optional uint64 net_tx_packets = 18;
  inline bool has_net_tx_packets() const;
  inline void clear_net_tx_packets();
  static const int kNetTxPacketsFieldNumber = 18;
  inline ::google::protobuf::uint64 net_tx_packets() const;
  inline void set_net_tx_packets(::google::protobuf::uint64 value);

  // optional uint64 net_tx_bytes = 19;
  inline bool has_net_tx_bytes() const;
  inline void clear_net_tx_bytes();
  static const int kNetTxBytesFieldNumber = 19;
  inline ::google::protobuf::uint64 net_tx_bytes() const;
  inline void set_net_tx_bytes(::google::protobuf::uint64 value);

  // optional uint64 net_tx_errors = 20;
  inline bool has_net_tx_errors() const;
  inline void clear_net_tx_errors();
  static const int kNetTxErrorsFieldNumber = 20;
  inline ::google::protobuf::uint64 net_tx_errors() const;
  inline void set_net_tx_errors(::google::protobuf::uint64 value);

  // optional uint64 net_tx_dropped = 21;
  inline bool has_net_tx_dropped() const;
  inline void clear_net_tx_dropped();
  static const int kNetTxDroppedFieldNumber = 21;
  inline ::google::protobuf::uint64 net_tx_dropped() const;
  inline void set_net_tx_dropped(::google::protobuf::uint64 value);

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  inline bool has_net_tcp_rtt_microsecs_p50() const;
  inline void clear_net_tcp_rtt_microsecs_p50();
  static const int kNetTcpRttMicrosecsP50FieldNumber = 22;
  inline double net_tcp_rtt_microsecs_p50() const;
  inline void set_net_tcp_rtt_microsecs_p50(double value);

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  inline bool has_net_tcp_rtt_microsecs_p90() const;
  inline void clear_net_tcp_rtt_microsecs_p90();
  static const int kNetTcpRttMicrosecsP90FieldNumber = 23;
  inline double net_tcp_rtt_microsecs_p90() const;
  inline void set_net_tcp_rtt_microsecs_p90(double value);

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  inline bool has_net_tcp_rtt_microsecs_p95() const;
  inline void clear_net_tcp_rtt_microsecs_p95();
  static const int kNetTcpRttMicrosecsP95FieldNumber = 24;
  inline double net_tcp_rtt_microsecs_p95() const;
  inline void set_net_tcp_rtt_microsecs_p95(double value);

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  inline bool has_net_tcp_rtt_microsecs_p99() const;
  inline void clear_net_tcp_rtt_microsecs_p99();
  static const int kNetTcpRttMicrosecsP99FieldNumber = 25;
  inline double net_tcp_rtt_microsecs_p99() const;
  inline void set_net_tcp_rtt_microsecs_p99(double value);

  // optional double net_tcp_active_connections = 28;
  inline bool has_net_tcp_active_connections() const;
  inline void clear_net_tcp_active_connections();
  static const int kNetTcpActiveConnectionsFieldNumber = 28;
  inline double net_tcp_active_connections() const;
  inline void set_net_tcp_active_connections(double value);

  // optional double net_tcp_time_wait_connections = 29;
  inline bool has_net_tcp_time_wait_connections() const;
  inline void clear_net_tcp_time_wait_connections();
  static const int kNetTcpTimeWaitConnectionsFieldNumber = 29;
  inline double net_tcp_time_wait_connections() const;
  inline void set_net_tcp_time_wait_connections(double value);

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  inline int net_traffic_control_statistics_size() const;
  inline void clear_net_traffic_control_statistics();
  static const int kNetTrafficControlStatisticsFieldNumber = 35;
  inline const ::mesos::TrafficControlStatistics& net_traffic_control_statistics(int index) const;
  inline ::mesos::TrafficControlStatistics* mutable_net_traffic_control_statistics(int index);
  inline ::mesos::TrafficControlStatistics* add_net_traffic_control_statistics();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >&
      net_traffic_control_statistics() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >*
      mutable_net_traffic_control_statistics();

  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  inline bool has_net_snmp_statistics() const;
  inline void clear_net_snmp_statistics();
  static const int kNetSnmpStatisticsFieldNumber = 42;
  inline const ::mesos::SNMPStatistics& net_snmp_statistics() const;
  inline ::mesos::SNMPStatistics* mutable_net_snmp_statistics();
  inline ::mesos::SNMPStatistics* release_net_snmp_statistics();
  inline void set_allocated_net_snmp_statistics(::mesos::SNMPStatistics* net_snmp_statistics);

  // @@protoc_insertion_point(class_scope:mesos.ResourceStatistics)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_processes();
  inline void clear_has_processes();
  inline void set_has_threads();
  inline void clear_has_threads();
  inline void set_has_cpus_user_time_secs();
  inline void clear_has_cpus_user_time_secs();
  inline void set_has_cpus_system_time_secs();
  inline void clear_has_cpus_system_time_secs();
  inline void set_has_cpus_limit();
  inline void clear_has_cpus_limit();
  inline void set_has_cpus_nr_periods();
  inline void clear_has_cpus_nr_periods();
  inline void set_has_cpus_nr_throttled();
  inline void clear_has_cpus_nr_throttled();
  inline void set_has_cpus_throttled_time_secs();
  inline void clear_has_cpus_throttled_time_secs();
  inline void set_has_mem_total_bytes();
  inline void clear_has_mem_total_bytes();
  inline void set_has_mem_total_memsw_bytes();
  inline void clear_has_mem_total_memsw_bytes();
  inline void set_has_mem_limit_bytes();
  inline void clear_has_mem_limit_bytes();
  inline void set_has_mem_soft_limit_bytes();
  inline void clear_has_mem_soft_limit_bytes();
  inline void set_has_mem_file_bytes();
  inline void clear_has_mem_file_bytes();
  inline void set_has_mem_anon_bytes();
  inline void clear_has_mem_anon_bytes();
  inline void set_has_mem_cache_bytes();
  inline void clear_has_mem_cache_bytes();
  inline void set_has_mem_rss_bytes();
  inline void clear_has_mem_rss_bytes();
  inline void set_has_mem_mapped_file_bytes();
  inline void clear_has_mem_mapped_file_bytes();
  inline void set_has_mem_swap_bytes();
  inline void clear_has_mem_swap_bytes();
  inline void set_has_mem_unevictable_bytes();
  inline void clear_has_mem_unevictable_bytes();
  inline void set_has_mem_low_pressure_counter();
  inline void clear_has_mem_low_pressure_counter();
  inline void set_has_mem_medium_pressure_counter();
  inline void clear_has_mem_medium_pressure_counter();
  inline void set_has_mem_critical_pressure_counter();
  inline void clear_has_mem_critical_pressure_counter();
  inline void set_has_disk_limit_bytes();
  inline void clear_has_disk_limit_bytes();
  inline void set_has_disk_used_bytes();
  inline void clear_has_disk_used_bytes();
  inline void set_has_perf();
  inline void clear_has_perf();
  inline void set_has_net_rx_packets();
  inline void clear_has_net_rx_packets();
  inline void set_has_net_rx_bytes();
  inline void clear_has_net_rx_bytes();
  inline void set_has_net_rx_errors();
  inline void clear_has_net_rx_errors();
  inline void set_has_net_rx_dropped();
  inline void clear_has_net_rx_dropped();
  inline void set_has_net_tx_packets();
  inline void clear_has_net_tx_packets();
  inline void set_has_net_tx_bytes();
  inline void clear_has_net_tx_bytes();
  inline void set_has_net_tx_errors();
  inline void clear_has_net_tx_errors();
  inline void set_has_net_tx_dropped();
  inline void clear_has_net_tx_dropped();
  inline void set_has_net_tcp_rtt_microsecs_p50();
  inline void clear_has_net_tcp_rtt_microsecs_p50();
  inline void set_has_net_tcp_rtt_microsecs_p90();
  inline void clear_has_net_tcp_rtt_microsecs_p90();
  inline void set_has_net_tcp_rtt_microsecs_p95();
  inline void clear_has_net_tcp_rtt_microsecs_p95();
  inline void set_has_net_tcp_rtt_microsecs_p99();
  inline void clear_has_net_tcp_rtt_microsecs_p99();
  inline void set_has_net_tcp_active_connections();
  inline void clear_has_net_tcp_active_connections();
  inline void set_has_net_tcp_time_wait_connections();
  inline void clear_has_net_tcp_time_wait_connections();
  inline void set_has_net_snmp_statistics();
  inline void clear_has_net_snmp_statistics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  double timestamp_;
  ::google::protobuf::uint32 processes_;
  ::google::protobuf::uint32 threads_;
  double cpus_user_time_secs_;
  double cpus_system_time_secs_;
  double cpus_limit_;
  ::google::protobuf::uint32 cpus_nr_periods_;
  ::google::protobuf::uint32 cpus_nr_throttled_;
  double cpus_throttled_time_secs_;
  ::google::protobuf::uint64 mem_total_bytes_;
  ::google::protobuf::uint64 mem_total_memsw_bytes_;
  ::google::protobuf::uint64 mem_limit_bytes_;
  ::google::protobuf::uint64 mem_soft_limit_bytes_;
  ::google::protobuf::uint64 mem_file_bytes_;
  ::google::protobuf::uint64 mem_anon_bytes_;
  ::google::protobuf::uint64 mem_cache_bytes_;
  ::google::protobuf::uint64 mem_rss_bytes_;
  ::google::protobuf::uint64 mem_mapped_file_bytes_;
  ::google::protobuf::uint64 mem_swap_bytes_;
  ::google::protobuf::uint64 mem_unevictable_bytes_;
  ::google::protobuf::uint64 mem_low_pressure_counter_;
  ::google::protobuf::uint64 mem_medium_pressure_counter_;
  ::google::protobuf::uint64 mem_critical_pressure_counter_;
  ::google::protobuf::uint64 disk_limit_bytes_;
  ::google::protobuf::uint64 disk_used_bytes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics > disk_statistics_;
  ::mesos::PerfStatistics* perf_;
  ::google::protobuf::uint64 net_rx_packets_;
  ::google::protobuf::uint64 net_rx_bytes_;
  ::google::protobuf::uint64 net_rx_errors_;
  ::google::protobuf::uint64 net_rx_dropped_;
  ::google::protobuf::uint64 net_tx_packets_;
  ::google::protobuf::uint64 net_tx_bytes_;
  ::google::protobuf::uint64 net_tx_errors_;
  ::google::protobuf::uint64 net_tx_dropped_;
  double net_tcp_rtt_microsecs_p50_;
  double net_tcp_rtt_microsecs_p90_;
  double net_tcp_rtt_microsecs_p95_;
  double net_tcp_rtt_microsecs_p99_;
  double net_tcp_active_connections_;
  double net_tcp_time_wait_connections_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics > net_traffic_control_statistics_;
  ::mesos::SNMPStatistics* net_snmp_statistics_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceStatistics* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUsage_Executor_Task : public ::google::protobuf::Message {
 public:
  ResourceUsage_Executor_Task();
  virtual ~ResourceUsage_Executor_Task();

  ResourceUsage_Executor_Task(const ResourceUsage_Executor_Task& from);

  inline ResourceUsage_Executor_Task& operator=(const ResourceUsage_Executor_Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage_Executor_Task& default_instance();

  void Swap(ResourceUsage_Executor_Task* other);

  // implements Message ----------------------------------------------

  ResourceUsage_Executor_Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceUsage_Executor_Task& from);
  void MergeFrom(const ResourceUsage_Executor_Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.TaskID id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::mesos::TaskID& id() const;
  inline ::mesos::TaskID* mutable_id();
  inline ::mesos::TaskID* release_id();
  inline void set_allocated_id(::mesos::TaskID* id);

  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional .mesos.Labels labels = 4;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 4;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage.Executor.Task)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::mesos::TaskID* id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::Labels* labels_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceUsage_Executor_Task* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUsage_Executor : public ::google::protobuf::Message {
 public:
  ResourceUsage_Executor();
  virtual ~ResourceUsage_Executor();

  ResourceUsage_Executor(const ResourceUsage_Executor& from);

  inline ResourceUsage_Executor& operator=(const ResourceUsage_Executor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage_Executor& default_instance();

  void Swap(ResourceUsage_Executor* other);

  // implements Message ----------------------------------------------

  ResourceUsage_Executor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceUsage_Executor& from);
  void MergeFrom(const ResourceUsage_Executor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResourceUsage_Executor_Task Task;

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorInfo executor_info = 1;
  inline bool has_executor_info() const;
  inline void clear_executor_info();
  static const int kExecutorInfoFieldNumber = 1;
  inline const ::mesos::ExecutorInfo& executor_info() const;
  inline ::mesos::ExecutorInfo* mutable_executor_info();
  inline ::mesos::ExecutorInfo* release_executor_info();
  inline void set_allocated_executor_info(::mesos::ExecutorInfo* executor_info);

  // repeated .mesos.Resource allocated = 2;
  inline int allocated_size() const;
  inline void clear_allocated();
  static const int kAllocatedFieldNumber = 2;
  inline const ::mesos::Resource& allocated(int index) const;
  inline ::mesos::Resource* mutable_allocated(int index);
  inline ::mesos::Resource* add_allocated();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      allocated() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_allocated();

  // optional .mesos.ResourceStatistics statistics = 3;
  inline bool has_statistics() const;
  inline void clear_statistics();
  static const int kStatisticsFieldNumber = 3;
  inline const ::mesos::ResourceStatistics& statistics() const;
  inline ::mesos::ResourceStatistics* mutable_statistics();
  inline ::mesos::ResourceStatistics* release_statistics();
  inline void set_allocated_statistics(::mesos::ResourceStatistics* statistics);

  // required .mesos.ContainerID container_id = 4;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  inline const ::mesos::ContainerID& container_id() const;
  inline ::mesos::ContainerID* mutable_container_id();
  inline ::mesos::ContainerID* release_container_id();
  inline void set_allocated_container_id(::mesos::ContainerID* container_id);

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 5;
  inline const ::mesos::ResourceUsage_Executor_Task& tasks(int index) const;
  inline ::mesos::ResourceUsage_Executor_Task* mutable_tasks(int index);
  inline ::mesos::ResourceUsage_Executor_Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage.Executor)
 private:
  inline void set_has_executor_info();
  inline void clear_has_executor_info();
  inline void set_has_statistics();
  inline void clear_has_statistics();
  inline void set_has_container_id();
  inline void clear_has_container_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_info_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > allocated_;
  ::mesos::ResourceStatistics* statistics_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task > tasks_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceUsage_Executor* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUsage : public ::google::protobuf::Message {
 public:
  ResourceUsage();
  virtual ~ResourceUsage();

  ResourceUsage(const ResourceUsage& from);

  inline ResourceUsage& operator=(const ResourceUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage& default_instance();

  void Swap(ResourceUsage* other);

  // implements Message ----------------------------------------------

  ResourceUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceUsage& from);
  void MergeFrom(const ResourceUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResourceUsage_Executor Executor;

  // accessors -------------------------------------------------------

  // repeated .mesos.ResourceUsage.Executor executors = 1;
  inline int executors_size() const;
  inline void clear_executors();
  static const int kExecutorsFieldNumber = 1;
  inline const ::mesos::ResourceUsage_Executor& executors(int index) const;
  inline ::mesos::ResourceUsage_Executor* mutable_executors(int index);
  inline ::mesos::ResourceUsage_Executor* add_executors();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >&
      executors() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >*
      mutable_executors();

  // repeated .mesos.Resource total = 2;
  inline int total_size() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline const ::mesos::Resource& total(int index) const;
  inline ::mesos::Resource* mutable_total(int index);
  inline ::mesos::Resource* add_total();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      total() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_total();

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor > executors_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > total_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceUsage* default_instance_;
};
// -------------------------------------------------------------------

class PerfStatistics : public ::google::protobuf::Message {
 public:
  PerfStatistics();
  virtual ~PerfStatistics();

  PerfStatistics(const PerfStatistics& from);

  inline PerfStatistics& operator=(const PerfStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerfStatistics& default_instance();

  void Swap(PerfStatistics* other);

  // implements Message ----------------------------------------------

  PerfStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerfStatistics& from);
  void MergeFrom(const PerfStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // required double duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline double duration() const;
  inline void set_duration(double value);

  // optional uint64 cycles = 3;
  inline bool has_cycles() const;
  inline void clear_cycles();
  static const int kCyclesFieldNumber = 3;
  inline ::google::protobuf::uint64 cycles() const;
  inline void set_cycles(::google::protobuf::uint64 value);

  // optional uint64 stalled_cycles_frontend = 4;
  inline bool has_stalled_cycles_frontend() const;
  inline void clear_stalled_cycles_frontend();
  static const int kStalledCyclesFrontendFieldNumber = 4;
  inline ::google::protobuf::uint64 stalled_cycles_frontend() const;
  inline void set_stalled_cycles_frontend(::google::protobuf::uint64 value);

  // optional uint64 stalled_cycles_backend = 5;
  inline bool has_stalled_cycles_backend() const;
  inline void clear_stalled_cycles_backend();
  static const int kStalledCyclesBackendFieldNumber = 5;
  inline ::google::protobuf::uint64 stalled_cycles_backend() const;
  inline void set_stalled_cycles_backend(::google::protobuf::uint64 value);

  // optional uint64 instructions = 6;
  inline bool has_instructions() const;
  inline void clear_instructions();
  static const int kInstructionsFieldNumber = 6;
  inline ::google::protobuf::uint64 instructions() const;
  inline void set_instructions(::google::protobuf::uint64 value);

  // optional uint64 cache_references = 7;
  inline bool has_cache_references() const;
  inline void clear_cache_references();
  static const int kCacheReferencesFieldNumber = 7;
  inline ::google::protobuf::uint64 cache_references() const;
  inline void set_cache_references(::google::protobuf::uint64 value);

  // optional uint64 cache_misses = 8;
  inline bool has_cache_misses() const;
  inline void clear_cache_misses();
  static const int kCacheMissesFieldNumber = 8;
  inline ::google::protobuf::uint64 cache_misses() const;
  inline void set_cache_misses(::google::protobuf::uint64 value);

  // optional uint64 branches = 9;
  inline bool has_branches() const;
  inline void clear_branches();
  static const int kBranchesFieldNumber = 9;
  inline ::google::protobuf::uint64 branches() const;
  inline void set_branches(::google::protobuf::uint64 value);

  // optional uint64 branch_misses = 10;
  inline bool has_branch_misses() const;
  inline void clear_branch_misses();
  static const int kBranchMissesFieldNumber = 10;
  inline ::google::protobuf::uint64 branch_misses() const;
  inline void set_branch_misses(::google::protobuf::uint64 value);

  // optional uint64 bus_cycles = 11;
  inline bool has_bus_cycles() const;
  inline void clear_bus_cycles();
  static const int kBusCyclesFieldNumber = 11;
  inline ::google::protobuf::uint64 bus_cycles() const;
  inline void set_bus_cycles(::google::protobuf::uint64 value);

  // optional uint64 ref_cycles = 12;
  inline bool has_ref_cycles() const;
  inline void clear_ref_cycles();
  static const int kRefCyclesFieldNumber = 12;
  inline ::google::protobuf::uint64 ref_cycles() const;
  inline void set_ref_cycles(::google::protobuf::uint64 value);

  // optional double cpu_clock = 13;
  inline bool has_cpu_clock() const;
  inline void clear_cpu_clock();
  static const int kCpuClockFieldNumber = 13;
  inline double cpu_clock() const;
  inline void set_cpu_clock(double value);

  // optional double task_clock = 14;
  inline bool has_task_clock() const;
  inline void clear_task_clock();
  static const int kTaskClockFieldNumber = 14;
  inline double task_clock() const;
  inline void set_task_clock(double value);

  // optional uint64 page_faults = 15;
  inline bool has_page_faults() const;
  inline void clear_page_faults();
  static const int kPageFaultsFieldNumber = 15;
  inline ::google::protobuf::uint64 page_faults() const;
  inline void set_page_faults(::google::protobuf::uint64 value);

  // optional uint64 minor_faults = 16;
  inline bool has_minor_faults() const;
  inline void clear_minor_faults();
  static const int kMinorFaultsFieldNumber = 16;
  inline ::google::protobuf::uint64 minor_faults() const;
  inline void set_minor_faults(::google::protobuf::uint64 value);

  // optional uint64 major_faults = 17;
  inline bool has_major_faults() const;
  inline void clear_major_faults();
  static const int kMajorFaultsFieldNumber = 17;
  inline ::google::protobuf::uint64 major_faults() const;
  inline void set_major_faults(::google::protobuf::uint64 value);

  // optional uint64 context_switches = 18;
  inline bool has_context_switches() const;
  inline void clear_context_switches();
  static const int kContextSwitchesFieldNumber = 18;
  inline ::google::protobuf::uint64 context_switches() const;
  inline void set_context_switches(::google::protobuf::uint64 value);

  // optional uint64 cpu_migrations = 19;
  inline bool has_cpu_migrations() const;
  inline void clear_cpu_migrations();
  static const int kCpuMigrationsFieldNumber = 19;
  inline ::google::protobuf::uint64 cpu_migrations() const;
  inline void set_cpu_migrations(::google::protobuf::uint64 value);

  // optional uint64 alignment_faults = 20;
  inline bool has_alignment_faults() const;
  inline void clear_alignment_faults();
  static const int kAlignmentFaultsFieldNumber = 20;
  inline ::google::protobuf::uint64 alignment_faults() const;
  inline void set_alignment_faults(::google::protobuf::uint64 value);

  // optional uint64 emulation_faults = 21;
  inline bool has_emulation_faults() const;
  inline void clear_emulation_faults();
  static const int kEmulationFaultsFieldNumber = 21;
  inline ::google::protobuf::uint64 emulation_faults() const;
  inline void set_emulation_faults(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_loads = 22;
  inline bool has_l1_dcache_loads() const;
  inline void clear_l1_dcache_loads();
  static const int kL1DcacheLoadsFieldNumber = 22;
  inline ::google::protobuf::uint64 l1_dcache_loads() const;
  inline void set_l1_dcache_loads(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_load_misses = 23;
  inline bool has_l1_dcache_load_misses() const;
  inline void clear_l1_dcache_load_misses();
  static const int kL1DcacheLoadMissesFieldNumber = 23;
  inline ::google::protobuf::uint64 l1_dcache_load_misses() const;
  inline void set_l1_dcache_load_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_stores = 24;
  inline bool has_l1_dcache_stores() const;
  inline void clear_l1_dcache_stores();
  static const int kL1DcacheStoresFieldNumber = 24;
  inline ::google::protobuf::uint64 l1_dcache_stores() const;
  inline void set_l1_dcache_stores(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_store_misses = 25;
  inline bool has_l1_dcache_store_misses() const;
  inline void clear_l1_dcache_store_misses();
  static const int kL1DcacheStoreMissesFieldNumber = 25;
  inline ::google::protobuf::uint64 l1_dcache_store_misses() const;
  inline void set_l1_dcache_store_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_prefetches = 26;
  inline bool has_l1_dcache_prefetches() const;
  inline void clear_l1_dcache_prefetches();
  static const int kL1DcachePrefetchesFieldNumber = 26;
  inline ::google::protobuf::uint64 l1_dcache_prefetches() const;
  inline void set_l1_dcache_prefetches(::google::protobuf::uint64 value);

  // optional uint64 l1_dcache_prefetch_misses = 27;
  inline bool has_l1_dcache_prefetch_misses() const;
  inline void clear_l1_dcache_prefetch_misses();
  static const int kL1DcachePrefetchMissesFieldNumber = 27;
  inline ::google::protobuf::uint64 l1_dcache_prefetch_misses() const;
  inline void set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_loads = 28;
  inline bool has_l1_icache_loads() const;
  inline void clear_l1_icache_loads();
  static const int kL1IcacheLoadsFieldNumber = 28;
  inline ::google::protobuf::uint64 l1_icache_loads() const;
  inline void set_l1_icache_loads(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_load_misses = 29;
  inline bool has_l1_icache_load_misses() const;
  inline void clear_l1_icache_load_misses();
  static const int kL1IcacheLoadMissesFieldNumber = 29;
  inline ::google::protobuf::uint64 l1_icache_load_misses() const;
  inline void set_l1_icache_load_misses(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_prefetches = 30;
  inline bool has_l1_icache_prefetches() const;
  inline void clear_l1_icache_prefetches();
  static const int kL1IcachePrefetchesFieldNumber = 30;
  inline ::google::protobuf::uint64 l1_icache_prefetches() const;
  inline void set_l1_icache_prefetches(::google::protobuf::uint64 value);

  // optional uint64 l1_icache_prefetch_misses = 31;
  inline bool has_l1_icache_prefetch_misses() const;
  inline void clear_l1_icache_prefetch_misses();
  static const int kL1IcachePrefetchMissesFieldNumber = 31;
  inline ::google::protobuf::uint64 l1_icache_prefetch_misses() const;
  inline void set_l1_icache_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_loads = 32;
  inline bool has_llc_loads() const;
  inline void clear_llc_loads();
  static const int kLlcLoadsFieldNumber = 32;
  inline ::google::protobuf::uint64 llc_loads() const;
  inline void set_llc_loads(::google::protobuf::uint64 value);

  // optional uint64 llc_load_misses = 33;
  inline bool has_llc_load_misses() const;
  inline void clear_llc_load_misses();
  static const int kLlcLoadMissesFieldNumber = 33;
  inline ::google::protobuf::uint64 llc_load_misses() const;
  inline void set_llc_load_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_stores = 34;
  inline bool has_llc_stores() const;
  inline void clear_llc_stores();
  static const int kLlcStoresFieldNumber = 34;
  inline ::google::protobuf::uint64 llc_stores() const;
  inline void set_llc_stores(::google::protobuf::uint64 value);

  // optional uint64 llc_store_misses = 35;
  inline bool has_llc_store_misses() const;
  inline void clear_llc_store_misses();
  static const int kLlcStoreMissesFieldNumber = 35;
  inline ::google::protobuf::uint64 llc_store_misses() const;
  inline void set_llc_store_misses(::google::protobuf::uint64 value);

  // optional uint64 llc_prefetches = 36;
  inline bool has_llc_prefetches() const;
  inline void clear_llc_prefetches();
  static const int kLlcPrefetchesFieldNumber = 36;
  inline ::google::protobuf::uint64 llc_prefetches() const;
  inline void set_llc_prefetches(::google::protobuf::uint64 value);

  // optional uint64 llc_prefetch_misses = 37;
  inline bool has_llc_prefetch_misses() const;
  inline void clear_llc_prefetch_misses();
  static const int kLlcPrefetchMissesFieldNumber = 37;
  inline ::google::protobuf::uint64 llc_prefetch_misses() const;
  inline void set_llc_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_loads = 38;
  inline bool has_dtlb_loads() const;
  inline void clear_dtlb_loads();
  static const int kDtlbLoadsFieldNumber = 38;
  inline ::google::protobuf::uint64 dtlb_loads() const;
  inline void set_dtlb_loads(::google::protobuf::uint64 value);

  // optional uint64 dtlb_load_misses = 39;
  inline bool has_dtlb_load_misses() const;
  inline void clear_dtlb_load_misses();
  static const int kDtlbLoadMissesFieldNumber = 39;
  inline ::google::protobuf::uint64 dtlb_load_misses() const;
  inline void set_dtlb_load_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_stores = 40;
  inline bool has_dtlb_stores() const;
  inline void clear_dtlb_stores();
  static const int kDtlbStoresFieldNumber = 40;
  inline ::google::protobuf::uint64 dtlb_stores() const;
  inline void set_dtlb_stores(::google::protobuf::uint64 value);

  // optional uint64 dtlb_store_misses = 41;
  inline bool has_dtlb_store_misses() const;
  inline void clear_dtlb_store_misses();
  static const int kDtlbStoreMissesFieldNumber = 41;
  inline ::google::protobuf::uint64 dtlb_store_misses() const;
  inline void set_dtlb_store_misses(::google::protobuf::uint64 value);

  // optional uint64 dtlb_prefetches = 42;
  inline bool has_dtlb_prefetches() const;
  inline void clear_dtlb_prefetches();
  static const int kDtlbPrefetchesFieldNumber = 42;
  inline ::google::protobuf::uint64 dtlb_prefetches() const;
  inline void set_dtlb_prefetches(::google::protobuf::uint64 value);

  // optional uint64 dtlb_prefetch_misses = 43;
  inline bool has_dtlb_prefetch_misses() const;
  inline void clear_dtlb_prefetch_misses();
  static const int kDtlbPrefetchMissesFieldNumber = 43;
  inline ::google::protobuf::uint64 dtlb_prefetch_misses() const;
  inline void set_dtlb_prefetch_misses(::google::protobuf::uint64 value);

  // optional uint64 itlb_loads = 44;
  inline bool has_itlb_loads() const;
  inline void clear_itlb_loads();
  static const int kItlbLoadsFieldNumber = 44;
  inline ::google::protobuf::uint64 itlb_loads() const;
  inline void set_itlb_loads(::google::protobuf::uint64 value);

  // optional uint64 itlb_load_misses = 45;
  inline bool has_itlb_load_misses() const;
  inline void clear_itlb_load_misses();
  static const int kItlbLoadMissesFieldNumber = 45;
  inline ::google::protobuf::uint64 itlb_load_misses() const;
  inline void set_itlb_load_misses(::google::protobuf::uint64 value);

  // optional uint64 branch_loads = 46;
  inline bool has_branch_loads() const;
  inline void clear_branch_loads();
  static const int kBranchLoadsFieldNumber = 46;
  inline ::google::protobuf::uint64 branch_loads() const;
  inline void set_branch_loads(::google::protobuf::uint64 value);

  // optional uint64 branch_load_misses = 47;
  inline bool has_branch_load_misses() const;
  inline void clear_branch_load_misses();
  static const int kBranchLoadMissesFieldNumber = 47;
  inline ::google::protobuf::uint64 branch_load_misses() const;
  inline void set_branch_load_misses(::google::protobuf::uint64 value);

  // optional uint64 node_loads = 48;
  inline bool has_node_loads() const;
  inline void clear_node_loads();
  static const int kNodeLoadsFieldNumber = 48;
  inline ::google::protobuf::uint64 node_loads() const;
  inline void set_node_loads(::google::protobuf::uint64 value);

  // optional uint64 node_load_misses = 49;
  inline bool has_node_load_misses() const;
  inline void clear_node_load_misses();
  static const int kNodeLoadMissesFieldNumber = 49;
  inline ::google::protobuf::uint64 node_load_misses() const;
  inline void set_node_load_misses(::google::protobuf::uint64 value);

  // optional uint64 node_stores = 50;
  inline bool has_node_stores() const;
  inline void clear_node_stores();
  static const int kNodeStoresFieldNumber = 50;
  inline ::google::protobuf::uint64 node_stores() const;
  inline void set_node_stores(::google::protobuf::uint64 value);

  // optional uint64 node_store_misses = 51;
  inline bool has_node_store_misses() const;
  inline void clear_node_store_misses();
  static const int kNodeStoreMissesFieldNumber = 51;
  inline ::google::protobuf::uint64 node_store_misses() const;
  inline void set_node_store_misses(::google::protobuf::uint64 value);

  // optional uint64 node_prefetches = 52;
  inline bool has_node_prefetches() const;
  inline void clear_node_prefetches();
  static const int kNodePrefetchesFieldNumber = 52;
  inline ::google::protobuf::uint64 node_prefetches() const;
  inline void set_node_prefetches(::google::protobuf::uint64 value);

  // optional uint64 node_prefetch_misses = 53;
  inline bool has_node_prefetch_misses() const;
  inline void clear_node_prefetch_misses();
  static const int kNodePrefetchMissesFieldNumber = 53;
  inline ::google::protobuf::uint64 node_prefetch_misses() const;
  inline void set_node_prefetch_misses(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.PerfStatistics)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_cycles();
  inline void clear_has_cycles();
  inline void set_has_stalled_cycles_frontend();
  inline void clear_has_stalled_cycles_frontend();
  inline void set_has_stalled_cycles_backend();
  inline void clear_has_stalled_cycles_backend();
  inline void set_has_instructions();
  inline void clear_has_instructions();
  inline void set_has_cache_references();
  inline void clear_has_cache_references();
  inline void set_has_cache_misses();
  inline void clear_has_cache_misses();
  inline void set_has_branches();
  inline void clear_has_branches();
  inline void set_has_branch_misses();
  inline void clear_has_branch_misses();
  inline void set_has_bus_cycles();
  inline void clear_has_bus_cycles();
  inline void set_has_ref_cycles();
  inline void clear_has_ref_cycles();
  inline void set_has_cpu_clock();
  inline void clear_has_cpu_clock();
  inline void set_has_task_clock();
  inline void clear_has_task_clock();
  inline void set_has_page_faults();
  inline void clear_has_page_faults();
  inline void set_has_minor_faults();
  inline void clear_has_minor_faults();
  inline void set_has_major_faults();
  inline void clear_has_major_faults();
  inline void set_has_context_switches();
  inline void clear_has_context_switches();
  inline void set_has_cpu_migrations();
  inline void clear_has_cpu_migrations();
  inline void set_has_alignment_faults();
  inline void clear_has_alignment_faults();
  inline void set_has_emulation_faults();
  inline void clear_has_emulation_faults();
  inline void set_has_l1_dcache_loads();
  inline void clear_has_l1_dcache_loads();
  inline void set_has_l1_dcache_load_misses();
  inline void clear_has_l1_dcache_load_misses();
  inline void set_has_l1_dcache_stores();
  inline void clear_has_l1_dcache_stores();
  inline void set_has_l1_dcache_store_misses();
  inline void clear_has_l1_dcache_store_misses();
  inline void set_has_l1_dcache_prefetches();
  inline void clear_has_l1_dcache_prefetches();
  inline void set_has_l1_dcache_prefetch_misses();
  inline void clear_has_l1_dcache_prefetch_misses();
  inline void set_has_l1_icache_loads();
  inline void clear_has_l1_icache_loads();
  inline void set_has_l1_icache_load_misses();
  inline void clear_has_l1_icache_load_misses();
  inline void set_has_l1_icache_prefetches();
  inline void clear_has_l1_icache_prefetches();
  inline void set_has_l1_icache_prefetch_misses();
  inline void clear_has_l1_icache_prefetch_misses();
  inline void set_has_llc_loads();
  inline void clear_has_llc_loads();
  inline void set_has_llc_load_misses();
  inline void clear_has_llc_load_misses();
  inline void set_has_llc_stores();
  inline void clear_has_llc_stores();
  inline void set_has_llc_store_misses();
  inline void clear_has_llc_store_misses();
  inline void set_has_llc_prefetches();
  inline void clear_has_llc_prefetches();
  inline void set_has_llc_prefetch_misses();
  inline void clear_has_llc_prefetch_misses();
  inline void set_has_dtlb_loads();
  inline void clear_has_dtlb_loads();
  inline void set_has_dtlb_load_misses();
  inline void clear_has_dtlb_load_misses();
  inline void set_has_dtlb_stores();
  inline void clear_has_dtlb_stores();
  inline void set_has_dtlb_store_misses();
  inline void clear_has_dtlb_store_misses();
  inline void set_has_dtlb_prefetches();
  inline void clear_has_dtlb_prefetches();
  inline void set_has_dtlb_prefetch_misses();
  inline void clear_has_dtlb_prefetch_misses();
  inline void set_has_itlb_loads();
  inline void clear_has_itlb_loads();
  inline void set_has_itlb_load_misses();
  inline void clear_has_itlb_load_misses();
  inline void set_has_branch_loads();
  inline void clear_has_branch_loads();
  inline void set_has_branch_load_misses();
  inline void clear_has_branch_load_misses();
  inline void set_has_node_loads();
  inline void clear_has_node_loads();
  inline void set_has_node_load_misses();
  inline void clear_has_node_load_misses();
  inline void set_has_node_stores();
  inline void clear_has_node_stores();
  inline void set_has_node_store_misses();
  inline void clear_has_node_store_misses();
  inline void set_has_node_prefetches();
  inline void clear_has_node_prefetches();
  inline void set_has_node_prefetch_misses();
  inline void clear_has_node_prefetch_misses();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  double timestamp_;
  double duration_;
  ::google::protobuf::uint64 cycles_;
  ::google::protobuf::uint64 stalled_cycles_frontend_;
  ::google::protobuf::uint64 stalled_cycles_backend_;
  ::google::protobuf::uint64 instructions_;
  ::google::protobuf::uint64 cache_references_;
  ::google::protobuf::uint64 cache_misses_;
  ::google::protobuf::uint64 branches_;
  ::google::protobuf::uint64 branch_misses_;
  ::google::protobuf::uint64 bus_cycles_;
  ::google::protobuf::uint64 ref_cycles_;
  double cpu_clock_;
  double task_clock_;
  ::google::protobuf::uint64 page_faults_;
  ::google::protobuf::uint64 minor_faults_;
  ::google::protobuf::uint64 major_faults_;
  ::google::protobuf::uint64 context_switches_;
  ::google::protobuf::uint64 cpu_migrations_;
  ::google::protobuf::uint64 alignment_faults_;
  ::google::protobuf::uint64 emulation_faults_;
  ::google::protobuf::uint64 l1_dcache_loads_;
  ::google::protobuf::uint64 l1_dcache_load_misses_;
  ::google::protobuf::uint64 l1_dcache_stores_;
  ::google::protobuf::uint64 l1_dcache_store_misses_;
  ::google::protobuf::uint64 l1_dcache_prefetches_;
  ::google::protobuf::uint64 l1_dcache_prefetch_misses_;
  ::google::protobuf::uint64 l1_icache_loads_;
  ::google::protobuf::uint64 l1_icache_load_misses_;
  ::google::protobuf::uint64 l1_icache_prefetches_;
  ::google::protobuf::uint64 l1_icache_prefetch_misses_;
  ::google::protobuf::uint64 llc_loads_;
  ::google::protobuf::uint64 llc_load_misses_;
  ::google::protobuf::uint64 llc_stores_;
  ::google::protobuf::uint64 llc_store_misses_;
  ::google::protobuf::uint64 llc_prefetches_;
  ::google::protobuf::uint64 llc_prefetch_misses_;
  ::google::protobuf::uint64 dtlb_loads_;
  ::google::protobuf::uint64 dtlb_load_misses_;
  ::google::protobuf::uint64 dtlb_stores_;
  ::google::protobuf::uint64 dtlb_store_misses_;
  ::google::protobuf::uint64 dtlb_prefetches_;
  ::google::protobuf::uint64 dtlb_prefetch_misses_;
  ::google::protobuf::uint64 itlb_loads_;
  ::google::protobuf::uint64 itlb_load_misses_;
  ::google::protobuf::uint64 branch_loads_;
  ::google::protobuf::uint64 branch_load_misses_;
  ::google::protobuf::uint64 node_loads_;
  ::google::protobuf::uint64 node_load_misses_;
  ::google::protobuf::uint64 node_stores_;
  ::google::protobuf::uint64 node_store_misses_;
  ::google::protobuf::uint64 node_prefetches_;
  ::google::protobuf::uint64 node_prefetch_misses_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static PerfStatistics* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource resources = 2;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 2;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Request)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Launch : public ::google::protobuf::Message {
 public:
  Offer_Operation_Launch();
  virtual ~Offer_Operation_Launch();

  Offer_Operation_Launch(const Offer_Operation_Launch& from);

  inline Offer_Operation_Launch& operator=(const Offer_Operation_Launch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Launch& default_instance();

  void Swap(Offer_Operation_Launch* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Launch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Launch& from);
  void MergeFrom(const Offer_Operation_Launch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskInfo task_infos = 1;
  inline int task_infos_size() const;
  inline void clear_task_infos();
  static const int kTaskInfosFieldNumber = 1;
  inline const ::mesos::TaskInfo& task_infos(int index) const;
  inline ::mesos::TaskInfo* mutable_task_infos(int index);
  inline ::mesos::TaskInfo* add_task_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      task_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_task_infos();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Launch)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > task_infos_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Launch* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_LaunchGroup : public ::google::protobuf::Message {
 public:
  Offer_Operation_LaunchGroup();
  virtual ~Offer_Operation_LaunchGroup();

  Offer_Operation_LaunchGroup(const Offer_Operation_LaunchGroup& from);

  inline Offer_Operation_LaunchGroup& operator=(const Offer_Operation_LaunchGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_LaunchGroup& default_instance();

  void Swap(Offer_Operation_LaunchGroup* other);

  // implements Message ----------------------------------------------

  Offer_Operation_LaunchGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_LaunchGroup& from);
  void MergeFrom(const Offer_Operation_LaunchGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorInfo executor = 1;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 1;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  inline ::mesos::ExecutorInfo* release_executor();
  inline void set_allocated_executor(::mesos::ExecutorInfo* executor);

  // required .mesos.TaskGroupInfo task_group = 2;
  inline bool has_task_group() const;
  inline void clear_task_group();
  static const int kTaskGroupFieldNumber = 2;
  inline const ::mesos::TaskGroupInfo& task_group() const;
  inline ::mesos::TaskGroupInfo* mutable_task_group();
  inline ::mesos::TaskGroupInfo* release_task_group();
  inline void set_allocated_task_group(::mesos::TaskGroupInfo* task_group);

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.LaunchGroup)
 private:
  inline void set_has_executor();
  inline void clear_has_executor();
  inline void set_has_task_group();
  inline void clear_has_task_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::TaskGroupInfo* task_group_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_LaunchGroup* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Reserve : public ::google::protobuf::Message {
 public:
  Offer_Operation_Reserve();
  virtual ~Offer_Operation_Reserve();

  Offer_Operation_Reserve(const Offer_Operation_Reserve& from);

  inline Offer_Operation_Reserve& operator=(const Offer_Operation_Reserve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Reserve& default_instance();

  void Swap(Offer_Operation_Reserve* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Reserve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Reserve& from);
  void MergeFrom(const Offer_Operation_Reserve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Reserve)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Reserve* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Unreserve : public ::google::protobuf::Message {
 public:
  Offer_Operation_Unreserve();
  virtual ~Offer_Operation_Unreserve();

  Offer_Operation_Unreserve(const Offer_Operation_Unreserve& from);

  inline Offer_Operation_Unreserve& operator=(const Offer_Operation_Unreserve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Unreserve& default_instance();

  void Swap(Offer_Operation_Unreserve* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Unreserve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Unreserve& from);
  void MergeFrom(const Offer_Operation_Unreserve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 1;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Unreserve)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Unreserve* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Create : public ::google::protobuf::Message {
 public:
  Offer_Operation_Create();
  virtual ~Offer_Operation_Create();

  Offer_Operation_Create(const Offer_Operation_Create& from);

  inline Offer_Operation_Create& operator=(const Offer_Operation_Create& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Create& default_instance();

  void Swap(Offer_Operation_Create* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Create* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Create& from);
  void MergeFrom(const Offer_Operation_Create& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::mesos::Resource& volumes(int index) const;
  inline ::mesos::Resource* mutable_volumes(int index);
  inline ::mesos::Resource* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Create)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Create* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation_Destroy : public ::google::protobuf::Message {
 public:
  Offer_Operation_Destroy();
  virtual ~Offer_Operation_Destroy();

  Offer_Operation_Destroy(const Offer_Operation_Destroy& from);

  inline Offer_Operation_Destroy& operator=(const Offer_Operation_Destroy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation_Destroy& default_instance();

  void Swap(Offer_Operation_Destroy* other);

  // implements Message ----------------------------------------------

  Offer_Operation_Destroy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation_Destroy& from);
  void MergeFrom(const Offer_Operation_Destroy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::mesos::Resource& volumes(int index) const;
  inline ::mesos::Resource* mutable_volumes(int index);
  inline ::mesos::Resource* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_volumes();

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation.Destroy)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > volumes_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation_Destroy* default_instance_;
};
// -------------------------------------------------------------------

class Offer_Operation : public ::google::protobuf::Message {
 public:
  Offer_Operation();
  virtual ~Offer_Operation();

  Offer_Operation(const Offer_Operation& from);

  inline Offer_Operation& operator=(const Offer_Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer_Operation& default_instance();

  void Swap(Offer_Operation* other);

  // implements Message ----------------------------------------------

  Offer_Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer_Operation& from);
  void MergeFrom(const Offer_Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Offer_Operation_Launch Launch;
  typedef Offer_Operation_LaunchGroup LaunchGroup;
  typedef Offer_Operation_Reserve Reserve;
  typedef Offer_Operation_Unreserve Unreserve;
  typedef Offer_Operation_Create Create;
  typedef Offer_Operation_Destroy Destroy;

  typedef Offer_Operation_Type Type;
  static const Type UNKNOWN = Offer_Operation_Type_UNKNOWN;
  static const Type LAUNCH = Offer_Operation_Type_LAUNCH;
  static const Type LAUNCH_GROUP = Offer_Operation_Type_LAUNCH_GROUP;
  static const Type RESERVE = Offer_Operation_Type_RESERVE;
  static const Type UNRESERVE = Offer_Operation_Type_UNRESERVE;
  static const Type CREATE = Offer_Operation_Type_CREATE;
  static const Type DESTROY = Offer_Operation_Type_DESTROY;
  static inline bool Type_IsValid(int value) {
    return Offer_Operation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Offer_Operation_Type_Type_MIN;
  static const Type Type_MAX =
    Offer_Operation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Offer_Operation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Offer_Operation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Offer_Operation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Offer_Operation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Offer.Operation.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Offer_Operation_Type type() const;
  inline void set_type(::mesos::Offer_Operation_Type value);

  // optional .mesos.Offer.Operation.Launch launch = 2;
  inline bool has_launch() const;
  inline void clear_launch();
  static const int kLaunchFieldNumber = 2;
  inline const ::mesos::Offer_Operation_Launch& launch() const;
  inline ::mesos::Offer_Operation_Launch* mutable_launch();
  inline ::mesos::Offer_Operation_Launch* release_launch();
  inline void set_allocated_launch(::mesos::Offer_Operation_Launch* launch);

  // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
  inline bool has_launch_group() const;
  inline void clear_launch_group();
  static const int kLaunchGroupFieldNumber = 7;
  inline const ::mesos::Offer_Operation_LaunchGroup& launch_group() const;
  inline ::mesos::Offer_Operation_LaunchGroup* mutable_launch_group();
  inline ::mesos::Offer_Operation_LaunchGroup* release_launch_group();
  inline void set_allocated_launch_group(::mesos::Offer_Operation_LaunchGroup* launch_group);

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 3;
  inline const ::mesos::Offer_Operation_Reserve& reserve() const;
  inline ::mesos::Offer_Operation_Reserve* mutable_reserve();
  inline ::mesos::Offer_Operation_Reserve* release_reserve();
  inline void set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve);

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  inline bool has_unreserve() const;
  inline void clear_unreserve();
  static const int kUnreserveFieldNumber = 4;
  inline const ::mesos::Offer_Operation_Unreserve& unreserve() const;
  inline ::mesos::Offer_Operation_Unreserve* mutable_unreserve();
  inline ::mesos::Offer_Operation_Unreserve* release_unreserve();
  inline void set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve);

  // optional .mesos.Offer.Operation.Create create = 5;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 5;
  inline const ::mesos::Offer_Operation_Create& create() const;
  inline ::mesos::Offer_Operation_Create* mutable_create();
  inline ::mesos::Offer_Operation_Create* release_create();
  inline void set_allocated_create(::mesos::Offer_Operation_Create* create);

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  inline bool has_destroy() const;
  inline void clear_destroy();
  static const int kDestroyFieldNumber = 6;
  inline const ::mesos::Offer_Operation_Destroy& destroy() const;
  inline ::mesos::Offer_Operation_Destroy* mutable_destroy();
  inline ::mesos::Offer_Operation_Destroy* release_destroy();
  inline void set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy);

  // @@protoc_insertion_point(class_scope:mesos.Offer.Operation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_launch();
  inline void clear_has_launch();
  inline void set_has_launch_group();
  inline void clear_has_launch_group();
  inline void set_has_reserve();
  inline void clear_has_reserve();
  inline void set_has_unreserve();
  inline void clear_has_unreserve();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_destroy();
  inline void clear_has_destroy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Offer_Operation_Launch* launch_;
  ::mesos::Offer_Operation_LaunchGroup* launch_group_;
  ::mesos::Offer_Operation_Reserve* reserve_;
  ::mesos::Offer_Operation_Unreserve* unreserve_;
  ::mesos::Offer_Operation_Create* create_;
  ::mesos::Offer_Operation_Destroy* destroy_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer_Operation* default_instance_;
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message {
 public:
  Offer();
  virtual ~Offer();

  Offer(const Offer& from);

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();

  void Swap(Offer* other);

  // implements Message ----------------------------------------------

  Offer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Offer_Operation Operation;

  // accessors -------------------------------------------------------

  // required .mesos.OfferID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::OfferID& id() const;
  inline ::mesos::OfferID* mutable_id();
  inline ::mesos::OfferID* release_id();
  inline void set_allocated_id(::mesos::OfferID* id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional .mesos.URL url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::mesos::URL& url() const;
  inline ::mesos::URL* mutable_url();
  inline ::mesos::URL* release_url();
  inline void set_allocated_url(::mesos::URL* url);

  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.Attribute attributes = 7;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 7;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();

  // repeated .mesos.ExecutorID executor_ids = 6;
  inline int executor_ids_size() const;
  inline void clear_executor_ids();
  static const int kExecutorIdsFieldNumber = 6;
  inline const ::mesos::ExecutorID& executor_ids(int index) const;
  inline ::mesos::ExecutorID* mutable_executor_ids(int index);
  inline ::mesos::ExecutorID* add_executor_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
      executor_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
      mutable_executor_ids();

  // optional .mesos.Unavailability unavailability = 9;
  inline bool has_unavailability() const;
  inline void clear_unavailability();
  static const int kUnavailabilityFieldNumber = 9;
  inline const ::mesos::Unavailability& unavailability() const;
  inline ::mesos::Unavailability* mutable_unavailability();
  inline ::mesos::Unavailability* release_unavailability();
  inline void set_allocated_unavailability(::mesos::Unavailability* unavailability);

  // optional .mesos.Resource.AllocationInfo allocation_info = 10;
  inline bool has_allocation_info() const;
  inline void clear_allocation_info();
  static const int kAllocationInfoFieldNumber = 10;
  inline const ::mesos::Resource_AllocationInfo& allocation_info() const;
  inline ::mesos::Resource_AllocationInfo* mutable_allocation_info();
  inline ::mesos::Resource_AllocationInfo* release_allocation_info();
  inline void set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info);

  // @@protoc_insertion_point(class_scope:mesos.Offer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_unavailability();
  inline void clear_has_unavailability();
  inline void set_has_allocation_info();
  inline void clear_has_allocation_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::OfferID* id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::std::string* hostname_;
  ::mesos::URL* url_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID > executor_ids_;
  ::mesos::Unavailability* unavailability_;
  ::mesos::Resource_AllocationInfo* allocation_info_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer* default_instance_;
};
// -------------------------------------------------------------------

class InverseOffer : public ::google::protobuf::Message {
 public:
  InverseOffer();
  virtual ~InverseOffer();

  InverseOffer(const InverseOffer& from);

  inline InverseOffer& operator=(const InverseOffer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InverseOffer& default_instance();

  void Swap(InverseOffer* other);

  // implements Message ----------------------------------------------

  InverseOffer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InverseOffer& from);
  void MergeFrom(const InverseOffer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::OfferID& id() const;
  inline ::mesos::OfferID* mutable_id();
  inline ::mesos::OfferID* release_id();
  inline void set_allocated_id(::mesos::OfferID* id);

  // optional .mesos.URL url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::mesos::URL& url() const;
  inline ::mesos::URL* mutable_url();
  inline ::mesos::URL* release_url();
  inline void set_allocated_url(::mesos::URL* url);

  // required .mesos.FrameworkID framework_id = 3;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.SlaveID slave_id = 4;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 4;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.Unavailability unavailability = 5;
  inline bool has_unavailability() const;
  inline void clear_unavailability();
  static const int kUnavailabilityFieldNumber = 5;
  inline const ::mesos::Unavailability& unavailability() const;
  inline ::mesos::Unavailability* mutable_unavailability();
  inline ::mesos::Unavailability* release_unavailability();
  inline void set_allocated_unavailability(::mesos::Unavailability* unavailability);

  // repeated .mesos.Resource resources = 6;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 6;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.InverseOffer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_unavailability();
  inline void clear_has_unavailability();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::OfferID* id_;
  ::mesos::URL* url_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::Unavailability* unavailability_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static InverseOffer* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();

  void Swap(TaskInfo* other);

  // implements Message ----------------------------------------------

  TaskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional .mesos.ExecutorInfo executor = 5;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 5;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  inline ::mesos::ExecutorInfo* release_executor();
  inline void set_allocated_executor(::mesos::ExecutorInfo* executor);

  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional .mesos.ContainerInfo container = 9;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 9;
  inline const ::mesos::ContainerInfo& container() const;
  inline ::mesos::ContainerInfo* mutable_container();
  inline ::mesos::ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::ContainerInfo* container);

  // optional .mesos.HealthCheck health_check = 8;
  inline bool has_health_check() const;
  inline void clear_health_check();
  static const int kHealthCheckFieldNumber = 8;
  inline const ::mesos::HealthCheck& health_check() const;
  inline ::mesos::HealthCheck* mutable_health_check();
  inline ::mesos::HealthCheck* release_health_check();
  inline void set_allocated_health_check(::mesos::HealthCheck* health_check);

  // optional .mesos.CheckInfo check = 13;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 13;
  inline const ::mesos::CheckInfo& check() const;
  inline ::mesos::CheckInfo* mutable_check();
  inline ::mesos::CheckInfo* release_check();
  inline void set_allocated_check(::mesos::CheckInfo* check);

  // optional .mesos.KillPolicy kill_policy = 12;
  inline bool has_kill_policy() const;
  inline void clear_kill_policy();
  static const int kKillPolicyFieldNumber = 12;
  inline const ::mesos::KillPolicy& kill_policy() const;
  inline ::mesos::KillPolicy* mutable_kill_policy();
  inline ::mesos::KillPolicy* release_kill_policy();
  inline void set_allocated_kill_policy(::mesos::KillPolicy* kill_policy);

  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.Labels labels = 10;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 10;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // optional .mesos.DiscoveryInfo discovery = 11;
  inline bool has_discovery() const;
  inline void clear_discovery();
  static const int kDiscoveryFieldNumber = 11;
  inline const ::mesos::DiscoveryInfo& discovery() const;
  inline ::mesos::DiscoveryInfo* mutable_discovery();
  inline ::mesos::DiscoveryInfo* release_discovery();
  inline void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);

  // @@protoc_insertion_point(class_scope:mesos.TaskInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor();
  inline void clear_has_executor();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_health_check();
  inline void clear_has_health_check();
  inline void set_has_check();
  inline void clear_has_check();
  inline void set_has_kill_policy();
  inline void clear_has_kill_policy();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_labels();
  inline void clear_has_labels();
  inline void set_has_discovery();
  inline void clear_has_discovery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::CommandInfo* command_;
  ::mesos::ContainerInfo* container_;
  ::mesos::HealthCheck* health_check_;
  ::mesos::CheckInfo* check_;
  ::mesos::KillPolicy* kill_policy_;
  ::std::string* data_;
  ::mesos::Labels* labels_;
  ::mesos::DiscoveryInfo* discovery_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class TaskGroupInfo : public ::google::protobuf::Message {
 public:
  TaskGroupInfo();
  virtual ~TaskGroupInfo();

  TaskGroupInfo(const TaskGroupInfo& from);

  inline TaskGroupInfo& operator=(const TaskGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskGroupInfo& default_instance();

  void Swap(TaskGroupInfo* other);

  // implements Message ----------------------------------------------

  TaskGroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskGroupInfo& from);
  void MergeFrom(const TaskGroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.TaskInfo tasks = 1;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 1;
  inline const ::mesos::TaskInfo& tasks(int index) const;
  inline ::mesos::TaskInfo* mutable_tasks(int index);
  inline ::mesos::TaskInfo* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:mesos.TaskGroupInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo > tasks_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.FrameworkID framework_id = 3;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 4;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 4;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.TaskState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::mesos::TaskState state() const;
  inline void set_state(::mesos::TaskState value);

  // repeated .mesos.Resource resources = 7;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 7;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.TaskStatus statuses = 8;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 8;
  inline const ::mesos::TaskStatus& statuses(int index) const;
  inline ::mesos::TaskStatus* mutable_statuses(int index);
  inline ::mesos::TaskStatus* add_statuses();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
      statuses() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
      mutable_statuses();

  // optional .mesos.TaskState status_update_state = 9;
  inline bool has_status_update_state() const;
  inline void clear_status_update_state();
  static const int kStatusUpdateStateFieldNumber = 9;
  inline ::mesos::TaskState status_update_state() const;
  inline void set_status_update_state(::mesos::TaskState value);

  // optional bytes status_update_uuid = 10;
  inline bool has_status_update_uuid() const;
  inline void clear_status_update_uuid();
  static const int kStatusUpdateUuidFieldNumber = 10;
  inline const ::std::string& status_update_uuid() const;
  inline void set_status_update_uuid(const ::std::string& value);
  inline void set_status_update_uuid(const char* value);
  inline void set_status_update_uuid(const void* value, size_t size);
  inline ::std::string* mutable_status_update_uuid();
  inline ::std::string* release_status_update_uuid();
  inline void set_allocated_status_update_uuid(::std::string* status_update_uuid);

  // optional .mesos.Labels labels = 11;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 11;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // optional .mesos.DiscoveryInfo discovery = 12;
  inline bool has_discovery() const;
  inline void clear_discovery();
  static const int kDiscoveryFieldNumber = 12;
  inline const ::mesos::DiscoveryInfo& discovery() const;
  inline ::mesos::DiscoveryInfo* mutable_discovery();
  inline ::mesos::DiscoveryInfo* release_discovery();
  inline void set_allocated_discovery(::mesos::DiscoveryInfo* discovery);

  // optional .mesos.ContainerInfo container = 13;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 13;
  inline const ::mesos::ContainerInfo& container() const;
  inline ::mesos::ContainerInfo* mutable_container();
  inline ::mesos::ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::ContainerInfo* container);

  // optional string user = 14;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 14;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:mesos.Task)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_status_update_state();
  inline void clear_has_status_update_state();
  inline void set_has_status_update_uuid();
  inline void clear_has_status_update_uuid();
  inline void set_has_labels();
  inline void clear_has_labels();
  inline void set_has_discovery();
  inline void clear_has_discovery();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::mesos::TaskID* task_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  int state_;
  int status_update_state_;
  ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus > statuses_;
  ::std::string* status_update_uuid_;
  ::mesos::Labels* labels_;
  ::mesos::DiscoveryInfo* discovery_;
  ::mesos::ContainerInfo* container_;
  ::std::string* user_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class CheckStatusInfo_Command : public ::google::protobuf::Message {
 public:
  CheckStatusInfo_Command();
  virtual ~CheckStatusInfo_Command();

  CheckStatusInfo_Command(const CheckStatusInfo_Command& from);

  inline CheckStatusInfo_Command& operator=(const CheckStatusInfo_Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo_Command& default_instance();

  void Swap(CheckStatusInfo_Command* other);

  // implements Message ----------------------------------------------

  CheckStatusInfo_Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckStatusInfo_Command& from);
  void MergeFrom(const CheckStatusInfo_Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 exit_code = 1;
  inline bool has_exit_code() const;
  inline void clear_exit_code();
  static const int kExitCodeFieldNumber = 1;
  inline ::google::protobuf::int32 exit_code() const;
  inline void set_exit_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo.Command)
 private:
  inline void set_has_exit_code();
  inline void clear_has_exit_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 exit_code_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckStatusInfo_Command* default_instance_;
};
// -------------------------------------------------------------------

class CheckStatusInfo_Http : public ::google::protobuf::Message {
 public:
  CheckStatusInfo_Http();
  virtual ~CheckStatusInfo_Http();

  CheckStatusInfo_Http(const CheckStatusInfo_Http& from);

  inline CheckStatusInfo_Http& operator=(const CheckStatusInfo_Http& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo_Http& default_instance();

  void Swap(CheckStatusInfo_Http* other);

  // implements Message ----------------------------------------------

  CheckStatusInfo_Http* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckStatusInfo_Http& from);
  void MergeFrom(const CheckStatusInfo_Http& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status_code = 1;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 status_code() const;
  inline void set_status_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo.Http)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 status_code_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckStatusInfo_Http* default_instance_;
};
// -------------------------------------------------------------------

class CheckStatusInfo_Tcp : public ::google::protobuf::Message {
 public:
  CheckStatusInfo_Tcp();
  virtual ~CheckStatusInfo_Tcp();

  CheckStatusInfo_Tcp(const CheckStatusInfo_Tcp& from);

  inline CheckStatusInfo_Tcp& operator=(const CheckStatusInfo_Tcp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo_Tcp& default_instance();

  void Swap(CheckStatusInfo_Tcp* other);

  // implements Message ----------------------------------------------

  CheckStatusInfo_Tcp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckStatusInfo_Tcp& from);
  void MergeFrom(const CheckStatusInfo_Tcp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool succeeded = 1;
  inline bool has_succeeded() const;
  inline void clear_succeeded();
  static const int kSucceededFieldNumber = 1;
  inline bool succeeded() const;
  inline void set_succeeded(bool value);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo.Tcp)
 private:
  inline void set_has_succeeded();
  inline void clear_has_succeeded();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool succeeded_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckStatusInfo_Tcp* default_instance_;
};
// -------------------------------------------------------------------

class CheckStatusInfo : public ::google::protobuf::Message {
 public:
  CheckStatusInfo();
  virtual ~CheckStatusInfo();

  CheckStatusInfo(const CheckStatusInfo& from);

  inline CheckStatusInfo& operator=(const CheckStatusInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckStatusInfo& default_instance();

  void Swap(CheckStatusInfo* other);

  // implements Message ----------------------------------------------

  CheckStatusInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckStatusInfo& from);
  void MergeFrom(const CheckStatusInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CheckStatusInfo_Command Command;
  typedef CheckStatusInfo_Http Http;
  typedef CheckStatusInfo_Tcp Tcp;

  // accessors -------------------------------------------------------

  // optional .mesos.CheckInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::CheckInfo_Type type() const;
  inline void set_type(::mesos::CheckInfo_Type value);

  // optional .mesos.CheckStatusInfo.Command command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::mesos::CheckStatusInfo_Command& command() const;
  inline ::mesos::CheckStatusInfo_Command* mutable_command();
  inline ::mesos::CheckStatusInfo_Command* release_command();
  inline void set_allocated_command(::mesos::CheckStatusInfo_Command* command);

  // optional .mesos.CheckStatusInfo.Http http = 3;
  inline bool has_http() const;
  inline void clear_http();
  static const int kHttpFieldNumber = 3;
  inline const ::mesos::CheckStatusInfo_Http& http() const;
  inline ::mesos::CheckStatusInfo_Http* mutable_http();
  inline ::mesos::CheckStatusInfo_Http* release_http();
  inline void set_allocated_http(::mesos::CheckStatusInfo_Http* http);

  // optional .mesos.CheckStatusInfo.Tcp tcp = 4;
  inline bool has_tcp() const;
  inline void clear_tcp();
  static const int kTcpFieldNumber = 4;
  inline const ::mesos::CheckStatusInfo_Tcp& tcp() const;
  inline ::mesos::CheckStatusInfo_Tcp* mutable_tcp();
  inline ::mesos::CheckStatusInfo_Tcp* release_tcp();
  inline void set_allocated_tcp(::mesos::CheckStatusInfo_Tcp* tcp);

  // @@protoc_insertion_point(class_scope:mesos.CheckStatusInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_tcp();
  inline void clear_has_tcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::CheckStatusInfo_Command* command_;
  ::mesos::CheckStatusInfo_Http* http_;
  ::mesos::CheckStatusInfo_Tcp* tcp_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CheckStatusInfo* default_instance_;
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message {
 public:
  TaskStatus();
  virtual ~TaskStatus();

  TaskStatus(const TaskStatus& from);

  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();

  void Swap(TaskStatus* other);

  // implements Message ----------------------------------------------

  TaskStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TaskStatus_Source Source;
  static const Source SOURCE_MASTER = TaskStatus_Source_SOURCE_MASTER;
  static const Source SOURCE_SLAVE = TaskStatus_Source_SOURCE_SLAVE;
  static const Source SOURCE_EXECUTOR = TaskStatus_Source_SOURCE_EXECUTOR;
  static inline bool Source_IsValid(int value) {
    return TaskStatus_Source_IsValid(value);
  }
  static const Source Source_MIN =
    TaskStatus_Source_Source_MIN;
  static const Source Source_MAX =
    TaskStatus_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    TaskStatus_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return TaskStatus_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return TaskStatus_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return TaskStatus_Source_Parse(name, value);
  }

  typedef TaskStatus_Reason Reason;
  static const Reason REASON_COMMAND_EXECUTOR_FAILED = TaskStatus_Reason_REASON_COMMAND_EXECUTOR_FAILED;
  static const Reason REASON_CONTAINER_LAUNCH_FAILED = TaskStatus_Reason_REASON_CONTAINER_LAUNCH_FAILED;
  static const Reason REASON_CONTAINER_LIMITATION = TaskStatus_Reason_REASON_CONTAINER_LIMITATION;
  static const Reason REASON_CONTAINER_LIMITATION_DISK = TaskStatus_Reason_REASON_CONTAINER_LIMITATION_DISK;
  static const Reason REASON_CONTAINER_LIMITATION_MEMORY = TaskStatus_Reason_REASON_CONTAINER_LIMITATION_MEMORY;
  static const Reason REASON_CONTAINER_PREEMPTED = TaskStatus_Reason_REASON_CONTAINER_PREEMPTED;
  static const Reason REASON_CONTAINER_UPDATE_FAILED = TaskStatus_Reason_REASON_CONTAINER_UPDATE_FAILED;
  static const Reason REASON_EXECUTOR_REGISTRATION_TIMEOUT = TaskStatus_Reason_REASON_EXECUTOR_REGISTRATION_TIMEOUT;
  static const Reason REASON_EXECUTOR_REREGISTRATION_TIMEOUT = TaskStatus_Reason_REASON_EXECUTOR_REREGISTRATION_TIMEOUT;
  static const Reason REASON_EXECUTOR_TERMINATED = TaskStatus_Reason_REASON_EXECUTOR_TERMINATED;
  static const Reason REASON_EXECUTOR_UNREGISTERED = TaskStatus_Reason_REASON_EXECUTOR_UNREGISTERED;
  static const Reason REASON_FRAMEWORK_REMOVED = TaskStatus_Reason_REASON_FRAMEWORK_REMOVED;
  static const Reason REASON_GC_ERROR = TaskStatus_Reason_REASON_GC_ERROR;
  static const Reason REASON_INVALID_FRAMEWORKID = TaskStatus_Reason_REASON_INVALID_FRAMEWORKID;
  static const Reason REASON_INVALID_OFFERS = TaskStatus_Reason_REASON_INVALID_OFFERS;
  static const Reason REASON_IO_SWITCHBOARD_EXITED = TaskStatus_Reason_REASON_IO_SWITCHBOARD_EXITED;
  static const Reason REASON_MASTER_DISCONNECTED = TaskStatus_Reason_REASON_MASTER_DISCONNECTED;
  static const Reason REASON_RECONCILIATION = TaskStatus_Reason_REASON_RECONCILIATION;
  static const Reason REASON_RESOURCES_UNKNOWN = TaskStatus_Reason_REASON_RESOURCES_UNKNOWN;
  static const Reason REASON_SLAVE_DISCONNECTED = TaskStatus_Reason_REASON_SLAVE_DISCONNECTED;
  static const Reason REASON_SLAVE_REMOVED = TaskStatus_Reason_REASON_SLAVE_REMOVED;
  static const Reason REASON_SLAVE_RESTARTED = TaskStatus_Reason_REASON_SLAVE_RESTARTED;
  static const Reason REASON_SLAVE_UNKNOWN = TaskStatus_Reason_REASON_SLAVE_UNKNOWN;
  static const Reason REASON_TASK_KILLED_DURING_LAUNCH = TaskStatus_Reason_REASON_TASK_KILLED_DURING_LAUNCH;
  static const Reason REASON_TASK_CHECK_STATUS_UPDATED = TaskStatus_Reason_REASON_TASK_CHECK_STATUS_UPDATED;
  static const Reason REASON_TASK_GROUP_INVALID = TaskStatus_Reason_REASON_TASK_GROUP_INVALID;
  static const Reason REASON_TASK_GROUP_UNAUTHORIZED = TaskStatus_Reason_REASON_TASK_GROUP_UNAUTHORIZED;
  static const Reason REASON_TASK_INVALID = TaskStatus_Reason_REASON_TASK_INVALID;
  static const Reason REASON_TASK_UNAUTHORIZED = TaskStatus_Reason_REASON_TASK_UNAUTHORIZED;
  static const Reason REASON_TASK_UNKNOWN = TaskStatus_Reason_REASON_TASK_UNKNOWN;
  static inline bool Reason_IsValid(int value) {
    return TaskStatus_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    TaskStatus_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    TaskStatus_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    TaskStatus_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reason_descriptor() {
    return TaskStatus_Reason_descriptor();
  }
  static inline const ::std::string& Reason_Name(Reason value) {
    return TaskStatus_Reason_Name(value);
  }
  static inline bool Reason_Parse(const ::std::string& name,
      Reason* value) {
    return TaskStatus_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.TaskState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mesos::TaskState state() const;
  inline void set_state(::mesos::TaskState value);

  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .mesos.TaskStatus.Source source = 9;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 9;
  inline ::mesos::TaskStatus_Source source() const;
  inline void set_source(::mesos::TaskStatus_Source value);

  // optional .mesos.TaskStatus.Reason reason = 10;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 10;
  inline ::mesos::TaskStatus_Reason reason() const;
  inline void set_reason(::mesos::TaskStatus_Reason value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.ExecutorID executor_id = 7;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 7;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional double timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional bytes uuid = 11;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 11;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional bool healthy = 8;
  inline bool has_healthy() const;
  inline void clear_healthy();
  static const int kHealthyFieldNumber = 8;
  inline bool healthy() const;
  inline void set_healthy(bool value);

  // optional .mesos.CheckStatusInfo check_status = 15;
  inline bool has_check_status() const;
  inline void clear_check_status();
  static const int kCheckStatusFieldNumber = 15;
  inline const ::mesos::CheckStatusInfo& check_status() const;
  inline ::mesos::CheckStatusInfo* mutable_check_status();
  inline ::mesos::CheckStatusInfo* release_check_status();
  inline void set_allocated_check_status(::mesos::CheckStatusInfo* check_status);

  // optional .mesos.Labels labels = 12;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 12;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // optional .mesos.ContainerStatus container_status = 13;
  inline bool has_container_status() const;
  inline void clear_container_status();
  static const int kContainerStatusFieldNumber = 13;
  inline const ::mesos::ContainerStatus& container_status() const;
  inline ::mesos::ContainerStatus* mutable_container_status();
  inline ::mesos::ContainerStatus* release_container_status();
  inline void set_allocated_container_status(::mesos::ContainerStatus* container_status);

  // optional .mesos.TimeInfo unreachable_time = 14;
  inline bool has_unreachable_time() const;
  inline void clear_unreachable_time();
  static const int kUnreachableTimeFieldNumber = 14;
  inline const ::mesos::TimeInfo& unreachable_time() const;
  inline ::mesos::TimeInfo* mutable_unreachable_time();
  inline ::mesos::TimeInfo* release_unreachable_time();
  inline void set_allocated_unreachable_time(::mesos::TimeInfo* unreachable_time);

  // @@protoc_insertion_point(class_scope:mesos.TaskStatus)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_healthy();
  inline void clear_has_healthy();
  inline void set_has_check_status();
  inline void clear_has_check_status();
  inline void set_has_labels();
  inline void clear_has_labels();
  inline void set_has_container_status();
  inline void clear_has_container_status();
  inline void set_has_unreachable_time();
  inline void clear_has_unreachable_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::TaskID* task_id_;
  ::std::string* message_;
  int state_;
  int source_;
  ::std::string* data_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  int reason_;
  bool healthy_;
  double timestamp_;
  ::std::string* uuid_;
  ::mesos::CheckStatusInfo* check_status_;
  ::mesos::Labels* labels_;
  ::mesos::ContainerStatus* container_status_;
  ::mesos::TimeInfo* unreachable_time_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskStatus* default_instance_;
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::Message {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Filters& default_instance();

  void Swap(Filters* other);

  // implements Message ----------------------------------------------

  Filters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double refuse_seconds = 1 [default = 5];
  inline bool has_refuse_seconds() const;
  inline void clear_refuse_seconds();
  static const int kRefuseSecondsFieldNumber = 1;
  inline double refuse_seconds() const;
  inline void set_refuse_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.Filters)
 private:
  inline void set_has_refuse_seconds();
  inline void clear_has_refuse_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double refuse_seconds_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Filters* default_instance_;
};
// -------------------------------------------------------------------

class Environment_Variable : public ::google::protobuf::Message {
 public:
  Environment_Variable();
  virtual ~Environment_Variable();

  Environment_Variable(const Environment_Variable& from);

  inline Environment_Variable& operator=(const Environment_Variable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Variable& default_instance();

  void Swap(Environment_Variable* other);

  // implements Message ----------------------------------------------

  Environment_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment_Variable& from);
  void MergeFrom(const Environment_Variable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Environment_Variable_Type Type;
  static const Type UNKNOWN = Environment_Variable_Type_UNKNOWN;
  static const Type VALUE = Environment_Variable_Type_VALUE;
  static const Type SECRET = Environment_Variable_Type_SECRET;
  static inline bool Type_IsValid(int value) {
    return Environment_Variable_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Environment_Variable_Type_Type_MIN;
  static const Type Type_MAX =
    Environment_Variable_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Environment_Variable_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Environment_Variable_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Environment_Variable_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Environment_Variable_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::mesos::Environment_Variable_Type type() const;
  inline void set_type(::mesos::Environment_Variable_Type value);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .mesos.Secret secret = 4;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 4;
  inline const ::mesos::Secret& secret() const;
  inline ::mesos::Secret* mutable_secret();
  inline ::mesos::Secret* release_secret();
  inline void set_allocated_secret(::mesos::Secret* secret);

  // @@protoc_insertion_point(class_scope:mesos.Environment.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  ::mesos::Secret* secret_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Environment_Variable* default_instance_;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message {
 public:
  Environment();
  virtual ~Environment();

  Environment(const Environment& from);

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();

  void Swap(Environment* other);

  // implements Message ----------------------------------------------

  Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Environment_Variable Variable;

  // accessors -------------------------------------------------------

  // repeated .mesos.Environment.Variable variables = 1;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 1;
  inline const ::mesos::Environment_Variable& variables(int index) const;
  inline ::mesos::Environment_Variable* mutable_variables(int index);
  inline ::mesos::Environment_Variable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
      mutable_variables();

  // @@protoc_insertion_point(class_scope:mesos.Environment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable > variables_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Environment* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Parameter)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  void Swap(Parameters* other);

  // implements Message ----------------------------------------------

  Parameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Parameter parameter = 1;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 1;
  inline const ::mesos::Parameter& parameter(int index) const;
  inline ::mesos::Parameter* mutable_parameter(int index);
  inline ::mesos::Parameter* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameter();

  // @@protoc_insertion_point(class_scope:mesos.Parameters)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameter_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Parameters* default_instance_;
};
// -------------------------------------------------------------------

class Credential : public ::google::protobuf::Message {
 public:
  Credential();
  virtual ~Credential();

  Credential(const Credential& from);

  inline Credential& operator=(const Credential& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Credential& default_instance();

  void Swap(Credential* other);

  // implements Message ----------------------------------------------

  Credential* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Credential& from);
  void MergeFrom(const Credential& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string principal = 1;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional string secret = 2;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 2;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:mesos.Credential)
 private:
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* principal_;
  ::std::string* secret_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Credential* default_instance_;
};
// -------------------------------------------------------------------

class Credentials : public ::google::protobuf::Message {
 public:
  Credentials();
  virtual ~Credentials();

  Credentials(const Credentials& from);

  inline Credentials& operator=(const Credentials& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Credentials& default_instance();

  void Swap(Credentials* other);

  // implements Message ----------------------------------------------

  Credentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Credentials& from);
  void MergeFrom(const Credentials& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Credential credentials = 1;
  inline int credentials_size() const;
  inline void clear_credentials();
  static const int kCredentialsFieldNumber = 1;
  inline const ::mesos::Credential& credentials(int index) const;
  inline ::mesos::Credential* mutable_credentials(int index);
  inline ::mesos::Credential* add_credentials();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
      credentials() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
      mutable_credentials();

  // @@protoc_insertion_point(class_scope:mesos.Credentials)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Credential > credentials_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Credentials* default_instance_;
};
// -------------------------------------------------------------------

class Secret_Reference : public ::google::protobuf::Message {
 public:
  Secret_Reference();
  virtual ~Secret_Reference();

  Secret_Reference(const Secret_Reference& from);

  inline Secret_Reference& operator=(const Secret_Reference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret_Reference& default_instance();

  void Swap(Secret_Reference* other);

  // implements Message ----------------------------------------------

  Secret_Reference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret_Reference& from);
  void MergeFrom(const Secret_Reference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:mesos.Secret.Reference)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* key_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Secret_Reference* default_instance_;
};
// -------------------------------------------------------------------

class Secret_Value : public ::google::protobuf::Message {
 public:
  Secret_Value();
  virtual ~Secret_Value();

  Secret_Value(const Secret_Value& from);

  inline Secret_Value& operator=(const Secret_Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret_Value& default_instance();

  void Swap(Secret_Value* other);

  // implements Message ----------------------------------------------

  Secret_Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret_Value& from);
  void MergeFrom(const Secret_Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.Secret.Value)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Secret_Value* default_instance_;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  void Swap(Secret* other);

  // implements Message ----------------------------------------------

  Secret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Secret_Reference Reference;
  typedef Secret_Value Value;

  typedef Secret_Type Type;
  static const Type UNKNOWN = Secret_Type_UNKNOWN;
  static const Type REFERENCE = Secret_Type_REFERENCE;
  static const Type VALUE = Secret_Type_VALUE;
  static inline bool Type_IsValid(int value) {
    return Secret_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Secret_Type_Type_MIN;
  static const Type Type_MAX =
    Secret_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Secret_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Secret_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Secret_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Secret_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Secret.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Secret_Type type() const;
  inline void set_type(::mesos::Secret_Type value);

  // optional .mesos.Secret.Reference reference = 2;
  inline bool has_reference() const;
  inline void clear_reference();
  static const int kReferenceFieldNumber = 2;
  inline const ::mesos::Secret_Reference& reference() const;
  inline ::mesos::Secret_Reference* mutable_reference();
  inline ::mesos::Secret_Reference* release_reference();
  inline void set_allocated_reference(::mesos::Secret_Reference* reference);

  // optional .mesos.Secret.Value value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::mesos::Secret_Value& value() const;
  inline ::mesos::Secret_Value* mutable_value();
  inline ::mesos::Secret_Value* release_value();
  inline void set_allocated_value(::mesos::Secret_Value* value);

  // @@protoc_insertion_point(class_scope:mesos.Secret)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reference();
  inline void clear_has_reference();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Secret_Reference* reference_;
  ::mesos::Secret_Value* value_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Secret* default_instance_;
};
// -------------------------------------------------------------------

class RateLimit : public ::google::protobuf::Message {
 public:
  RateLimit();
  virtual ~RateLimit();

  RateLimit(const RateLimit& from);

  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit& default_instance();

  void Swap(RateLimit* other);

  // implements Message ----------------------------------------------

  RateLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RateLimit& from);
  void MergeFrom(const RateLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double qps = 1;
  inline bool has_qps() const;
  inline void clear_qps();
  static const int kQpsFieldNumber = 1;
  inline double qps() const;
  inline void set_qps(double value);

  // required string principal = 2;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 2;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional uint64 capacity = 3;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  inline ::google::protobuf::uint64 capacity() const;
  inline void set_capacity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RateLimit)
 private:
  inline void set_has_qps();
  inline void clear_has_qps();
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_capacity();
  inline void clear_has_capacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double qps_;
  ::std::string* principal_;
  ::google::protobuf::uint64 capacity_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static RateLimit* default_instance_;
};
// -------------------------------------------------------------------

class RateLimits : public ::google::protobuf::Message {
 public:
  RateLimits();
  virtual ~RateLimits();

  RateLimits(const RateLimits& from);

  inline RateLimits& operator=(const RateLimits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimits& default_instance();

  void Swap(RateLimits* other);

  // implements Message ----------------------------------------------

  RateLimits* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RateLimits& from);
  void MergeFrom(const RateLimits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.RateLimit limits = 1;
  inline int limits_size() const;
  inline void clear_limits();
  static const int kLimitsFieldNumber = 1;
  inline const ::mesos::RateLimit& limits(int index) const;
  inline ::mesos::RateLimit* mutable_limits(int index);
  inline ::mesos::RateLimit* add_limits();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
      limits() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
      mutable_limits();

  // optional double aggregate_default_qps = 2;
  inline bool has_aggregate_default_qps() const;
  inline void clear_aggregate_default_qps();
  static const int kAggregateDefaultQpsFieldNumber = 2;
  inline double aggregate_default_qps() const;
  inline void set_aggregate_default_qps(double value);

  // optional uint64 aggregate_default_capacity = 3;
  inline bool has_aggregate_default_capacity() const;
  inline void clear_aggregate_default_capacity();
  static const int kAggregateDefaultCapacityFieldNumber = 3;
  inline ::google::protobuf::uint64 aggregate_default_capacity() const;
  inline void set_aggregate_default_capacity(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RateLimits)
 private:
  inline void set_has_aggregate_default_qps();
  inline void clear_has_aggregate_default_qps();
  inline void set_has_aggregate_default_capacity();
  inline void clear_has_aggregate_default_capacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit > limits_;
  double aggregate_default_qps_;
  ::google::protobuf::uint64 aggregate_default_capacity_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static RateLimits* default_instance_;
};
// -------------------------------------------------------------------

class Image_Appc : public ::google::protobuf::Message {
 public:
  Image_Appc();
  virtual ~Image_Appc();

  Image_Appc(const Image_Appc& from);

  inline Image_Appc& operator=(const Image_Appc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image_Appc& default_instance();

  void Swap(Image_Appc* other);

  // implements Message ----------------------------------------------

  Image_Appc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image_Appc& from);
  void MergeFrom(const Image_Appc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .mesos.Labels labels = 3;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 3;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.Image.Appc)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* id_;
  ::mesos::Labels* labels_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Image_Appc* default_instance_;
};
// -------------------------------------------------------------------

class Image_Docker : public ::google::protobuf::Message {
 public:
  Image_Docker();
  virtual ~Image_Docker();

  Image_Docker(const Image_Docker& from);

  inline Image_Docker& operator=(const Image_Docker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image_Docker& default_instance();

  void Swap(Image_Docker* other);

  // implements Message ----------------------------------------------

  Image_Docker* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image_Docker& from);
  void MergeFrom(const Image_Docker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mesos.Credential credential = 2 [deprecated = true];
  inline bool has_credential() const PROTOBUF_DEPRECATED;
  inline void clear_credential() PROTOBUF_DEPRECATED;
  static const int kCredentialFieldNumber = 2;
  inline const ::mesos::Credential& credential() const PROTOBUF_DEPRECATED;
  inline ::mesos::Credential* mutable_credential() PROTOBUF_DEPRECATED;
  inline ::mesos::Credential* release_credential() PROTOBUF_DEPRECATED;
  inline void set_allocated_credential(::mesos::Credential* credential) PROTOBUF_DEPRECATED;

  // optional .mesos.Secret config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::mesos::Secret& config() const;
  inline ::mesos::Secret* mutable_config();
  inline ::mesos::Secret* release_config();
  inline void set_allocated_config(::mesos::Secret* config);

  // @@protoc_insertion_point(class_scope:mesos.Image.Docker)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_credential();
  inline void clear_has_credential();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::mesos::Credential* credential_;
  ::mesos::Secret* config_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Image_Docker* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Image_Appc Appc;
  typedef Image_Docker Docker;

  typedef Image_Type Type;
  static const Type APPC = Image_Type_APPC;
  static const Type DOCKER = Image_Type_DOCKER;
  static inline bool Type_IsValid(int value) {
    return Image_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Image_Type_Type_MIN;
  static const Type Type_MAX =
    Image_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Image_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Image_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Image_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Image_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Image.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Image_Type type() const;
  inline void set_type(::mesos::Image_Type value);

  // optional .mesos.Image.Appc appc = 2;
  inline bool has_appc() const;
  inline void clear_appc();
  static const int kAppcFieldNumber = 2;
  inline const ::mesos::Image_Appc& appc() const;
  inline ::mesos::Image_Appc* mutable_appc();
  inline ::mesos::Image_Appc* release_appc();
  inline void set_allocated_appc(::mesos::Image_Appc* appc);

  // optional .mesos.Image.Docker docker = 3;
  inline bool has_docker() const;
  inline void clear_docker();
  static const int kDockerFieldNumber = 3;
  inline const ::mesos::Image_Docker& docker() const;
  inline ::mesos::Image_Docker* mutable_docker();
  inline ::mesos::Image_Docker* release_docker();
  inline void set_allocated_docker(::mesos::Image_Docker* docker);

  // optional bool cached = 4 [default = true];
  inline bool has_cached() const;
  inline void clear_cached();
  static const int kCachedFieldNumber = 4;
  inline bool cached() const;
  inline void set_cached(bool value);

  // @@protoc_insertion_point(class_scope:mesos.Image)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_appc();
  inline void clear_has_appc();
  inline void set_has_docker();
  inline void clear_has_docker();
  inline void set_has_cached();
  inline void clear_has_cached();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Image_Appc* appc_;
  int type_;
  bool cached_;
  ::mesos::Image_Docker* docker_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Volume_Source_DockerVolume : public ::google::protobuf::Message {
 public:
  Volume_Source_DockerVolume();
  virtual ~Volume_Source_DockerVolume();

  Volume_Source_DockerVolume(const Volume_Source_DockerVolume& from);

  inline Volume_Source_DockerVolume& operator=(const Volume_Source_DockerVolume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source_DockerVolume& default_instance();

  void Swap(Volume_Source_DockerVolume* other);

  // implements Message ----------------------------------------------

  Volume_Source_DockerVolume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume_Source_DockerVolume& from);
  void MergeFrom(const Volume_Source_DockerVolume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string driver = 1;
  inline bool has_driver() const;
  inline void clear_driver();
  static const int kDriverFieldNumber = 1;
  inline const ::std::string& driver() const;
  inline void set_driver(const ::std::string& value);
  inline void set_driver(const char* value);
  inline void set_driver(const char* value, size_t size);
  inline ::std::string* mutable_driver();
  inline ::std::string* release_driver();
  inline void set_allocated_driver(::std::string* driver);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mesos.Parameters driver_options = 3;
  inline bool has_driver_options() const;
  inline void clear_driver_options();
  static const int kDriverOptionsFieldNumber = 3;
  inline const ::mesos::Parameters& driver_options() const;
  inline ::mesos::Parameters* mutable_driver_options();
  inline ::mesos::Parameters* release_driver_options();
  inline void set_allocated_driver_options(::mesos::Parameters* driver_options);

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source.DockerVolume)
 private:
  inline void set_has_driver();
  inline void clear_has_driver();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_driver_options();
  inline void clear_has_driver_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* driver_;
  ::std::string* name_;
  ::mesos::Parameters* driver_options_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Volume_Source_DockerVolume* default_instance_;
};
// -------------------------------------------------------------------

class Volume_Source_SandboxPath : public ::google::protobuf::Message {
 public:
  Volume_Source_SandboxPath();
  virtual ~Volume_Source_SandboxPath();

  Volume_Source_SandboxPath(const Volume_Source_SandboxPath& from);

  inline Volume_Source_SandboxPath& operator=(const Volume_Source_SandboxPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source_SandboxPath& default_instance();

  void Swap(Volume_Source_SandboxPath* other);

  // implements Message ----------------------------------------------

  Volume_Source_SandboxPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume_Source_SandboxPath& from);
  void MergeFrom(const Volume_Source_SandboxPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Volume_Source_SandboxPath_Type Type;
  static const Type UNKNOWN = Volume_Source_SandboxPath_Type_UNKNOWN;
  static const Type SELF = Volume_Source_SandboxPath_Type_SELF;
  static const Type PARENT = Volume_Source_SandboxPath_Type_PARENT;
  static inline bool Type_IsValid(int value) {
    return Volume_Source_SandboxPath_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Volume_Source_SandboxPath_Type_Type_MIN;
  static const Type Type_MAX =
    Volume_Source_SandboxPath_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Volume_Source_SandboxPath_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Volume_Source_SandboxPath_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Volume_Source_SandboxPath_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Volume_Source_SandboxPath_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Volume_Source_SandboxPath_Type type() const;
  inline void set_type(::mesos::Volume_Source_SandboxPath_Type value);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source.SandboxPath)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Volume_Source_SandboxPath* default_instance_;
};
// -------------------------------------------------------------------

class Volume_Source : public ::google::protobuf::Message {
 public:
  Volume_Source();
  virtual ~Volume_Source();

  Volume_Source(const Volume_Source& from);

  inline Volume_Source& operator=(const Volume_Source& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume_Source& default_instance();

  void Swap(Volume_Source* other);

  // implements Message ----------------------------------------------

  Volume_Source* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume_Source& from);
  void MergeFrom(const Volume_Source& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Volume_Source_DockerVolume DockerVolume;
  typedef Volume_Source_SandboxPath SandboxPath;

  typedef Volume_Source_Type Type;
  static const Type UNKNOWN = Volume_Source_Type_UNKNOWN;
  static const Type DOCKER_VOLUME = Volume_Source_Type_DOCKER_VOLUME;
  static const Type SANDBOX_PATH = Volume_Source_Type_SANDBOX_PATH;
  static const Type SECRET = Volume_Source_Type_SECRET;
  static inline bool Type_IsValid(int value) {
    return Volume_Source_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Volume_Source_Type_Type_MIN;
  static const Type Type_MAX =
    Volume_Source_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Volume_Source_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Volume_Source_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Volume_Source_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Volume_Source_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.Volume.Source.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Volume_Source_Type type() const;
  inline void set_type(::mesos::Volume_Source_Type value);

  // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
  inline bool has_docker_volume() const;
  inline void clear_docker_volume();
  static const int kDockerVolumeFieldNumber = 2;
  inline const ::mesos::Volume_Source_DockerVolume& docker_volume() const;
  inline ::mesos::Volume_Source_DockerVolume* mutable_docker_volume();
  inline ::mesos::Volume_Source_DockerVolume* release_docker_volume();
  inline void set_allocated_docker_volume(::mesos::Volume_Source_DockerVolume* docker_volume);

  // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
  inline bool has_sandbox_path() const;
  inline void clear_sandbox_path();
  static const int kSandboxPathFieldNumber = 3;
  inline const ::mesos::Volume_Source_SandboxPath& sandbox_path() const;
  inline ::mesos::Volume_Source_SandboxPath* mutable_sandbox_path();
  inline ::mesos::Volume_Source_SandboxPath* release_sandbox_path();
  inline void set_allocated_sandbox_path(::mesos::Volume_Source_SandboxPath* sandbox_path);

  // optional .mesos.Secret secret = 4;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 4;
  inline const ::mesos::Secret& secret() const;
  inline ::mesos::Secret* mutable_secret();
  inline ::mesos::Secret* release_secret();
  inline void set_allocated_secret(::mesos::Secret* secret);

  // @@protoc_insertion_point(class_scope:mesos.Volume.Source)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_docker_volume();
  inline void clear_has_docker_volume();
  inline void set_has_sandbox_path();
  inline void clear_has_sandbox_path();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Volume_Source_DockerVolume* docker_volume_;
  ::mesos::Volume_Source_SandboxPath* sandbox_path_;
  ::mesos::Secret* secret_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Volume_Source* default_instance_;
};
// -------------------------------------------------------------------

class Volume : public ::google::protobuf::Message {
 public:
  Volume();
  virtual ~Volume();

  Volume(const Volume& from);

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume& default_instance();

  void Swap(Volume* other);

  // implements Message ----------------------------------------------

  Volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Volume_Source Source;

  typedef Volume_Mode Mode;
  static const Mode RW = Volume_Mode_RW;
  static const Mode RO = Volume_Mode_RO;
  static inline bool Mode_IsValid(int value) {
    return Volume_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    Volume_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    Volume_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    Volume_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return Volume_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return Volume_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return Volume_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Volume.Mode mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::mesos::Volume_Mode mode() const;
  inline void set_mode(::mesos::Volume_Mode value);

  // required string container_path = 1;
  inline bool has_container_path() const;
  inline void clear_container_path();
  static const int kContainerPathFieldNumber = 1;
  inline const ::std::string& container_path() const;
  inline void set_container_path(const ::std::string& value);
  inline void set_container_path(const char* value);
  inline void set_container_path(const char* value, size_t size);
  inline ::std::string* mutable_container_path();
  inline ::std::string* release_container_path();
  inline void set_allocated_container_path(::std::string* container_path);

  // optional string host_path = 2;
  inline bool has_host_path() const;
  inline void clear_host_path();
  static const int kHostPathFieldNumber = 2;
  inline const ::std::string& host_path() const;
  inline void set_host_path(const ::std::string& value);
  inline void set_host_path(const char* value);
  inline void set_host_path(const char* value, size_t size);
  inline ::std::string* mutable_host_path();
  inline ::std::string* release_host_path();
  inline void set_allocated_host_path(::std::string* host_path);

  // optional .mesos.Image image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline const ::mesos::Image& image() const;
  inline ::mesos::Image* mutable_image();
  inline ::mesos::Image* release_image();
  inline void set_allocated_image(::mesos::Image* image);

  // optional .mesos.Volume.Source source = 5;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 5;
  inline const ::mesos::Volume_Source& source() const;
  inline ::mesos::Volume_Source* mutable_source();
  inline ::mesos::Volume_Source* release_source();
  inline void set_allocated_source(::mesos::Volume_Source* source);

  // @@protoc_insertion_point(class_scope:mesos.Volume)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_container_path();
  inline void clear_has_container_path();
  inline void set_has_host_path();
  inline void clear_has_host_path();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* container_path_;
  ::std::string* host_path_;
  ::mesos::Image* image_;
  ::mesos::Volume_Source* source_;
  int mode_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Volume* default_instance_;
};
// -------------------------------------------------------------------

class NetworkInfo_IPAddress : public ::google::protobuf::Message {
 public:
  NetworkInfo_IPAddress();
  virtual ~NetworkInfo_IPAddress();

  NetworkInfo_IPAddress(const NetworkInfo_IPAddress& from);

  inline NetworkInfo_IPAddress& operator=(const NetworkInfo_IPAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo_IPAddress& default_instance();

  void Swap(NetworkInfo_IPAddress* other);

  // implements Message ----------------------------------------------

  NetworkInfo_IPAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkInfo_IPAddress& from);
  void MergeFrom(const NetworkInfo_IPAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.NetworkInfo.Protocol protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline ::mesos::NetworkInfo_Protocol protocol() const;
  inline void set_protocol(::mesos::NetworkInfo_Protocol value);

  // optional string ip_address = 2;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const char* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // @@protoc_insertion_point(class_scope:mesos.NetworkInfo.IPAddress)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_address_;
  int protocol_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static NetworkInfo_IPAddress* default_instance_;
};
// -------------------------------------------------------------------

class NetworkInfo_PortMapping : public ::google::protobuf::Message {
 public:
  NetworkInfo_PortMapping();
  virtual ~NetworkInfo_PortMapping();

  NetworkInfo_PortMapping(const NetworkInfo_PortMapping& from);

  inline NetworkInfo_PortMapping& operator=(const NetworkInfo_PortMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo_PortMapping& default_instance();

  void Swap(NetworkInfo_PortMapping* other);

  // implements Message ----------------------------------------------

  NetworkInfo_PortMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkInfo_PortMapping& from);
  void MergeFrom(const NetworkInfo_PortMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host_port = 1;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 1;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // required uint32 container_port = 2;
  inline bool has_container_port() const;
  inline void clear_container_port();
  static const int kContainerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 container_port() const;
  inline void set_container_port(::google::protobuf::uint32 value);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // @@protoc_insertion_point(class_scope:mesos.NetworkInfo.PortMapping)
 private:
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_container_port();
  inline void clear_has_container_port();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_port_;
  ::std::string* protocol_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static NetworkInfo_PortMapping* default_instance_;
};
// -------------------------------------------------------------------

class NetworkInfo : public ::google::protobuf::Message {
 public:
  NetworkInfo();
  virtual ~NetworkInfo();

  NetworkInfo(const NetworkInfo& from);

  inline NetworkInfo& operator=(const NetworkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo& default_instance();

  void Swap(NetworkInfo* other);

  // implements Message ----------------------------------------------

  NetworkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkInfo& from);
  void MergeFrom(const NetworkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NetworkInfo_IPAddress IPAddress;
  typedef NetworkInfo_PortMapping PortMapping;

  typedef NetworkInfo_Protocol Protocol;
  static const Protocol IPv4 = NetworkInfo_Protocol_IPv4;
  static const Protocol IPv6 = NetworkInfo_Protocol_IPv6;
  static inline bool Protocol_IsValid(int value) {
    return NetworkInfo_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    NetworkInfo_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    NetworkInfo_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    NetworkInfo_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Protocol_descriptor() {
    return NetworkInfo_Protocol_descriptor();
  }
  static inline const ::std::string& Protocol_Name(Protocol value) {
    return NetworkInfo_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(const ::std::string& name,
      Protocol* value) {
    return NetworkInfo_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  inline int ip_addresses_size() const;
  inline void clear_ip_addresses();
  static const int kIpAddressesFieldNumber = 5;
  inline const ::mesos::NetworkInfo_IPAddress& ip_addresses(int index) const;
  inline ::mesos::NetworkInfo_IPAddress* mutable_ip_addresses(int index);
  inline ::mesos::NetworkInfo_IPAddress* add_ip_addresses();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >&
      ip_addresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >*
      mutable_ip_addresses();

  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string groups = 3;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 3;
  inline const ::std::string& groups(int index) const;
  inline ::std::string* mutable_groups(int index);
  inline void set_groups(int index, const ::std::string& value);
  inline void set_groups(int index, const char* value);
  inline void set_groups(int index, const char* value, size_t size);
  inline ::std::string* add_groups();
  inline void add_groups(const ::std::string& value);
  inline void add_groups(const char* value);
  inline void add_groups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();

  // optional .mesos.Labels labels = 4;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 4;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  inline int port_mappings_size() const;
  inline void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 7;
  inline const ::mesos::NetworkInfo_PortMapping& port_mappings(int index) const;
  inline ::mesos::NetworkInfo_PortMapping* mutable_port_mappings(int index);
  inline ::mesos::NetworkInfo_PortMapping* add_port_mappings();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >&
      port_mappings() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >*
      mutable_port_mappings();

  // @@protoc_insertion_point(class_scope:mesos.NetworkInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress > ip_addresses_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;
  ::mesos::Labels* labels_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping > port_mappings_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static NetworkInfo* default_instance_;
};
// -------------------------------------------------------------------

class CapabilityInfo : public ::google::protobuf::Message {
 public:
  CapabilityInfo();
  virtual ~CapabilityInfo();

  CapabilityInfo(const CapabilityInfo& from);

  inline CapabilityInfo& operator=(const CapabilityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CapabilityInfo& default_instance();

  void Swap(CapabilityInfo* other);

  // implements Message ----------------------------------------------

  CapabilityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CapabilityInfo& from);
  void MergeFrom(const CapabilityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CapabilityInfo_Capability Capability;
  static const Capability UNKNOWN = CapabilityInfo_Capability_UNKNOWN;
  static const Capability CHOWN = CapabilityInfo_Capability_CHOWN;
  static const Capability DAC_OVERRIDE = CapabilityInfo_Capability_DAC_OVERRIDE;
  static const Capability DAC_READ_SEARCH = CapabilityInfo_Capability_DAC_READ_SEARCH;
  static const Capability FOWNER = CapabilityInfo_Capability_FOWNER;
  static const Capability FSETID = CapabilityInfo_Capability_FSETID;
  static const Capability KILL = CapabilityInfo_Capability_KILL;
  static const Capability SETGID = CapabilityInfo_Capability_SETGID;
  static const Capability SETUID = CapabilityInfo_Capability_SETUID;
  static const Capability SETPCAP = CapabilityInfo_Capability_SETPCAP;
  static const Capability LINUX_IMMUTABLE = CapabilityInfo_Capability_LINUX_IMMUTABLE;
  static const Capability NET_BIND_SERVICE = CapabilityInfo_Capability_NET_BIND_SERVICE;
  static const Capability NET_BROADCAST = CapabilityInfo_Capability_NET_BROADCAST;
  static const Capability NET_ADMIN = CapabilityInfo_Capability_NET_ADMIN;
  static const Capability NET_RAW = CapabilityInfo_Capability_NET_RAW;
  static const Capability IPC_LOCK = CapabilityInfo_Capability_IPC_LOCK;
  static const Capability IPC_OWNER = CapabilityInfo_Capability_IPC_OWNER;
  static const Capability SYS_MODULE = CapabilityInfo_Capability_SYS_MODULE;
  static const Capability SYS_RAWIO = CapabilityInfo_Capability_SYS_RAWIO;
  static const Capability SYS_CHROOT = CapabilityInfo_Capability_SYS_CHROOT;
  static const Capability SYS_PTRACE = CapabilityInfo_Capability_SYS_PTRACE;
  static const Capability SYS_PACCT = CapabilityInfo_Capability_SYS_PACCT;
  static const Capability SYS_ADMIN = CapabilityInfo_Capability_SYS_ADMIN;
  static const Capability SYS_BOOT = CapabilityInfo_Capability_SYS_BOOT;
  static const Capability SYS_NICE = CapabilityInfo_Capability_SYS_NICE;
  static const Capability SYS_RESOURCE = CapabilityInfo_Capability_SYS_RESOURCE;
  static const Capability SYS_TIME = CapabilityInfo_Capability_SYS_TIME;
  static const Capability SYS_TTY_CONFIG = CapabilityInfo_Capability_SYS_TTY_CONFIG;
  static const Capability MKNOD = CapabilityInfo_Capability_MKNOD;
  static const Capability LEASE = CapabilityInfo_Capability_LEASE;
  static const Capability AUDIT_WRITE = CapabilityInfo_Capability_AUDIT_WRITE;
  static const Capability AUDIT_CONTROL = CapabilityInfo_Capability_AUDIT_CONTROL;
  static const Capability SETFCAP = CapabilityInfo_Capability_SETFCAP;
  static const Capability MAC_OVERRIDE = CapabilityInfo_Capability_MAC_OVERRIDE;
  static const Capability MAC_ADMIN = CapabilityInfo_Capability_MAC_ADMIN;
  static const Capability SYSLOG = CapabilityInfo_Capability_SYSLOG;
  static const Capability WAKE_ALARM = CapabilityInfo_Capability_WAKE_ALARM;
  static const Capability BLOCK_SUSPEND = CapabilityInfo_Capability_BLOCK_SUSPEND;
  static const Capability AUDIT_READ = CapabilityInfo_Capability_AUDIT_READ;
  static inline bool Capability_IsValid(int value) {
    return CapabilityInfo_Capability_IsValid(value);
  }
  static const Capability Capability_MIN =
    CapabilityInfo_Capability_Capability_MIN;
  static const Capability Capability_MAX =
    CapabilityInfo_Capability_Capability_MAX;
  static const int Capability_ARRAYSIZE =
    CapabilityInfo_Capability_Capability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Capability_descriptor() {
    return CapabilityInfo_Capability_descriptor();
  }
  static inline const ::std::string& Capability_Name(Capability value) {
    return CapabilityInfo_Capability_Name(value);
  }
  static inline bool Capability_Parse(const ::std::string& name,
      Capability* value) {
    return CapabilityInfo_Capability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  inline int capabilities_size() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 1;
  inline ::mesos::CapabilityInfo_Capability capabilities(int index) const;
  inline void set_capabilities(int index, ::mesos::CapabilityInfo_Capability value);
  inline void add_capabilities(::mesos::CapabilityInfo_Capability value);
  inline const ::google::protobuf::RepeatedField<int>& capabilities() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_capabilities();

  // @@protoc_insertion_point(class_scope:mesos.CapabilityInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> capabilities_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CapabilityInfo* default_instance_;
};
// -------------------------------------------------------------------

class LinuxInfo : public ::google::protobuf::Message {
 public:
  LinuxInfo();
  virtual ~LinuxInfo();

  LinuxInfo(const LinuxInfo& from);

  inline LinuxInfo& operator=(const LinuxInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinuxInfo& default_instance();

  void Swap(LinuxInfo* other);

  // implements Message ----------------------------------------------

  LinuxInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinuxInfo& from);
  void MergeFrom(const LinuxInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.CapabilityInfo capability_info = 1;
  inline bool has_capability_info() const;
  inline void clear_capability_info();
  static const int kCapabilityInfoFieldNumber = 1;
  inline const ::mesos::CapabilityInfo& capability_info() const;
  inline ::mesos::CapabilityInfo* mutable_capability_info();
  inline ::mesos::CapabilityInfo* release_capability_info();
  inline void set_allocated_capability_info(::mesos::CapabilityInfo* capability_info);

  // @@protoc_insertion_point(class_scope:mesos.LinuxInfo)
 private:
  inline void set_has_capability_info();
  inline void clear_has_capability_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::CapabilityInfo* capability_info_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static LinuxInfo* default_instance_;
};
// -------------------------------------------------------------------

class RLimitInfo_RLimit : public ::google::protobuf::Message {
 public:
  RLimitInfo_RLimit();
  virtual ~RLimitInfo_RLimit();

  RLimitInfo_RLimit(const RLimitInfo_RLimit& from);

  inline RLimitInfo_RLimit& operator=(const RLimitInfo_RLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RLimitInfo_RLimit& default_instance();

  void Swap(RLimitInfo_RLimit* other);

  // implements Message ----------------------------------------------

  RLimitInfo_RLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RLimitInfo_RLimit& from);
  void MergeFrom(const RLimitInfo_RLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RLimitInfo_RLimit_Type Type;
  static const Type UNKNOWN = RLimitInfo_RLimit_Type_UNKNOWN;
  static const Type RLMT_AS = RLimitInfo_RLimit_Type_RLMT_AS;
  static const Type RLMT_CORE = RLimitInfo_RLimit_Type_RLMT_CORE;
  static const Type RLMT_CPU = RLimitInfo_RLimit_Type_RLMT_CPU;
  static const Type RLMT_DATA = RLimitInfo_RLimit_Type_RLMT_DATA;
  static const Type RLMT_FSIZE = RLimitInfo_RLimit_Type_RLMT_FSIZE;
  static const Type RLMT_LOCKS = RLimitInfo_RLimit_Type_RLMT_LOCKS;
  static const Type RLMT_MEMLOCK = RLimitInfo_RLimit_Type_RLMT_MEMLOCK;
  static const Type RLMT_MSGQUEUE = RLimitInfo_RLimit_Type_RLMT_MSGQUEUE;
  static const Type RLMT_NICE = RLimitInfo_RLimit_Type_RLMT_NICE;
  static const Type RLMT_NOFILE = RLimitInfo_RLimit_Type_RLMT_NOFILE;
  static const Type RLMT_NPROC = RLimitInfo_RLimit_Type_RLMT_NPROC;
  static const Type RLMT_RSS = RLimitInfo_RLimit_Type_RLMT_RSS;
  static const Type RLMT_RTPRIO = RLimitInfo_RLimit_Type_RLMT_RTPRIO;
  static const Type RLMT_RTTIME = RLimitInfo_RLimit_Type_RLMT_RTTIME;
  static const Type RLMT_SIGPENDING = RLimitInfo_RLimit_Type_RLMT_SIGPENDING;
  static const Type RLMT_STACK = RLimitInfo_RLimit_Type_RLMT_STACK;
  static inline bool Type_IsValid(int value) {
    return RLimitInfo_RLimit_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RLimitInfo_RLimit_Type_Type_MIN;
  static const Type Type_MAX =
    RLimitInfo_RLimit_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RLimitInfo_RLimit_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RLimitInfo_RLimit_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RLimitInfo_RLimit_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RLimitInfo_RLimit_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.RLimitInfo.RLimit.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::RLimitInfo_RLimit_Type type() const;
  inline void set_type(::mesos::RLimitInfo_RLimit_Type value);

  // optional uint64 hard = 2;
  inline bool has_hard() const;
  inline void clear_hard();
  static const int kHardFieldNumber = 2;
  inline ::google::protobuf::uint64 hard() const;
  inline void set_hard(::google::protobuf::uint64 value);

  // optional uint64 soft = 3;
  inline bool has_soft() const;
  inline void clear_soft();
  static const int kSoftFieldNumber = 3;
  inline ::google::protobuf::uint64 soft() const;
  inline void set_soft(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.RLimitInfo.RLimit)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hard();
  inline void clear_has_hard();
  inline void set_has_soft();
  inline void clear_has_soft();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 hard_;
  ::google::protobuf::uint64 soft_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static RLimitInfo_RLimit* default_instance_;
};
// -------------------------------------------------------------------

class RLimitInfo : public ::google::protobuf::Message {
 public:
  RLimitInfo();
  virtual ~RLimitInfo();

  RLimitInfo(const RLimitInfo& from);

  inline RLimitInfo& operator=(const RLimitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RLimitInfo& default_instance();

  void Swap(RLimitInfo* other);

  // implements Message ----------------------------------------------

  RLimitInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RLimitInfo& from);
  void MergeFrom(const RLimitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RLimitInfo_RLimit RLimit;

  // accessors -------------------------------------------------------

  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  inline int rlimits_size() const;
  inline void clear_rlimits();
  static const int kRlimitsFieldNumber = 1;
  inline const ::mesos::RLimitInfo_RLimit& rlimits(int index) const;
  inline ::mesos::RLimitInfo_RLimit* mutable_rlimits(int index);
  inline ::mesos::RLimitInfo_RLimit* add_rlimits();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >&
      rlimits() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >*
      mutable_rlimits();

  // @@protoc_insertion_point(class_scope:mesos.RLimitInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit > rlimits_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static RLimitInfo* default_instance_;
};
// -------------------------------------------------------------------

class TTYInfo_WindowSize : public ::google::protobuf::Message {
 public:
  TTYInfo_WindowSize();
  virtual ~TTYInfo_WindowSize();

  TTYInfo_WindowSize(const TTYInfo_WindowSize& from);

  inline TTYInfo_WindowSize& operator=(const TTYInfo_WindowSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTYInfo_WindowSize& default_instance();

  void Swap(TTYInfo_WindowSize* other);

  // implements Message ----------------------------------------------

  TTYInfo_WindowSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTYInfo_WindowSize& from);
  void MergeFrom(const TTYInfo_WindowSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rows = 1;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);

  // required uint32 columns = 2;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline ::google::protobuf::uint32 columns() const;
  inline void set_columns(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.TTYInfo.WindowSize)
 private:
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_columns();
  inline void clear_has_columns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rows_;
  ::google::protobuf::uint32 columns_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TTYInfo_WindowSize* default_instance_;
};
// -------------------------------------------------------------------

class TTYInfo : public ::google::protobuf::Message {
 public:
  TTYInfo();
  virtual ~TTYInfo();

  TTYInfo(const TTYInfo& from);

  inline TTYInfo& operator=(const TTYInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTYInfo& default_instance();

  void Swap(TTYInfo* other);

  // implements Message ----------------------------------------------

  TTYInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TTYInfo& from);
  void MergeFrom(const TTYInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TTYInfo_WindowSize WindowSize;

  // accessors -------------------------------------------------------

  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  inline bool has_window_size() const;
  inline void clear_window_size();
  static const int kWindowSizeFieldNumber = 1;
  inline const ::mesos::TTYInfo_WindowSize& window_size() const;
  inline ::mesos::TTYInfo_WindowSize* mutable_window_size();
  inline ::mesos::TTYInfo_WindowSize* release_window_size();
  inline void set_allocated_window_size(::mesos::TTYInfo_WindowSize* window_size);

  // @@protoc_insertion_point(class_scope:mesos.TTYInfo)
 private:
  inline void set_has_window_size();
  inline void clear_has_window_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::TTYInfo_WindowSize* window_size_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TTYInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo_DockerInfo_PortMapping : public ::google::protobuf::Message {
 public:
  ContainerInfo_DockerInfo_PortMapping();
  virtual ~ContainerInfo_DockerInfo_PortMapping();

  ContainerInfo_DockerInfo_PortMapping(const ContainerInfo_DockerInfo_PortMapping& from);

  inline ContainerInfo_DockerInfo_PortMapping& operator=(const ContainerInfo_DockerInfo_PortMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_DockerInfo_PortMapping& default_instance();

  void Swap(ContainerInfo_DockerInfo_PortMapping* other);

  // implements Message ----------------------------------------------

  ContainerInfo_DockerInfo_PortMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo_DockerInfo_PortMapping& from);
  void MergeFrom(const ContainerInfo_DockerInfo_PortMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 host_port = 1;
  inline bool has_host_port() const;
  inline void clear_host_port();
  static const int kHostPortFieldNumber = 1;
  inline ::google::protobuf::uint32 host_port() const;
  inline void set_host_port(::google::protobuf::uint32 value);

  // required uint32 container_port = 2;
  inline bool has_container_port() const;
  inline void clear_container_port();
  static const int kContainerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 container_port() const;
  inline void set_container_port(::google::protobuf::uint32 value);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.DockerInfo.PortMapping)
 private:
  inline void set_has_host_port();
  inline void clear_has_host_port();
  inline void set_has_container_port();
  inline void clear_has_container_port();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 host_port_;
  ::google::protobuf::uint32 container_port_;
  ::std::string* protocol_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo_DockerInfo_PortMapping* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo_DockerInfo : public ::google::protobuf::Message {
 public:
  ContainerInfo_DockerInfo();
  virtual ~ContainerInfo_DockerInfo();

  ContainerInfo_DockerInfo(const ContainerInfo_DockerInfo& from);

  inline ContainerInfo_DockerInfo& operator=(const ContainerInfo_DockerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_DockerInfo& default_instance();

  void Swap(ContainerInfo_DockerInfo* other);

  // implements Message ----------------------------------------------

  ContainerInfo_DockerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo_DockerInfo& from);
  void MergeFrom(const ContainerInfo_DockerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContainerInfo_DockerInfo_PortMapping PortMapping;

  typedef ContainerInfo_DockerInfo_Network Network;
  static const Network HOST = ContainerInfo_DockerInfo_Network_HOST;
  static const Network BRIDGE = ContainerInfo_DockerInfo_Network_BRIDGE;
  static const Network NONE = ContainerInfo_DockerInfo_Network_NONE;
  static const Network USER = ContainerInfo_DockerInfo_Network_USER;
  static inline bool Network_IsValid(int value) {
    return ContainerInfo_DockerInfo_Network_IsValid(value);
  }
  static const Network Network_MIN =
    ContainerInfo_DockerInfo_Network_Network_MIN;
  static const Network Network_MAX =
    ContainerInfo_DockerInfo_Network_Network_MAX;
  static const int Network_ARRAYSIZE =
    ContainerInfo_DockerInfo_Network_Network_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Network_descriptor() {
    return ContainerInfo_DockerInfo_Network_descriptor();
  }
  static inline const ::std::string& Network_Name(Network value) {
    return ContainerInfo_DockerInfo_Network_Name(value);
  }
  static inline bool Network_Parse(const ::std::string& name,
      Network* value) {
    return ContainerInfo_DockerInfo_Network_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 2;
  inline ::mesos::ContainerInfo_DockerInfo_Network network() const;
  inline void set_network(::mesos::ContainerInfo_DockerInfo_Network value);

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  inline int port_mappings_size() const;
  inline void clear_port_mappings();
  static const int kPortMappingsFieldNumber = 3;
  inline const ::mesos::ContainerInfo_DockerInfo_PortMapping& port_mappings(int index) const;
  inline ::mesos::ContainerInfo_DockerInfo_PortMapping* mutable_port_mappings(int index);
  inline ::mesos::ContainerInfo_DockerInfo_PortMapping* add_port_mappings();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
      port_mappings() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
      mutable_port_mappings();

  // optional bool privileged = 4 [default = false];
  inline bool has_privileged() const;
  inline void clear_privileged();
  static const int kPrivilegedFieldNumber = 4;
  inline bool privileged() const;
  inline void set_privileged(bool value);

  // repeated .mesos.Parameter parameters = 5;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 5;
  inline const ::mesos::Parameter& parameters(int index) const;
  inline ::mesos::Parameter* mutable_parameters(int index);
  inline ::mesos::Parameter* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameters();

  // optional bool force_pull_image = 6;
  inline bool has_force_pull_image() const;
  inline void clear_force_pull_image();
  static const int kForcePullImageFieldNumber = 6;
  inline bool force_pull_image() const;
  inline void set_force_pull_image(bool value);

  // optional string volume_driver = 7 [deprecated = true];
  inline bool has_volume_driver() const PROTOBUF_DEPRECATED;
  inline void clear_volume_driver() PROTOBUF_DEPRECATED;
  static const int kVolumeDriverFieldNumber = 7;
  inline const ::std::string& volume_driver() const PROTOBUF_DEPRECATED;
  inline void set_volume_driver(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_volume_driver(const char* value) PROTOBUF_DEPRECATED;
  inline void set_volume_driver(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_volume_driver() PROTOBUF_DEPRECATED;
  inline ::std::string* release_volume_driver() PROTOBUF_DEPRECATED;
  inline void set_allocated_volume_driver(::std::string* volume_driver) PROTOBUF_DEPRECATED;

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.DockerInfo)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_privileged();
  inline void clear_has_privileged();
  inline void set_has_force_pull_image();
  inline void clear_has_force_pull_image();
  inline void set_has_volume_driver();
  inline void clear_has_volume_driver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* image_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping > port_mappings_;
  int network_;
  bool privileged_;
  bool force_pull_image_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameters_;
  ::std::string* volume_driver_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo_DockerInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo_MesosInfo : public ::google::protobuf::Message {
 public:
  ContainerInfo_MesosInfo();
  virtual ~ContainerInfo_MesosInfo();

  ContainerInfo_MesosInfo(const ContainerInfo_MesosInfo& from);

  inline ContainerInfo_MesosInfo& operator=(const ContainerInfo_MesosInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo_MesosInfo& default_instance();

  void Swap(ContainerInfo_MesosInfo* other);

  // implements Message ----------------------------------------------

  ContainerInfo_MesosInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo_MesosInfo& from);
  void MergeFrom(const ContainerInfo_MesosInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.Image image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::mesos::Image& image() const;
  inline ::mesos::Image* mutable_image();
  inline ::mesos::Image* release_image();
  inline void set_allocated_image(::mesos::Image* image);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo.MesosInfo)
 private:
  inline void set_has_image();
  inline void clear_has_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Image* image_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo_MesosInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo : public ::google::protobuf::Message {
 public:
  ContainerInfo();
  virtual ~ContainerInfo();

  ContainerInfo(const ContainerInfo& from);

  inline ContainerInfo& operator=(const ContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo& default_instance();

  void Swap(ContainerInfo* other);

  // implements Message ----------------------------------------------

  ContainerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo& from);
  void MergeFrom(const ContainerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContainerInfo_DockerInfo DockerInfo;
  typedef ContainerInfo_MesosInfo MesosInfo;

  typedef ContainerInfo_Type Type;
  static const Type DOCKER = ContainerInfo_Type_DOCKER;
  static const Type MESOS = ContainerInfo_Type_MESOS;
  static inline bool Type_IsValid(int value) {
    return ContainerInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ContainerInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ContainerInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ContainerInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ContainerInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ContainerInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ContainerInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.ContainerInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::ContainerInfo_Type type() const;
  inline void set_type(::mesos::ContainerInfo_Type value);

  // repeated .mesos.Volume volumes = 2;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 2;
  inline const ::mesos::Volume& volumes(int index) const;
  inline ::mesos::Volume* mutable_volumes(int index);
  inline ::mesos::Volume* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
      mutable_volumes();

  // optional string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  inline bool has_docker() const;
  inline void clear_docker();
  static const int kDockerFieldNumber = 3;
  inline const ::mesos::ContainerInfo_DockerInfo& docker() const;
  inline ::mesos::ContainerInfo_DockerInfo* mutable_docker();
  inline ::mesos::ContainerInfo_DockerInfo* release_docker();
  inline void set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker);

  // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
  inline bool has_mesos() const;
  inline void clear_mesos();
  static const int kMesosFieldNumber = 5;
  inline const ::mesos::ContainerInfo_MesosInfo& mesos() const;
  inline ::mesos::ContainerInfo_MesosInfo* mutable_mesos();
  inline ::mesos::ContainerInfo_MesosInfo* release_mesos();
  inline void set_allocated_mesos(::mesos::ContainerInfo_MesosInfo* mesos);

  // repeated .mesos.NetworkInfo network_infos = 7;
  inline int network_infos_size() const;
  inline void clear_network_infos();
  static const int kNetworkInfosFieldNumber = 7;
  inline const ::mesos::NetworkInfo& network_infos(int index) const;
  inline ::mesos::NetworkInfo* mutable_network_infos(int index);
  inline ::mesos::NetworkInfo* add_network_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
      network_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
      mutable_network_infos();

  // optional .mesos.LinuxInfo linux_info = 8;
  inline bool has_linux_info() const;
  inline void clear_linux_info();
  static const int kLinuxInfoFieldNumber = 8;
  inline const ::mesos::LinuxInfo& linux_info() const;
  inline ::mesos::LinuxInfo* mutable_linux_info();
  inline ::mesos::LinuxInfo* release_linux_info();
  inline void set_allocated_linux_info(::mesos::LinuxInfo* linux_info);

  // optional .mesos.RLimitInfo rlimit_info = 9;
  inline bool has_rlimit_info() const;
  inline void clear_rlimit_info();
  static const int kRlimitInfoFieldNumber = 9;
  inline const ::mesos::RLimitInfo& rlimit_info() const;
  inline ::mesos::RLimitInfo* mutable_rlimit_info();
  inline ::mesos::RLimitInfo* release_rlimit_info();
  inline void set_allocated_rlimit_info(::mesos::RLimitInfo* rlimit_info);

  // optional .mesos.TTYInfo tty_info = 10;
  inline bool has_tty_info() const;
  inline void clear_tty_info();
  static const int kTtyInfoFieldNumber = 10;
  inline const ::mesos::TTYInfo& tty_info() const;
  inline ::mesos::TTYInfo* mutable_tty_info();
  inline ::mesos::TTYInfo* release_tty_info();
  inline void set_allocated_tty_info(::mesos::TTYInfo* tty_info);

  // @@protoc_insertion_point(class_scope:mesos.ContainerInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_docker();
  inline void clear_has_docker();
  inline void set_has_mesos();
  inline void clear_has_mesos();
  inline void set_has_linux_info();
  inline void clear_has_linux_info();
  inline void set_has_rlimit_info();
  inline void clear_has_rlimit_info();
  inline void set_has_tty_info();
  inline void clear_has_tty_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Volume > volumes_;
  ::std::string* hostname_;
  ::mesos::ContainerInfo_DockerInfo* docker_;
  ::mesos::ContainerInfo_MesosInfo* mesos_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo > network_infos_;
  ::mesos::LinuxInfo* linux_info_;
  ::mesos::RLimitInfo* rlimit_info_;
  ::mesos::TTYInfo* tty_info_;
  int type_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContainerStatus : public ::google::protobuf::Message {
 public:
  ContainerStatus();
  virtual ~ContainerStatus();

  ContainerStatus(const ContainerStatus& from);

  inline ContainerStatus& operator=(const ContainerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerStatus& default_instance();

  void Swap(ContainerStatus* other);

  // implements Message ----------------------------------------------

  ContainerStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerStatus& from);
  void MergeFrom(const ContainerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.ContainerID container_id = 4;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 4;
  inline const ::mesos::ContainerID& container_id() const;
  inline ::mesos::ContainerID* mutable_container_id();
  inline ::mesos::ContainerID* release_container_id();
  inline void set_allocated_container_id(::mesos::ContainerID* container_id);

  // repeated .mesos.NetworkInfo network_infos = 1;
  inline int network_infos_size() const;
  inline void clear_network_infos();
  static const int kNetworkInfosFieldNumber = 1;
  inline const ::mesos::NetworkInfo& network_infos(int index) const;
  inline ::mesos::NetworkInfo* mutable_network_infos(int index);
  inline ::mesos::NetworkInfo* add_network_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
      network_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
      mutable_network_infos();

  // optional .mesos.CgroupInfo cgroup_info = 2;
  inline bool has_cgroup_info() const;
  inline void clear_cgroup_info();
  static const int kCgroupInfoFieldNumber = 2;
  inline const ::mesos::CgroupInfo& cgroup_info() const;
  inline ::mesos::CgroupInfo* mutable_cgroup_info();
  inline ::mesos::CgroupInfo* release_cgroup_info();
  inline void set_allocated_cgroup_info(::mesos::CgroupInfo* cgroup_info);

  // optional uint32 executor_pid = 3;
  inline bool has_executor_pid() const;
  inline void clear_executor_pid();
  static const int kExecutorPidFieldNumber = 3;
  inline ::google::protobuf::uint32 executor_pid() const;
  inline void set_executor_pid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerStatus)
 private:
  inline void set_has_container_id();
  inline void clear_has_container_id();
  inline void set_has_cgroup_info();
  inline void clear_has_cgroup_info();
  inline void set_has_executor_pid();
  inline void clear_has_executor_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ContainerID* container_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo > network_infos_;
  ::mesos::CgroupInfo* cgroup_info_;
  ::google::protobuf::uint32 executor_pid_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerStatus* default_instance_;
};
// -------------------------------------------------------------------

class CgroupInfo_NetCls : public ::google::protobuf::Message {
 public:
  CgroupInfo_NetCls();
  virtual ~CgroupInfo_NetCls();

  CgroupInfo_NetCls(const CgroupInfo_NetCls& from);

  inline CgroupInfo_NetCls& operator=(const CgroupInfo_NetCls& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo_NetCls& default_instance();

  void Swap(CgroupInfo_NetCls* other);

  // implements Message ----------------------------------------------

  CgroupInfo_NetCls* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CgroupInfo_NetCls& from);
  void MergeFrom(const CgroupInfo_NetCls& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 classid = 1;
  inline bool has_classid() const;
  inline void clear_classid();
  static const int kClassidFieldNumber = 1;
  inline ::google::protobuf::uint32 classid() const;
  inline void set_classid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo.NetCls)
 private:
  inline void set_has_classid();
  inline void clear_has_classid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 classid_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CgroupInfo_NetCls* default_instance_;
};
// -------------------------------------------------------------------

class CgroupInfo : public ::google::protobuf::Message {
 public:
  CgroupInfo();
  virtual ~CgroupInfo();

  CgroupInfo(const CgroupInfo& from);

  inline CgroupInfo& operator=(const CgroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CgroupInfo& default_instance();

  void Swap(CgroupInfo* other);

  // implements Message ----------------------------------------------

  CgroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CgroupInfo& from);
  void MergeFrom(const CgroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CgroupInfo_NetCls NetCls;

  // accessors -------------------------------------------------------

  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  inline bool has_net_cls() const;
  inline void clear_net_cls();
  static const int kNetClsFieldNumber = 1;
  inline const ::mesos::CgroupInfo_NetCls& net_cls() const;
  inline ::mesos::CgroupInfo_NetCls* mutable_net_cls();
  inline ::mesos::CgroupInfo_NetCls* release_net_cls();
  inline void set_allocated_net_cls(::mesos::CgroupInfo_NetCls* net_cls);

  // @@protoc_insertion_point(class_scope:mesos.CgroupInfo)
 private:
  inline void set_has_net_cls();
  inline void clear_has_net_cls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::CgroupInfo_NetCls* net_cls_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CgroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class Labels : public ::google::protobuf::Message {
 public:
  Labels();
  virtual ~Labels();

  Labels(const Labels& from);

  inline Labels& operator=(const Labels& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Labels& default_instance();

  void Swap(Labels* other);

  // implements Message ----------------------------------------------

  Labels* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Labels& from);
  void MergeFrom(const Labels& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Label labels = 1;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 1;
  inline const ::mesos::Label& labels(int index) const;
  inline ::mesos::Label* mutable_labels(int index);
  inline ::mesos::Label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Label >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:mesos.Labels)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Label > labels_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Labels* default_instance_;
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::Message {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();

  void Swap(Label* other);

  // implements Message ----------------------------------------------

  Label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Label)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// -------------------------------------------------------------------

class Port : public ::google::protobuf::Message {
 public:
  Port();
  virtual ~Port();

  Port(const Port& from);

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Port& default_instance();

  void Swap(Port* other);

  // implements Message ----------------------------------------------

  Port* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 4;
  inline ::mesos::DiscoveryInfo_Visibility visibility() const;
  inline void set_visibility(::mesos::DiscoveryInfo_Visibility value);

  // optional .mesos.Labels labels = 5;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 5;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.Port)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 number_;
  int visibility_;
  ::std::string* protocol_;
  ::mesos::Labels* labels_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Port* default_instance_;
};
// -------------------------------------------------------------------

class Ports : public ::google::protobuf::Message {
 public:
  Ports();
  virtual ~Ports();

  Ports(const Ports& from);

  inline Ports& operator=(const Ports& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ports& default_instance();

  void Swap(Ports* other);

  // implements Message ----------------------------------------------

  Ports* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ports& from);
  void MergeFrom(const Ports& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Port ports = 1;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 1;
  inline const ::mesos::Port& ports(int index) const;
  inline ::mesos::Port* mutable_ports(int index);
  inline ::mesos::Port* add_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
      ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Port >*
      mutable_ports();

  // @@protoc_insertion_point(class_scope:mesos.Ports)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Port > ports_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Ports* default_instance_;
};
// -------------------------------------------------------------------

class DiscoveryInfo : public ::google::protobuf::Message {
 public:
  DiscoveryInfo();
  virtual ~DiscoveryInfo();

  DiscoveryInfo(const DiscoveryInfo& from);

  inline DiscoveryInfo& operator=(const DiscoveryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoveryInfo& default_instance();

  void Swap(DiscoveryInfo* other);

  // implements Message ----------------------------------------------

  DiscoveryInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiscoveryInfo& from);
  void MergeFrom(const DiscoveryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DiscoveryInfo_Visibility Visibility;
  static const Visibility FRAMEWORK = DiscoveryInfo_Visibility_FRAMEWORK;
  static const Visibility CLUSTER = DiscoveryInfo_Visibility_CLUSTER;
  static const Visibility EXTERNAL = DiscoveryInfo_Visibility_EXTERNAL;
  static inline bool Visibility_IsValid(int value) {
    return DiscoveryInfo_Visibility_IsValid(value);
  }
  static const Visibility Visibility_MIN =
    DiscoveryInfo_Visibility_Visibility_MIN;
  static const Visibility Visibility_MAX =
    DiscoveryInfo_Visibility_Visibility_MAX;
  static const int Visibility_ARRAYSIZE =
    DiscoveryInfo_Visibility_Visibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Visibility_descriptor() {
    return DiscoveryInfo_Visibility_descriptor();
  }
  static inline const ::std::string& Visibility_Name(Visibility value) {
    return DiscoveryInfo_Visibility_Name(value);
  }
  static inline bool Visibility_Parse(const ::std::string& name,
      Visibility* value) {
    return DiscoveryInfo_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  inline bool has_visibility() const;
  inline void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  inline ::mesos::DiscoveryInfo_Visibility visibility() const;
  inline void set_visibility(::mesos::DiscoveryInfo_Visibility value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string environment = 3;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 3;
  inline const ::std::string& environment() const;
  inline void set_environment(const ::std::string& value);
  inline void set_environment(const char* value);
  inline void set_environment(const char* value, size_t size);
  inline ::std::string* mutable_environment();
  inline ::std::string* release_environment();
  inline void set_allocated_environment(::std::string* environment);

  // optional string location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .mesos.Ports ports = 6;
  inline bool has_ports() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 6;
  inline const ::mesos::Ports& ports() const;
  inline ::mesos::Ports* mutable_ports();
  inline ::mesos::Ports* release_ports();
  inline void set_allocated_ports(::mesos::Ports* ports);

  // optional .mesos.Labels labels = 7;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 7;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:mesos.DiscoveryInfo)
 private:
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_ports();
  inline void clear_has_ports();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* environment_;
  ::std::string* location_;
  ::std::string* version_;
  ::mesos::Ports* ports_;
  ::mesos::Labels* labels_;
  int visibility_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static DiscoveryInfo* default_instance_;
};
// -------------------------------------------------------------------

class WeightInfo : public ::google::protobuf::Message {
 public:
  WeightInfo();
  virtual ~WeightInfo();

  WeightInfo(const WeightInfo& from);

  inline WeightInfo& operator=(const WeightInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightInfo& default_instance();

  void Swap(WeightInfo* other);

  // implements Message ----------------------------------------------

  WeightInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeightInfo& from);
  void MergeFrom(const WeightInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline double weight() const;
  inline void set_weight(double value);

  // optional string role = 2;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 2;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // @@protoc_insertion_point(class_scope:mesos.WeightInfo)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double weight_;
  ::std::string* role_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static WeightInfo* default_instance_;
};
// -------------------------------------------------------------------

class VersionInfo : public ::google::protobuf::Message {
 public:
  VersionInfo();
  virtual ~VersionInfo();

  VersionInfo(const VersionInfo& from);

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionInfo& default_instance();

  void Swap(VersionInfo* other);

  // implements Message ----------------------------------------------

  VersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string build_date = 2;
  inline bool has_build_date() const;
  inline void clear_build_date();
  static const int kBuildDateFieldNumber = 2;
  inline const ::std::string& build_date() const;
  inline void set_build_date(const ::std::string& value);
  inline void set_build_date(const char* value);
  inline void set_build_date(const char* value, size_t size);
  inline ::std::string* mutable_build_date();
  inline ::std::string* release_build_date();
  inline void set_allocated_build_date(::std::string* build_date);

  // optional double build_time = 3;
  inline bool has_build_time() const;
  inline void clear_build_time();
  static const int kBuildTimeFieldNumber = 3;
  inline double build_time() const;
  inline void set_build_time(double value);

  // optional string build_user = 4;
  inline bool has_build_user() const;
  inline void clear_build_user();
  static const int kBuildUserFieldNumber = 4;
  inline const ::std::string& build_user() const;
  inline void set_build_user(const ::std::string& value);
  inline void set_build_user(const char* value);
  inline void set_build_user(const char* value, size_t size);
  inline ::std::string* mutable_build_user();
  inline ::std::string* release_build_user();
  inline void set_allocated_build_user(::std::string* build_user);

  // optional string git_sha = 5;
  inline bool has_git_sha() const;
  inline void clear_git_sha();
  static const int kGitShaFieldNumber = 5;
  inline const ::std::string& git_sha() const;
  inline void set_git_sha(const ::std::string& value);
  inline void set_git_sha(const char* value);
  inline void set_git_sha(const char* value, size_t size);
  inline ::std::string* mutable_git_sha();
  inline ::std::string* release_git_sha();
  inline void set_allocated_git_sha(::std::string* git_sha);

  // optional string git_branch = 6;
  inline bool has_git_branch() const;
  inline void clear_git_branch();
  static const int kGitBranchFieldNumber = 6;
  inline const ::std::string& git_branch() const;
  inline void set_git_branch(const ::std::string& value);
  inline void set_git_branch(const char* value);
  inline void set_git_branch(const char* value, size_t size);
  inline ::std::string* mutable_git_branch();
  inline ::std::string* release_git_branch();
  inline void set_allocated_git_branch(::std::string* git_branch);

  // optional string git_tag = 7;
  inline bool has_git_tag() const;
  inline void clear_git_tag();
  static const int kGitTagFieldNumber = 7;
  inline const ::std::string& git_tag() const;
  inline void set_git_tag(const ::std::string& value);
  inline void set_git_tag(const char* value);
  inline void set_git_tag(const char* value, size_t size);
  inline ::std::string* mutable_git_tag();
  inline ::std::string* release_git_tag();
  inline void set_allocated_git_tag(::std::string* git_tag);

  // @@protoc_insertion_point(class_scope:mesos.VersionInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_build_date();
  inline void clear_has_build_date();
  inline void set_has_build_time();
  inline void clear_has_build_time();
  inline void set_has_build_user();
  inline void clear_has_build_user();
  inline void set_has_git_sha();
  inline void clear_has_git_sha();
  inline void set_has_git_branch();
  inline void clear_has_git_branch();
  inline void set_has_git_tag();
  inline void clear_has_git_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  ::std::string* build_date_;
  double build_time_;
  ::std::string* build_user_;
  ::std::string* git_sha_;
  ::std::string* git_branch_;
  ::std::string* git_tag_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static VersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class Flag : public ::google::protobuf::Message {
 public:
  Flag();
  virtual ~Flag();

  Flag(const Flag& from);

  inline Flag& operator=(const Flag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Flag& default_instance();

  void Swap(Flag* other);

  // implements Message ----------------------------------------------

  Flag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Flag& from);
  void MergeFrom(const Flag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Flag)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Flag* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required double weight = 2;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline double weight() const;
  inline void set_weight(double value);

  // repeated .mesos.FrameworkID frameworks = 3;
  inline int frameworks_size() const;
  inline void clear_frameworks();
  static const int kFrameworksFieldNumber = 3;
  inline const ::mesos::FrameworkID& frameworks(int index) const;
  inline ::mesos::FrameworkID* mutable_frameworks(int index);
  inline ::mesos::FrameworkID* add_frameworks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >&
      frameworks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >*
      mutable_frameworks();

  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Role)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_weight();
  inline void clear_has_weight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  double weight_;
  ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID > frameworks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class Metric : public ::google::protobuf::Message {
 public:
  Metric();
  virtual ~Metric();

  Metric(const Metric& from);

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metric& default_instance();

  void Swap(Metric* other);

  // implements Message ----------------------------------------------

  Metric* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metric& from);
  void MergeFrom(const Metric& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:mesos.Metric)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  double value_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Metric* default_instance_;
};
// -------------------------------------------------------------------

class FileInfo : public ::google::protobuf::Message {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  void Swap(FileInfo* other);

  // implements Message ----------------------------------------------

  FileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int32 nlink = 2;
  inline bool has_nlink() const;
  inline void clear_nlink();
  static const int kNlinkFieldNumber = 2;
  inline ::google::protobuf::int32 nlink() const;
  inline void set_nlink(::google::protobuf::int32 value);

  // optional uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // optional .mesos.TimeInfo mtime = 4;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 4;
  inline const ::mesos::TimeInfo& mtime() const;
  inline ::mesos::TimeInfo* mutable_mtime();
  inline ::mesos::TimeInfo* release_mtime();
  inline void set_allocated_mtime(::mesos::TimeInfo* mtime);

  // optional uint32 mode = 5;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // optional string uid = 6;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string gid = 7;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 7;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // @@protoc_insertion_point(class_scope:mesos.FileInfo)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_nlink();
  inline void clear_has_nlink();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 nlink_;
  ::google::protobuf::uint32 mode_;
  ::mesos::TimeInfo* mtime_;
  ::std::string* uid_;
  ::std::string* gid_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static FileInfo* default_instance_;
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  void Swap(Device* other);

  // implements Message ----------------------------------------------

  Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mesos.Device)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class DeviceAccess_Access : public ::google::protobuf::Message {
 public:
  DeviceAccess_Access();
  virtual ~DeviceAccess_Access();

  DeviceAccess_Access(const DeviceAccess_Access& from);

  inline DeviceAccess_Access& operator=(const DeviceAccess_Access& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAccess_Access& default_instance();

  void Swap(DeviceAccess_Access* other);

  // implements Message ----------------------------------------------

  DeviceAccess_Access* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceAccess_Access& from);
  void MergeFrom(const DeviceAccess_Access& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool read = 1;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 1;
  inline bool read() const;
  inline void set_read(bool value);

  // optional bool write = 2;
  inline bool has_write() const;
  inline void clear_write();
  static const int kWriteFieldNumber = 2;
  inline bool write() const;
  inline void set_write(bool value);

  // optional bool mknod = 3;
  inline bool has_mknod() const;
  inline void clear_mknod();
  static const int kMknodFieldNumber = 3;
  inline bool mknod() const;
  inline void set_mknod(bool value);

  // @@protoc_insertion_point(class_scope:mesos.DeviceAccess.Access)
 private:
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_write();
  inline void clear_has_write();
  inline void set_has_mknod();
  inline void clear_has_mknod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool read_;
  bool write_;
  bool mknod_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static DeviceAccess_Access* default_instance_;
};
// -------------------------------------------------------------------

class DeviceAccess : public ::google::protobuf::Message {
 public:
  DeviceAccess();
  virtual ~DeviceAccess();

  DeviceAccess(const DeviceAccess& from);

  inline DeviceAccess& operator=(const DeviceAccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAccess& default_instance();

  void Swap(DeviceAccess* other);

  // implements Message ----------------------------------------------

  DeviceAccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceAccess& from);
  void MergeFrom(const DeviceAccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DeviceAccess_Access Access;

  // accessors -------------------------------------------------------

  // required .mesos.Device device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::mesos::Device& device() const;
  inline ::mesos::Device* mutable_device();
  inline ::mesos::Device* release_device();
  inline void set_allocated_device(::mesos::Device* device);

  // required .mesos.DeviceAccess.Access access = 2;
  inline bool has_access() const;
  inline void clear_access();
  static const int kAccessFieldNumber = 2;
  inline const ::mesos::DeviceAccess_Access& access() const;
  inline ::mesos::DeviceAccess_Access* mutable_access();
  inline ::mesos::DeviceAccess_Access* release_access();
  inline void set_allocated_access(::mesos::DeviceAccess_Access* access);

  // @@protoc_insertion_point(class_scope:mesos.DeviceAccess)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_access();
  inline void clear_has_access();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::Device* device_;
  ::mesos::DeviceAccess_Access* access_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static DeviceAccess* default_instance_;
};
// -------------------------------------------------------------------

class DeviceWhitelist : public ::google::protobuf::Message {
 public:
  DeviceWhitelist();
  virtual ~DeviceWhitelist();

  DeviceWhitelist(const DeviceWhitelist& from);

  inline DeviceWhitelist& operator=(const DeviceWhitelist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceWhitelist& default_instance();

  void Swap(DeviceWhitelist* other);

  // implements Message ----------------------------------------------

  DeviceWhitelist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceWhitelist& from);
  void MergeFrom(const DeviceWhitelist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.DeviceAccess allowed_devices = 1;
  inline int allowed_devices_size() const;
  inline void clear_allowed_devices();
  static const int kAllowedDevicesFieldNumber = 1;
  inline const ::mesos::DeviceAccess& allowed_devices(int index) const;
  inline ::mesos::DeviceAccess* mutable_allowed_devices(int index);
  inline ::mesos::DeviceAccess* add_allowed_devices();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >&
      allowed_devices() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >*
      mutable_allowed_devices();

  // @@protoc_insertion_point(class_scope:mesos.DeviceWhitelist)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess > allowed_devices_;
  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static DeviceWhitelist* default_instance_;
};
// ===================================================================


// ===================================================================

// FrameworkID

// required string value = 1;
inline bool FrameworkID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FrameworkID::value() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkID.value)
  return *value_;
}
inline void FrameworkID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkID.value)
}
inline void FrameworkID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkID.value)
}
inline void FrameworkID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkID.value)
}
inline ::std::string* FrameworkID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkID.value)
  return value_;
}
inline ::std::string* FrameworkID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameworkID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkID.value)
}

// -------------------------------------------------------------------

// OfferID

// required string value = 1;
inline bool OfferID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OfferID::value() const {
  // @@protoc_insertion_point(field_get:mesos.OfferID.value)
  return *value_;
}
inline void OfferID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.OfferID.value)
}
inline void OfferID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.OfferID.value)
}
inline void OfferID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.OfferID.value)
}
inline ::std::string* OfferID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.OfferID.value)
  return value_;
}
inline ::std::string* OfferID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfferID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.OfferID.value)
}

// -------------------------------------------------------------------

// SlaveID

// required string value = 1;
inline bool SlaveID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SlaveID::value() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveID.value)
  return *value_;
}
inline void SlaveID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.SlaveID.value)
}
inline void SlaveID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.SlaveID.value)
}
inline void SlaveID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.SlaveID.value)
}
inline ::std::string* SlaveID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SlaveID.value)
  return value_;
}
inline ::std::string* SlaveID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveID.value)
}

// -------------------------------------------------------------------

// TaskID

// required string value = 1;
inline bool TaskID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TaskID::value() const {
  // @@protoc_insertion_point(field_get:mesos.TaskID.value)
  return *value_;
}
inline void TaskID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TaskID.value)
}
inline void TaskID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TaskID.value)
}
inline void TaskID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskID.value)
}
inline ::std::string* TaskID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskID.value)
  return value_;
}
inline ::std::string* TaskID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskID.value)
}

// -------------------------------------------------------------------

// ExecutorID

// required string value = 1;
inline bool ExecutorID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ExecutorID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorID.value)
  return *value_;
}
inline void ExecutorID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorID.value)
}
inline void ExecutorID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorID.value)
}
inline void ExecutorID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorID.value)
}
inline ::std::string* ExecutorID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorID.value)
  return value_;
}
inline ::std::string* ExecutorID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecutorID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorID.value)
}

// -------------------------------------------------------------------

// ContainerID

// required string value = 1;
inline bool ContainerID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ContainerID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerID.value)
  return *value_;
}
inline void ContainerID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ContainerID.value)
}
inline void ContainerID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ContainerID.value)
}
inline void ContainerID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerID.value)
}
inline ::std::string* ContainerID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerID.value)
  return value_;
}
inline ::std::string* ContainerID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerID.value)
}

// optional .mesos.ContainerID parent = 2;
inline bool ContainerID::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerID::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerID::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerID::clear_parent() {
  if (parent_ != NULL) parent_->::mesos::ContainerID::Clear();
  clear_has_parent();
}
inline const ::mesos::ContainerID& ContainerID::parent() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerID.parent)
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::mesos::ContainerID* ContainerID::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::mesos::ContainerID;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerID.parent)
  return parent_;
}
inline ::mesos::ContainerID* ContainerID::release_parent() {
  clear_has_parent();
  ::mesos::ContainerID* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void ContainerID::set_allocated_parent(::mesos::ContainerID* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerID.parent)
}

// -------------------------------------------------------------------

// ResourceProviderID

// required string value = 1;
inline bool ResourceProviderID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceProviderID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceProviderID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceProviderID::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ResourceProviderID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceProviderID.value)
  return *value_;
}
inline void ResourceProviderID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ResourceProviderID.value)
}
inline void ResourceProviderID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ResourceProviderID.value)
}
inline void ResourceProviderID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceProviderID.value)
}
inline ::std::string* ResourceProviderID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceProviderID.value)
  return value_;
}
inline ::std::string* ResourceProviderID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResourceProviderID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceProviderID.value)
}

// -------------------------------------------------------------------

// TimeInfo

// required int64 nanoseconds = 1;
inline bool TimeInfo::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeInfo::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeInfo::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeInfo::clear_nanoseconds() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_nanoseconds();
}
inline ::google::protobuf::int64 TimeInfo::nanoseconds() const {
  // @@protoc_insertion_point(field_get:mesos.TimeInfo.nanoseconds)
  return nanoseconds_;
}
inline void TimeInfo::set_nanoseconds(::google::protobuf::int64 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.TimeInfo.nanoseconds)
}

// -------------------------------------------------------------------

// DurationInfo

// required int64 nanoseconds = 1;
inline bool DurationInfo::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DurationInfo::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DurationInfo::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DurationInfo::clear_nanoseconds() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_nanoseconds();
}
inline ::google::protobuf::int64 DurationInfo::nanoseconds() const {
  // @@protoc_insertion_point(field_get:mesos.DurationInfo.nanoseconds)
  return nanoseconds_;
}
inline void DurationInfo::set_nanoseconds(::google::protobuf::int64 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.DurationInfo.nanoseconds)
}

// -------------------------------------------------------------------

// Address

// optional string hostname = 1;
inline bool Address::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Address::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.Address.hostname)
  return *hostname_;
}
inline void Address::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Address.hostname)
}
inline void Address::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Address.hostname)
}
inline void Address::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Address.hostname)
}
inline ::std::string* Address::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Address.hostname)
  return hostname_;
}
inline ::std::string* Address::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Address::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Address.hostname)
}

// optional string ip = 2;
inline bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Address::ip() const {
  // @@protoc_insertion_point(field_get:mesos.Address.ip)
  return *ip_;
}
inline void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Address.ip)
}
inline void Address::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Address.ip)
}
inline void Address::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Address.ip)
}
inline ::std::string* Address::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Address.ip)
  return ip_;
}
inline ::std::string* Address::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Address::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Address.ip)
}

// required int32 port = 3;
inline bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:mesos.Address.port)
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.Address.port)
}

// -------------------------------------------------------------------

// URL

// required string scheme = 1;
inline bool URL::has_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void URL::set_has_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
inline void URL::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void URL::clear_scheme() {
  if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_->clear();
  }
  clear_has_scheme();
}
inline const ::std::string& URL::scheme() const {
  // @@protoc_insertion_point(field_get:mesos.URL.scheme)
  return *scheme_;
}
inline void URL::set_scheme(const ::std::string& value) {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  scheme_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.URL.scheme)
}
inline void URL::set_scheme(const char* value) {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  scheme_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.URL.scheme)
}
inline void URL::set_scheme(const char* value, size_t size) {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  scheme_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.scheme)
}
inline ::std::string* URL::mutable_scheme() {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.URL.scheme)
  return scheme_;
}
inline ::std::string* URL::release_scheme() {
  clear_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = scheme_;
    scheme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void URL::set_allocated_scheme(::std::string* scheme) {
  if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scheme_;
  }
  if (scheme) {
    set_has_scheme();
    scheme_ = scheme;
  } else {
    clear_has_scheme();
    scheme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.scheme)
}

// required .mesos.Address address = 2;
inline bool URL::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void URL::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void URL::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void URL::clear_address() {
  if (address_ != NULL) address_->::mesos::Address::Clear();
  clear_has_address();
}
inline const ::mesos::Address& URL::address() const {
  // @@protoc_insertion_point(field_get:mesos.URL.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::mesos::Address* URL::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::mesos::Address;
  // @@protoc_insertion_point(field_mutable:mesos.URL.address)
  return address_;
}
inline ::mesos::Address* URL::release_address() {
  clear_has_address();
  ::mesos::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void URL::set_allocated_address(::mesos::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.address)
}

// optional string path = 3;
inline bool URL::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void URL::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void URL::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void URL::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& URL::path() const {
  // @@protoc_insertion_point(field_get:mesos.URL.path)
  return *path_;
}
inline void URL::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.URL.path)
}
inline void URL::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.URL.path)
}
inline void URL::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.path)
}
inline ::std::string* URL::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.URL.path)
  return path_;
}
inline ::std::string* URL::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void URL::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.path)
}

// repeated .mesos.Parameter query = 4;
inline int URL::query_size() const {
  return query_.size();
}
inline void URL::clear_query() {
  query_.Clear();
}
inline const ::mesos::Parameter& URL::query(int index) const {
  // @@protoc_insertion_point(field_get:mesos.URL.query)
  return query_.Get(index);
}
inline ::mesos::Parameter* URL::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.URL.query)
  return query_.Mutable(index);
}
inline ::mesos::Parameter* URL::add_query() {
  // @@protoc_insertion_point(field_add:mesos.URL.query)
  return query_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
URL::query() const {
  // @@protoc_insertion_point(field_list:mesos.URL.query)
  return query_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
URL::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:mesos.URL.query)
  return &query_;
}

// optional string fragment = 5;
inline bool URL::has_fragment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void URL::set_has_fragment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void URL::clear_has_fragment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void URL::clear_fragment() {
  if (fragment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fragment_->clear();
  }
  clear_has_fragment();
}
inline const ::std::string& URL::fragment() const {
  // @@protoc_insertion_point(field_get:mesos.URL.fragment)
  return *fragment_;
}
inline void URL::set_fragment(const ::std::string& value) {
  set_has_fragment();
  if (fragment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fragment_ = new ::std::string;
  }
  fragment_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.URL.fragment)
}
inline void URL::set_fragment(const char* value) {
  set_has_fragment();
  if (fragment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fragment_ = new ::std::string;
  }
  fragment_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.URL.fragment)
}
inline void URL::set_fragment(const char* value, size_t size) {
  set_has_fragment();
  if (fragment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fragment_ = new ::std::string;
  }
  fragment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.fragment)
}
inline ::std::string* URL::mutable_fragment() {
  set_has_fragment();
  if (fragment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fragment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.URL.fragment)
  return fragment_;
}
inline ::std::string* URL::release_fragment() {
  clear_has_fragment();
  if (fragment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fragment_;
    fragment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void URL::set_allocated_fragment(::std::string* fragment) {
  if (fragment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fragment_;
  }
  if (fragment) {
    set_has_fragment();
    fragment_ = fragment;
  } else {
    clear_has_fragment();
    fragment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.fragment)
}

// -------------------------------------------------------------------

// Unavailability

// required .mesos.TimeInfo start = 1;
inline bool Unavailability::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Unavailability::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Unavailability::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Unavailability::clear_start() {
  if (start_ != NULL) start_->::mesos::TimeInfo::Clear();
  clear_has_start();
}
inline const ::mesos::TimeInfo& Unavailability::start() const {
  // @@protoc_insertion_point(field_get:mesos.Unavailability.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::mesos::TimeInfo* Unavailability::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::mesos::TimeInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Unavailability.start)
  return start_;
}
inline ::mesos::TimeInfo* Unavailability::release_start() {
  clear_has_start();
  ::mesos::TimeInfo* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Unavailability::set_allocated_start(::mesos::TimeInfo* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Unavailability.start)
}

// optional .mesos.DurationInfo duration = 2;
inline bool Unavailability::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Unavailability::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Unavailability::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Unavailability::clear_duration() {
  if (duration_ != NULL) duration_->::mesos::DurationInfo::Clear();
  clear_has_duration();
}
inline const ::mesos::DurationInfo& Unavailability::duration() const {
  // @@protoc_insertion_point(field_get:mesos.Unavailability.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mesos::DurationInfo* Unavailability::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) duration_ = new ::mesos::DurationInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Unavailability.duration)
  return duration_;
}
inline ::mesos::DurationInfo* Unavailability::release_duration() {
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void Unavailability::set_allocated_duration(::mesos::DurationInfo* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Unavailability.duration)
}

// -------------------------------------------------------------------

// MachineID

// optional string hostname = 1;
inline bool MachineID::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineID::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineID::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineID::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& MachineID::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.MachineID.hostname)
  return *hostname_;
}
inline void MachineID::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.MachineID.hostname)
}
inline void MachineID::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.MachineID.hostname)
}
inline void MachineID::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.MachineID.hostname)
}
inline ::std::string* MachineID::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MachineID.hostname)
  return hostname_;
}
inline ::std::string* MachineID::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MachineID::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineID.hostname)
}

// optional string ip = 2;
inline bool MachineID::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineID::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineID::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineID::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& MachineID::ip() const {
  // @@protoc_insertion_point(field_get:mesos.MachineID.ip)
  return *ip_;
}
inline void MachineID::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.MachineID.ip)
}
inline void MachineID::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.MachineID.ip)
}
inline void MachineID::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.MachineID.ip)
}
inline ::std::string* MachineID::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MachineID.ip)
  return ip_;
}
inline ::std::string* MachineID::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MachineID::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineID.ip)
}

// -------------------------------------------------------------------

// MachineInfo

// required .mesos.MachineID id = 1;
inline bool MachineInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::MachineID::Clear();
  clear_has_id();
}
inline const ::mesos::MachineID& MachineInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::MachineID* MachineInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::MachineID;
  // @@protoc_insertion_point(field_mutable:mesos.MachineInfo.id)
  return id_;
}
inline ::mesos::MachineID* MachineInfo::release_id() {
  clear_has_id();
  ::mesos::MachineID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MachineInfo::set_allocated_id(::mesos::MachineID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineInfo.id)
}

// optional .mesos.MachineInfo.Mode mode = 2;
inline bool MachineInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineInfo::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::mesos::MachineInfo_Mode MachineInfo::mode() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.mode)
  return static_cast< ::mesos::MachineInfo_Mode >(mode_);
}
inline void MachineInfo::set_mode(::mesos::MachineInfo_Mode value) {
  assert(::mesos::MachineInfo_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.MachineInfo.mode)
}

// optional .mesos.Unavailability unavailability = 3;
inline bool MachineInfo::has_unavailability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MachineInfo::set_has_unavailability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MachineInfo::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MachineInfo::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
  clear_has_unavailability();
}
inline const ::mesos::Unavailability& MachineInfo::unavailability() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.unavailability)
  return unavailability_ != NULL ? *unavailability_ : *default_instance_->unavailability_;
}
inline ::mesos::Unavailability* MachineInfo::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) unavailability_ = new ::mesos::Unavailability;
  // @@protoc_insertion_point(field_mutable:mesos.MachineInfo.unavailability)
  return unavailability_;
}
inline ::mesos::Unavailability* MachineInfo::release_unavailability() {
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
inline void MachineInfo::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  delete unavailability_;
  unavailability_ = unavailability;
  if (unavailability) {
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineInfo.unavailability)
}

// -------------------------------------------------------------------

// FrameworkInfo_Capability

// optional .mesos.FrameworkInfo.Capability.Type type = 1;
inline bool FrameworkInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::FrameworkInfo_Capability_Type FrameworkInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.Capability.type)
  return static_cast< ::mesos::FrameworkInfo_Capability_Type >(type_);
}
inline void FrameworkInfo_Capability::set_type(::mesos::FrameworkInfo_Capability_Type value) {
  assert(::mesos::FrameworkInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.Capability.type)
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
inline bool FrameworkInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& FrameworkInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.user)
  return *user_;
}
inline void FrameworkInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.user)
}
inline void FrameworkInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.user)
}
inline void FrameworkInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.user)
}
inline ::std::string* FrameworkInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.user)
  return user_;
}
inline ::std::string* FrameworkInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.user)
}

// required string name = 2;
inline bool FrameworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FrameworkInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.name)
  return *name_;
}
inline void FrameworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.name)
}
inline void FrameworkInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.name)
}
inline void FrameworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.name)
}
inline ::std::string* FrameworkInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.name)
  return name_;
}
inline ::std::string* FrameworkInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.name)
}

// optional .mesos.FrameworkID id = 3;
inline bool FrameworkInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
  clear_has_id();
}
inline const ::mesos::FrameworkID& FrameworkInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.id)
  return id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::release_id() {
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void FrameworkInfo::set_allocated_id(::mesos::FrameworkID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.id)
}

// optional double failover_timeout = 4 [default = 0];
inline bool FrameworkInfo::has_failover_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameworkInfo::set_has_failover_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameworkInfo::clear_has_failover_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameworkInfo::clear_failover_timeout() {
  failover_timeout_ = 0;
  clear_has_failover_timeout();
}
inline double FrameworkInfo::failover_timeout() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.failover_timeout)
  return failover_timeout_;
}
inline void FrameworkInfo::set_failover_timeout(double value) {
  set_has_failover_timeout();
  failover_timeout_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.failover_timeout)
}

// optional bool checkpoint = 5 [default = false];
inline bool FrameworkInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameworkInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrameworkInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrameworkInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool FrameworkInfo::checkpoint() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.checkpoint)
  return checkpoint_;
}
inline void FrameworkInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.checkpoint)
}

// optional string role = 6 [default = "*", deprecated = true];
inline bool FrameworkInfo::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameworkInfo::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrameworkInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrameworkInfo::clear_role() {
  if (role_ != _default_role_) {
    role_->assign(*_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& FrameworkInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.role)
  return *role_;
}
inline void FrameworkInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.role)
}
inline void FrameworkInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.role)
}
inline void FrameworkInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.role)
}
inline ::std::string* FrameworkInfo::mutable_role() {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string(*_default_role_);
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.role)
  return role_;
}
inline ::std::string* FrameworkInfo::release_role() {
  clear_has_role();
  if (role_ == _default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(_default_role_);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_role(::std::string* role) {
  if (role_ != _default_role_) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(_default_role_);
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.role)
}

// repeated string roles = 12;
inline int FrameworkInfo::roles_size() const {
  return roles_.size();
}
inline void FrameworkInfo::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& FrameworkInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.roles)
  return roles_.Get(index);
}
inline ::std::string* FrameworkInfo::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.roles)
  return roles_.Mutable(index);
}
inline void FrameworkInfo::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.roles)
  roles_.Mutable(index)->assign(value);
}
inline void FrameworkInfo::set_roles(int index, const char* value) {
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.roles)
}
inline void FrameworkInfo::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.roles)
}
inline ::std::string* FrameworkInfo::add_roles() {
  return roles_.Add();
}
inline void FrameworkInfo::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.roles)
}
inline void FrameworkInfo::add_roles(const char* value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.FrameworkInfo.roles)
}
inline void FrameworkInfo::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.FrameworkInfo.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FrameworkInfo::roles() const {
  // @@protoc_insertion_point(field_list:mesos.FrameworkInfo.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FrameworkInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.FrameworkInfo.roles)
  return &roles_;
}

// optional string hostname = 7;
inline bool FrameworkInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrameworkInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FrameworkInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FrameworkInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& FrameworkInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.hostname)
  return *hostname_;
}
inline void FrameworkInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.hostname)
}
inline void FrameworkInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.hostname)
}
inline void FrameworkInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.hostname)
}
inline ::std::string* FrameworkInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.hostname)
  return hostname_;
}
inline ::std::string* FrameworkInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.hostname)
}

// optional string principal = 8;
inline bool FrameworkInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FrameworkInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FrameworkInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FrameworkInfo::clear_principal() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& FrameworkInfo::principal() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.principal)
  return *principal_;
}
inline void FrameworkInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.principal)
}
inline void FrameworkInfo::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.principal)
}
inline void FrameworkInfo::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.principal)
}
inline ::std::string* FrameworkInfo::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.principal)
  return principal_;
}
inline ::std::string* FrameworkInfo::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.principal)
}

// optional string webui_url = 9;
inline bool FrameworkInfo::has_webui_url() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FrameworkInfo::set_has_webui_url() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FrameworkInfo::clear_has_webui_url() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FrameworkInfo::clear_webui_url() {
  if (webui_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_url_->clear();
  }
  clear_has_webui_url();
}
inline const ::std::string& FrameworkInfo::webui_url() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.webui_url)
  return *webui_url_;
}
inline void FrameworkInfo::set_webui_url(const ::std::string& value) {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_url_ = new ::std::string;
  }
  webui_url_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.webui_url)
}
inline void FrameworkInfo::set_webui_url(const char* value) {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_url_ = new ::std::string;
  }
  webui_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.webui_url)
}
inline void FrameworkInfo::set_webui_url(const char* value, size_t size) {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_url_ = new ::std::string;
  }
  webui_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.webui_url)
}
inline ::std::string* FrameworkInfo::mutable_webui_url() {
  set_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.webui_url)
  return webui_url_;
}
inline ::std::string* FrameworkInfo::release_webui_url() {
  clear_has_webui_url();
  if (webui_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = webui_url_;
    webui_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_webui_url(::std::string* webui_url) {
  if (webui_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete webui_url_;
  }
  if (webui_url) {
    set_has_webui_url();
    webui_url_ = webui_url;
  } else {
    clear_has_webui_url();
    webui_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.webui_url)
}

// repeated .mesos.FrameworkInfo.Capability capabilities = 10;
inline int FrameworkInfo::capabilities_size() const {
  return capabilities_.size();
}
inline void FrameworkInfo::clear_capabilities() {
  capabilities_.Clear();
}
inline const ::mesos::FrameworkInfo_Capability& FrameworkInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.capabilities)
  return capabilities_.Get(index);
}
inline ::mesos::FrameworkInfo_Capability* FrameworkInfo::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.capabilities)
  return capabilities_.Mutable(index);
}
inline ::mesos::FrameworkInfo_Capability* FrameworkInfo::add_capabilities() {
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.capabilities)
  return capabilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >&
FrameworkInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.FrameworkInfo.capabilities)
  return capabilities_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >*
FrameworkInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.FrameworkInfo.capabilities)
  return &capabilities_;
}

// optional .mesos.Labels labels = 11;
inline bool FrameworkInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FrameworkInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FrameworkInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FrameworkInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& FrameworkInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* FrameworkInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.labels)
  return labels_;
}
inline ::mesos::Labels* FrameworkInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void FrameworkInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.labels)
}

// -------------------------------------------------------------------

// CheckInfo_Command

// required .mesos.CommandInfo command = 1;
inline bool CheckInfo_Command::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo_Command::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo_Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo_Command::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& CheckInfo_Command::command() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Command.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* CheckInfo_Command::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.Command.command)
  return command_;
}
inline ::mesos::CommandInfo* CheckInfo_Command::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void CheckInfo_Command::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.Command.command)
}

// -------------------------------------------------------------------

// CheckInfo_Http

// required uint32 port = 1;
inline bool CheckInfo_Http::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo_Http::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo_Http::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo_Http::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CheckInfo_Http::port() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Http.port)
  return port_;
}
inline void CheckInfo_Http::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Http.port)
}

// optional string path = 2;
inline bool CheckInfo_Http::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckInfo_Http::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckInfo_Http::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckInfo_Http::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CheckInfo_Http::path() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Http.path)
  return *path_;
}
inline void CheckInfo_Http::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Http.path)
}
inline void CheckInfo_Http::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CheckInfo.Http.path)
}
inline void CheckInfo_Http::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CheckInfo.Http.path)
}
inline ::std::string* CheckInfo_Http::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.Http.path)
  return path_;
}
inline ::std::string* CheckInfo_Http::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CheckInfo_Http::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.Http.path)
}

// -------------------------------------------------------------------

// CheckInfo_Tcp

// required uint32 port = 1;
inline bool CheckInfo_Tcp::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo_Tcp::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo_Tcp::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo_Tcp::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CheckInfo_Tcp::port() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Tcp.port)
  return port_;
}
inline void CheckInfo_Tcp::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Tcp.port)
}

// -------------------------------------------------------------------

// CheckInfo

// optional .mesos.CheckInfo.Type type = 1;
inline bool CheckInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::CheckInfo_Type CheckInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.type)
  return static_cast< ::mesos::CheckInfo_Type >(type_);
}
inline void CheckInfo::set_type(::mesos::CheckInfo_Type value) {
  assert(::mesos::CheckInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.type)
}

// optional .mesos.CheckInfo.Command command = 2;
inline bool CheckInfo::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckInfo::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CheckInfo_Command::Clear();
  clear_has_command();
}
inline const ::mesos::CheckInfo_Command& CheckInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CheckInfo_Command* CheckInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CheckInfo_Command;
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.command)
  return command_;
}
inline ::mesos::CheckInfo_Command* CheckInfo::release_command() {
  clear_has_command();
  ::mesos::CheckInfo_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void CheckInfo::set_allocated_command(::mesos::CheckInfo_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.command)
}

// optional .mesos.CheckInfo.Http http = 3;
inline bool CheckInfo::has_http() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckInfo::set_has_http() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckInfo::clear_has_http() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckInfo::clear_http() {
  if (http_ != NULL) http_->::mesos::CheckInfo_Http::Clear();
  clear_has_http();
}
inline const ::mesos::CheckInfo_Http& CheckInfo::http() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.http)
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
inline ::mesos::CheckInfo_Http* CheckInfo::mutable_http() {
  set_has_http();
  if (http_ == NULL) http_ = new ::mesos::CheckInfo_Http;
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.http)
  return http_;
}
inline ::mesos::CheckInfo_Http* CheckInfo::release_http() {
  clear_has_http();
  ::mesos::CheckInfo_Http* temp = http_;
  http_ = NULL;
  return temp;
}
inline void CheckInfo::set_allocated_http(::mesos::CheckInfo_Http* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.http)
}

// optional .mesos.CheckInfo.Tcp tcp = 7;
inline bool CheckInfo::has_tcp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckInfo::set_has_tcp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckInfo::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckInfo::clear_tcp() {
  if (tcp_ != NULL) tcp_->::mesos::CheckInfo_Tcp::Clear();
  clear_has_tcp();
}
inline const ::mesos::CheckInfo_Tcp& CheckInfo::tcp() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.tcp)
  return tcp_ != NULL ? *tcp_ : *default_instance_->tcp_;
}
inline ::mesos::CheckInfo_Tcp* CheckInfo::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) tcp_ = new ::mesos::CheckInfo_Tcp;
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.tcp)
  return tcp_;
}
inline ::mesos::CheckInfo_Tcp* CheckInfo::release_tcp() {
  clear_has_tcp();
  ::mesos::CheckInfo_Tcp* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline void CheckInfo::set_allocated_tcp(::mesos::CheckInfo_Tcp* tcp) {
  delete tcp_;
  tcp_ = tcp;
  if (tcp) {
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.tcp)
}

// optional double delay_seconds = 4 [default = 15];
inline bool CheckInfo::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckInfo::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckInfo::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckInfo::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
inline double CheckInfo::delay_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.delay_seconds)
  return delay_seconds_;
}
inline void CheckInfo::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.delay_seconds)
}

// optional double interval_seconds = 5 [default = 10];
inline bool CheckInfo::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckInfo::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckInfo::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckInfo::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
inline double CheckInfo::interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.interval_seconds)
  return interval_seconds_;
}
inline void CheckInfo::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.interval_seconds)
}

// optional double timeout_seconds = 6 [default = 20];
inline bool CheckInfo::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckInfo::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckInfo::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckInfo::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
inline double CheckInfo::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.timeout_seconds)
  return timeout_seconds_;
}
inline void CheckInfo::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.timeout_seconds)
}

// -------------------------------------------------------------------

// HealthCheck_HTTPCheckInfo

// optional string scheme = 3;
inline bool HealthCheck_HTTPCheckInfo::has_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck_HTTPCheckInfo::clear_scheme() {
  if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_->clear();
  }
  clear_has_scheme();
}
inline const ::std::string& HealthCheck_HTTPCheckInfo::scheme() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.scheme)
  return *scheme_;
}
inline void HealthCheck_HTTPCheckInfo::set_scheme(const ::std::string& value) {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  scheme_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
inline void HealthCheck_HTTPCheckInfo::set_scheme(const char* value) {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  scheme_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
inline void HealthCheck_HTTPCheckInfo::set_scheme(const char* value, size_t size) {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  scheme_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
inline ::std::string* HealthCheck_HTTPCheckInfo::mutable_scheme() {
  set_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scheme_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.HTTPCheckInfo.scheme)
  return scheme_;
}
inline ::std::string* HealthCheck_HTTPCheckInfo::release_scheme() {
  clear_has_scheme();
  if (scheme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = scheme_;
    scheme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HealthCheck_HTTPCheckInfo::set_allocated_scheme(::std::string* scheme) {
  if (scheme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scheme_;
  }
  if (scheme) {
    set_has_scheme();
    scheme_ = scheme;
  } else {
    clear_has_scheme();
    scheme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.HTTPCheckInfo.scheme)
}

// required uint32 port = 1;
inline bool HealthCheck_HTTPCheckInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck_HTTPCheckInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HealthCheck_HTTPCheckInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.port)
  return port_;
}
inline void HealthCheck_HTTPCheckInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.port)
}

// optional string path = 2;
inline bool HealthCheck_HTTPCheckInfo::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCheck_HTTPCheckInfo::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCheck_HTTPCheckInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCheck_HTTPCheckInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& HealthCheck_HTTPCheckInfo::path() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.path)
  return *path_;
}
inline void HealthCheck_HTTPCheckInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.path)
}
inline void HealthCheck_HTTPCheckInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.HealthCheck.HTTPCheckInfo.path)
}
inline void HealthCheck_HTTPCheckInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.HealthCheck.HTTPCheckInfo.path)
}
inline ::std::string* HealthCheck_HTTPCheckInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.HTTPCheckInfo.path)
  return path_;
}
inline ::std::string* HealthCheck_HTTPCheckInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HealthCheck_HTTPCheckInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.HTTPCheckInfo.path)
}

// repeated uint32 statuses = 4;
inline int HealthCheck_HTTPCheckInfo::statuses_size() const {
  return statuses_.size();
}
inline void HealthCheck_HTTPCheckInfo::clear_statuses() {
  statuses_.Clear();
}
inline ::google::protobuf::uint32 HealthCheck_HTTPCheckInfo::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return statuses_.Get(index);
}
inline void HealthCheck_HTTPCheckInfo::set_statuses(int index, ::google::protobuf::uint32 value) {
  statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.statuses)
}
inline void HealthCheck_HTTPCheckInfo::add_statuses(::google::protobuf::uint32 value) {
  statuses_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.HealthCheck.HTTPCheckInfo.statuses)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HealthCheck_HTTPCheckInfo::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return statuses_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HealthCheck_HTTPCheckInfo::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return &statuses_;
}

// -------------------------------------------------------------------

// HealthCheck_TCPCheckInfo

// required uint32 port = 1;
inline bool HealthCheck_TCPCheckInfo::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck_TCPCheckInfo::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck_TCPCheckInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck_TCPCheckInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HealthCheck_TCPCheckInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.TCPCheckInfo.port)
  return port_;
}
inline void HealthCheck_TCPCheckInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.TCPCheckInfo.port)
}

// -------------------------------------------------------------------

// HealthCheck

// optional double delay_seconds = 2 [default = 15];
inline bool HealthCheck::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
inline double HealthCheck::delay_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.delay_seconds)
  return delay_seconds_;
}
inline void HealthCheck::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.delay_seconds)
}

// optional double interval_seconds = 3 [default = 10];
inline bool HealthCheck::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
inline double HealthCheck::interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.interval_seconds)
  return interval_seconds_;
}
inline void HealthCheck::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.interval_seconds)
}

// optional double timeout_seconds = 4 [default = 20];
inline bool HealthCheck::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCheck::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCheck::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCheck::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
inline double HealthCheck::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.timeout_seconds)
  return timeout_seconds_;
}
inline void HealthCheck::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.timeout_seconds)
}

// optional uint32 consecutive_failures = 5 [default = 3];
inline bool HealthCheck::has_consecutive_failures() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthCheck::set_has_consecutive_failures() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthCheck::clear_has_consecutive_failures() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthCheck::clear_consecutive_failures() {
  consecutive_failures_ = 3u;
  clear_has_consecutive_failures();
}
inline ::google::protobuf::uint32 HealthCheck::consecutive_failures() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.consecutive_failures)
  return consecutive_failures_;
}
inline void HealthCheck::set_consecutive_failures(::google::protobuf::uint32 value) {
  set_has_consecutive_failures();
  consecutive_failures_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.consecutive_failures)
}

// optional double grace_period_seconds = 6 [default = 10];
inline bool HealthCheck::has_grace_period_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthCheck::set_has_grace_period_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthCheck::clear_has_grace_period_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthCheck::clear_grace_period_seconds() {
  grace_period_seconds_ = 10;
  clear_has_grace_period_seconds();
}
inline double HealthCheck::grace_period_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.grace_period_seconds)
  return grace_period_seconds_;
}
inline void HealthCheck::set_grace_period_seconds(double value) {
  set_has_grace_period_seconds();
  grace_period_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.grace_period_seconds)
}

// optional .mesos.HealthCheck.Type type = 8;
inline bool HealthCheck::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HealthCheck::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HealthCheck::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HealthCheck::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::HealthCheck_Type HealthCheck::type() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.type)
  return static_cast< ::mesos::HealthCheck_Type >(type_);
}
inline void HealthCheck::set_type(::mesos::HealthCheck_Type value) {
  assert(::mesos::HealthCheck_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.type)
}

// optional .mesos.CommandInfo command = 7;
inline bool HealthCheck::has_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HealthCheck::set_has_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HealthCheck::clear_has_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HealthCheck::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& HealthCheck::command() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* HealthCheck::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.command)
  return command_;
}
inline ::mesos::CommandInfo* HealthCheck::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void HealthCheck::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.command)
}

// optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
inline bool HealthCheck::has_http() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HealthCheck::set_has_http() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HealthCheck::clear_has_http() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HealthCheck::clear_http() {
  if (http_ != NULL) http_->::mesos::HealthCheck_HTTPCheckInfo::Clear();
  clear_has_http();
}
inline const ::mesos::HealthCheck_HTTPCheckInfo& HealthCheck::http() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.http)
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
inline ::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::mutable_http() {
  set_has_http();
  if (http_ == NULL) http_ = new ::mesos::HealthCheck_HTTPCheckInfo;
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.http)
  return http_;
}
inline ::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::release_http() {
  clear_has_http();
  ::mesos::HealthCheck_HTTPCheckInfo* temp = http_;
  http_ = NULL;
  return temp;
}
inline void HealthCheck::set_allocated_http(::mesos::HealthCheck_HTTPCheckInfo* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.http)
}

// optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
inline bool HealthCheck::has_tcp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HealthCheck::set_has_tcp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HealthCheck::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HealthCheck::clear_tcp() {
  if (tcp_ != NULL) tcp_->::mesos::HealthCheck_TCPCheckInfo::Clear();
  clear_has_tcp();
}
inline const ::mesos::HealthCheck_TCPCheckInfo& HealthCheck::tcp() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.tcp)
  return tcp_ != NULL ? *tcp_ : *default_instance_->tcp_;
}
inline ::mesos::HealthCheck_TCPCheckInfo* HealthCheck::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) tcp_ = new ::mesos::HealthCheck_TCPCheckInfo;
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.tcp)
  return tcp_;
}
inline ::mesos::HealthCheck_TCPCheckInfo* HealthCheck::release_tcp() {
  clear_has_tcp();
  ::mesos::HealthCheck_TCPCheckInfo* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline void HealthCheck::set_allocated_tcp(::mesos::HealthCheck_TCPCheckInfo* tcp) {
  delete tcp_;
  tcp_ = tcp;
  if (tcp) {
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.tcp)
}

// -------------------------------------------------------------------

// KillPolicy

// optional .mesos.DurationInfo grace_period = 1;
inline bool KillPolicy::has_grace_period() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillPolicy::set_has_grace_period() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillPolicy::clear_has_grace_period() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillPolicy::clear_grace_period() {
  if (grace_period_ != NULL) grace_period_->::mesos::DurationInfo::Clear();
  clear_has_grace_period();
}
inline const ::mesos::DurationInfo& KillPolicy::grace_period() const {
  // @@protoc_insertion_point(field_get:mesos.KillPolicy.grace_period)
  return grace_period_ != NULL ? *grace_period_ : *default_instance_->grace_period_;
}
inline ::mesos::DurationInfo* KillPolicy::mutable_grace_period() {
  set_has_grace_period();
  if (grace_period_ == NULL) grace_period_ = new ::mesos::DurationInfo;
  // @@protoc_insertion_point(field_mutable:mesos.KillPolicy.grace_period)
  return grace_period_;
}
inline ::mesos::DurationInfo* KillPolicy::release_grace_period() {
  clear_has_grace_period();
  ::mesos::DurationInfo* temp = grace_period_;
  grace_period_ = NULL;
  return temp;
}
inline void KillPolicy::set_allocated_grace_period(::mesos::DurationInfo* grace_period) {
  delete grace_period_;
  grace_period_ = grace_period;
  if (grace_period) {
    set_has_grace_period();
  } else {
    clear_has_grace_period();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.KillPolicy.grace_period)
}

// -------------------------------------------------------------------

// CommandInfo_URI

// required string value = 1;
inline bool CommandInfo_URI::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_URI::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_URI::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_URI::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo_URI::value() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.value)
  return *value_;
}
inline void CommandInfo_URI::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.value)
}
inline void CommandInfo_URI::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.URI.value)
}
inline void CommandInfo_URI::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.URI.value)
}
inline ::std::string* CommandInfo_URI::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.URI.value)
  return value_;
}
inline ::std::string* CommandInfo_URI::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandInfo_URI::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.URI.value)
}

// optional bool executable = 2;
inline bool CommandInfo_URI::has_executable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo_URI::set_has_executable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo_URI::clear_has_executable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo_URI::clear_executable() {
  executable_ = false;
  clear_has_executable();
}
inline bool CommandInfo_URI::executable() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.executable)
  return executable_;
}
inline void CommandInfo_URI::set_executable(bool value) {
  set_has_executable();
  executable_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.executable)
}

// optional bool extract = 3 [default = true];
inline bool CommandInfo_URI::has_extract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo_URI::set_has_extract() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo_URI::clear_has_extract() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo_URI::clear_extract() {
  extract_ = true;
  clear_has_extract();
}
inline bool CommandInfo_URI::extract() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.extract)
  return extract_;
}
inline void CommandInfo_URI::set_extract(bool value) {
  set_has_extract();
  extract_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.extract)
}

// optional bool cache = 4;
inline bool CommandInfo_URI::has_cache() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInfo_URI::set_has_cache() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInfo_URI::clear_has_cache() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInfo_URI::clear_cache() {
  cache_ = false;
  clear_has_cache();
}
inline bool CommandInfo_URI::cache() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.cache)
  return cache_;
}
inline void CommandInfo_URI::set_cache(bool value) {
  set_has_cache();
  cache_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.cache)
}

// optional string output_file = 5;
inline bool CommandInfo_URI::has_output_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandInfo_URI::set_has_output_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandInfo_URI::clear_has_output_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandInfo_URI::clear_output_file() {
  if (output_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_file_->clear();
  }
  clear_has_output_file();
}
inline const ::std::string& CommandInfo_URI::output_file() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.output_file)
  return *output_file_;
}
inline void CommandInfo_URI::set_output_file(const ::std::string& value) {
  set_has_output_file();
  if (output_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_file_ = new ::std::string;
  }
  output_file_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.output_file)
}
inline void CommandInfo_URI::set_output_file(const char* value) {
  set_has_output_file();
  if (output_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_file_ = new ::std::string;
  }
  output_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.URI.output_file)
}
inline void CommandInfo_URI::set_output_file(const char* value, size_t size) {
  set_has_output_file();
  if (output_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_file_ = new ::std::string;
  }
  output_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.URI.output_file)
}
inline ::std::string* CommandInfo_URI::mutable_output_file() {
  set_has_output_file();
  if (output_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.URI.output_file)
  return output_file_;
}
inline ::std::string* CommandInfo_URI::release_output_file() {
  clear_has_output_file();
  if (output_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = output_file_;
    output_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandInfo_URI::set_allocated_output_file(::std::string* output_file) {
  if (output_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete output_file_;
  }
  if (output_file) {
    set_has_output_file();
    output_file_ = output_file;
  } else {
    clear_has_output_file();
    output_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.URI.output_file)
}

// -------------------------------------------------------------------

// CommandInfo

// repeated .mesos.CommandInfo.URI uris = 1;
inline int CommandInfo::uris_size() const {
  return uris_.size();
}
inline void CommandInfo::clear_uris() {
  uris_.Clear();
}
inline const ::mesos::CommandInfo_URI& CommandInfo::uris(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.uris)
  return uris_.Get(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::mutable_uris(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.uris)
  return uris_.Mutable(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::add_uris() {
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.uris)
  return uris_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
CommandInfo::uris() const {
  // @@protoc_insertion_point(field_list:mesos.CommandInfo.uris)
  return uris_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
CommandInfo::mutable_uris() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CommandInfo.uris)
  return &uris_;
}

// optional .mesos.Environment environment = 2;
inline bool CommandInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo::clear_environment() {
  if (environment_ != NULL) environment_->::mesos::Environment::Clear();
  clear_has_environment();
}
inline const ::mesos::Environment& CommandInfo::environment() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.environment)
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::mesos::Environment* CommandInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::mesos::Environment;
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.environment)
  return environment_;
}
inline ::mesos::Environment* CommandInfo::release_environment() {
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void CommandInfo::set_allocated_environment(::mesos::Environment* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.environment)
}

// optional bool shell = 6 [default = true];
inline bool CommandInfo::has_shell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo::set_has_shell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo::clear_has_shell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo::clear_shell() {
  shell_ = true;
  clear_has_shell();
}
inline bool CommandInfo::shell() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.shell)
  return shell_;
}
inline void CommandInfo::set_shell(bool value) {
  set_has_shell();
  shell_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.shell)
}

// optional string value = 3;
inline bool CommandInfo::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInfo::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo::value() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.value)
  return *value_;
}
inline void CommandInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.value)
}
inline void CommandInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.value)
}
inline void CommandInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.value)
}
inline ::std::string* CommandInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.value)
  return value_;
}
inline ::std::string* CommandInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandInfo::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.value)
}

// repeated string arguments = 7;
inline int CommandInfo::arguments_size() const {
  return arguments_.size();
}
inline void CommandInfo::clear_arguments() {
  arguments_.Clear();
}
inline const ::std::string& CommandInfo::arguments(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.arguments)
  return arguments_.Get(index);
}
inline ::std::string* CommandInfo::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.arguments)
  return arguments_.Mutable(index);
}
inline void CommandInfo::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.arguments)
  arguments_.Mutable(index)->assign(value);
}
inline void CommandInfo::set_arguments(int index, const char* value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.arguments)
}
inline void CommandInfo::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.arguments)
}
inline ::std::string* CommandInfo::add_arguments() {
  return arguments_.Add();
}
inline void CommandInfo::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.arguments)
}
inline void CommandInfo::add_arguments(const char* value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.CommandInfo.arguments)
}
inline void CommandInfo::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.CommandInfo.arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandInfo::arguments() const {
  // @@protoc_insertion_point(field_list:mesos.CommandInfo.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandInfo::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CommandInfo.arguments)
  return &arguments_;
}

// optional string user = 5;
inline bool CommandInfo::has_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandInfo::set_has_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& CommandInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.user)
  return *user_;
}
inline void CommandInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.user)
}
inline void CommandInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.user)
}
inline void CommandInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.user)
}
inline ::std::string* CommandInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.user)
  return user_;
}
inline ::std::string* CommandInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.user)
}

// -------------------------------------------------------------------

// ExecutorInfo

// optional .mesos.ExecutorInfo.Type type = 15;
inline bool ExecutorInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::ExecutorInfo_Type ExecutorInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.type)
  return static_cast< ::mesos::ExecutorInfo_Type >(type_);
}
inline void ExecutorInfo::set_type(::mesos::ExecutorInfo_Type value) {
  assert(::mesos::ExecutorInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.type)
}

// required .mesos.ExecutorID executor_id = 1;
inline bool ExecutorInfo::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorInfo::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorInfo::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.executor_id)
}

// optional .mesos.FrameworkID framework_id = 8;
inline bool ExecutorInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorInfo::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorInfo::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.framework_id)
}

// optional .mesos.CommandInfo command = 7;
inline bool ExecutorInfo::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutorInfo::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutorInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutorInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& ExecutorInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.command)
  return command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.command)
}

// optional .mesos.ContainerInfo container = 11;
inline bool ExecutorInfo::has_container() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutorInfo::set_has_container() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutorInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutorInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& ExecutorInfo::container() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::ContainerInfo* ExecutorInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::ContainerInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.container)
  return container_;
}
inline ::mesos::ContainerInfo* ExecutorInfo::release_container() {
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.container)
}

// repeated .mesos.Resource resources = 5;
inline int ExecutorInfo::resources_size() const {
  return resources_.size();
}
inline void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ExecutorInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.ExecutorInfo.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.ExecutorInfo.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ExecutorInfo.resources)
  return &resources_;
}

// optional string name = 9;
inline bool ExecutorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutorInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExecutorInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.name)
  return *name_;
}
inline void ExecutorInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.name)
}
inline void ExecutorInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.name)
}
inline void ExecutorInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.name)
}
inline ::std::string* ExecutorInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.name)
  return name_;
}
inline ::std::string* ExecutorInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.name)
}

// optional string source = 10 [deprecated = true];
inline bool ExecutorInfo::has_source() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutorInfo::set_has_source() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutorInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutorInfo::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& ExecutorInfo::source() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.source)
  return *source_;
}
inline void ExecutorInfo::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.source)
}
inline void ExecutorInfo::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.source)
}
inline void ExecutorInfo::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.source)
}
inline ::std::string* ExecutorInfo::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.source)
  return source_;
}
inline ::std::string* ExecutorInfo::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.source)
}

// optional bytes data = 4;
inline bool ExecutorInfo::has_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutorInfo::set_has_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutorInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutorInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ExecutorInfo::data() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.data)
  return *data_;
}
inline void ExecutorInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.data)
}
inline void ExecutorInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.data)
}
inline void ExecutorInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.data)
}
inline ::std::string* ExecutorInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.data)
  return data_;
}
inline ::std::string* ExecutorInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.data)
}

// optional .mesos.DiscoveryInfo discovery = 12;
inline bool ExecutorInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExecutorInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExecutorInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExecutorInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& ExecutorInfo::discovery() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.discovery)
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) discovery_ = new ::mesos::DiscoveryInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.discovery)
  return discovery_;
}
inline ::mesos::DiscoveryInfo* ExecutorInfo::release_discovery() {
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.discovery)
}

// optional .mesos.DurationInfo shutdown_grace_period = 13;
inline bool ExecutorInfo::has_shutdown_grace_period() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutorInfo::set_has_shutdown_grace_period() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutorInfo::clear_has_shutdown_grace_period() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutorInfo::clear_shutdown_grace_period() {
  if (shutdown_grace_period_ != NULL) shutdown_grace_period_->::mesos::DurationInfo::Clear();
  clear_has_shutdown_grace_period();
}
inline const ::mesos::DurationInfo& ExecutorInfo::shutdown_grace_period() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.shutdown_grace_period)
  return shutdown_grace_period_ != NULL ? *shutdown_grace_period_ : *default_instance_->shutdown_grace_period_;
}
inline ::mesos::DurationInfo* ExecutorInfo::mutable_shutdown_grace_period() {
  set_has_shutdown_grace_period();
  if (shutdown_grace_period_ == NULL) shutdown_grace_period_ = new ::mesos::DurationInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.shutdown_grace_period)
  return shutdown_grace_period_;
}
inline ::mesos::DurationInfo* ExecutorInfo::release_shutdown_grace_period() {
  clear_has_shutdown_grace_period();
  ::mesos::DurationInfo* temp = shutdown_grace_period_;
  shutdown_grace_period_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_shutdown_grace_period(::mesos::DurationInfo* shutdown_grace_period) {
  delete shutdown_grace_period_;
  shutdown_grace_period_ = shutdown_grace_period;
  if (shutdown_grace_period) {
    set_has_shutdown_grace_period();
  } else {
    clear_has_shutdown_grace_period();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.shutdown_grace_period)
}

// optional .mesos.Labels labels = 14;
inline bool ExecutorInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExecutorInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExecutorInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExecutorInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& ExecutorInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* ExecutorInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.labels)
  return labels_;
}
inline ::mesos::Labels* ExecutorInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.labels)
}

// -------------------------------------------------------------------

// MasterInfo

// required string id = 1;
inline bool MasterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MasterInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.id)
  return *id_;
}
inline void MasterInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.id)
}
inline void MasterInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.id)
}
inline void MasterInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.id)
}
inline ::std::string* MasterInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.id)
  return id_;
}
inline ::std::string* MasterInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.id)
}

// required uint32 ip = 2;
inline bool MasterInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 MasterInfo::ip() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.ip)
  return ip_;
}
inline void MasterInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.ip)
}

// required uint32 port = 3 [default = 5050];
inline bool MasterInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterInfo::clear_port() {
  port_ = 5050u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MasterInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.port)
  return port_;
}
inline void MasterInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.port)
}

// optional string pid = 4;
inline bool MasterInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterInfo::clear_pid() {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& MasterInfo::pid() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.pid)
  return *pid_;
}
inline void MasterInfo::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.pid)
}
inline void MasterInfo::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.pid)
}
inline void MasterInfo::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.pid)
}
inline ::std::string* MasterInfo::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.pid)
  return pid_;
}
inline ::std::string* MasterInfo::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterInfo::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.pid)
}

// optional string hostname = 5;
inline bool MasterInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& MasterInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.hostname)
  return *hostname_;
}
inline void MasterInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.hostname)
}
inline void MasterInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.hostname)
}
inline void MasterInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.hostname)
}
inline ::std::string* MasterInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.hostname)
  return hostname_;
}
inline ::std::string* MasterInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.hostname)
}

// optional string version = 6;
inline bool MasterInfo::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MasterInfo::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MasterInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MasterInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& MasterInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.version)
  return *version_;
}
inline void MasterInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.version)
}
inline void MasterInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.version)
}
inline void MasterInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.version)
}
inline ::std::string* MasterInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.version)
  return version_;
}
inline ::std::string* MasterInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.version)
}

// optional .mesos.Address address = 7;
inline bool MasterInfo::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MasterInfo::set_has_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MasterInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MasterInfo::clear_address() {
  if (address_ != NULL) address_->::mesos::Address::Clear();
  clear_has_address();
}
inline const ::mesos::Address& MasterInfo::address() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::mesos::Address* MasterInfo::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::mesos::Address;
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.address)
  return address_;
}
inline ::mesos::Address* MasterInfo::release_address() {
  clear_has_address();
  ::mesos::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void MasterInfo::set_allocated_address(::mesos::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.address)
}

// -------------------------------------------------------------------

// SlaveInfo_Capability

// optional .mesos.SlaveInfo.Capability.Type type = 1;
inline bool SlaveInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::SlaveInfo_Capability_Type SlaveInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.Capability.type)
  return static_cast< ::mesos::SlaveInfo_Capability_Type >(type_);
}
inline void SlaveInfo_Capability::set_type(::mesos::SlaveInfo_Capability_Type value) {
  assert(::mesos::SlaveInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.Capability.type)
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
inline bool SlaveInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& SlaveInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.hostname)
  return *hostname_;
}
inline void SlaveInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.hostname)
}
inline void SlaveInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.SlaveInfo.hostname)
}
inline void SlaveInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.SlaveInfo.hostname)
}
inline ::std::string* SlaveInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.hostname)
  return hostname_;
}
inline ::std::string* SlaveInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.hostname)
}

// optional int32 port = 8 [default = 5051];
inline bool SlaveInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveInfo::clear_port() {
  port_ = 5051;
  clear_has_port();
}
inline ::google::protobuf::int32 SlaveInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.port)
  return port_;
}
inline void SlaveInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.port)
}

// repeated .mesos.Resource resources = 3;
inline int SlaveInfo::resources_size() const {
  return resources_.size();
}
inline void SlaveInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& SlaveInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* SlaveInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.SlaveInfo.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.SlaveInfo.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.SlaveInfo.resources)
  return &resources_;
}

// repeated .mesos.Attribute attributes = 5;
inline int SlaveInfo::attributes_size() const {
  return attributes_.size();
}
inline void SlaveInfo::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& SlaveInfo::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.attributes)
  return attributes_.Get(index);
}
inline ::mesos::Attribute* SlaveInfo::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.attributes)
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* SlaveInfo::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.SlaveInfo.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
SlaveInfo::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.SlaveInfo.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
SlaveInfo::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.SlaveInfo.attributes)
  return &attributes_;
}

// optional .mesos.SlaveID id = 6;
inline bool SlaveInfo::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveInfo::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::SlaveID::Clear();
  clear_has_id();
}
inline const ::mesos::SlaveID& SlaveInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::SlaveID* SlaveInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.id)
  return id_;
}
inline ::mesos::SlaveID* SlaveInfo::release_id() {
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SlaveInfo::set_allocated_id(::mesos::SlaveID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.id)
}

// optional bool checkpoint = 7 [default = false];
inline bool SlaveInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool SlaveInfo::checkpoint() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.checkpoint)
  return checkpoint_;
}
inline void SlaveInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.checkpoint)
}

// -------------------------------------------------------------------

// Value_Scalar

// required double value = 1;
inline bool Value_Scalar::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Scalar::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Scalar::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Scalar::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Value_Scalar::value() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Scalar.value)
  return value_;
}
inline void Value_Scalar::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Scalar.value)
}

// -------------------------------------------------------------------

// Value_Range

// required uint64 begin = 1;
inline bool Value_Range::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Range::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Range::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::uint64 Value_Range::begin() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Range.begin)
  return begin_;
}
inline void Value_Range::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Range.begin)
}

// required uint64 end = 2;
inline bool Value_Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 Value_Range::end() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Range.end)
  return end_;
}
inline void Value_Range::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Range.end)
}

// -------------------------------------------------------------------

// Value_Ranges

// repeated .mesos.Value.Range range = 1;
inline int Value_Ranges::range_size() const {
  return range_.size();
}
inline void Value_Ranges::clear_range() {
  range_.Clear();
}
inline const ::mesos::Value_Range& Value_Ranges::range(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Value.Ranges.range)
  return range_.Get(index);
}
inline ::mesos::Value_Range* Value_Ranges::mutable_range(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Value.Ranges.range)
  return range_.Mutable(index);
}
inline ::mesos::Value_Range* Value_Ranges::add_range() {
  // @@protoc_insertion_point(field_add:mesos.Value.Ranges.range)
  return range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
Value_Ranges::range() const {
  // @@protoc_insertion_point(field_list:mesos.Value.Ranges.range)
  return range_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
Value_Ranges::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Value.Ranges.range)
  return &range_;
}

// -------------------------------------------------------------------

// Value_Set

// repeated string item = 1;
inline int Value_Set::item_size() const {
  return item_.size();
}
inline void Value_Set::clear_item() {
  item_.Clear();
}
inline const ::std::string& Value_Set::item(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Value.Set.item)
  return item_.Get(index);
}
inline ::std::string* Value_Set::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Value.Set.item)
  return item_.Mutable(index);
}
inline void Value_Set::set_item(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.Value.Set.item)
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value) {
  item_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Value.Set.item)
}
inline void Value_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Value.Set.item)
}
inline ::std::string* Value_Set::add_item() {
  return item_.Add();
}
inline void Value_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.Value.Set.item)
}
inline void Value_Set::add_item(const char* value) {
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.Value.Set.item)
}
inline void Value_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.Value.Set.item)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Value_Set::item() const {
  // @@protoc_insertion_point(field_list:mesos.Value.Set.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Value_Set::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Value.Set.item)
  return &item_;
}

// -------------------------------------------------------------------

// Value_Text

// required string value = 1;
inline bool Value_Text::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Text::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Text::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Text::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Value_Text::value() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Text.value)
  return *value_;
}
inline void Value_Text::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Value.Text.value)
}
inline void Value_Text::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Value.Text.value)
}
inline void Value_Text::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Value.Text.value)
}
inline ::std::string* Value_Text::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.Text.value)
  return value_;
}
inline ::std::string* Value_Text::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Value_Text::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.Text.value)
}

// -------------------------------------------------------------------

// Value

// required .mesos.Value.Type type = 1;
inline bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Value::type() const {
  // @@protoc_insertion_point(field_get:mesos.Value.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Value::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.type)
}

// optional .mesos.Value.Scalar scalar = 2;
inline bool Value::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Value::scalar() const {
  // @@protoc_insertion_point(field_get:mesos.Value.scalar)
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Value::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  // @@protoc_insertion_point(field_mutable:mesos.Value.scalar)
  return scalar_;
}
inline ::mesos::Value_Scalar* Value::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Value::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.scalar)
}

// optional .mesos.Value.Ranges ranges = 3;
inline bool Value::has_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Value::ranges() const {
  // @@protoc_insertion_point(field_get:mesos.Value.ranges)
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Value::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  // @@protoc_insertion_point(field_mutable:mesos.Value.ranges)
  return ranges_;
}
inline ::mesos::Value_Ranges* Value::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Value::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.ranges)
}

// optional .mesos.Value.Set set = 4;
inline bool Value::has_set() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_set() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_set() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Value::set() const {
  // @@protoc_insertion_point(field_get:mesos.Value.set)
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Value::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  // @@protoc_insertion_point(field_mutable:mesos.Value.set)
  return set_;
}
inline ::mesos::Value_Set* Value::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Value::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.set)
}

// optional .mesos.Value.Text text = 5;
inline bool Value::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Value::text() const {
  // @@protoc_insertion_point(field_get:mesos.Value.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Value::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  // @@protoc_insertion_point(field_mutable:mesos.Value.text)
  return text_;
}
inline ::mesos::Value_Text* Value::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Value::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.text)
}

// -------------------------------------------------------------------

// Attribute

// required string name = 1;
inline bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Attribute::name() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.name)
  return *name_;
}
inline void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Attribute.name)
}
inline void Attribute::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Attribute.name)
}
inline void Attribute::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Attribute.name)
}
inline ::std::string* Attribute::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.name)
  return name_;
}
inline ::std::string* Attribute::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Attribute::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.name)
}

// required .mesos.Value.Type type = 2;
inline bool Attribute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Attribute::type() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Attribute::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Attribute.type)
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Attribute::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Attribute::scalar() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.scalar)
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Attribute::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.scalar)
  return scalar_;
}
inline ::mesos::Value_Scalar* Attribute::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.scalar)
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Attribute::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Attribute::ranges() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.ranges)
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Attribute::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.ranges)
  return ranges_;
}
inline ::mesos::Value_Ranges* Attribute::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.ranges)
}

// optional .mesos.Value.Set set = 6;
inline bool Attribute::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attribute::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attribute::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attribute::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Attribute::set() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.set)
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Attribute::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.set)
  return set_;
}
inline ::mesos::Value_Set* Attribute::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.set)
}

// optional .mesos.Value.Text text = 5;
inline bool Attribute::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Attribute::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Attribute::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Attribute::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Attribute::text() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Attribute::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.text)
  return text_;
}
inline ::mesos::Value_Text* Attribute::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.text)
}

// -------------------------------------------------------------------

// Resource_AllocationInfo

// optional string role = 1;
inline bool Resource_AllocationInfo::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_AllocationInfo::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_AllocationInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_AllocationInfo::clear_role() {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& Resource_AllocationInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.AllocationInfo.role)
  return *role_;
}
inline void Resource_AllocationInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.AllocationInfo.role)
}
inline void Resource_AllocationInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.AllocationInfo.role)
}
inline void Resource_AllocationInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.AllocationInfo.role)
}
inline ::std::string* Resource_AllocationInfo::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.AllocationInfo.role)
  return role_;
}
inline ::std::string* Resource_AllocationInfo::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource_AllocationInfo::set_allocated_role(::std::string* role) {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.AllocationInfo.role)
}

// -------------------------------------------------------------------

// Resource_ReservationInfo

// optional string principal = 1;
inline bool Resource_ReservationInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_ReservationInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_ReservationInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_ReservationInfo::clear_principal() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& Resource_ReservationInfo::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.principal)
  return *principal_;
}
inline void Resource_ReservationInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.ReservationInfo.principal)
}
inline void Resource_ReservationInfo::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.ReservationInfo.principal)
}
inline void Resource_ReservationInfo::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.ReservationInfo.principal)
}
inline ::std::string* Resource_ReservationInfo::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.principal)
  return principal_;
}
inline ::std::string* Resource_ReservationInfo::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource_ReservationInfo::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.principal)
}

// optional .mesos.Labels labels = 2;
inline bool Resource_ReservationInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_ReservationInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_ReservationInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_ReservationInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Resource_ReservationInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* Resource_ReservationInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.labels)
  return labels_;
}
inline ::mesos::Labels* Resource_ReservationInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void Resource_ReservationInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.labels)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Persistence

// required string id = 1;
inline bool Resource_DiskInfo_Persistence::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Persistence::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Persistence::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Persistence::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Resource_DiskInfo_Persistence::id() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Persistence.id)
  return *id_;
}
inline void Resource_DiskInfo_Persistence::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Persistence.id)
}
inline void Resource_DiskInfo_Persistence::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Persistence.id)
}
inline void Resource_DiskInfo_Persistence::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Persistence.id)
}
inline ::std::string* Resource_DiskInfo_Persistence::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Persistence.id)
  return id_;
}
inline ::std::string* Resource_DiskInfo_Persistence::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource_DiskInfo_Persistence::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Persistence.id)
}

// optional string principal = 2;
inline bool Resource_DiskInfo_Persistence::has_principal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo_Persistence::set_has_principal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo_Persistence::clear_has_principal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo_Persistence::clear_principal() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& Resource_DiskInfo_Persistence::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Persistence.principal)
  return *principal_;
}
inline void Resource_DiskInfo_Persistence::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Persistence.principal)
}
inline void Resource_DiskInfo_Persistence::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Persistence.principal)
}
inline void Resource_DiskInfo_Persistence::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Persistence.principal)
}
inline ::std::string* Resource_DiskInfo_Persistence::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Persistence.principal)
  return principal_;
}
inline ::std::string* Resource_DiskInfo_Persistence::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource_DiskInfo_Persistence::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Persistence.principal)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source_Path

// optional string root = 1;
inline bool Resource_DiskInfo_Source_Path::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Source_Path::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Source_Path::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Source_Path::clear_root() {
  if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_->clear();
  }
  clear_has_root();
}
inline const ::std::string& Resource_DiskInfo_Source_Path::root() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.Path.root)
  return *root_;
}
inline void Resource_DiskInfo_Source_Path::set_root(const ::std::string& value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  root_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.Path.root)
}
inline void Resource_DiskInfo_Source_Path::set_root(const char* value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  root_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.Path.root)
}
inline void Resource_DiskInfo_Source_Path::set_root(const char* value, size_t size) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  root_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.Path.root)
}
inline ::std::string* Resource_DiskInfo_Source_Path::mutable_root() {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.Path.root)
  return root_;
}
inline ::std::string* Resource_DiskInfo_Source_Path::release_root() {
  clear_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = root_;
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource_DiskInfo_Source_Path::set_allocated_root(::std::string* root) {
  if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete root_;
  }
  if (root) {
    set_has_root();
    root_ = root;
  } else {
    clear_has_root();
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.Path.root)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source_Mount

// optional string root = 1;
inline bool Resource_DiskInfo_Source_Mount::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Source_Mount::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Source_Mount::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Source_Mount::clear_root() {
  if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_->clear();
  }
  clear_has_root();
}
inline const ::std::string& Resource_DiskInfo_Source_Mount::root() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.Mount.root)
  return *root_;
}
inline void Resource_DiskInfo_Source_Mount::set_root(const ::std::string& value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  root_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.Mount.root)
}
inline void Resource_DiskInfo_Source_Mount::set_root(const char* value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  root_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.Mount.root)
}
inline void Resource_DiskInfo_Source_Mount::set_root(const char* value, size_t size) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  root_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.Mount.root)
}
inline ::std::string* Resource_DiskInfo_Source_Mount::mutable_root() {
  set_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    root_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.Mount.root)
  return root_;
}
inline ::std::string* Resource_DiskInfo_Source_Mount::release_root() {
  clear_has_root();
  if (root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = root_;
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource_DiskInfo_Source_Mount::set_allocated_root(::std::string* root) {
  if (root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete root_;
  }
  if (root) {
    set_has_root();
    root_ = root;
  } else {
    clear_has_root();
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.Mount.root)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source

// required .mesos.Resource.DiskInfo.Source.Type type = 1;
inline bool Resource_DiskInfo_Source::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo_Source::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo_Source::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.type)
  return static_cast< ::mesos::Resource_DiskInfo_Source_Type >(type_);
}
inline void Resource_DiskInfo_Source::set_type(::mesos::Resource_DiskInfo_Source_Type value) {
  assert(::mesos::Resource_DiskInfo_Source_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.type)
}

// optional .mesos.Resource.DiskInfo.Source.Path path = 2;
inline bool Resource_DiskInfo_Source::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo_Source::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo_Source::clear_path() {
  if (path_ != NULL) path_->::mesos::Resource_DiskInfo_Source_Path::Clear();
  clear_has_path();
}
inline const ::mesos::Resource_DiskInfo_Source_Path& Resource_DiskInfo_Source::path() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.path)
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::mesos::Resource_DiskInfo_Source_Path;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.path)
  return path_;
}
inline ::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::release_path() {
  clear_has_path();
  ::mesos::Resource_DiskInfo_Source_Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void Resource_DiskInfo_Source::set_allocated_path(::mesos::Resource_DiskInfo_Source_Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.path)
}

// optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
inline bool Resource_DiskInfo_Source::has_mount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource_DiskInfo_Source::set_has_mount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource_DiskInfo_Source::clear_has_mount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource_DiskInfo_Source::clear_mount() {
  if (mount_ != NULL) mount_->::mesos::Resource_DiskInfo_Source_Mount::Clear();
  clear_has_mount();
}
inline const ::mesos::Resource_DiskInfo_Source_Mount& Resource_DiskInfo_Source::mount() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.mount)
  return mount_ != NULL ? *mount_ : *default_instance_->mount_;
}
inline ::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::mutable_mount() {
  set_has_mount();
  if (mount_ == NULL) mount_ = new ::mesos::Resource_DiskInfo_Source_Mount;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.mount)
  return mount_;
}
inline ::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::release_mount() {
  clear_has_mount();
  ::mesos::Resource_DiskInfo_Source_Mount* temp = mount_;
  mount_ = NULL;
  return temp;
}
inline void Resource_DiskInfo_Source::set_allocated_mount(::mesos::Resource_DiskInfo_Source_Mount* mount) {
  delete mount_;
  mount_ = mount;
  if (mount) {
    set_has_mount();
  } else {
    clear_has_mount();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.mount)
}

// -------------------------------------------------------------------

// Resource_DiskInfo

// optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
inline bool Resource_DiskInfo::has_persistence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource_DiskInfo::set_has_persistence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource_DiskInfo::clear_has_persistence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource_DiskInfo::clear_persistence() {
  if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
  clear_has_persistence();
}
inline const ::mesos::Resource_DiskInfo_Persistence& Resource_DiskInfo::persistence() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.persistence)
  return persistence_ != NULL ? *persistence_ : *default_instance_->persistence_;
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::mutable_persistence() {
  set_has_persistence();
  if (persistence_ == NULL) persistence_ = new ::mesos::Resource_DiskInfo_Persistence;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.persistence)
  return persistence_;
}
inline ::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::release_persistence() {
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
inline void Resource_DiskInfo::set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence) {
  delete persistence_;
  persistence_ = persistence;
  if (persistence) {
    set_has_persistence();
  } else {
    clear_has_persistence();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.persistence)
}

// optional .mesos.Volume volume = 2;
inline bool Resource_DiskInfo::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource_DiskInfo::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource_DiskInfo::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource_DiskInfo::clear_volume() {
  if (volume_ != NULL) volume_->::mesos::Volume::Clear();
  clear_has_volume();
}
inline const ::mesos::Volume& Resource_DiskInfo::volume() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.volume)
  return volume_ != NULL ? *volume_ : *default_instance_->volume_;
}
inline ::mesos::Volume* Resource_DiskInfo::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) volume_ = new ::mesos::Volume;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.volume)
  return volume_;
}
inline ::mesos::Volume* Resource_DiskInfo::release_volume() {
  clear_has_volume();
  ::mesos::Volume* temp = volume_;
  volume_ = NULL;
  return temp;
}
inline void Resource_DiskInfo::set_allocated_volume(::mesos::Volume* volume) {
  delete volume_;
  volume_ = volume;
  if (volume) {
    set_has_volume();
  } else {
    clear_has_volume();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.volume)
}

// optional .mesos.Resource.DiskInfo.Source source = 3;
inline bool Resource_DiskInfo::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource_DiskInfo::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource_DiskInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource_DiskInfo::clear_source() {
  if (source_ != NULL) source_->::mesos::Resource_DiskInfo_Source::Clear();
  clear_has_source();
}
inline const ::mesos::Resource_DiskInfo_Source& Resource_DiskInfo::source() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::mesos::Resource_DiskInfo_Source;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.source)
  return source_;
}
inline ::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::release_source() {
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Resource_DiskInfo::set_allocated_source(::mesos::Resource_DiskInfo_Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.source)
}

// -------------------------------------------------------------------

// Resource_RevocableInfo

// -------------------------------------------------------------------

// Resource_SharedInfo

// -------------------------------------------------------------------

// Resource

// optional .mesos.ResourceProviderID provider_id = 12;
inline bool Resource::has_provider_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_provider_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_provider_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_provider_id() {
  if (provider_id_ != NULL) provider_id_->::mesos::ResourceProviderID::Clear();
  clear_has_provider_id();
}
inline const ::mesos::ResourceProviderID& Resource::provider_id() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.provider_id)
  return provider_id_ != NULL ? *provider_id_ : *default_instance_->provider_id_;
}
inline ::mesos::ResourceProviderID* Resource::mutable_provider_id() {
  set_has_provider_id();
  if (provider_id_ == NULL) provider_id_ = new ::mesos::ResourceProviderID;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.provider_id)
  return provider_id_;
}
inline ::mesos::ResourceProviderID* Resource::release_provider_id() {
  clear_has_provider_id();
  ::mesos::ResourceProviderID* temp = provider_id_;
  provider_id_ = NULL;
  return temp;
}
inline void Resource::set_allocated_provider_id(::mesos::ResourceProviderID* provider_id) {
  delete provider_id_;
  provider_id_ = provider_id;
  if (provider_id) {
    set_has_provider_id();
  } else {
    clear_has_provider_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.provider_id)
}

// required string name = 1;
inline bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.name)
  return *name_;
}
inline void Resource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.name)
}
inline void Resource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.name)
}
inline void Resource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.name)
}
inline ::std::string* Resource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.name)
  return name_;
}
inline ::std::string* Resource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.name)
}

// required .mesos.Value.Type type = 2;
inline bool Resource::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Resource::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Resource::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.type)
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Resource::has_scalar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_scalar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Resource::scalar() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.scalar)
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Resource::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.scalar)
  return scalar_;
}
inline ::mesos::Value_Scalar* Resource::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Resource::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.scalar)
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Resource::has_ranges() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource::set_has_ranges() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Resource::ranges() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ranges)
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Resource::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ranges)
  return ranges_;
}
inline ::mesos::Value_Ranges* Resource::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Resource::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ranges)
}

// optional .mesos.Value.Set set = 5;
inline bool Resource::has_set() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource::set_has_set() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource::clear_has_set() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Resource::set() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.set)
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Resource::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.set)
  return set_;
}
inline ::mesos::Value_Set* Resource::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Resource::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.set)
}

// optional string role = 6 [default = "*"];
inline bool Resource::has_role() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Resource::set_has_role() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Resource::clear_has_role() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Resource::clear_role() {
  if (role_ != _default_role_) {
    role_->assign(*_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& Resource::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.role)
  return *role_;
}
inline void Resource::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Resource.role)
}
inline void Resource::set_role(const char* value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Resource.role)
}
inline void Resource::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.role)
}
inline ::std::string* Resource::mutable_role() {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string(*_default_role_);
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.role)
  return role_;
}
inline ::std::string* Resource::release_role() {
  clear_has_role();
  if (role_ == _default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(_default_role_);
    return temp;
  }
}
inline void Resource::set_allocated_role(::std::string* role) {
  if (role_ != _default_role_) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(_default_role_);
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.role)
}

// optional .mesos.Resource.AllocationInfo allocation_info = 11;
inline bool Resource::has_allocation_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Resource::set_has_allocation_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Resource::clear_has_allocation_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Resource::clear_allocation_info() {
  if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
  clear_has_allocation_info();
}
inline const ::mesos::Resource_AllocationInfo& Resource::allocation_info() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.allocation_info)
  return allocation_info_ != NULL ? *allocation_info_ : *default_instance_->allocation_info_;
}
inline ::mesos::Resource_AllocationInfo* Resource::mutable_allocation_info() {
  set_has_allocation_info();
  if (allocation_info_ == NULL) allocation_info_ = new ::mesos::Resource_AllocationInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.allocation_info)
  return allocation_info_;
}
inline ::mesos::Resource_AllocationInfo* Resource::release_allocation_info() {
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  allocation_info_ = NULL;
  return temp;
}
inline void Resource::set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info) {
  delete allocation_info_;
  allocation_info_ = allocation_info;
  if (allocation_info) {
    set_has_allocation_info();
  } else {
    clear_has_allocation_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.allocation_info)
}

// optional .mesos.Resource.ReservationInfo reservation = 8;
inline bool Resource::has_reservation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Resource::set_has_reservation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Resource::clear_has_reservation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Resource::clear_reservation() {
  if (reservation_ != NULL) reservation_->::mesos::Resource_ReservationInfo::Clear();
  clear_has_reservation();
}
inline const ::mesos::Resource_ReservationInfo& Resource::reservation() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.reservation)
  return reservation_ != NULL ? *reservation_ : *default_instance_->reservation_;
}
inline ::mesos::Resource_ReservationInfo* Resource::mutable_reservation() {
  set_has_reservation();
  if (reservation_ == NULL) reservation_ = new ::mesos::Resource_ReservationInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.reservation)
  return reservation_;
}
inline ::mesos::Resource_ReservationInfo* Resource::release_reservation() {
  clear_has_reservation();
  ::mesos::Resource_ReservationInfo* temp = reservation_;
  reservation_ = NULL;
  return temp;
}
inline void Resource::set_allocated_reservation(::mesos::Resource_ReservationInfo* reservation) {
  delete reservation_;
  reservation_ = reservation;
  if (reservation) {
    set_has_reservation();
  } else {
    clear_has_reservation();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.reservation)
}

// optional .mesos.Resource.DiskInfo disk = 7;
inline bool Resource::has_disk() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Resource::set_has_disk() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Resource::clear_has_disk() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Resource::clear_disk() {
  if (disk_ != NULL) disk_->::mesos::Resource_DiskInfo::Clear();
  clear_has_disk();
}
inline const ::mesos::Resource_DiskInfo& Resource::disk() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.disk)
  return disk_ != NULL ? *disk_ : *default_instance_->disk_;
}
inline ::mesos::Resource_DiskInfo* Resource::mutable_disk() {
  set_has_disk();
  if (disk_ == NULL) disk_ = new ::mesos::Resource_DiskInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.disk)
  return disk_;
}
inline ::mesos::Resource_DiskInfo* Resource::release_disk() {
  clear_has_disk();
  ::mesos::Resource_DiskInfo* temp = disk_;
  disk_ = NULL;
  return temp;
}
inline void Resource::set_allocated_disk(::mesos::Resource_DiskInfo* disk) {
  delete disk_;
  disk_ = disk;
  if (disk) {
    set_has_disk();
  } else {
    clear_has_disk();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.disk)
}

// optional .mesos.Resource.RevocableInfo revocable = 9;
inline bool Resource::has_revocable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Resource::set_has_revocable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Resource::clear_has_revocable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Resource::clear_revocable() {
  if (revocable_ != NULL) revocable_->::mesos::Resource_RevocableInfo::Clear();
  clear_has_revocable();
}
inline const ::mesos::Resource_RevocableInfo& Resource::revocable() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.revocable)
  return revocable_ != NULL ? *revocable_ : *default_instance_->revocable_;
}
inline ::mesos::Resource_RevocableInfo* Resource::mutable_revocable() {
  set_has_revocable();
  if (revocable_ == NULL) revocable_ = new ::mesos::Resource_RevocableInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.revocable)
  return revocable_;
}
inline ::mesos::Resource_RevocableInfo* Resource::release_revocable() {
  clear_has_revocable();
  ::mesos::Resource_RevocableInfo* temp = revocable_;
  revocable_ = NULL;
  return temp;
}
inline void Resource::set_allocated_revocable(::mesos::Resource_RevocableInfo* revocable) {
  delete revocable_;
  revocable_ = revocable;
  if (revocable) {
    set_has_revocable();
  } else {
    clear_has_revocable();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.revocable)
}

// optional .mesos.Resource.SharedInfo shared = 10;
inline bool Resource::has_shared() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Resource::set_has_shared() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Resource::clear_has_shared() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Resource::clear_shared() {
  if (shared_ != NULL) shared_->::mesos::Resource_SharedInfo::Clear();
  clear_has_shared();
}
inline const ::mesos::Resource_SharedInfo& Resource::shared() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.shared)
  return shared_ != NULL ? *shared_ : *default_instance_->shared_;
}
inline ::mesos::Resource_SharedInfo* Resource::mutable_shared() {
  set_has_shared();
  if (shared_ == NULL) shared_ = new ::mesos::Resource_SharedInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Resource.shared)
  return shared_;
}
inline ::mesos::Resource_SharedInfo* Resource::release_shared() {
  clear_has_shared();
  ::mesos::Resource_SharedInfo* temp = shared_;
  shared_ = NULL;
  return temp;
}
inline void Resource::set_allocated_shared(::mesos::Resource_SharedInfo* shared) {
  delete shared_;
  shared_ = shared;
  if (shared) {
    set_has_shared();
  } else {
    clear_has_shared();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.shared)
}

// -------------------------------------------------------------------

// TrafficControlStatistics

// required string id = 1;
inline bool TrafficControlStatistics::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficControlStatistics::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficControlStatistics::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficControlStatistics::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TrafficControlStatistics::id() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.id)
  return *id_;
}
inline void TrafficControlStatistics::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.id)
}
inline void TrafficControlStatistics::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TrafficControlStatistics.id)
}
inline void TrafficControlStatistics::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TrafficControlStatistics.id)
}
inline ::std::string* TrafficControlStatistics::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TrafficControlStatistics.id)
  return id_;
}
inline ::std::string* TrafficControlStatistics::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TrafficControlStatistics::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TrafficControlStatistics.id)
}

// optional uint64 backlog = 2;
inline bool TrafficControlStatistics::has_backlog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficControlStatistics::set_has_backlog() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficControlStatistics::clear_has_backlog() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficControlStatistics::clear_backlog() {
  backlog_ = GOOGLE_ULONGLONG(0);
  clear_has_backlog();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::backlog() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.backlog)
  return backlog_;
}
inline void TrafficControlStatistics::set_backlog(::google::protobuf::uint64 value) {
  set_has_backlog();
  backlog_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.backlog)
}

// optional uint64 bytes = 3;
inline bool TrafficControlStatistics::has_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficControlStatistics::set_has_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficControlStatistics::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficControlStatistics::clear_bytes() {
  bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::bytes() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.bytes)
  return bytes_;
}
inline void TrafficControlStatistics::set_bytes(::google::protobuf::uint64 value) {
  set_has_bytes();
  bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.bytes)
}

// optional uint64 drops = 4;
inline bool TrafficControlStatistics::has_drops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficControlStatistics::set_has_drops() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficControlStatistics::clear_has_drops() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficControlStatistics::clear_drops() {
  drops_ = GOOGLE_ULONGLONG(0);
  clear_has_drops();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::drops() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.drops)
  return drops_;
}
inline void TrafficControlStatistics::set_drops(::google::protobuf::uint64 value) {
  set_has_drops();
  drops_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.drops)
}

// optional uint64 overlimits = 5;
inline bool TrafficControlStatistics::has_overlimits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficControlStatistics::set_has_overlimits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficControlStatistics::clear_has_overlimits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficControlStatistics::clear_overlimits() {
  overlimits_ = GOOGLE_ULONGLONG(0);
  clear_has_overlimits();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::overlimits() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.overlimits)
  return overlimits_;
}
inline void TrafficControlStatistics::set_overlimits(::google::protobuf::uint64 value) {
  set_has_overlimits();
  overlimits_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.overlimits)
}

// optional uint64 packets = 6;
inline bool TrafficControlStatistics::has_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficControlStatistics::set_has_packets() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficControlStatistics::clear_has_packets() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficControlStatistics::clear_packets() {
  packets_ = GOOGLE_ULONGLONG(0);
  clear_has_packets();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::packets() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.packets)
  return packets_;
}
inline void TrafficControlStatistics::set_packets(::google::protobuf::uint64 value) {
  set_has_packets();
  packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.packets)
}

// optional uint64 qlen = 7;
inline bool TrafficControlStatistics::has_qlen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficControlStatistics::set_has_qlen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficControlStatistics::clear_has_qlen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficControlStatistics::clear_qlen() {
  qlen_ = GOOGLE_ULONGLONG(0);
  clear_has_qlen();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::qlen() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.qlen)
  return qlen_;
}
inline void TrafficControlStatistics::set_qlen(::google::protobuf::uint64 value) {
  set_has_qlen();
  qlen_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.qlen)
}

// optional uint64 ratebps = 8;
inline bool TrafficControlStatistics::has_ratebps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrafficControlStatistics::set_has_ratebps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrafficControlStatistics::clear_has_ratebps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrafficControlStatistics::clear_ratebps() {
  ratebps_ = GOOGLE_ULONGLONG(0);
  clear_has_ratebps();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::ratebps() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.ratebps)
  return ratebps_;
}
inline void TrafficControlStatistics::set_ratebps(::google::protobuf::uint64 value) {
  set_has_ratebps();
  ratebps_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.ratebps)
}

// optional uint64 ratepps = 9;
inline bool TrafficControlStatistics::has_ratepps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrafficControlStatistics::set_has_ratepps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrafficControlStatistics::clear_has_ratepps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrafficControlStatistics::clear_ratepps() {
  ratepps_ = GOOGLE_ULONGLONG(0);
  clear_has_ratepps();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::ratepps() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.ratepps)
  return ratepps_;
}
inline void TrafficControlStatistics::set_ratepps(::google::protobuf::uint64 value) {
  set_has_ratepps();
  ratepps_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.ratepps)
}

// optional uint64 requeues = 10;
inline bool TrafficControlStatistics::has_requeues() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrafficControlStatistics::set_has_requeues() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrafficControlStatistics::clear_has_requeues() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrafficControlStatistics::clear_requeues() {
  requeues_ = GOOGLE_ULONGLONG(0);
  clear_has_requeues();
}
inline ::google::protobuf::uint64 TrafficControlStatistics::requeues() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.requeues)
  return requeues_;
}
inline void TrafficControlStatistics::set_requeues(::google::protobuf::uint64 value) {
  set_has_requeues();
  requeues_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.requeues)
}

// -------------------------------------------------------------------

// IpStatistics

// optional int64 Forwarding = 1;
inline bool IpStatistics::has_forwarding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpStatistics::set_has_forwarding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpStatistics::clear_has_forwarding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpStatistics::clear_forwarding() {
  forwarding_ = GOOGLE_LONGLONG(0);
  clear_has_forwarding();
}
inline ::google::protobuf::int64 IpStatistics::forwarding() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.Forwarding)
  return forwarding_;
}
inline void IpStatistics::set_forwarding(::google::protobuf::int64 value) {
  set_has_forwarding();
  forwarding_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.Forwarding)
}

// optional int64 DefaultTTL = 2;
inline bool IpStatistics::has_defaultttl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpStatistics::set_has_defaultttl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpStatistics::clear_has_defaultttl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpStatistics::clear_defaultttl() {
  defaultttl_ = GOOGLE_LONGLONG(0);
  clear_has_defaultttl();
}
inline ::google::protobuf::int64 IpStatistics::defaultttl() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.DefaultTTL)
  return defaultttl_;
}
inline void IpStatistics::set_defaultttl(::google::protobuf::int64 value) {
  set_has_defaultttl();
  defaultttl_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.DefaultTTL)
}

// optional int64 InReceives = 3;
inline bool IpStatistics::has_inreceives() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpStatistics::set_has_inreceives() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IpStatistics::clear_has_inreceives() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IpStatistics::clear_inreceives() {
  inreceives_ = GOOGLE_LONGLONG(0);
  clear_has_inreceives();
}
inline ::google::protobuf::int64 IpStatistics::inreceives() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InReceives)
  return inreceives_;
}
inline void IpStatistics::set_inreceives(::google::protobuf::int64 value) {
  set_has_inreceives();
  inreceives_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InReceives)
}

// optional int64 InHdrErrors = 4;
inline bool IpStatistics::has_inhdrerrors() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IpStatistics::set_has_inhdrerrors() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IpStatistics::clear_has_inhdrerrors() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IpStatistics::clear_inhdrerrors() {
  inhdrerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inhdrerrors();
}
inline ::google::protobuf::int64 IpStatistics::inhdrerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InHdrErrors)
  return inhdrerrors_;
}
inline void IpStatistics::set_inhdrerrors(::google::protobuf::int64 value) {
  set_has_inhdrerrors();
  inhdrerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InHdrErrors)
}

// optional int64 InAddrErrors = 5;
inline bool IpStatistics::has_inaddrerrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IpStatistics::set_has_inaddrerrors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IpStatistics::clear_has_inaddrerrors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IpStatistics::clear_inaddrerrors() {
  inaddrerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrerrors();
}
inline ::google::protobuf::int64 IpStatistics::inaddrerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InAddrErrors)
  return inaddrerrors_;
}
inline void IpStatistics::set_inaddrerrors(::google::protobuf::int64 value) {
  set_has_inaddrerrors();
  inaddrerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InAddrErrors)
}

// optional int64 ForwDatagrams = 6;
inline bool IpStatistics::has_forwdatagrams() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IpStatistics::set_has_forwdatagrams() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IpStatistics::clear_has_forwdatagrams() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IpStatistics::clear_forwdatagrams() {
  forwdatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_forwdatagrams();
}
inline ::google::protobuf::int64 IpStatistics::forwdatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ForwDatagrams)
  return forwdatagrams_;
}
inline void IpStatistics::set_forwdatagrams(::google::protobuf::int64 value) {
  set_has_forwdatagrams();
  forwdatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ForwDatagrams)
}

// optional int64 InUnknownProtos = 7;
inline bool IpStatistics::has_inunknownprotos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IpStatistics::set_has_inunknownprotos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IpStatistics::clear_has_inunknownprotos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IpStatistics::clear_inunknownprotos() {
  inunknownprotos_ = GOOGLE_LONGLONG(0);
  clear_has_inunknownprotos();
}
inline ::google::protobuf::int64 IpStatistics::inunknownprotos() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InUnknownProtos)
  return inunknownprotos_;
}
inline void IpStatistics::set_inunknownprotos(::google::protobuf::int64 value) {
  set_has_inunknownprotos();
  inunknownprotos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InUnknownProtos)
}

// optional int64 InDiscards = 8;
inline bool IpStatistics::has_indiscards() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IpStatistics::set_has_indiscards() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IpStatistics::clear_has_indiscards() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IpStatistics::clear_indiscards() {
  indiscards_ = GOOGLE_LONGLONG(0);
  clear_has_indiscards();
}
inline ::google::protobuf::int64 IpStatistics::indiscards() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InDiscards)
  return indiscards_;
}
inline void IpStatistics::set_indiscards(::google::protobuf::int64 value) {
  set_has_indiscards();
  indiscards_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InDiscards)
}

// optional int64 InDelivers = 9;
inline bool IpStatistics::has_indelivers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IpStatistics::set_has_indelivers() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IpStatistics::clear_has_indelivers() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IpStatistics::clear_indelivers() {
  indelivers_ = GOOGLE_LONGLONG(0);
  clear_has_indelivers();
}
inline ::google::protobuf::int64 IpStatistics::indelivers() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InDelivers)
  return indelivers_;
}
inline void IpStatistics::set_indelivers(::google::protobuf::int64 value) {
  set_has_indelivers();
  indelivers_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InDelivers)
}

// optional int64 OutRequests = 10;
inline bool IpStatistics::has_outrequests() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IpStatistics::set_has_outrequests() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IpStatistics::clear_has_outrequests() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IpStatistics::clear_outrequests() {
  outrequests_ = GOOGLE_LONGLONG(0);
  clear_has_outrequests();
}
inline ::google::protobuf::int64 IpStatistics::outrequests() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutRequests)
  return outrequests_;
}
inline void IpStatistics::set_outrequests(::google::protobuf::int64 value) {
  set_has_outrequests();
  outrequests_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutRequests)
}

// optional int64 OutDiscards = 11;
inline bool IpStatistics::has_outdiscards() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IpStatistics::set_has_outdiscards() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IpStatistics::clear_has_outdiscards() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IpStatistics::clear_outdiscards() {
  outdiscards_ = GOOGLE_LONGLONG(0);
  clear_has_outdiscards();
}
inline ::google::protobuf::int64 IpStatistics::outdiscards() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutDiscards)
  return outdiscards_;
}
inline void IpStatistics::set_outdiscards(::google::protobuf::int64 value) {
  set_has_outdiscards();
  outdiscards_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutDiscards)
}

// optional int64 OutNoRoutes = 12;
inline bool IpStatistics::has_outnoroutes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IpStatistics::set_has_outnoroutes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IpStatistics::clear_has_outnoroutes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IpStatistics::clear_outnoroutes() {
  outnoroutes_ = GOOGLE_LONGLONG(0);
  clear_has_outnoroutes();
}
inline ::google::protobuf::int64 IpStatistics::outnoroutes() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutNoRoutes)
  return outnoroutes_;
}
inline void IpStatistics::set_outnoroutes(::google::protobuf::int64 value) {
  set_has_outnoroutes();
  outnoroutes_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutNoRoutes)
}

// optional int64 ReasmTimeout = 13;
inline bool IpStatistics::has_reasmtimeout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IpStatistics::set_has_reasmtimeout() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IpStatistics::clear_has_reasmtimeout() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IpStatistics::clear_reasmtimeout() {
  reasmtimeout_ = GOOGLE_LONGLONG(0);
  clear_has_reasmtimeout();
}
inline ::google::protobuf::int64 IpStatistics::reasmtimeout() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmTimeout)
  return reasmtimeout_;
}
inline void IpStatistics::set_reasmtimeout(::google::protobuf::int64 value) {
  set_has_reasmtimeout();
  reasmtimeout_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmTimeout)
}

// optional int64 ReasmReqds = 14;
inline bool IpStatistics::has_reasmreqds() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IpStatistics::set_has_reasmreqds() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IpStatistics::clear_has_reasmreqds() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IpStatistics::clear_reasmreqds() {
  reasmreqds_ = GOOGLE_LONGLONG(0);
  clear_has_reasmreqds();
}
inline ::google::protobuf::int64 IpStatistics::reasmreqds() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmReqds)
  return reasmreqds_;
}
inline void IpStatistics::set_reasmreqds(::google::protobuf::int64 value) {
  set_has_reasmreqds();
  reasmreqds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmReqds)
}

// optional int64 ReasmOKs = 15;
inline bool IpStatistics::has_reasmoks() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IpStatistics::set_has_reasmoks() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IpStatistics::clear_has_reasmoks() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IpStatistics::clear_reasmoks() {
  reasmoks_ = GOOGLE_LONGLONG(0);
  clear_has_reasmoks();
}
inline ::google::protobuf::int64 IpStatistics::reasmoks() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmOKs)
  return reasmoks_;
}
inline void IpStatistics::set_reasmoks(::google::protobuf::int64 value) {
  set_has_reasmoks();
  reasmoks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmOKs)
}

// optional int64 ReasmFails = 16;
inline bool IpStatistics::has_reasmfails() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IpStatistics::set_has_reasmfails() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IpStatistics::clear_has_reasmfails() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IpStatistics::clear_reasmfails() {
  reasmfails_ = GOOGLE_LONGLONG(0);
  clear_has_reasmfails();
}
inline ::google::protobuf::int64 IpStatistics::reasmfails() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmFails)
  return reasmfails_;
}
inline void IpStatistics::set_reasmfails(::google::protobuf::int64 value) {
  set_has_reasmfails();
  reasmfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmFails)
}

// optional int64 FragOKs = 17;
inline bool IpStatistics::has_fragoks() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IpStatistics::set_has_fragoks() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IpStatistics::clear_has_fragoks() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IpStatistics::clear_fragoks() {
  fragoks_ = GOOGLE_LONGLONG(0);
  clear_has_fragoks();
}
inline ::google::protobuf::int64 IpStatistics::fragoks() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragOKs)
  return fragoks_;
}
inline void IpStatistics::set_fragoks(::google::protobuf::int64 value) {
  set_has_fragoks();
  fragoks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragOKs)
}

// optional int64 FragFails = 18;
inline bool IpStatistics::has_fragfails() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IpStatistics::set_has_fragfails() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IpStatistics::clear_has_fragfails() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IpStatistics::clear_fragfails() {
  fragfails_ = GOOGLE_LONGLONG(0);
  clear_has_fragfails();
}
inline ::google::protobuf::int64 IpStatistics::fragfails() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragFails)
  return fragfails_;
}
inline void IpStatistics::set_fragfails(::google::protobuf::int64 value) {
  set_has_fragfails();
  fragfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragFails)
}

// optional int64 FragCreates = 19;
inline bool IpStatistics::has_fragcreates() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IpStatistics::set_has_fragcreates() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IpStatistics::clear_has_fragcreates() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IpStatistics::clear_fragcreates() {
  fragcreates_ = GOOGLE_LONGLONG(0);
  clear_has_fragcreates();
}
inline ::google::protobuf::int64 IpStatistics::fragcreates() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragCreates)
  return fragcreates_;
}
inline void IpStatistics::set_fragcreates(::google::protobuf::int64 value) {
  set_has_fragcreates();
  fragcreates_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragCreates)
}

// -------------------------------------------------------------------

// IcmpStatistics

// optional int64 InMsgs = 1;
inline bool IcmpStatistics::has_inmsgs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IcmpStatistics::set_has_inmsgs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IcmpStatistics::clear_has_inmsgs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IcmpStatistics::clear_inmsgs() {
  inmsgs_ = GOOGLE_LONGLONG(0);
  clear_has_inmsgs();
}
inline ::google::protobuf::int64 IcmpStatistics::inmsgs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InMsgs)
  return inmsgs_;
}
inline void IcmpStatistics::set_inmsgs(::google::protobuf::int64 value) {
  set_has_inmsgs();
  inmsgs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InMsgs)
}

// optional int64 InErrors = 2;
inline bool IcmpStatistics::has_inerrors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IcmpStatistics::set_has_inerrors() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IcmpStatistics::clear_has_inerrors() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IcmpStatistics::clear_inerrors() {
  inerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inerrors();
}
inline ::google::protobuf::int64 IcmpStatistics::inerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InErrors)
  return inerrors_;
}
inline void IcmpStatistics::set_inerrors(::google::protobuf::int64 value) {
  set_has_inerrors();
  inerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InErrors)
}

// optional int64 InCsumErrors = 3;
inline bool IcmpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IcmpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IcmpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IcmpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
inline ::google::protobuf::int64 IcmpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InCsumErrors)
  return incsumerrors_;
}
inline void IcmpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InCsumErrors)
}

// optional int64 InDestUnreachs = 4;
inline bool IcmpStatistics::has_indestunreachs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IcmpStatistics::set_has_indestunreachs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IcmpStatistics::clear_has_indestunreachs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IcmpStatistics::clear_indestunreachs() {
  indestunreachs_ = GOOGLE_LONGLONG(0);
  clear_has_indestunreachs();
}
inline ::google::protobuf::int64 IcmpStatistics::indestunreachs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InDestUnreachs)
  return indestunreachs_;
}
inline void IcmpStatistics::set_indestunreachs(::google::protobuf::int64 value) {
  set_has_indestunreachs();
  indestunreachs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InDestUnreachs)
}

// optional int64 InTimeExcds = 5;
inline bool IcmpStatistics::has_intimeexcds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IcmpStatistics::set_has_intimeexcds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IcmpStatistics::clear_has_intimeexcds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IcmpStatistics::clear_intimeexcds() {
  intimeexcds_ = GOOGLE_LONGLONG(0);
  clear_has_intimeexcds();
}
inline ::google::protobuf::int64 IcmpStatistics::intimeexcds() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimeExcds)
  return intimeexcds_;
}
inline void IcmpStatistics::set_intimeexcds(::google::protobuf::int64 value) {
  set_has_intimeexcds();
  intimeexcds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimeExcds)
}

// optional int64 InParmProbs = 6;
inline bool IcmpStatistics::has_inparmprobs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IcmpStatistics::set_has_inparmprobs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IcmpStatistics::clear_has_inparmprobs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IcmpStatistics::clear_inparmprobs() {
  inparmprobs_ = GOOGLE_LONGLONG(0);
  clear_has_inparmprobs();
}
inline ::google::protobuf::int64 IcmpStatistics::inparmprobs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InParmProbs)
  return inparmprobs_;
}
inline void IcmpStatistics::set_inparmprobs(::google::protobuf::int64 value) {
  set_has_inparmprobs();
  inparmprobs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InParmProbs)
}

// optional int64 InSrcQuenchs = 7;
inline bool IcmpStatistics::has_insrcquenchs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IcmpStatistics::set_has_insrcquenchs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IcmpStatistics::clear_has_insrcquenchs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IcmpStatistics::clear_insrcquenchs() {
  insrcquenchs_ = GOOGLE_LONGLONG(0);
  clear_has_insrcquenchs();
}
inline ::google::protobuf::int64 IcmpStatistics::insrcquenchs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InSrcQuenchs)
  return insrcquenchs_;
}
inline void IcmpStatistics::set_insrcquenchs(::google::protobuf::int64 value) {
  set_has_insrcquenchs();
  insrcquenchs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InSrcQuenchs)
}

// optional int64 InRedirects = 8;
inline bool IcmpStatistics::has_inredirects() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IcmpStatistics::set_has_inredirects() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IcmpStatistics::clear_has_inredirects() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IcmpStatistics::clear_inredirects() {
  inredirects_ = GOOGLE_LONGLONG(0);
  clear_has_inredirects();
}
inline ::google::protobuf::int64 IcmpStatistics::inredirects() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InRedirects)
  return inredirects_;
}
inline void IcmpStatistics::set_inredirects(::google::protobuf::int64 value) {
  set_has_inredirects();
  inredirects_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InRedirects)
}

// optional int64 InEchos = 9;
inline bool IcmpStatistics::has_inechos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IcmpStatistics::set_has_inechos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IcmpStatistics::clear_has_inechos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IcmpStatistics::clear_inechos() {
  inechos_ = GOOGLE_LONGLONG(0);
  clear_has_inechos();
}
inline ::google::protobuf::int64 IcmpStatistics::inechos() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InEchos)
  return inechos_;
}
inline void IcmpStatistics::set_inechos(::google::protobuf::int64 value) {
  set_has_inechos();
  inechos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InEchos)
}

// optional int64 InEchoReps = 10;
inline bool IcmpStatistics::has_inechoreps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IcmpStatistics::set_has_inechoreps() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IcmpStatistics::clear_has_inechoreps() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IcmpStatistics::clear_inechoreps() {
  inechoreps_ = GOOGLE_LONGLONG(0);
  clear_has_inechoreps();
}
inline ::google::protobuf::int64 IcmpStatistics::inechoreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InEchoReps)
  return inechoreps_;
}
inline void IcmpStatistics::set_inechoreps(::google::protobuf::int64 value) {
  set_has_inechoreps();
  inechoreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InEchoReps)
}

// optional int64 InTimestamps = 11;
inline bool IcmpStatistics::has_intimestamps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IcmpStatistics::set_has_intimestamps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IcmpStatistics::clear_has_intimestamps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IcmpStatistics::clear_intimestamps() {
  intimestamps_ = GOOGLE_LONGLONG(0);
  clear_has_intimestamps();
}
inline ::google::protobuf::int64 IcmpStatistics::intimestamps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimestamps)
  return intimestamps_;
}
inline void IcmpStatistics::set_intimestamps(::google::protobuf::int64 value) {
  set_has_intimestamps();
  intimestamps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimestamps)
}

// optional int64 InTimestampReps = 12;
inline bool IcmpStatistics::has_intimestampreps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IcmpStatistics::set_has_intimestampreps() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IcmpStatistics::clear_has_intimestampreps() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IcmpStatistics::clear_intimestampreps() {
  intimestampreps_ = GOOGLE_LONGLONG(0);
  clear_has_intimestampreps();
}
inline ::google::protobuf::int64 IcmpStatistics::intimestampreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimestampReps)
  return intimestampreps_;
}
inline void IcmpStatistics::set_intimestampreps(::google::protobuf::int64 value) {
  set_has_intimestampreps();
  intimestampreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimestampReps)
}

// optional int64 InAddrMasks = 13;
inline bool IcmpStatistics::has_inaddrmasks() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IcmpStatistics::set_has_inaddrmasks() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IcmpStatistics::clear_has_inaddrmasks() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IcmpStatistics::clear_inaddrmasks() {
  inaddrmasks_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrmasks();
}
inline ::google::protobuf::int64 IcmpStatistics::inaddrmasks() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InAddrMasks)
  return inaddrmasks_;
}
inline void IcmpStatistics::set_inaddrmasks(::google::protobuf::int64 value) {
  set_has_inaddrmasks();
  inaddrmasks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InAddrMasks)
}

// optional int64 InAddrMaskReps = 14;
inline bool IcmpStatistics::has_inaddrmaskreps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IcmpStatistics::set_has_inaddrmaskreps() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IcmpStatistics::clear_has_inaddrmaskreps() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IcmpStatistics::clear_inaddrmaskreps() {
  inaddrmaskreps_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrmaskreps();
}
inline ::google::protobuf::int64 IcmpStatistics::inaddrmaskreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InAddrMaskReps)
  return inaddrmaskreps_;
}
inline void IcmpStatistics::set_inaddrmaskreps(::google::protobuf::int64 value) {
  set_has_inaddrmaskreps();
  inaddrmaskreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InAddrMaskReps)
}

// optional int64 OutMsgs = 15;
inline bool IcmpStatistics::has_outmsgs() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IcmpStatistics::set_has_outmsgs() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IcmpStatistics::clear_has_outmsgs() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IcmpStatistics::clear_outmsgs() {
  outmsgs_ = GOOGLE_LONGLONG(0);
  clear_has_outmsgs();
}
inline ::google::protobuf::int64 IcmpStatistics::outmsgs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutMsgs)
  return outmsgs_;
}
inline void IcmpStatistics::set_outmsgs(::google::protobuf::int64 value) {
  set_has_outmsgs();
  outmsgs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutMsgs)
}

// optional int64 OutErrors = 16;
inline bool IcmpStatistics::has_outerrors() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IcmpStatistics::set_has_outerrors() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IcmpStatistics::clear_has_outerrors() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IcmpStatistics::clear_outerrors() {
  outerrors_ = GOOGLE_LONGLONG(0);
  clear_has_outerrors();
}
inline ::google::protobuf::int64 IcmpStatistics::outerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutErrors)
  return outerrors_;
}
inline void IcmpStatistics::set_outerrors(::google::protobuf::int64 value) {
  set_has_outerrors();
  outerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutErrors)
}

// optional int64 OutDestUnreachs = 17;
inline bool IcmpStatistics::has_outdestunreachs() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IcmpStatistics::set_has_outdestunreachs() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IcmpStatistics::clear_has_outdestunreachs() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IcmpStatistics::clear_outdestunreachs() {
  outdestunreachs_ = GOOGLE_LONGLONG(0);
  clear_has_outdestunreachs();
}
inline ::google::protobuf::int64 IcmpStatistics::outdestunreachs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutDestUnreachs)
  return outdestunreachs_;
}
inline void IcmpStatistics::set_outdestunreachs(::google::protobuf::int64 value) {
  set_has_outdestunreachs();
  outdestunreachs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutDestUnreachs)
}

// optional int64 OutTimeExcds = 18;
inline bool IcmpStatistics::has_outtimeexcds() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IcmpStatistics::set_has_outtimeexcds() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IcmpStatistics::clear_has_outtimeexcds() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IcmpStatistics::clear_outtimeexcds() {
  outtimeexcds_ = GOOGLE_LONGLONG(0);
  clear_has_outtimeexcds();
}
inline ::google::protobuf::int64 IcmpStatistics::outtimeexcds() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimeExcds)
  return outtimeexcds_;
}
inline void IcmpStatistics::set_outtimeexcds(::google::protobuf::int64 value) {
  set_has_outtimeexcds();
  outtimeexcds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimeExcds)
}

// optional int64 OutParmProbs = 19;
inline bool IcmpStatistics::has_outparmprobs() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IcmpStatistics::set_has_outparmprobs() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IcmpStatistics::clear_has_outparmprobs() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IcmpStatistics::clear_outparmprobs() {
  outparmprobs_ = GOOGLE_LONGLONG(0);
  clear_has_outparmprobs();
}
inline ::google::protobuf::int64 IcmpStatistics::outparmprobs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutParmProbs)
  return outparmprobs_;
}
inline void IcmpStatistics::set_outparmprobs(::google::protobuf::int64 value) {
  set_has_outparmprobs();
  outparmprobs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutParmProbs)
}

// optional int64 OutSrcQuenchs = 20;
inline bool IcmpStatistics::has_outsrcquenchs() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void IcmpStatistics::set_has_outsrcquenchs() {
  _has_bits_[0] |= 0x00080000u;
}
inline void IcmpStatistics::clear_has_outsrcquenchs() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void IcmpStatistics::clear_outsrcquenchs() {
  outsrcquenchs_ = GOOGLE_LONGLONG(0);
  clear_has_outsrcquenchs();
}
inline ::google::protobuf::int64 IcmpStatistics::outsrcquenchs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutSrcQuenchs)
  return outsrcquenchs_;
}
inline void IcmpStatistics::set_outsrcquenchs(::google::protobuf::int64 value) {
  set_has_outsrcquenchs();
  outsrcquenchs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutSrcQuenchs)
}

// optional int64 OutRedirects = 21;
inline bool IcmpStatistics::has_outredirects() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void IcmpStatistics::set_has_outredirects() {
  _has_bits_[0] |= 0x00100000u;
}
inline void IcmpStatistics::clear_has_outredirects() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void IcmpStatistics::clear_outredirects() {
  outredirects_ = GOOGLE_LONGLONG(0);
  clear_has_outredirects();
}
inline ::google::protobuf::int64 IcmpStatistics::outredirects() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutRedirects)
  return outredirects_;
}
inline void IcmpStatistics::set_outredirects(::google::protobuf::int64 value) {
  set_has_outredirects();
  outredirects_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutRedirects)
}

// optional int64 OutEchos = 22;
inline bool IcmpStatistics::has_outechos() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void IcmpStatistics::set_has_outechos() {
  _has_bits_[0] |= 0x00200000u;
}
inline void IcmpStatistics::clear_has_outechos() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void IcmpStatistics::clear_outechos() {
  outechos_ = GOOGLE_LONGLONG(0);
  clear_has_outechos();
}
inline ::google::protobuf::int64 IcmpStatistics::outechos() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutEchos)
  return outechos_;
}
inline void IcmpStatistics::set_outechos(::google::protobuf::int64 value) {
  set_has_outechos();
  outechos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutEchos)
}

// optional int64 OutEchoReps = 23;
inline bool IcmpStatistics::has_outechoreps() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void IcmpStatistics::set_has_outechoreps() {
  _has_bits_[0] |= 0x00400000u;
}
inline void IcmpStatistics::clear_has_outechoreps() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void IcmpStatistics::clear_outechoreps() {
  outechoreps_ = GOOGLE_LONGLONG(0);
  clear_has_outechoreps();
}
inline ::google::protobuf::int64 IcmpStatistics::outechoreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutEchoReps)
  return outechoreps_;
}
inline void IcmpStatistics::set_outechoreps(::google::protobuf::int64 value) {
  set_has_outechoreps();
  outechoreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutEchoReps)
}

// optional int64 OutTimestamps = 24;
inline bool IcmpStatistics::has_outtimestamps() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void IcmpStatistics::set_has_outtimestamps() {
  _has_bits_[0] |= 0x00800000u;
}
inline void IcmpStatistics::clear_has_outtimestamps() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void IcmpStatistics::clear_outtimestamps() {
  outtimestamps_ = GOOGLE_LONGLONG(0);
  clear_has_outtimestamps();
}
inline ::google::protobuf::int64 IcmpStatistics::outtimestamps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimestamps)
  return outtimestamps_;
}
inline void IcmpStatistics::set_outtimestamps(::google::protobuf::int64 value) {
  set_has_outtimestamps();
  outtimestamps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimestamps)
}

// optional int64 OutTimestampReps = 25;
inline bool IcmpStatistics::has_outtimestampreps() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void IcmpStatistics::set_has_outtimestampreps() {
  _has_bits_[0] |= 0x01000000u;
}
inline void IcmpStatistics::clear_has_outtimestampreps() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void IcmpStatistics::clear_outtimestampreps() {
  outtimestampreps_ = GOOGLE_LONGLONG(0);
  clear_has_outtimestampreps();
}
inline ::google::protobuf::int64 IcmpStatistics::outtimestampreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimestampReps)
  return outtimestampreps_;
}
inline void IcmpStatistics::set_outtimestampreps(::google::protobuf::int64 value) {
  set_has_outtimestampreps();
  outtimestampreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimestampReps)
}

// optional int64 OutAddrMasks = 26;
inline bool IcmpStatistics::has_outaddrmasks() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void IcmpStatistics::set_has_outaddrmasks() {
  _has_bits_[0] |= 0x02000000u;
}
inline void IcmpStatistics::clear_has_outaddrmasks() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void IcmpStatistics::clear_outaddrmasks() {
  outaddrmasks_ = GOOGLE_LONGLONG(0);
  clear_has_outaddrmasks();
}
inline ::google::protobuf::int64 IcmpStatistics::outaddrmasks() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutAddrMasks)
  return outaddrmasks_;
}
inline void IcmpStatistics::set_outaddrmasks(::google::protobuf::int64 value) {
  set_has_outaddrmasks();
  outaddrmasks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutAddrMasks)
}

// optional int64 OutAddrMaskReps = 27;
inline bool IcmpStatistics::has_outaddrmaskreps() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void IcmpStatistics::set_has_outaddrmaskreps() {
  _has_bits_[0] |= 0x04000000u;
}
inline void IcmpStatistics::clear_has_outaddrmaskreps() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void IcmpStatistics::clear_outaddrmaskreps() {
  outaddrmaskreps_ = GOOGLE_LONGLONG(0);
  clear_has_outaddrmaskreps();
}
inline ::google::protobuf::int64 IcmpStatistics::outaddrmaskreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutAddrMaskReps)
  return outaddrmaskreps_;
}
inline void IcmpStatistics::set_outaddrmaskreps(::google::protobuf::int64 value) {
  set_has_outaddrmaskreps();
  outaddrmaskreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutAddrMaskReps)
}

// -------------------------------------------------------------------

// TcpStatistics

// optional int64 RtoAlgorithm = 1;
inline bool TcpStatistics::has_rtoalgorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpStatistics::set_has_rtoalgorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpStatistics::clear_has_rtoalgorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpStatistics::clear_rtoalgorithm() {
  rtoalgorithm_ = GOOGLE_LONGLONG(0);
  clear_has_rtoalgorithm();
}
inline ::google::protobuf::int64 TcpStatistics::rtoalgorithm() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoAlgorithm)
  return rtoalgorithm_;
}
inline void TcpStatistics::set_rtoalgorithm(::google::protobuf::int64 value) {
  set_has_rtoalgorithm();
  rtoalgorithm_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoAlgorithm)
}

// optional int64 RtoMin = 2;
inline bool TcpStatistics::has_rtomin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpStatistics::set_has_rtomin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpStatistics::clear_has_rtomin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpStatistics::clear_rtomin() {
  rtomin_ = GOOGLE_LONGLONG(0);
  clear_has_rtomin();
}
inline ::google::protobuf::int64 TcpStatistics::rtomin() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoMin)
  return rtomin_;
}
inline void TcpStatistics::set_rtomin(::google::protobuf::int64 value) {
  set_has_rtomin();
  rtomin_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoMin)
}

// optional int64 RtoMax = 3;
inline bool TcpStatistics::has_rtomax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpStatistics::set_has_rtomax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpStatistics::clear_has_rtomax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpStatistics::clear_rtomax() {
  rtomax_ = GOOGLE_LONGLONG(0);
  clear_has_rtomax();
}
inline ::google::protobuf::int64 TcpStatistics::rtomax() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoMax)
  return rtomax_;
}
inline void TcpStatistics::set_rtomax(::google::protobuf::int64 value) {
  set_has_rtomax();
  rtomax_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoMax)
}

// optional int64 MaxConn = 4;
inline bool TcpStatistics::has_maxconn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpStatistics::set_has_maxconn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpStatistics::clear_has_maxconn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpStatistics::clear_maxconn() {
  maxconn_ = GOOGLE_LONGLONG(0);
  clear_has_maxconn();
}
inline ::google::protobuf::int64 TcpStatistics::maxconn() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.MaxConn)
  return maxconn_;
}
inline void TcpStatistics::set_maxconn(::google::protobuf::int64 value) {
  set_has_maxconn();
  maxconn_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.MaxConn)
}

// optional int64 ActiveOpens = 5;
inline bool TcpStatistics::has_activeopens() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpStatistics::set_has_activeopens() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpStatistics::clear_has_activeopens() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpStatistics::clear_activeopens() {
  activeopens_ = GOOGLE_LONGLONG(0);
  clear_has_activeopens();
}
inline ::google::protobuf::int64 TcpStatistics::activeopens() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.ActiveOpens)
  return activeopens_;
}
inline void TcpStatistics::set_activeopens(::google::protobuf::int64 value) {
  set_has_activeopens();
  activeopens_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.ActiveOpens)
}

// optional int64 PassiveOpens = 6;
inline bool TcpStatistics::has_passiveopens() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TcpStatistics::set_has_passiveopens() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TcpStatistics::clear_has_passiveopens() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TcpStatistics::clear_passiveopens() {
  passiveopens_ = GOOGLE_LONGLONG(0);
  clear_has_passiveopens();
}
inline ::google::protobuf::int64 TcpStatistics::passiveopens() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.PassiveOpens)
  return passiveopens_;
}
inline void TcpStatistics::set_passiveopens(::google::protobuf::int64 value) {
  set_has_passiveopens();
  passiveopens_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.PassiveOpens)
}

// optional int64 AttemptFails = 7;
inline bool TcpStatistics::has_attemptfails() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TcpStatistics::set_has_attemptfails() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TcpStatistics::clear_has_attemptfails() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TcpStatistics::clear_attemptfails() {
  attemptfails_ = GOOGLE_LONGLONG(0);
  clear_has_attemptfails();
}
inline ::google::protobuf::int64 TcpStatistics::attemptfails() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.AttemptFails)
  return attemptfails_;
}
inline void TcpStatistics::set_attemptfails(::google::protobuf::int64 value) {
  set_has_attemptfails();
  attemptfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.AttemptFails)
}

// optional int64 EstabResets = 8;
inline bool TcpStatistics::has_estabresets() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TcpStatistics::set_has_estabresets() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TcpStatistics::clear_has_estabresets() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TcpStatistics::clear_estabresets() {
  estabresets_ = GOOGLE_LONGLONG(0);
  clear_has_estabresets();
}
inline ::google::protobuf::int64 TcpStatistics::estabresets() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.EstabResets)
  return estabresets_;
}
inline void TcpStatistics::set_estabresets(::google::protobuf::int64 value) {
  set_has_estabresets();
  estabresets_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.EstabResets)
}

// optional int64 CurrEstab = 9;
inline bool TcpStatistics::has_currestab() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TcpStatistics::set_has_currestab() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TcpStatistics::clear_has_currestab() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TcpStatistics::clear_currestab() {
  currestab_ = GOOGLE_LONGLONG(0);
  clear_has_currestab();
}
inline ::google::protobuf::int64 TcpStatistics::currestab() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.CurrEstab)
  return currestab_;
}
inline void TcpStatistics::set_currestab(::google::protobuf::int64 value) {
  set_has_currestab();
  currestab_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.CurrEstab)
}

// optional int64 InSegs = 10;
inline bool TcpStatistics::has_insegs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TcpStatistics::set_has_insegs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TcpStatistics::clear_has_insegs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TcpStatistics::clear_insegs() {
  insegs_ = GOOGLE_LONGLONG(0);
  clear_has_insegs();
}
inline ::google::protobuf::int64 TcpStatistics::insegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InSegs)
  return insegs_;
}
inline void TcpStatistics::set_insegs(::google::protobuf::int64 value) {
  set_has_insegs();
  insegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InSegs)
}

// optional int64 OutSegs = 11;
inline bool TcpStatistics::has_outsegs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TcpStatistics::set_has_outsegs() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TcpStatistics::clear_has_outsegs() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TcpStatistics::clear_outsegs() {
  outsegs_ = GOOGLE_LONGLONG(0);
  clear_has_outsegs();
}
inline ::google::protobuf::int64 TcpStatistics::outsegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.OutSegs)
  return outsegs_;
}
inline void TcpStatistics::set_outsegs(::google::protobuf::int64 value) {
  set_has_outsegs();
  outsegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.OutSegs)
}

// optional int64 RetransSegs = 12;
inline bool TcpStatistics::has_retranssegs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TcpStatistics::set_has_retranssegs() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TcpStatistics::clear_has_retranssegs() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TcpStatistics::clear_retranssegs() {
  retranssegs_ = GOOGLE_LONGLONG(0);
  clear_has_retranssegs();
}
inline ::google::protobuf::int64 TcpStatistics::retranssegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RetransSegs)
  return retranssegs_;
}
inline void TcpStatistics::set_retranssegs(::google::protobuf::int64 value) {
  set_has_retranssegs();
  retranssegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RetransSegs)
}

// optional int64 InErrs = 13;
inline bool TcpStatistics::has_inerrs() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TcpStatistics::set_has_inerrs() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TcpStatistics::clear_has_inerrs() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TcpStatistics::clear_inerrs() {
  inerrs_ = GOOGLE_LONGLONG(0);
  clear_has_inerrs();
}
inline ::google::protobuf::int64 TcpStatistics::inerrs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InErrs)
  return inerrs_;
}
inline void TcpStatistics::set_inerrs(::google::protobuf::int64 value) {
  set_has_inerrs();
  inerrs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InErrs)
}

// optional int64 OutRsts = 14;
inline bool TcpStatistics::has_outrsts() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TcpStatistics::set_has_outrsts() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TcpStatistics::clear_has_outrsts() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TcpStatistics::clear_outrsts() {
  outrsts_ = GOOGLE_LONGLONG(0);
  clear_has_outrsts();
}
inline ::google::protobuf::int64 TcpStatistics::outrsts() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.OutRsts)
  return outrsts_;
}
inline void TcpStatistics::set_outrsts(::google::protobuf::int64 value) {
  set_has_outrsts();
  outrsts_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.OutRsts)
}

// optional int64 InCsumErrors = 15;
inline bool TcpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TcpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TcpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TcpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
inline ::google::protobuf::int64 TcpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InCsumErrors)
  return incsumerrors_;
}
inline void TcpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InCsumErrors)
}

// -------------------------------------------------------------------

// UdpStatistics

// optional int64 InDatagrams = 1;
inline bool UdpStatistics::has_indatagrams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdpStatistics::set_has_indatagrams() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdpStatistics::clear_has_indatagrams() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdpStatistics::clear_indatagrams() {
  indatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_indatagrams();
}
inline ::google::protobuf::int64 UdpStatistics::indatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InDatagrams)
  return indatagrams_;
}
inline void UdpStatistics::set_indatagrams(::google::protobuf::int64 value) {
  set_has_indatagrams();
  indatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InDatagrams)
}

// optional int64 NoPorts = 2;
inline bool UdpStatistics::has_noports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdpStatistics::set_has_noports() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdpStatistics::clear_has_noports() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdpStatistics::clear_noports() {
  noports_ = GOOGLE_LONGLONG(0);
  clear_has_noports();
}
inline ::google::protobuf::int64 UdpStatistics::noports() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.NoPorts)
  return noports_;
}
inline void UdpStatistics::set_noports(::google::protobuf::int64 value) {
  set_has_noports();
  noports_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.NoPorts)
}

// optional int64 InErrors = 3;
inline bool UdpStatistics::has_inerrors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UdpStatistics::set_has_inerrors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UdpStatistics::clear_has_inerrors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UdpStatistics::clear_inerrors() {
  inerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inerrors();
}
inline ::google::protobuf::int64 UdpStatistics::inerrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InErrors)
  return inerrors_;
}
inline void UdpStatistics::set_inerrors(::google::protobuf::int64 value) {
  set_has_inerrors();
  inerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InErrors)
}

// optional int64 OutDatagrams = 4;
inline bool UdpStatistics::has_outdatagrams() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UdpStatistics::set_has_outdatagrams() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UdpStatistics::clear_has_outdatagrams() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UdpStatistics::clear_outdatagrams() {
  outdatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_outdatagrams();
}
inline ::google::protobuf::int64 UdpStatistics::outdatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.OutDatagrams)
  return outdatagrams_;
}
inline void UdpStatistics::set_outdatagrams(::google::protobuf::int64 value) {
  set_has_outdatagrams();
  outdatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.OutDatagrams)
}

// optional int64 RcvbufErrors = 5;
inline bool UdpStatistics::has_rcvbuferrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UdpStatistics::set_has_rcvbuferrors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UdpStatistics::clear_has_rcvbuferrors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UdpStatistics::clear_rcvbuferrors() {
  rcvbuferrors_ = GOOGLE_LONGLONG(0);
  clear_has_rcvbuferrors();
}
inline ::google::protobuf::int64 UdpStatistics::rcvbuferrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.RcvbufErrors)
  return rcvbuferrors_;
}
inline void UdpStatistics::set_rcvbuferrors(::google::protobuf::int64 value) {
  set_has_rcvbuferrors();
  rcvbuferrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.RcvbufErrors)
}

// optional int64 SndbufErrors = 6;
inline bool UdpStatistics::has_sndbuferrors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UdpStatistics::set_has_sndbuferrors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UdpStatistics::clear_has_sndbuferrors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UdpStatistics::clear_sndbuferrors() {
  sndbuferrors_ = GOOGLE_LONGLONG(0);
  clear_has_sndbuferrors();
}
inline ::google::protobuf::int64 UdpStatistics::sndbuferrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.SndbufErrors)
  return sndbuferrors_;
}
inline void UdpStatistics::set_sndbuferrors(::google::protobuf::int64 value) {
  set_has_sndbuferrors();
  sndbuferrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.SndbufErrors)
}

// optional int64 InCsumErrors = 7;
inline bool UdpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UdpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UdpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UdpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
inline ::google::protobuf::int64 UdpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InCsumErrors)
  return incsumerrors_;
}
inline void UdpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InCsumErrors)
}

// optional int64 IgnoredMulti = 8;
inline bool UdpStatistics::has_ignoredmulti() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UdpStatistics::set_has_ignoredmulti() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UdpStatistics::clear_has_ignoredmulti() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UdpStatistics::clear_ignoredmulti() {
  ignoredmulti_ = GOOGLE_LONGLONG(0);
  clear_has_ignoredmulti();
}
inline ::google::protobuf::int64 UdpStatistics::ignoredmulti() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.IgnoredMulti)
  return ignoredmulti_;
}
inline void UdpStatistics::set_ignoredmulti(::google::protobuf::int64 value) {
  set_has_ignoredmulti();
  ignoredmulti_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.IgnoredMulti)
}

// -------------------------------------------------------------------

// SNMPStatistics

// optional .mesos.IpStatistics ip_stats = 1;
inline bool SNMPStatistics::has_ip_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SNMPStatistics::set_has_ip_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SNMPStatistics::clear_has_ip_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SNMPStatistics::clear_ip_stats() {
  if (ip_stats_ != NULL) ip_stats_->::mesos::IpStatistics::Clear();
  clear_has_ip_stats();
}
inline const ::mesos::IpStatistics& SNMPStatistics::ip_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.ip_stats)
  return ip_stats_ != NULL ? *ip_stats_ : *default_instance_->ip_stats_;
}
inline ::mesos::IpStatistics* SNMPStatistics::mutable_ip_stats() {
  set_has_ip_stats();
  if (ip_stats_ == NULL) ip_stats_ = new ::mesos::IpStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.ip_stats)
  return ip_stats_;
}
inline ::mesos::IpStatistics* SNMPStatistics::release_ip_stats() {
  clear_has_ip_stats();
  ::mesos::IpStatistics* temp = ip_stats_;
  ip_stats_ = NULL;
  return temp;
}
inline void SNMPStatistics::set_allocated_ip_stats(::mesos::IpStatistics* ip_stats) {
  delete ip_stats_;
  ip_stats_ = ip_stats;
  if (ip_stats) {
    set_has_ip_stats();
  } else {
    clear_has_ip_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.ip_stats)
}

// optional .mesos.IcmpStatistics icmp_stats = 2;
inline bool SNMPStatistics::has_icmp_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SNMPStatistics::set_has_icmp_stats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SNMPStatistics::clear_has_icmp_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SNMPStatistics::clear_icmp_stats() {
  if (icmp_stats_ != NULL) icmp_stats_->::mesos::IcmpStatistics::Clear();
  clear_has_icmp_stats();
}
inline const ::mesos::IcmpStatistics& SNMPStatistics::icmp_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.icmp_stats)
  return icmp_stats_ != NULL ? *icmp_stats_ : *default_instance_->icmp_stats_;
}
inline ::mesos::IcmpStatistics* SNMPStatistics::mutable_icmp_stats() {
  set_has_icmp_stats();
  if (icmp_stats_ == NULL) icmp_stats_ = new ::mesos::IcmpStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.icmp_stats)
  return icmp_stats_;
}
inline ::mesos::IcmpStatistics* SNMPStatistics::release_icmp_stats() {
  clear_has_icmp_stats();
  ::mesos::IcmpStatistics* temp = icmp_stats_;
  icmp_stats_ = NULL;
  return temp;
}
inline void SNMPStatistics::set_allocated_icmp_stats(::mesos::IcmpStatistics* icmp_stats) {
  delete icmp_stats_;
  icmp_stats_ = icmp_stats;
  if (icmp_stats) {
    set_has_icmp_stats();
  } else {
    clear_has_icmp_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.icmp_stats)
}

// optional .mesos.TcpStatistics tcp_stats = 3;
inline bool SNMPStatistics::has_tcp_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SNMPStatistics::set_has_tcp_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SNMPStatistics::clear_has_tcp_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SNMPStatistics::clear_tcp_stats() {
  if (tcp_stats_ != NULL) tcp_stats_->::mesos::TcpStatistics::Clear();
  clear_has_tcp_stats();
}
inline const ::mesos::TcpStatistics& SNMPStatistics::tcp_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.tcp_stats)
  return tcp_stats_ != NULL ? *tcp_stats_ : *default_instance_->tcp_stats_;
}
inline ::mesos::TcpStatistics* SNMPStatistics::mutable_tcp_stats() {
  set_has_tcp_stats();
  if (tcp_stats_ == NULL) tcp_stats_ = new ::mesos::TcpStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.tcp_stats)
  return tcp_stats_;
}
inline ::mesos::TcpStatistics* SNMPStatistics::release_tcp_stats() {
  clear_has_tcp_stats();
  ::mesos::TcpStatistics* temp = tcp_stats_;
  tcp_stats_ = NULL;
  return temp;
}
inline void SNMPStatistics::set_allocated_tcp_stats(::mesos::TcpStatistics* tcp_stats) {
  delete tcp_stats_;
  tcp_stats_ = tcp_stats;
  if (tcp_stats) {
    set_has_tcp_stats();
  } else {
    clear_has_tcp_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.tcp_stats)
}

// optional .mesos.UdpStatistics udp_stats = 4;
inline bool SNMPStatistics::has_udp_stats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SNMPStatistics::set_has_udp_stats() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SNMPStatistics::clear_has_udp_stats() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SNMPStatistics::clear_udp_stats() {
  if (udp_stats_ != NULL) udp_stats_->::mesos::UdpStatistics::Clear();
  clear_has_udp_stats();
}
inline const ::mesos::UdpStatistics& SNMPStatistics::udp_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.udp_stats)
  return udp_stats_ != NULL ? *udp_stats_ : *default_instance_->udp_stats_;
}
inline ::mesos::UdpStatistics* SNMPStatistics::mutable_udp_stats() {
  set_has_udp_stats();
  if (udp_stats_ == NULL) udp_stats_ = new ::mesos::UdpStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.udp_stats)
  return udp_stats_;
}
inline ::mesos::UdpStatistics* SNMPStatistics::release_udp_stats() {
  clear_has_udp_stats();
  ::mesos::UdpStatistics* temp = udp_stats_;
  udp_stats_ = NULL;
  return temp;
}
inline void SNMPStatistics::set_allocated_udp_stats(::mesos::UdpStatistics* udp_stats) {
  delete udp_stats_;
  udp_stats_ = udp_stats;
  if (udp_stats) {
    set_has_udp_stats();
  } else {
    clear_has_udp_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.udp_stats)
}

// -------------------------------------------------------------------

// DiskStatistics

// optional .mesos.Resource.DiskInfo.Source source = 1;
inline bool DiskStatistics::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskStatistics::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskStatistics::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskStatistics::clear_source() {
  if (source_ != NULL) source_->::mesos::Resource_DiskInfo_Source::Clear();
  clear_has_source();
}
inline const ::mesos::Resource_DiskInfo_Source& DiskStatistics::source() const {
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::mesos::Resource_DiskInfo_Source* DiskStatistics::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::mesos::Resource_DiskInfo_Source;
  // @@protoc_insertion_point(field_mutable:mesos.DiskStatistics.source)
  return source_;
}
inline ::mesos::Resource_DiskInfo_Source* DiskStatistics::release_source() {
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void DiskStatistics::set_allocated_source(::mesos::Resource_DiskInfo_Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiskStatistics.source)
}

// optional .mesos.Resource.DiskInfo.Persistence persistence = 2;
inline bool DiskStatistics::has_persistence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskStatistics::set_has_persistence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskStatistics::clear_has_persistence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskStatistics::clear_persistence() {
  if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
  clear_has_persistence();
}
inline const ::mesos::Resource_DiskInfo_Persistence& DiskStatistics::persistence() const {
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.persistence)
  return persistence_ != NULL ? *persistence_ : *default_instance_->persistence_;
}
inline ::mesos::Resource_DiskInfo_Persistence* DiskStatistics::mutable_persistence() {
  set_has_persistence();
  if (persistence_ == NULL) persistence_ = new ::mesos::Resource_DiskInfo_Persistence;
  // @@protoc_insertion_point(field_mutable:mesos.DiskStatistics.persistence)
  return persistence_;
}
inline ::mesos::Resource_DiskInfo_Persistence* DiskStatistics::release_persistence() {
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
inline void DiskStatistics::set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence) {
  delete persistence_;
  persistence_ = persistence;
  if (persistence) {
    set_has_persistence();
  } else {
    clear_has_persistence();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiskStatistics.persistence)
}

// optional uint64 limit_bytes = 3;
inline bool DiskStatistics::has_limit_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskStatistics::set_has_limit_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskStatistics::clear_has_limit_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskStatistics::clear_limit_bytes() {
  limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_limit_bytes();
}
inline ::google::protobuf::uint64 DiskStatistics::limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.limit_bytes)
  return limit_bytes_;
}
inline void DiskStatistics::set_limit_bytes(::google::protobuf::uint64 value) {
  set_has_limit_bytes();
  limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiskStatistics.limit_bytes)
}

// optional uint64 used_bytes = 4;
inline bool DiskStatistics::has_used_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskStatistics::set_has_used_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskStatistics::clear_has_used_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskStatistics::clear_used_bytes() {
  used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_bytes();
}
inline ::google::protobuf::uint64 DiskStatistics::used_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.DiskStatistics.used_bytes)
  return used_bytes_;
}
inline void DiskStatistics::set_used_bytes(::google::protobuf::uint64 value) {
  set_has_used_bytes();
  used_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiskStatistics.used_bytes)
}

// -------------------------------------------------------------------

// ResourceStatistics

// required double timestamp = 1;
inline bool ResourceStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ResourceStatistics::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.timestamp)
  return timestamp_;
}
inline void ResourceStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.timestamp)
}

// optional uint32 processes = 30;
inline bool ResourceStatistics::has_processes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_processes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_processes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_processes() {
  processes_ = 0u;
  clear_has_processes();
}
inline ::google::protobuf::uint32 ResourceStatistics::processes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.processes)
  return processes_;
}
inline void ResourceStatistics::set_processes(::google::protobuf::uint32 value) {
  set_has_processes();
  processes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.processes)
}

// optional uint32 threads = 31;
inline bool ResourceStatistics::has_threads() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_threads() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_threads() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_threads() {
  threads_ = 0u;
  clear_has_threads();
}
inline ::google::protobuf::uint32 ResourceStatistics::threads() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.threads)
  return threads_;
}
inline void ResourceStatistics::set_threads(::google::protobuf::uint32 value) {
  set_has_threads();
  threads_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.threads)
}

// optional double cpus_user_time_secs = 2;
inline bool ResourceStatistics::has_cpus_user_time_secs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_cpus_user_time_secs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_cpus_user_time_secs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_cpus_user_time_secs() {
  cpus_user_time_secs_ = 0;
  clear_has_cpus_user_time_secs();
}
inline double ResourceStatistics::cpus_user_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_user_time_secs)
  return cpus_user_time_secs_;
}
inline void ResourceStatistics::set_cpus_user_time_secs(double value) {
  set_has_cpus_user_time_secs();
  cpus_user_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_user_time_secs)
}

// optional double cpus_system_time_secs = 3;
inline bool ResourceStatistics::has_cpus_system_time_secs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_cpus_system_time_secs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_cpus_system_time_secs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_cpus_system_time_secs() {
  cpus_system_time_secs_ = 0;
  clear_has_cpus_system_time_secs();
}
inline double ResourceStatistics::cpus_system_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_system_time_secs)
  return cpus_system_time_secs_;
}
inline void ResourceStatistics::set_cpus_system_time_secs(double value) {
  set_has_cpus_system_time_secs();
  cpus_system_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_system_time_secs)
}

// optional double cpus_limit = 4;
inline bool ResourceStatistics::has_cpus_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_cpus_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_cpus_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_cpus_limit() {
  cpus_limit_ = 0;
  clear_has_cpus_limit();
}
inline double ResourceStatistics::cpus_limit() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_limit)
  return cpus_limit_;
}
inline void ResourceStatistics::set_cpus_limit(double value) {
  set_has_cpus_limit();
  cpus_limit_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_limit)
}

// optional uint32 cpus_nr_periods = 7;
inline bool ResourceStatistics::has_cpus_nr_periods() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_periods() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResourceStatistics::clear_has_cpus_nr_periods() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResourceStatistics::clear_cpus_nr_periods() {
  cpus_nr_periods_ = 0u;
  clear_has_cpus_nr_periods();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_periods() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_nr_periods)
  return cpus_nr_periods_;
}
inline void ResourceStatistics::set_cpus_nr_periods(::google::protobuf::uint32 value) {
  set_has_cpus_nr_periods();
  cpus_nr_periods_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_nr_periods)
}

// optional uint32 cpus_nr_throttled = 8;
inline bool ResourceStatistics::has_cpus_nr_throttled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_throttled() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResourceStatistics::clear_has_cpus_nr_throttled() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResourceStatistics::clear_cpus_nr_throttled() {
  cpus_nr_throttled_ = 0u;
  clear_has_cpus_nr_throttled();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_throttled() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_nr_throttled)
  return cpus_nr_throttled_;
}
inline void ResourceStatistics::set_cpus_nr_throttled(::google::protobuf::uint32 value) {
  set_has_cpus_nr_throttled();
  cpus_nr_throttled_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_nr_throttled)
}

// optional double cpus_throttled_time_secs = 9;
inline bool ResourceStatistics::has_cpus_throttled_time_secs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResourceStatistics::set_has_cpus_throttled_time_secs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResourceStatistics::clear_has_cpus_throttled_time_secs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResourceStatistics::clear_cpus_throttled_time_secs() {
  cpus_throttled_time_secs_ = 0;
  clear_has_cpus_throttled_time_secs();
}
inline double ResourceStatistics::cpus_throttled_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_throttled_time_secs)
  return cpus_throttled_time_secs_;
}
inline void ResourceStatistics::set_cpus_throttled_time_secs(double value) {
  set_has_cpus_throttled_time_secs();
  cpus_throttled_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_throttled_time_secs)
}

// optional uint64 mem_total_bytes = 36;
inline bool ResourceStatistics::has_mem_total_bytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResourceStatistics::set_has_mem_total_bytes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResourceStatistics::clear_has_mem_total_bytes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResourceStatistics::clear_mem_total_bytes() {
  mem_total_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_total_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_total_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_total_bytes)
  return mem_total_bytes_;
}
inline void ResourceStatistics::set_mem_total_bytes(::google::protobuf::uint64 value) {
  set_has_mem_total_bytes();
  mem_total_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_total_bytes)
}

// optional uint64 mem_total_memsw_bytes = 37;
inline bool ResourceStatistics::has_mem_total_memsw_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResourceStatistics::set_has_mem_total_memsw_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResourceStatistics::clear_has_mem_total_memsw_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResourceStatistics::clear_mem_total_memsw_bytes() {
  mem_total_memsw_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_total_memsw_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_total_memsw_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_total_memsw_bytes)
  return mem_total_memsw_bytes_;
}
inline void ResourceStatistics::set_mem_total_memsw_bytes(::google::protobuf::uint64 value) {
  set_has_mem_total_memsw_bytes();
  mem_total_memsw_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_total_memsw_bytes)
}

// optional uint64 mem_limit_bytes = 6;
inline bool ResourceStatistics::has_mem_limit_bytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResourceStatistics::set_has_mem_limit_bytes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResourceStatistics::clear_has_mem_limit_bytes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResourceStatistics::clear_mem_limit_bytes() {
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_limit_bytes)
  return mem_limit_bytes_;
}
inline void ResourceStatistics::set_mem_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_limit_bytes();
  mem_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_limit_bytes)
}

// optional uint64 mem_soft_limit_bytes = 38;
inline bool ResourceStatistics::has_mem_soft_limit_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResourceStatistics::set_has_mem_soft_limit_bytes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResourceStatistics::clear_has_mem_soft_limit_bytes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResourceStatistics::clear_mem_soft_limit_bytes() {
  mem_soft_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_soft_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_soft_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_soft_limit_bytes)
  return mem_soft_limit_bytes_;
}
inline void ResourceStatistics::set_mem_soft_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_soft_limit_bytes();
  mem_soft_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_soft_limit_bytes)
}

// optional uint64 mem_file_bytes = 10;
inline bool ResourceStatistics::has_mem_file_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResourceStatistics::set_has_mem_file_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResourceStatistics::clear_has_mem_file_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResourceStatistics::clear_mem_file_bytes() {
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_file_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_file_bytes)
  return mem_file_bytes_;
}
inline void ResourceStatistics::set_mem_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_file_bytes();
  mem_file_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_file_bytes)
}

// optional uint64 mem_anon_bytes = 11;
inline bool ResourceStatistics::has_mem_anon_bytes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResourceStatistics::set_has_mem_anon_bytes() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResourceStatistics::clear_has_mem_anon_bytes() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResourceStatistics::clear_mem_anon_bytes() {
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_anon_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_anon_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_anon_bytes)
  return mem_anon_bytes_;
}
inline void ResourceStatistics::set_mem_anon_bytes(::google::protobuf::uint64 value) {
  set_has_mem_anon_bytes();
  mem_anon_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_anon_bytes)
}

// optional uint64 mem_cache_bytes = 39;
inline bool ResourceStatistics::has_mem_cache_bytes() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResourceStatistics::set_has_mem_cache_bytes() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResourceStatistics::clear_has_mem_cache_bytes() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResourceStatistics::clear_mem_cache_bytes() {
  mem_cache_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_cache_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_cache_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_cache_bytes)
  return mem_cache_bytes_;
}
inline void ResourceStatistics::set_mem_cache_bytes(::google::protobuf::uint64 value) {
  set_has_mem_cache_bytes();
  mem_cache_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_cache_bytes)
}

// optional uint64 mem_rss_bytes = 5;
inline bool ResourceStatistics::has_mem_rss_bytes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResourceStatistics::set_has_mem_rss_bytes() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResourceStatistics::clear_has_mem_rss_bytes() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResourceStatistics::clear_mem_rss_bytes() {
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_rss_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_rss_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_rss_bytes)
  return mem_rss_bytes_;
}
inline void ResourceStatistics::set_mem_rss_bytes(::google::protobuf::uint64 value) {
  set_has_mem_rss_bytes();
  mem_rss_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_rss_bytes)
}

// optional uint64 mem_mapped_file_bytes = 12;
inline bool ResourceStatistics::has_mem_mapped_file_bytes() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResourceStatistics::set_has_mem_mapped_file_bytes() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResourceStatistics::clear_has_mem_mapped_file_bytes() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResourceStatistics::clear_mem_mapped_file_bytes() {
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_mapped_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_mapped_file_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_mapped_file_bytes)
  return mem_mapped_file_bytes_;
}
inline void ResourceStatistics::set_mem_mapped_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_mapped_file_bytes();
  mem_mapped_file_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_mapped_file_bytes)
}

// optional uint64 mem_swap_bytes = 40;
inline bool ResourceStatistics::has_mem_swap_bytes() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResourceStatistics::set_has_mem_swap_bytes() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResourceStatistics::clear_has_mem_swap_bytes() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResourceStatistics::clear_mem_swap_bytes() {
  mem_swap_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_swap_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_swap_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_swap_bytes)
  return mem_swap_bytes_;
}
inline void ResourceStatistics::set_mem_swap_bytes(::google::protobuf::uint64 value) {
  set_has_mem_swap_bytes();
  mem_swap_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_swap_bytes)
}

// optional uint64 mem_unevictable_bytes = 41;
inline bool ResourceStatistics::has_mem_unevictable_bytes() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ResourceStatistics::set_has_mem_unevictable_bytes() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ResourceStatistics::clear_has_mem_unevictable_bytes() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ResourceStatistics::clear_mem_unevictable_bytes() {
  mem_unevictable_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_unevictable_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_unevictable_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_unevictable_bytes)
  return mem_unevictable_bytes_;
}
inline void ResourceStatistics::set_mem_unevictable_bytes(::google::protobuf::uint64 value) {
  set_has_mem_unevictable_bytes();
  mem_unevictable_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_unevictable_bytes)
}

// optional uint64 mem_low_pressure_counter = 32;
inline bool ResourceStatistics::has_mem_low_pressure_counter() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ResourceStatistics::set_has_mem_low_pressure_counter() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ResourceStatistics::clear_has_mem_low_pressure_counter() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ResourceStatistics::clear_mem_low_pressure_counter() {
  mem_low_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_low_pressure_counter();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_low_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_low_pressure_counter)
  return mem_low_pressure_counter_;
}
inline void ResourceStatistics::set_mem_low_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_low_pressure_counter();
  mem_low_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_low_pressure_counter)
}

// optional uint64 mem_medium_pressure_counter = 33;
inline bool ResourceStatistics::has_mem_medium_pressure_counter() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ResourceStatistics::set_has_mem_medium_pressure_counter() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ResourceStatistics::clear_has_mem_medium_pressure_counter() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ResourceStatistics::clear_mem_medium_pressure_counter() {
  mem_medium_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_medium_pressure_counter();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_medium_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_medium_pressure_counter)
  return mem_medium_pressure_counter_;
}
inline void ResourceStatistics::set_mem_medium_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_medium_pressure_counter();
  mem_medium_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_medium_pressure_counter)
}

// optional uint64 mem_critical_pressure_counter = 34;
inline bool ResourceStatistics::has_mem_critical_pressure_counter() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ResourceStatistics::set_has_mem_critical_pressure_counter() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ResourceStatistics::clear_has_mem_critical_pressure_counter() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ResourceStatistics::clear_mem_critical_pressure_counter() {
  mem_critical_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_critical_pressure_counter();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_critical_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_critical_pressure_counter)
  return mem_critical_pressure_counter_;
}
inline void ResourceStatistics::set_mem_critical_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_critical_pressure_counter();
  mem_critical_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_critical_pressure_counter)
}

// optional uint64 disk_limit_bytes = 26;
inline bool ResourceStatistics::has_disk_limit_bytes() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ResourceStatistics::set_has_disk_limit_bytes() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ResourceStatistics::clear_has_disk_limit_bytes() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ResourceStatistics::clear_disk_limit_bytes() {
  disk_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::disk_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_limit_bytes)
  return disk_limit_bytes_;
}
inline void ResourceStatistics::set_disk_limit_bytes(::google::protobuf::uint64 value) {
  set_has_disk_limit_bytes();
  disk_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.disk_limit_bytes)
}

// optional uint64 disk_used_bytes = 27;
inline bool ResourceStatistics::has_disk_used_bytes() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ResourceStatistics::set_has_disk_used_bytes() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ResourceStatistics::clear_has_disk_used_bytes() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ResourceStatistics::clear_disk_used_bytes() {
  disk_used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_used_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::disk_used_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_used_bytes)
  return disk_used_bytes_;
}
inline void ResourceStatistics::set_disk_used_bytes(::google::protobuf::uint64 value) {
  set_has_disk_used_bytes();
  disk_used_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.disk_used_bytes)
}

// repeated .mesos.DiskStatistics disk_statistics = 43;
inline int ResourceStatistics::disk_statistics_size() const {
  return disk_statistics_.size();
}
inline void ResourceStatistics::clear_disk_statistics() {
  disk_statistics_.Clear();
}
inline const ::mesos::DiskStatistics& ResourceStatistics::disk_statistics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_.Get(index);
}
inline ::mesos::DiskStatistics* ResourceStatistics::mutable_disk_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_.Mutable(index);
}
inline ::mesos::DiskStatistics* ResourceStatistics::add_disk_statistics() {
  // @@protoc_insertion_point(field_add:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >&
ResourceStatistics::disk_statistics() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceStatistics.disk_statistics)
  return disk_statistics_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::DiskStatistics >*
ResourceStatistics::mutable_disk_statistics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceStatistics.disk_statistics)
  return &disk_statistics_;
}

// optional .mesos.PerfStatistics perf = 13;
inline bool ResourceStatistics::has_perf() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ResourceStatistics::set_has_perf() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ResourceStatistics::clear_has_perf() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ResourceStatistics::clear_perf() {
  if (perf_ != NULL) perf_->::mesos::PerfStatistics::Clear();
  clear_has_perf();
}
inline const ::mesos::PerfStatistics& ResourceStatistics::perf() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.perf)
  return perf_ != NULL ? *perf_ : *default_instance_->perf_;
}
inline ::mesos::PerfStatistics* ResourceStatistics::mutable_perf() {
  set_has_perf();
  if (perf_ == NULL) perf_ = new ::mesos::PerfStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.perf)
  return perf_;
}
inline ::mesos::PerfStatistics* ResourceStatistics::release_perf() {
  clear_has_perf();
  ::mesos::PerfStatistics* temp = perf_;
  perf_ = NULL;
  return temp;
}
inline void ResourceStatistics::set_allocated_perf(::mesos::PerfStatistics* perf) {
  delete perf_;
  perf_ = perf;
  if (perf) {
    set_has_perf();
  } else {
    clear_has_perf();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.perf)
}

// optional uint64 net_rx_packets = 14;
inline bool ResourceStatistics::has_net_rx_packets() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_packets() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ResourceStatistics::clear_has_net_rx_packets() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ResourceStatistics::clear_net_rx_packets() {
  net_rx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_packets();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_packets() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_packets)
  return net_rx_packets_;
}
inline void ResourceStatistics::set_net_rx_packets(::google::protobuf::uint64 value) {
  set_has_net_rx_packets();
  net_rx_packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_packets)
}

// optional uint64 net_rx_bytes = 15;
inline bool ResourceStatistics::has_net_rx_bytes() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_bytes() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ResourceStatistics::clear_has_net_rx_bytes() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ResourceStatistics::clear_net_rx_bytes() {
  net_rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_bytes)
  return net_rx_bytes_;
}
inline void ResourceStatistics::set_net_rx_bytes(::google::protobuf::uint64 value) {
  set_has_net_rx_bytes();
  net_rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_bytes)
}

// optional uint64 net_rx_errors = 16;
inline bool ResourceStatistics::has_net_rx_errors() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_errors() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ResourceStatistics::clear_has_net_rx_errors() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ResourceStatistics::clear_net_rx_errors() {
  net_rx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_errors();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_errors() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_errors)
  return net_rx_errors_;
}
inline void ResourceStatistics::set_net_rx_errors(::google::protobuf::uint64 value) {
  set_has_net_rx_errors();
  net_rx_errors_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_errors)
}

// optional uint64 net_rx_dropped = 17;
inline bool ResourceStatistics::has_net_rx_dropped() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ResourceStatistics::set_has_net_rx_dropped() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ResourceStatistics::clear_has_net_rx_dropped() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ResourceStatistics::clear_net_rx_dropped() {
  net_rx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_dropped();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_rx_dropped() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_dropped)
  return net_rx_dropped_;
}
inline void ResourceStatistics::set_net_rx_dropped(::google::protobuf::uint64 value) {
  set_has_net_rx_dropped();
  net_rx_dropped_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_dropped)
}

// optional uint64 net_tx_packets = 18;
inline bool ResourceStatistics::has_net_tx_packets() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_packets() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ResourceStatistics::clear_has_net_tx_packets() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ResourceStatistics::clear_net_tx_packets() {
  net_tx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_packets();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_packets() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_packets)
  return net_tx_packets_;
}
inline void ResourceStatistics::set_net_tx_packets(::google::protobuf::uint64 value) {
  set_has_net_tx_packets();
  net_tx_packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_packets)
}

// optional uint64 net_tx_bytes = 19;
inline bool ResourceStatistics::has_net_tx_bytes() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_bytes() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_net_tx_bytes() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_net_tx_bytes() {
  net_tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_bytes)
  return net_tx_bytes_;
}
inline void ResourceStatistics::set_net_tx_bytes(::google::protobuf::uint64 value) {
  set_has_net_tx_bytes();
  net_tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_bytes)
}

// optional uint64 net_tx_errors = 20;
inline bool ResourceStatistics::has_net_tx_errors() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_errors() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_net_tx_errors() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_net_tx_errors() {
  net_tx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_errors();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_errors() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_errors)
  return net_tx_errors_;
}
inline void ResourceStatistics::set_net_tx_errors(::google::protobuf::uint64 value) {
  set_has_net_tx_errors();
  net_tx_errors_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_errors)
}

// optional uint64 net_tx_dropped = 21;
inline bool ResourceStatistics::has_net_tx_dropped() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_net_tx_dropped() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_net_tx_dropped() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_net_tx_dropped() {
  net_tx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_dropped();
}
inline ::google::protobuf::uint64 ResourceStatistics::net_tx_dropped() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_dropped)
  return net_tx_dropped_;
}
inline void ResourceStatistics::set_net_tx_dropped(::google::protobuf::uint64 value) {
  set_has_net_tx_dropped();
  net_tx_dropped_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_dropped)
}

// optional double net_tcp_rtt_microsecs_p50 = 22;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p50() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p50() {
  net_tcp_rtt_microsecs_p50_ = 0;
  clear_has_net_tcp_rtt_microsecs_p50();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p50() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p50)
  return net_tcp_rtt_microsecs_p50_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p50(double value) {
  set_has_net_tcp_rtt_microsecs_p50();
  net_tcp_rtt_microsecs_p50_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p50)
}

// optional double net_tcp_rtt_microsecs_p90 = 23;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p90() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p90() {
  net_tcp_rtt_microsecs_p90_ = 0;
  clear_has_net_tcp_rtt_microsecs_p90();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p90() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p90)
  return net_tcp_rtt_microsecs_p90_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p90(double value) {
  set_has_net_tcp_rtt_microsecs_p90();
  net_tcp_rtt_microsecs_p90_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p90)
}

// optional double net_tcp_rtt_microsecs_p95 = 24;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p95() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p95() {
  net_tcp_rtt_microsecs_p95_ = 0;
  clear_has_net_tcp_rtt_microsecs_p95();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p95() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p95)
  return net_tcp_rtt_microsecs_p95_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p95(double value) {
  set_has_net_tcp_rtt_microsecs_p95();
  net_tcp_rtt_microsecs_p95_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p95)
}

// optional double net_tcp_rtt_microsecs_p99 = 25;
inline bool ResourceStatistics::has_net_tcp_rtt_microsecs_p99() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ResourceStatistics::clear_net_tcp_rtt_microsecs_p99() {
  net_tcp_rtt_microsecs_p99_ = 0;
  clear_has_net_tcp_rtt_microsecs_p99();
}
inline double ResourceStatistics::net_tcp_rtt_microsecs_p99() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p99)
  return net_tcp_rtt_microsecs_p99_;
}
inline void ResourceStatistics::set_net_tcp_rtt_microsecs_p99(double value) {
  set_has_net_tcp_rtt_microsecs_p99();
  net_tcp_rtt_microsecs_p99_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p99)
}

// optional double net_tcp_active_connections = 28;
inline bool ResourceStatistics::has_net_tcp_active_connections() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_active_connections() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ResourceStatistics::clear_has_net_tcp_active_connections() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ResourceStatistics::clear_net_tcp_active_connections() {
  net_tcp_active_connections_ = 0;
  clear_has_net_tcp_active_connections();
}
inline double ResourceStatistics::net_tcp_active_connections() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_active_connections)
  return net_tcp_active_connections_;
}
inline void ResourceStatistics::set_net_tcp_active_connections(double value) {
  set_has_net_tcp_active_connections();
  net_tcp_active_connections_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_active_connections)
}

// optional double net_tcp_time_wait_connections = 29;
inline bool ResourceStatistics::has_net_tcp_time_wait_connections() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ResourceStatistics::set_has_net_tcp_time_wait_connections() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ResourceStatistics::clear_has_net_tcp_time_wait_connections() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ResourceStatistics::clear_net_tcp_time_wait_connections() {
  net_tcp_time_wait_connections_ = 0;
  clear_has_net_tcp_time_wait_connections();
}
inline double ResourceStatistics::net_tcp_time_wait_connections() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_time_wait_connections)
  return net_tcp_time_wait_connections_;
}
inline void ResourceStatistics::set_net_tcp_time_wait_connections(double value) {
  set_has_net_tcp_time_wait_connections();
  net_tcp_time_wait_connections_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_time_wait_connections)
}

// repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
inline int ResourceStatistics::net_traffic_control_statistics_size() const {
  return net_traffic_control_statistics_.size();
}
inline void ResourceStatistics::clear_net_traffic_control_statistics() {
  net_traffic_control_statistics_.Clear();
}
inline const ::mesos::TrafficControlStatistics& ResourceStatistics::net_traffic_control_statistics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Get(index);
}
inline ::mesos::TrafficControlStatistics* ResourceStatistics::mutable_net_traffic_control_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Mutable(index);
}
inline ::mesos::TrafficControlStatistics* ResourceStatistics::add_net_traffic_control_statistics() {
  // @@protoc_insertion_point(field_add:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >&
ResourceStatistics::net_traffic_control_statistics() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >*
ResourceStatistics::mutable_net_traffic_control_statistics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceStatistics.net_traffic_control_statistics)
  return &net_traffic_control_statistics_;
}

// optional .mesos.SNMPStatistics net_snmp_statistics = 42;
inline bool ResourceStatistics::has_net_snmp_statistics() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void ResourceStatistics::set_has_net_snmp_statistics() {
  _has_bits_[1] |= 0x00000400u;
}
inline void ResourceStatistics::clear_has_net_snmp_statistics() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void ResourceStatistics::clear_net_snmp_statistics() {
  if (net_snmp_statistics_ != NULL) net_snmp_statistics_->::mesos::SNMPStatistics::Clear();
  clear_has_net_snmp_statistics();
}
inline const ::mesos::SNMPStatistics& ResourceStatistics::net_snmp_statistics() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_snmp_statistics)
  return net_snmp_statistics_ != NULL ? *net_snmp_statistics_ : *default_instance_->net_snmp_statistics_;
}
inline ::mesos::SNMPStatistics* ResourceStatistics::mutable_net_snmp_statistics() {
  set_has_net_snmp_statistics();
  if (net_snmp_statistics_ == NULL) net_snmp_statistics_ = new ::mesos::SNMPStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.net_snmp_statistics)
  return net_snmp_statistics_;
}
inline ::mesos::SNMPStatistics* ResourceStatistics::release_net_snmp_statistics() {
  clear_has_net_snmp_statistics();
  ::mesos::SNMPStatistics* temp = net_snmp_statistics_;
  net_snmp_statistics_ = NULL;
  return temp;
}
inline void ResourceStatistics::set_allocated_net_snmp_statistics(::mesos::SNMPStatistics* net_snmp_statistics) {
  delete net_snmp_statistics_;
  net_snmp_statistics_ = net_snmp_statistics;
  if (net_snmp_statistics) {
    set_has_net_snmp_statistics();
  } else {
    clear_has_net_snmp_statistics();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.net_snmp_statistics)
}

// -------------------------------------------------------------------

// ResourceUsage_Executor_Task

// required string name = 1;
inline bool ResourceUsage_Executor_Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage_Executor_Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage_Executor_Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage_Executor_Task::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ResourceUsage_Executor_Task::name() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.name)
  return *name_;
}
inline void ResourceUsage_Executor_Task::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ResourceUsage.Executor.Task.name)
}
inline void ResourceUsage_Executor_Task::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ResourceUsage.Executor.Task.name)
}
inline void ResourceUsage_Executor_Task::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceUsage.Executor.Task.name)
}
inline ::std::string* ResourceUsage_Executor_Task::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.name)
  return name_;
}
inline ::std::string* ResourceUsage_Executor_Task::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResourceUsage_Executor_Task::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.name)
}

// required .mesos.TaskID id = 2;
inline bool ResourceUsage_Executor_Task::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceUsage_Executor_Task::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceUsage_Executor_Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceUsage_Executor_Task::clear_id() {
  if (id_ != NULL) id_->::mesos::TaskID::Clear();
  clear_has_id();
}
inline const ::mesos::TaskID& ResourceUsage_Executor_Task::id() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::TaskID* ResourceUsage_Executor_Task::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.id)
  return id_;
}
inline ::mesos::TaskID* ResourceUsage_Executor_Task::release_id() {
  clear_has_id();
  ::mesos::TaskID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ResourceUsage_Executor_Task::set_allocated_id(::mesos::TaskID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.id)
}

// repeated .mesos.Resource resources = 3;
inline int ResourceUsage_Executor_Task::resources_size() const {
  return resources_.size();
}
inline void ResourceUsage_Executor_Task::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ResourceUsage_Executor_Task::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* ResourceUsage_Executor_Task::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ResourceUsage_Executor_Task::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage_Executor_Task::resources() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.Task.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage_Executor_Task::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.Task.resources)
  return &resources_;
}

// optional .mesos.Labels labels = 4;
inline bool ResourceUsage_Executor_Task::has_labels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceUsage_Executor_Task::set_has_labels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceUsage_Executor_Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceUsage_Executor_Task::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& ResourceUsage_Executor_Task::labels() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* ResourceUsage_Executor_Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.labels)
  return labels_;
}
inline ::mesos::Labels* ResourceUsage_Executor_Task::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void ResourceUsage_Executor_Task::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.labels)
}

// -------------------------------------------------------------------

// ResourceUsage_Executor

// required .mesos.ExecutorInfo executor_info = 1;
inline bool ResourceUsage_Executor::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage_Executor::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage_Executor::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage_Executor::clear_executor_info() {
  if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
  clear_has_executor_info();
}
inline const ::mesos::ExecutorInfo& ResourceUsage_Executor::executor_info() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.executor_info)
  return executor_info_ != NULL ? *executor_info_ : *default_instance_->executor_info_;
}
inline ::mesos::ExecutorInfo* ResourceUsage_Executor::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) executor_info_ = new ::mesos::ExecutorInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.executor_info)
  return executor_info_;
}
inline ::mesos::ExecutorInfo* ResourceUsage_Executor::release_executor_info() {
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
inline void ResourceUsage_Executor::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  delete executor_info_;
  executor_info_ = executor_info;
  if (executor_info) {
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.executor_info)
}

// repeated .mesos.Resource allocated = 2;
inline int ResourceUsage_Executor::allocated_size() const {
  return allocated_.size();
}
inline void ResourceUsage_Executor::clear_allocated() {
  allocated_.Clear();
}
inline const ::mesos::Resource& ResourceUsage_Executor::allocated(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Get(index);
}
inline ::mesos::Resource* ResourceUsage_Executor::mutable_allocated(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Mutable(index);
}
inline ::mesos::Resource* ResourceUsage_Executor::add_allocated() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage_Executor::allocated() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.allocated)
  return allocated_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage_Executor::mutable_allocated() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.allocated)
  return &allocated_;
}

// optional .mesos.ResourceStatistics statistics = 3;
inline bool ResourceUsage_Executor::has_statistics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceUsage_Executor::set_has_statistics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceUsage_Executor::clear_has_statistics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceUsage_Executor::clear_statistics() {
  if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
  clear_has_statistics();
}
inline const ::mesos::ResourceStatistics& ResourceUsage_Executor::statistics() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.statistics)
  return statistics_ != NULL ? *statistics_ : *default_instance_->statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage_Executor::mutable_statistics() {
  set_has_statistics();
  if (statistics_ == NULL) statistics_ = new ::mesos::ResourceStatistics;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.statistics)
  return statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage_Executor::release_statistics() {
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  statistics_ = NULL;
  return temp;
}
inline void ResourceUsage_Executor::set_allocated_statistics(::mesos::ResourceStatistics* statistics) {
  delete statistics_;
  statistics_ = statistics;
  if (statistics) {
    set_has_statistics();
  } else {
    clear_has_statistics();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.statistics)
}

// required .mesos.ContainerID container_id = 4;
inline bool ResourceUsage_Executor::has_container_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceUsage_Executor::set_has_container_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceUsage_Executor::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceUsage_Executor::clear_container_id() {
  if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
  clear_has_container_id();
}
inline const ::mesos::ContainerID& ResourceUsage_Executor::container_id() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.container_id)
  return container_id_ != NULL ? *container_id_ : *default_instance_->container_id_;
}
inline ::mesos::ContainerID* ResourceUsage_Executor::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) container_id_ = new ::mesos::ContainerID;
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.container_id)
  return container_id_;
}
inline ::mesos::ContainerID* ResourceUsage_Executor::release_container_id() {
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline void ResourceUsage_Executor::set_allocated_container_id(::mesos::ContainerID* container_id) {
  delete container_id_;
  container_id_ = container_id;
  if (container_id) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.container_id)
}

// repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
inline int ResourceUsage_Executor::tasks_size() const {
  return tasks_.size();
}
inline void ResourceUsage_Executor::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::ResourceUsage_Executor_Task& ResourceUsage_Executor::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Get(index);
}
inline ::mesos::ResourceUsage_Executor_Task* ResourceUsage_Executor::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::ResourceUsage_Executor_Task* ResourceUsage_Executor::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >&
ResourceUsage_Executor::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >*
ResourceUsage_Executor::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.tasks)
  return &tasks_;
}

// -------------------------------------------------------------------

// ResourceUsage

// repeated .mesos.ResourceUsage.Executor executors = 1;
inline int ResourceUsage::executors_size() const {
  return executors_.size();
}
inline void ResourceUsage::clear_executors() {
  executors_.Clear();
}
inline const ::mesos::ResourceUsage_Executor& ResourceUsage::executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.executors)
  return executors_.Get(index);
}
inline ::mesos::ResourceUsage_Executor* ResourceUsage::mutable_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.executors)
  return executors_.Mutable(index);
}
inline ::mesos::ResourceUsage_Executor* ResourceUsage::add_executors() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.executors)
  return executors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >&
ResourceUsage::executors() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.executors)
  return executors_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >*
ResourceUsage::mutable_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.executors)
  return &executors_;
}

// repeated .mesos.Resource total = 2;
inline int ResourceUsage::total_size() const {
  return total_.size();
}
inline void ResourceUsage::clear_total() {
  total_.Clear();
}
inline const ::mesos::Resource& ResourceUsage::total(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.total)
  return total_.Get(index);
}
inline ::mesos::Resource* ResourceUsage::mutable_total(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.total)
  return total_.Mutable(index);
}
inline ::mesos::Resource* ResourceUsage::add_total() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.total)
  return total_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage::total() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.total)
  return total_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage::mutable_total() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.total)
  return &total_;
}

// -------------------------------------------------------------------

// PerfStatistics

// required double timestamp = 1;
inline bool PerfStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerfStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerfStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerfStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double PerfStatistics::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.timestamp)
  return timestamp_;
}
inline void PerfStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.timestamp)
}

// required double duration = 2;
inline bool PerfStatistics::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerfStatistics::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerfStatistics::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerfStatistics::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double PerfStatistics::duration() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.duration)
  return duration_;
}
inline void PerfStatistics::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.duration)
}

// optional uint64 cycles = 3;
inline bool PerfStatistics::has_cycles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerfStatistics::set_has_cycles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerfStatistics::clear_has_cycles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerfStatistics::clear_cycles() {
  cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cycles)
  return cycles_;
}
inline void PerfStatistics::set_cycles(::google::protobuf::uint64 value) {
  set_has_cycles();
  cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cycles)
}

// optional uint64 stalled_cycles_frontend = 4;
inline bool PerfStatistics::has_stalled_cycles_frontend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerfStatistics::set_has_stalled_cycles_frontend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerfStatistics::clear_has_stalled_cycles_frontend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerfStatistics::clear_stalled_cycles_frontend() {
  stalled_cycles_frontend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_frontend();
}
inline ::google::protobuf::uint64 PerfStatistics::stalled_cycles_frontend() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.stalled_cycles_frontend)
  return stalled_cycles_frontend_;
}
inline void PerfStatistics::set_stalled_cycles_frontend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_frontend();
  stalled_cycles_frontend_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.stalled_cycles_frontend)
}

// optional uint64 stalled_cycles_backend = 5;
inline bool PerfStatistics::has_stalled_cycles_backend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerfStatistics::set_has_stalled_cycles_backend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerfStatistics::clear_has_stalled_cycles_backend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerfStatistics::clear_stalled_cycles_backend() {
  stalled_cycles_backend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_backend();
}
inline ::google::protobuf::uint64 PerfStatistics::stalled_cycles_backend() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.stalled_cycles_backend)
  return stalled_cycles_backend_;
}
inline void PerfStatistics::set_stalled_cycles_backend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_backend();
  stalled_cycles_backend_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.stalled_cycles_backend)
}

// optional uint64 instructions = 6;
inline bool PerfStatistics::has_instructions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerfStatistics::set_has_instructions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerfStatistics::clear_has_instructions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PerfStatistics::clear_instructions() {
  instructions_ = GOOGLE_ULONGLONG(0);
  clear_has_instructions();
}
inline ::google::protobuf::uint64 PerfStatistics::instructions() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.instructions)
  return instructions_;
}
inline void PerfStatistics::set_instructions(::google::protobuf::uint64 value) {
  set_has_instructions();
  instructions_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.instructions)
}

// optional uint64 cache_references = 7;
inline bool PerfStatistics::has_cache_references() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PerfStatistics::set_has_cache_references() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PerfStatistics::clear_has_cache_references() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PerfStatistics::clear_cache_references() {
  cache_references_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_references();
}
inline ::google::protobuf::uint64 PerfStatistics::cache_references() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cache_references)
  return cache_references_;
}
inline void PerfStatistics::set_cache_references(::google::protobuf::uint64 value) {
  set_has_cache_references();
  cache_references_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cache_references)
}

// optional uint64 cache_misses = 8;
inline bool PerfStatistics::has_cache_misses() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PerfStatistics::set_has_cache_misses() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PerfStatistics::clear_has_cache_misses() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PerfStatistics::clear_cache_misses() {
  cache_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::cache_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cache_misses)
  return cache_misses_;
}
inline void PerfStatistics::set_cache_misses(::google::protobuf::uint64 value) {
  set_has_cache_misses();
  cache_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cache_misses)
}

// optional uint64 branches = 9;
inline bool PerfStatistics::has_branches() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PerfStatistics::set_has_branches() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PerfStatistics::clear_has_branches() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PerfStatistics::clear_branches() {
  branches_ = GOOGLE_ULONGLONG(0);
  clear_has_branches();
}
inline ::google::protobuf::uint64 PerfStatistics::branches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branches)
  return branches_;
}
inline void PerfStatistics::set_branches(::google::protobuf::uint64 value) {
  set_has_branches();
  branches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branches)
}

// optional uint64 branch_misses = 10;
inline bool PerfStatistics::has_branch_misses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PerfStatistics::set_has_branch_misses() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PerfStatistics::clear_has_branch_misses() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PerfStatistics::clear_branch_misses() {
  branch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_misses)
  return branch_misses_;
}
inline void PerfStatistics::set_branch_misses(::google::protobuf::uint64 value) {
  set_has_branch_misses();
  branch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_misses)
}

// optional uint64 bus_cycles = 11;
inline bool PerfStatistics::has_bus_cycles() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PerfStatistics::set_has_bus_cycles() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PerfStatistics::clear_has_bus_cycles() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PerfStatistics::clear_bus_cycles() {
  bus_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_bus_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::bus_cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.bus_cycles)
  return bus_cycles_;
}
inline void PerfStatistics::set_bus_cycles(::google::protobuf::uint64 value) {
  set_has_bus_cycles();
  bus_cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.bus_cycles)
}

// optional uint64 ref_cycles = 12;
inline bool PerfStatistics::has_ref_cycles() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PerfStatistics::set_has_ref_cycles() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PerfStatistics::clear_has_ref_cycles() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PerfStatistics::clear_ref_cycles() {
  ref_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_ref_cycles();
}
inline ::google::protobuf::uint64 PerfStatistics::ref_cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.ref_cycles)
  return ref_cycles_;
}
inline void PerfStatistics::set_ref_cycles(::google::protobuf::uint64 value) {
  set_has_ref_cycles();
  ref_cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.ref_cycles)
}

// optional double cpu_clock = 13;
inline bool PerfStatistics::has_cpu_clock() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PerfStatistics::set_has_cpu_clock() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PerfStatistics::clear_has_cpu_clock() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PerfStatistics::clear_cpu_clock() {
  cpu_clock_ = 0;
  clear_has_cpu_clock();
}
inline double PerfStatistics::cpu_clock() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cpu_clock)
  return cpu_clock_;
}
inline void PerfStatistics::set_cpu_clock(double value) {
  set_has_cpu_clock();
  cpu_clock_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cpu_clock)
}

// optional double task_clock = 14;
inline bool PerfStatistics::has_task_clock() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PerfStatistics::set_has_task_clock() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PerfStatistics::clear_has_task_clock() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PerfStatistics::clear_task_clock() {
  task_clock_ = 0;
  clear_has_task_clock();
}
inline double PerfStatistics::task_clock() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.task_clock)
  return task_clock_;
}
inline void PerfStatistics::set_task_clock(double value) {
  set_has_task_clock();
  task_clock_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.task_clock)
}

// optional uint64 page_faults = 15;
inline bool PerfStatistics::has_page_faults() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PerfStatistics::set_has_page_faults() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PerfStatistics::clear_has_page_faults() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PerfStatistics::clear_page_faults() {
  page_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_page_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::page_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.page_faults)
  return page_faults_;
}
inline void PerfStatistics::set_page_faults(::google::protobuf::uint64 value) {
  set_has_page_faults();
  page_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.page_faults)
}

// optional uint64 minor_faults = 16;
inline bool PerfStatistics::has_minor_faults() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PerfStatistics::set_has_minor_faults() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PerfStatistics::clear_has_minor_faults() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PerfStatistics::clear_minor_faults() {
  minor_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::minor_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.minor_faults)
  return minor_faults_;
}
inline void PerfStatistics::set_minor_faults(::google::protobuf::uint64 value) {
  set_has_minor_faults();
  minor_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.minor_faults)
}

// optional uint64 major_faults = 17;
inline bool PerfStatistics::has_major_faults() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PerfStatistics::set_has_major_faults() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PerfStatistics::clear_has_major_faults() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PerfStatistics::clear_major_faults() {
  major_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_major_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::major_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.major_faults)
  return major_faults_;
}
inline void PerfStatistics::set_major_faults(::google::protobuf::uint64 value) {
  set_has_major_faults();
  major_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.major_faults)
}

// optional uint64 context_switches = 18;
inline bool PerfStatistics::has_context_switches() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PerfStatistics::set_has_context_switches() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PerfStatistics::clear_has_context_switches() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PerfStatistics::clear_context_switches() {
  context_switches_ = GOOGLE_ULONGLONG(0);
  clear_has_context_switches();
}
inline ::google::protobuf::uint64 PerfStatistics::context_switches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.context_switches)
  return context_switches_;
}
inline void PerfStatistics::set_context_switches(::google::protobuf::uint64 value) {
  set_has_context_switches();
  context_switches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.context_switches)
}

// optional uint64 cpu_migrations = 19;
inline bool PerfStatistics::has_cpu_migrations() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PerfStatistics::set_has_cpu_migrations() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PerfStatistics::clear_has_cpu_migrations() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PerfStatistics::clear_cpu_migrations() {
  cpu_migrations_ = GOOGLE_ULONGLONG(0);
  clear_has_cpu_migrations();
}
inline ::google::protobuf::uint64 PerfStatistics::cpu_migrations() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cpu_migrations)
  return cpu_migrations_;
}
inline void PerfStatistics::set_cpu_migrations(::google::protobuf::uint64 value) {
  set_has_cpu_migrations();
  cpu_migrations_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cpu_migrations)
}

// optional uint64 alignment_faults = 20;
inline bool PerfStatistics::has_alignment_faults() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PerfStatistics::set_has_alignment_faults() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PerfStatistics::clear_has_alignment_faults() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PerfStatistics::clear_alignment_faults() {
  alignment_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_alignment_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::alignment_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.alignment_faults)
  return alignment_faults_;
}
inline void PerfStatistics::set_alignment_faults(::google::protobuf::uint64 value) {
  set_has_alignment_faults();
  alignment_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.alignment_faults)
}

// optional uint64 emulation_faults = 21;
inline bool PerfStatistics::has_emulation_faults() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PerfStatistics::set_has_emulation_faults() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PerfStatistics::clear_has_emulation_faults() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PerfStatistics::clear_emulation_faults() {
  emulation_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_emulation_faults();
}
inline ::google::protobuf::uint64 PerfStatistics::emulation_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.emulation_faults)
  return emulation_faults_;
}
inline void PerfStatistics::set_emulation_faults(::google::protobuf::uint64 value) {
  set_has_emulation_faults();
  emulation_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.emulation_faults)
}

// optional uint64 l1_dcache_loads = 22;
inline bool PerfStatistics::has_l1_dcache_loads() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_loads() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PerfStatistics::clear_has_l1_dcache_loads() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PerfStatistics::clear_l1_dcache_loads() {
  l1_dcache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_loads)
  return l1_dcache_loads_;
}
inline void PerfStatistics::set_l1_dcache_loads(::google::protobuf::uint64 value) {
  set_has_l1_dcache_loads();
  l1_dcache_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_loads)
}

// optional uint64 l1_dcache_load_misses = 23;
inline bool PerfStatistics::has_l1_dcache_load_misses() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_load_misses() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PerfStatistics::clear_has_l1_dcache_load_misses() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PerfStatistics::clear_l1_dcache_load_misses() {
  l1_dcache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_load_misses)
  return l1_dcache_load_misses_;
}
inline void PerfStatistics::set_l1_dcache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_load_misses();
  l1_dcache_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_load_misses)
}

// optional uint64 l1_dcache_stores = 24;
inline bool PerfStatistics::has_l1_dcache_stores() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_stores() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PerfStatistics::clear_has_l1_dcache_stores() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PerfStatistics::clear_l1_dcache_stores() {
  l1_dcache_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_stores)
  return l1_dcache_stores_;
}
inline void PerfStatistics::set_l1_dcache_stores(::google::protobuf::uint64 value) {
  set_has_l1_dcache_stores();
  l1_dcache_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_stores)
}

// optional uint64 l1_dcache_store_misses = 25;
inline bool PerfStatistics::has_l1_dcache_store_misses() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_store_misses() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_store_misses() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PerfStatistics::clear_l1_dcache_store_misses() {
  l1_dcache_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_store_misses)
  return l1_dcache_store_misses_;
}
inline void PerfStatistics::set_l1_dcache_store_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_store_misses();
  l1_dcache_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_store_misses)
}

// optional uint64 l1_dcache_prefetches = 26;
inline bool PerfStatistics::has_l1_dcache_prefetches() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_prefetches() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_prefetches() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PerfStatistics::clear_l1_dcache_prefetches() {
  l1_dcache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_prefetches)
  return l1_dcache_prefetches_;
}
inline void PerfStatistics::set_l1_dcache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetches();
  l1_dcache_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_prefetches)
}

// optional uint64 l1_dcache_prefetch_misses = 27;
inline bool PerfStatistics::has_l1_dcache_prefetch_misses() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PerfStatistics::set_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PerfStatistics::clear_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PerfStatistics::clear_l1_dcache_prefetch_misses() {
  l1_dcache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_prefetch_misses)
  return l1_dcache_prefetch_misses_;
}
inline void PerfStatistics::set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetch_misses();
  l1_dcache_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_prefetch_misses)
}

// optional uint64 l1_icache_loads = 28;
inline bool PerfStatistics::has_l1_icache_loads() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_loads() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PerfStatistics::clear_has_l1_icache_loads() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PerfStatistics::clear_l1_icache_loads() {
  l1_icache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_loads)
  return l1_icache_loads_;
}
inline void PerfStatistics::set_l1_icache_loads(::google::protobuf::uint64 value) {
  set_has_l1_icache_loads();
  l1_icache_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_loads)
}

// optional uint64 l1_icache_load_misses = 29;
inline bool PerfStatistics::has_l1_icache_load_misses() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_load_misses() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PerfStatistics::clear_has_l1_icache_load_misses() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PerfStatistics::clear_l1_icache_load_misses() {
  l1_icache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_load_misses)
  return l1_icache_load_misses_;
}
inline void PerfStatistics::set_l1_icache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_load_misses();
  l1_icache_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_load_misses)
}

// optional uint64 l1_icache_prefetches = 30;
inline bool PerfStatistics::has_l1_icache_prefetches() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_prefetches() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PerfStatistics::clear_has_l1_icache_prefetches() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PerfStatistics::clear_l1_icache_prefetches() {
  l1_icache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_prefetches)
  return l1_icache_prefetches_;
}
inline void PerfStatistics::set_l1_icache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetches();
  l1_icache_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_prefetches)
}

// optional uint64 l1_icache_prefetch_misses = 31;
inline bool PerfStatistics::has_l1_icache_prefetch_misses() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PerfStatistics::set_has_l1_icache_prefetch_misses() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PerfStatistics::clear_has_l1_icache_prefetch_misses() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PerfStatistics::clear_l1_icache_prefetch_misses() {
  l1_icache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_prefetch_misses)
  return l1_icache_prefetch_misses_;
}
inline void PerfStatistics::set_l1_icache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetch_misses();
  l1_icache_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_prefetch_misses)
}

// optional uint64 llc_loads = 32;
inline bool PerfStatistics::has_llc_loads() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PerfStatistics::set_has_llc_loads() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PerfStatistics::clear_has_llc_loads() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PerfStatistics::clear_llc_loads() {
  llc_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_loads)
  return llc_loads_;
}
inline void PerfStatistics::set_llc_loads(::google::protobuf::uint64 value) {
  set_has_llc_loads();
  llc_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_loads)
}

// optional uint64 llc_load_misses = 33;
inline bool PerfStatistics::has_llc_load_misses() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PerfStatistics::set_has_llc_load_misses() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PerfStatistics::clear_has_llc_load_misses() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PerfStatistics::clear_llc_load_misses() {
  llc_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_load_misses)
  return llc_load_misses_;
}
inline void PerfStatistics::set_llc_load_misses(::google::protobuf::uint64 value) {
  set_has_llc_load_misses();
  llc_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_load_misses)
}

// optional uint64 llc_stores = 34;
inline bool PerfStatistics::has_llc_stores() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PerfStatistics::set_has_llc_stores() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PerfStatistics::clear_has_llc_stores() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PerfStatistics::clear_llc_stores() {
  llc_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_stores)
  return llc_stores_;
}
inline void PerfStatistics::set_llc_stores(::google::protobuf::uint64 value) {
  set_has_llc_stores();
  llc_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_stores)
}

// optional uint64 llc_store_misses = 35;
inline bool PerfStatistics::has_llc_store_misses() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PerfStatistics::set_has_llc_store_misses() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PerfStatistics::clear_has_llc_store_misses() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PerfStatistics::clear_llc_store_misses() {
  llc_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_store_misses)
  return llc_store_misses_;
}
inline void PerfStatistics::set_llc_store_misses(::google::protobuf::uint64 value) {
  set_has_llc_store_misses();
  llc_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_store_misses)
}

// optional uint64 llc_prefetches = 36;
inline bool PerfStatistics::has_llc_prefetches() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PerfStatistics::set_has_llc_prefetches() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PerfStatistics::clear_has_llc_prefetches() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PerfStatistics::clear_llc_prefetches() {
  llc_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_prefetches)
  return llc_prefetches_;
}
inline void PerfStatistics::set_llc_prefetches(::google::protobuf::uint64 value) {
  set_has_llc_prefetches();
  llc_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_prefetches)
}

// optional uint64 llc_prefetch_misses = 37;
inline bool PerfStatistics::has_llc_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PerfStatistics::set_has_llc_prefetch_misses() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PerfStatistics::clear_has_llc_prefetch_misses() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PerfStatistics::clear_llc_prefetch_misses() {
  llc_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::llc_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_prefetch_misses)
  return llc_prefetch_misses_;
}
inline void PerfStatistics::set_llc_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_llc_prefetch_misses();
  llc_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_prefetch_misses)
}

// optional uint64 dtlb_loads = 38;
inline bool PerfStatistics::has_dtlb_loads() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PerfStatistics::set_has_dtlb_loads() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PerfStatistics::clear_has_dtlb_loads() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PerfStatistics::clear_dtlb_loads() {
  dtlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_loads)
  return dtlb_loads_;
}
inline void PerfStatistics::set_dtlb_loads(::google::protobuf::uint64 value) {
  set_has_dtlb_loads();
  dtlb_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_loads)
}

// optional uint64 dtlb_load_misses = 39;
inline bool PerfStatistics::has_dtlb_load_misses() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PerfStatistics::set_has_dtlb_load_misses() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PerfStatistics::clear_has_dtlb_load_misses() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PerfStatistics::clear_dtlb_load_misses() {
  dtlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_load_misses)
  return dtlb_load_misses_;
}
inline void PerfStatistics::set_dtlb_load_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_load_misses();
  dtlb_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_load_misses)
}

// optional uint64 dtlb_stores = 40;
inline bool PerfStatistics::has_dtlb_stores() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PerfStatistics::set_has_dtlb_stores() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PerfStatistics::clear_has_dtlb_stores() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PerfStatistics::clear_dtlb_stores() {
  dtlb_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_stores)
  return dtlb_stores_;
}
inline void PerfStatistics::set_dtlb_stores(::google::protobuf::uint64 value) {
  set_has_dtlb_stores();
  dtlb_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_stores)
}

// optional uint64 dtlb_store_misses = 41;
inline bool PerfStatistics::has_dtlb_store_misses() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PerfStatistics::set_has_dtlb_store_misses() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PerfStatistics::clear_has_dtlb_store_misses() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PerfStatistics::clear_dtlb_store_misses() {
  dtlb_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_store_misses)
  return dtlb_store_misses_;
}
inline void PerfStatistics::set_dtlb_store_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_store_misses();
  dtlb_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_store_misses)
}

// optional uint64 dtlb_prefetches = 42;
inline bool PerfStatistics::has_dtlb_prefetches() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PerfStatistics::set_has_dtlb_prefetches() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PerfStatistics::clear_has_dtlb_prefetches() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PerfStatistics::clear_dtlb_prefetches() {
  dtlb_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_prefetches)
  return dtlb_prefetches_;
}
inline void PerfStatistics::set_dtlb_prefetches(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetches();
  dtlb_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_prefetches)
}

// optional uint64 dtlb_prefetch_misses = 43;
inline bool PerfStatistics::has_dtlb_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PerfStatistics::set_has_dtlb_prefetch_misses() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PerfStatistics::clear_has_dtlb_prefetch_misses() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PerfStatistics::clear_dtlb_prefetch_misses() {
  dtlb_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::dtlb_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_prefetch_misses)
  return dtlb_prefetch_misses_;
}
inline void PerfStatistics::set_dtlb_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetch_misses();
  dtlb_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_prefetch_misses)
}

// optional uint64 itlb_loads = 44;
inline bool PerfStatistics::has_itlb_loads() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PerfStatistics::set_has_itlb_loads() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PerfStatistics::clear_has_itlb_loads() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PerfStatistics::clear_itlb_loads() {
  itlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::itlb_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.itlb_loads)
  return itlb_loads_;
}
inline void PerfStatistics::set_itlb_loads(::google::protobuf::uint64 value) {
  set_has_itlb_loads();
  itlb_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.itlb_loads)
}

// optional uint64 itlb_load_misses = 45;
inline bool PerfStatistics::has_itlb_load_misses() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PerfStatistics::set_has_itlb_load_misses() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PerfStatistics::clear_has_itlb_load_misses() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PerfStatistics::clear_itlb_load_misses() {
  itlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::itlb_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.itlb_load_misses)
  return itlb_load_misses_;
}
inline void PerfStatistics::set_itlb_load_misses(::google::protobuf::uint64 value) {
  set_has_itlb_load_misses();
  itlb_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.itlb_load_misses)
}

// optional uint64 branch_loads = 46;
inline bool PerfStatistics::has_branch_loads() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PerfStatistics::set_has_branch_loads() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PerfStatistics::clear_has_branch_loads() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PerfStatistics::clear_branch_loads() {
  branch_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_loads)
  return branch_loads_;
}
inline void PerfStatistics::set_branch_loads(::google::protobuf::uint64 value) {
  set_has_branch_loads();
  branch_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_loads)
}

// optional uint64 branch_load_misses = 47;
inline bool PerfStatistics::has_branch_load_misses() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PerfStatistics::set_has_branch_load_misses() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PerfStatistics::clear_has_branch_load_misses() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PerfStatistics::clear_branch_load_misses() {
  branch_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::branch_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_load_misses)
  return branch_load_misses_;
}
inline void PerfStatistics::set_branch_load_misses(::google::protobuf::uint64 value) {
  set_has_branch_load_misses();
  branch_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_load_misses)
}

// optional uint64 node_loads = 48;
inline bool PerfStatistics::has_node_loads() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PerfStatistics::set_has_node_loads() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PerfStatistics::clear_has_node_loads() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PerfStatistics::clear_node_loads() {
  node_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_node_loads();
}
inline ::google::protobuf::uint64 PerfStatistics::node_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_loads)
  return node_loads_;
}
inline void PerfStatistics::set_node_loads(::google::protobuf::uint64 value) {
  set_has_node_loads();
  node_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_loads)
}

// optional uint64 node_load_misses = 49;
inline bool PerfStatistics::has_node_load_misses() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PerfStatistics::set_has_node_load_misses() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PerfStatistics::clear_has_node_load_misses() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PerfStatistics::clear_node_load_misses() {
  node_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_load_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_load_misses)
  return node_load_misses_;
}
inline void PerfStatistics::set_node_load_misses(::google::protobuf::uint64 value) {
  set_has_node_load_misses();
  node_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_load_misses)
}

// optional uint64 node_stores = 50;
inline bool PerfStatistics::has_node_stores() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PerfStatistics::set_has_node_stores() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PerfStatistics::clear_has_node_stores() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PerfStatistics::clear_node_stores() {
  node_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_node_stores();
}
inline ::google::protobuf::uint64 PerfStatistics::node_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_stores)
  return node_stores_;
}
inline void PerfStatistics::set_node_stores(::google::protobuf::uint64 value) {
  set_has_node_stores();
  node_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_stores)
}

// optional uint64 node_store_misses = 51;
inline bool PerfStatistics::has_node_store_misses() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PerfStatistics::set_has_node_store_misses() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PerfStatistics::clear_has_node_store_misses() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PerfStatistics::clear_node_store_misses() {
  node_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_store_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_store_misses)
  return node_store_misses_;
}
inline void PerfStatistics::set_node_store_misses(::google::protobuf::uint64 value) {
  set_has_node_store_misses();
  node_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_store_misses)
}

// optional uint64 node_prefetches = 52;
inline bool PerfStatistics::has_node_prefetches() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PerfStatistics::set_has_node_prefetches() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PerfStatistics::clear_has_node_prefetches() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PerfStatistics::clear_node_prefetches() {
  node_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetches();
}
inline ::google::protobuf::uint64 PerfStatistics::node_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_prefetches)
  return node_prefetches_;
}
inline void PerfStatistics::set_node_prefetches(::google::protobuf::uint64 value) {
  set_has_node_prefetches();
  node_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_prefetches)
}

// optional uint64 node_prefetch_misses = 53;
inline bool PerfStatistics::has_node_prefetch_misses() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PerfStatistics::set_has_node_prefetch_misses() {
  _has_bits_[1] |= 0x00100000u;
}
inline void PerfStatistics::clear_has_node_prefetch_misses() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void PerfStatistics::clear_node_prefetch_misses() {
  node_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetch_misses();
}
inline ::google::protobuf::uint64 PerfStatistics::node_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_prefetch_misses)
  return node_prefetch_misses_;
}
inline void PerfStatistics::set_node_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_node_prefetch_misses();
  node_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_prefetch_misses)
}

// -------------------------------------------------------------------

// Request

// optional .mesos.SlaveID slave_id = 1;
inline bool Request::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Request::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.Request.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Request::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.Request.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Request::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Request::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Request.slave_id)
}

// repeated .mesos.Resource resources = 2;
inline int Request::resources_size() const {
  return resources_.size();
}
inline void Request::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Request::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Request.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Request::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Request.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Request::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Request.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Request::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Request.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Request::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Request.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Launch

// repeated .mesos.TaskInfo task_infos = 1;
inline int Offer_Operation_Launch::task_infos_size() const {
  return task_infos_.size();
}
inline void Offer_Operation_Launch::clear_task_infos() {
  task_infos_.Clear();
}
inline const ::mesos::TaskInfo& Offer_Operation_Launch::task_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Get(index);
}
inline ::mesos::TaskInfo* Offer_Operation_Launch::mutable_task_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Mutable(index);
}
inline ::mesos::TaskInfo* Offer_Operation_Launch::add_task_infos() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
Offer_Operation_Launch::task_infos() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
Offer_Operation_Launch::mutable_task_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Launch.task_infos)
  return &task_infos_;
}

// -------------------------------------------------------------------

// Offer_Operation_LaunchGroup

// required .mesos.ExecutorInfo executor = 1;
inline bool Offer_Operation_LaunchGroup::has_executor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation_LaunchGroup::set_has_executor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation_LaunchGroup::clear_has_executor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation_LaunchGroup::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& Offer_Operation_LaunchGroup::executor() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.LaunchGroup.executor)
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.LaunchGroup.executor)
  return executor_;
}
inline ::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::release_executor() {
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
inline void Offer_Operation_LaunchGroup::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  delete executor_;
  executor_ = executor;
  if (executor) {
    set_has_executor();
  } else {
    clear_has_executor();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.LaunchGroup.executor)
}

// required .mesos.TaskGroupInfo task_group = 2;
inline bool Offer_Operation_LaunchGroup::has_task_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation_LaunchGroup::set_has_task_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation_LaunchGroup::clear_has_task_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation_LaunchGroup::clear_task_group() {
  if (task_group_ != NULL) task_group_->::mesos::TaskGroupInfo::Clear();
  clear_has_task_group();
}
inline const ::mesos::TaskGroupInfo& Offer_Operation_LaunchGroup::task_group() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.LaunchGroup.task_group)
  return task_group_ != NULL ? *task_group_ : *default_instance_->task_group_;
}
inline ::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::mutable_task_group() {
  set_has_task_group();
  if (task_group_ == NULL) task_group_ = new ::mesos::TaskGroupInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.LaunchGroup.task_group)
  return task_group_;
}
inline ::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::release_task_group() {
  clear_has_task_group();
  ::mesos::TaskGroupInfo* temp = task_group_;
  task_group_ = NULL;
  return temp;
}
inline void Offer_Operation_LaunchGroup::set_allocated_task_group(::mesos::TaskGroupInfo* task_group) {
  delete task_group_;
  task_group_ = task_group;
  if (task_group) {
    set_has_task_group();
  } else {
    clear_has_task_group();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.LaunchGroup.task_group)
}

// -------------------------------------------------------------------

// Offer_Operation_Reserve

// repeated .mesos.Resource resources = 1;
inline int Offer_Operation_Reserve::resources_size() const {
  return resources_.size();
}
inline void Offer_Operation_Reserve::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Reserve::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Reserve.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Reserve::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Reserve.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Reserve::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Reserve.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Reserve::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Reserve.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Reserve::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Reserve.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Unreserve

// repeated .mesos.Resource resources = 1;
inline int Offer_Operation_Unreserve::resources_size() const {
  return resources_.size();
}
inline void Offer_Operation_Unreserve::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Unreserve::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Unreserve::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Unreserve::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Unreserve::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Unreserve.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Unreserve::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Unreserve.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Create

// repeated .mesos.Resource volumes = 1;
inline int Offer_Operation_Create::volumes_size() const {
  return volumes_.size();
}
inline void Offer_Operation_Create::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Create::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Create.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Create::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Create.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Create::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Create.volumes)
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Create::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Create.volumes)
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Create::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Create.volumes)
  return &volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation_Destroy

// repeated .mesos.Resource volumes = 1;
inline int Offer_Operation_Destroy::volumes_size() const {
  return volumes_.size();
}
inline void Offer_Operation_Destroy::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Resource& Offer_Operation_Destroy::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Resource* Offer_Operation_Destroy::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Resource* Offer_Operation_Destroy::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Destroy::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Destroy.volumes)
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Destroy::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Destroy.volumes)
  return &volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation

// optional .mesos.Offer.Operation.Type type = 1;
inline bool Offer_Operation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer_Operation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer_Operation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer_Operation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Offer_Operation_Type Offer_Operation::type() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.type)
  return static_cast< ::mesos::Offer_Operation_Type >(type_);
}
inline void Offer_Operation::set_type(::mesos::Offer_Operation_Type value) {
  assert(::mesos::Offer_Operation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Offer.Operation.type)
}

// optional .mesos.Offer.Operation.Launch launch = 2;
inline bool Offer_Operation::has_launch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer_Operation::set_has_launch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer_Operation::clear_has_launch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer_Operation::clear_launch() {
  if (launch_ != NULL) launch_->::mesos::Offer_Operation_Launch::Clear();
  clear_has_launch();
}
inline const ::mesos::Offer_Operation_Launch& Offer_Operation::launch() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.launch)
  return launch_ != NULL ? *launch_ : *default_instance_->launch_;
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::mutable_launch() {
  set_has_launch();
  if (launch_ == NULL) launch_ = new ::mesos::Offer_Operation_Launch;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.launch)
  return launch_;
}
inline ::mesos::Offer_Operation_Launch* Offer_Operation::release_launch() {
  clear_has_launch();
  ::mesos::Offer_Operation_Launch* temp = launch_;
  launch_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_launch(::mesos::Offer_Operation_Launch* launch) {
  delete launch_;
  launch_ = launch;
  if (launch) {
    set_has_launch();
  } else {
    clear_has_launch();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.launch)
}

// optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
inline bool Offer_Operation::has_launch_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer_Operation::set_has_launch_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer_Operation::clear_has_launch_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer_Operation::clear_launch_group() {
  if (launch_group_ != NULL) launch_group_->::mesos::Offer_Operation_LaunchGroup::Clear();
  clear_has_launch_group();
}
inline const ::mesos::Offer_Operation_LaunchGroup& Offer_Operation::launch_group() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.launch_group)
  return launch_group_ != NULL ? *launch_group_ : *default_instance_->launch_group_;
}
inline ::mesos::Offer_Operation_LaunchGroup* Offer_Operation::mutable_launch_group() {
  set_has_launch_group();
  if (launch_group_ == NULL) launch_group_ = new ::mesos::Offer_Operation_LaunchGroup;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.launch_group)
  return launch_group_;
}
inline ::mesos::Offer_Operation_LaunchGroup* Offer_Operation::release_launch_group() {
  clear_has_launch_group();
  ::mesos::Offer_Operation_LaunchGroup* temp = launch_group_;
  launch_group_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_launch_group(::mesos::Offer_Operation_LaunchGroup* launch_group) {
  delete launch_group_;
  launch_group_ = launch_group;
  if (launch_group) {
    set_has_launch_group();
  } else {
    clear_has_launch_group();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.launch_group)
}

// optional .mesos.Offer.Operation.Reserve reserve = 3;
inline bool Offer_Operation::has_reserve() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer_Operation::set_has_reserve() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer_Operation::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer_Operation::clear_reserve() {
  if (reserve_ != NULL) reserve_->::mesos::Offer_Operation_Reserve::Clear();
  clear_has_reserve();
}
inline const ::mesos::Offer_Operation_Reserve& Offer_Operation::reserve() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.reserve)
  return reserve_ != NULL ? *reserve_ : *default_instance_->reserve_;
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::mutable_reserve() {
  set_has_reserve();
  if (reserve_ == NULL) reserve_ = new ::mesos::Offer_Operation_Reserve;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.reserve)
  return reserve_;
}
inline ::mesos::Offer_Operation_Reserve* Offer_Operation::release_reserve() {
  clear_has_reserve();
  ::mesos::Offer_Operation_Reserve* temp = reserve_;
  reserve_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve) {
  delete reserve_;
  reserve_ = reserve;
  if (reserve) {
    set_has_reserve();
  } else {
    clear_has_reserve();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.reserve)
}

// optional .mesos.Offer.Operation.Unreserve unreserve = 4;
inline bool Offer_Operation::has_unreserve() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Offer_Operation::set_has_unreserve() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Offer_Operation::clear_has_unreserve() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Offer_Operation::clear_unreserve() {
  if (unreserve_ != NULL) unreserve_->::mesos::Offer_Operation_Unreserve::Clear();
  clear_has_unreserve();
}
inline const ::mesos::Offer_Operation_Unreserve& Offer_Operation::unreserve() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.unreserve)
  return unreserve_ != NULL ? *unreserve_ : *default_instance_->unreserve_;
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::mutable_unreserve() {
  set_has_unreserve();
  if (unreserve_ == NULL) unreserve_ = new ::mesos::Offer_Operation_Unreserve;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.unreserve)
  return unreserve_;
}
inline ::mesos::Offer_Operation_Unreserve* Offer_Operation::release_unreserve() {
  clear_has_unreserve();
  ::mesos::Offer_Operation_Unreserve* temp = unreserve_;
  unreserve_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve) {
  delete unreserve_;
  unreserve_ = unreserve;
  if (unreserve) {
    set_has_unreserve();
  } else {
    clear_has_unreserve();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.unreserve)
}

// optional .mesos.Offer.Operation.Create create = 5;
inline bool Offer_Operation::has_create() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Offer_Operation::set_has_create() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Offer_Operation::clear_has_create() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Offer_Operation::clear_create() {
  if (create_ != NULL) create_->::mesos::Offer_Operation_Create::Clear();
  clear_has_create();
}
inline const ::mesos::Offer_Operation_Create& Offer_Operation::create() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.create)
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::mutable_create() {
  set_has_create();
  if (create_ == NULL) create_ = new ::mesos::Offer_Operation_Create;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.create)
  return create_;
}
inline ::mesos::Offer_Operation_Create* Offer_Operation::release_create() {
  clear_has_create();
  ::mesos::Offer_Operation_Create* temp = create_;
  create_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_create(::mesos::Offer_Operation_Create* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.create)
}

// optional .mesos.Offer.Operation.Destroy destroy = 6;
inline bool Offer_Operation::has_destroy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Offer_Operation::set_has_destroy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Offer_Operation::clear_has_destroy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Offer_Operation::clear_destroy() {
  if (destroy_ != NULL) destroy_->::mesos::Offer_Operation_Destroy::Clear();
  clear_has_destroy();
}
inline const ::mesos::Offer_Operation_Destroy& Offer_Operation::destroy() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.destroy)
  return destroy_ != NULL ? *destroy_ : *default_instance_->destroy_;
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::mutable_destroy() {
  set_has_destroy();
  if (destroy_ == NULL) destroy_ = new ::mesos::Offer_Operation_Destroy;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.destroy)
  return destroy_;
}
inline ::mesos::Offer_Operation_Destroy* Offer_Operation::release_destroy() {
  clear_has_destroy();
  ::mesos::Offer_Operation_Destroy* temp = destroy_;
  destroy_ = NULL;
  return temp;
}
inline void Offer_Operation::set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy) {
  delete destroy_;
  destroy_ = destroy;
  if (destroy) {
    set_has_destroy();
  } else {
    clear_has_destroy();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.destroy)
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
inline bool Offer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& Offer::id() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::OfferID* Offer::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::OfferID;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.id)
  return id_;
}
inline ::mesos::OfferID* Offer::release_id() {
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_id(::mesos::OfferID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.id)
}

// required .mesos.FrameworkID framework_id = 2;
inline bool Offer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Offer::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Offer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* Offer::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.framework_id)
}

// required .mesos.SlaveID slave_id = 3;
inline bool Offer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Offer::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Offer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Offer::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.slave_id)
}

// required string hostname = 4;
inline bool Offer::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Offer::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.hostname)
  return *hostname_;
}
inline void Offer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Offer.hostname)
}
inline void Offer::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Offer.hostname)
}
inline void Offer::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Offer.hostname)
}
inline ::std::string* Offer::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.hostname)
  return hostname_;
}
inline ::std::string* Offer::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Offer::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.hostname)
}

// optional .mesos.URL url = 8;
inline bool Offer::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Offer::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Offer::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Offer::clear_url() {
  if (url_ != NULL) url_->::mesos::URL::Clear();
  clear_has_url();
}
inline const ::mesos::URL& Offer::url() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.url)
  return url_ != NULL ? *url_ : *default_instance_->url_;
}
inline ::mesos::URL* Offer::mutable_url() {
  set_has_url();
  if (url_ == NULL) url_ = new ::mesos::URL;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.url)
  return url_;
}
inline ::mesos::URL* Offer::release_url() {
  clear_has_url();
  ::mesos::URL* temp = url_;
  url_ = NULL;
  return temp;
}
inline void Offer::set_allocated_url(::mesos::URL* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.url)
}

// repeated .mesos.Resource resources = 5;
inline int Offer::resources_size() const {
  return resources_.size();
}
inline void Offer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.resources)
  return &resources_;
}

// repeated .mesos.Attribute attributes = 7;
inline int Offer::attributes_size() const {
  return attributes_.size();
}
inline void Offer::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& Offer::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.attributes)
  return attributes_.Get(index);
}
inline ::mesos::Attribute* Offer::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.attributes)
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* Offer::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
Offer::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
Offer::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.attributes)
  return &attributes_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
inline int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
inline void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
inline const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.executor_ids)
  return executor_ids_.Get(index);
}
inline ::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.executor_ids)
  return executor_ids_.Mutable(index);
}
inline ::mesos::ExecutorID* Offer::add_executor_ids() {
  // @@protoc_insertion_point(field_add:mesos.Offer.executor_ids)
  return executor_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.executor_ids)
  return executor_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.executor_ids)
  return &executor_ids_;
}

// optional .mesos.Unavailability unavailability = 9;
inline bool Offer::has_unavailability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Offer::set_has_unavailability() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Offer::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Offer::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
  clear_has_unavailability();
}
inline const ::mesos::Unavailability& Offer::unavailability() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.unavailability)
  return unavailability_ != NULL ? *unavailability_ : *default_instance_->unavailability_;
}
inline ::mesos::Unavailability* Offer::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) unavailability_ = new ::mesos::Unavailability;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.unavailability)
  return unavailability_;
}
inline ::mesos::Unavailability* Offer::release_unavailability() {
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
inline void Offer::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  delete unavailability_;
  unavailability_ = unavailability;
  if (unavailability) {
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.unavailability)
}

// optional .mesos.Resource.AllocationInfo allocation_info = 10;
inline bool Offer::has_allocation_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Offer::set_has_allocation_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Offer::clear_has_allocation_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Offer::clear_allocation_info() {
  if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
  clear_has_allocation_info();
}
inline const ::mesos::Resource_AllocationInfo& Offer::allocation_info() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.allocation_info)
  return allocation_info_ != NULL ? *allocation_info_ : *default_instance_->allocation_info_;
}
inline ::mesos::Resource_AllocationInfo* Offer::mutable_allocation_info() {
  set_has_allocation_info();
  if (allocation_info_ == NULL) allocation_info_ = new ::mesos::Resource_AllocationInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Offer.allocation_info)
  return allocation_info_;
}
inline ::mesos::Resource_AllocationInfo* Offer::release_allocation_info() {
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  allocation_info_ = NULL;
  return temp;
}
inline void Offer::set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info) {
  delete allocation_info_;
  allocation_info_ = allocation_info;
  if (allocation_info) {
    set_has_allocation_info();
  } else {
    clear_has_allocation_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.allocation_info)
}

// -------------------------------------------------------------------

// InverseOffer

// required .mesos.OfferID id = 1;
inline bool InverseOffer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InverseOffer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InverseOffer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InverseOffer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& InverseOffer::id() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::OfferID* InverseOffer::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::OfferID;
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.id)
  return id_;
}
inline ::mesos::OfferID* InverseOffer::release_id() {
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void InverseOffer::set_allocated_id(::mesos::OfferID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.id)
}

// optional .mesos.URL url = 2;
inline bool InverseOffer::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InverseOffer::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InverseOffer::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InverseOffer::clear_url() {
  if (url_ != NULL) url_->::mesos::URL::Clear();
  clear_has_url();
}
inline const ::mesos::URL& InverseOffer::url() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.url)
  return url_ != NULL ? *url_ : *default_instance_->url_;
}
inline ::mesos::URL* InverseOffer::mutable_url() {
  set_has_url();
  if (url_ == NULL) url_ = new ::mesos::URL;
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.url)
  return url_;
}
inline ::mesos::URL* InverseOffer::release_url() {
  clear_has_url();
  ::mesos::URL* temp = url_;
  url_ = NULL;
  return temp;
}
inline void InverseOffer::set_allocated_url(::mesos::URL* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.url)
}

// required .mesos.FrameworkID framework_id = 3;
inline bool InverseOffer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InverseOffer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InverseOffer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InverseOffer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& InverseOffer::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* InverseOffer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* InverseOffer::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void InverseOffer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.framework_id)
}

// optional .mesos.SlaveID slave_id = 4;
inline bool InverseOffer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InverseOffer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InverseOffer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InverseOffer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& InverseOffer::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* InverseOffer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* InverseOffer::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void InverseOffer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.slave_id)
}

// required .mesos.Unavailability unavailability = 5;
inline bool InverseOffer::has_unavailability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InverseOffer::set_has_unavailability() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InverseOffer::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InverseOffer::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
  clear_has_unavailability();
}
inline const ::mesos::Unavailability& InverseOffer::unavailability() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.unavailability)
  return unavailability_ != NULL ? *unavailability_ : *default_instance_->unavailability_;
}
inline ::mesos::Unavailability* InverseOffer::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) unavailability_ = new ::mesos::Unavailability;
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.unavailability)
  return unavailability_;
}
inline ::mesos::Unavailability* InverseOffer::release_unavailability() {
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
inline void InverseOffer::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  delete unavailability_;
  unavailability_ = unavailability;
  if (unavailability) {
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.unavailability)
}

// repeated .mesos.Resource resources = 6;
inline int InverseOffer::resources_size() const {
  return resources_.size();
}
inline void InverseOffer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& InverseOffer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* InverseOffer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* InverseOffer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.InverseOffer.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
InverseOffer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.InverseOffer.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
InverseOffer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.InverseOffer.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// TaskInfo

// required string name = 1;
inline bool TaskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.name)
  return *name_;
}
inline void TaskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TaskInfo.name)
}
inline void TaskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TaskInfo.name)
}
inline void TaskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskInfo.name)
}
inline ::std::string* TaskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.name)
  return name_;
}
inline ::std::string* TaskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.name)
}

// required .mesos.TaskID task_id = 2;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskInfo::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.task_id)
  return task_id_;
}
inline ::mesos::TaskID* TaskInfo::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.task_id)
}

// required .mesos.SlaveID slave_id = 3;
inline bool TaskInfo::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskInfo::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.slave_id)
}

// repeated .mesos.Resource resources = 4;
inline int TaskInfo::resources_size() const {
  return resources_.size();
}
inline void TaskInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.TaskInfo.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.TaskInfo.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskInfo.resources)
  return &resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
inline bool TaskInfo::has_executor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_executor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_executor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& TaskInfo::executor() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.executor)
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.executor)
  return executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::release_executor() {
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  delete executor_;
  executor_ = executor;
  if (executor) {
    set_has_executor();
  } else {
    clear_has_executor();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.executor)
}

// optional .mesos.CommandInfo command = 7;
inline bool TaskInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& TaskInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* TaskInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.command)
  return command_;
}
inline ::mesos::CommandInfo* TaskInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.command)
}

// optional .mesos.ContainerInfo container = 9;
inline bool TaskInfo::has_container() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskInfo::set_has_container() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& TaskInfo::container() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::ContainerInfo* TaskInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::ContainerInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.container)
  return container_;
}
inline ::mesos::ContainerInfo* TaskInfo::release_container() {
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.container)
}

// optional .mesos.HealthCheck health_check = 8;
inline bool TaskInfo::has_health_check() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskInfo::set_has_health_check() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskInfo::clear_has_health_check() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskInfo::clear_health_check() {
  if (health_check_ != NULL) health_check_->::mesos::HealthCheck::Clear();
  clear_has_health_check();
}
inline const ::mesos::HealthCheck& TaskInfo::health_check() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.health_check)
  return health_check_ != NULL ? *health_check_ : *default_instance_->health_check_;
}
inline ::mesos::HealthCheck* TaskInfo::mutable_health_check() {
  set_has_health_check();
  if (health_check_ == NULL) health_check_ = new ::mesos::HealthCheck;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.health_check)
  return health_check_;
}
inline ::mesos::HealthCheck* TaskInfo::release_health_check() {
  clear_has_health_check();
  ::mesos::HealthCheck* temp = health_check_;
  health_check_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_health_check(::mesos::HealthCheck* health_check) {
  delete health_check_;
  health_check_ = health_check;
  if (health_check) {
    set_has_health_check();
  } else {
    clear_has_health_check();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.health_check)
}

// optional .mesos.CheckInfo check = 13;
inline bool TaskInfo::has_check() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskInfo::set_has_check() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskInfo::clear_has_check() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskInfo::clear_check() {
  if (check_ != NULL) check_->::mesos::CheckInfo::Clear();
  clear_has_check();
}
inline const ::mesos::CheckInfo& TaskInfo::check() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.check)
  return check_ != NULL ? *check_ : *default_instance_->check_;
}
inline ::mesos::CheckInfo* TaskInfo::mutable_check() {
  set_has_check();
  if (check_ == NULL) check_ = new ::mesos::CheckInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.check)
  return check_;
}
inline ::mesos::CheckInfo* TaskInfo::release_check() {
  clear_has_check();
  ::mesos::CheckInfo* temp = check_;
  check_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_check(::mesos::CheckInfo* check) {
  delete check_;
  check_ = check;
  if (check) {
    set_has_check();
  } else {
    clear_has_check();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.check)
}

// optional .mesos.KillPolicy kill_policy = 12;
inline bool TaskInfo::has_kill_policy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskInfo::set_has_kill_policy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskInfo::clear_has_kill_policy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskInfo::clear_kill_policy() {
  if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
  clear_has_kill_policy();
}
inline const ::mesos::KillPolicy& TaskInfo::kill_policy() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.kill_policy)
  return kill_policy_ != NULL ? *kill_policy_ : *default_instance_->kill_policy_;
}
inline ::mesos::KillPolicy* TaskInfo::mutable_kill_policy() {
  set_has_kill_policy();
  if (kill_policy_ == NULL) kill_policy_ = new ::mesos::KillPolicy;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.kill_policy)
  return kill_policy_;
}
inline ::mesos::KillPolicy* TaskInfo::release_kill_policy() {
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  kill_policy_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_kill_policy(::mesos::KillPolicy* kill_policy) {
  delete kill_policy_;
  kill_policy_ = kill_policy;
  if (kill_policy) {
    set_has_kill_policy();
  } else {
    clear_has_kill_policy();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.kill_policy)
}

// optional bytes data = 6;
inline bool TaskInfo::has_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskInfo::set_has_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskInfo::data() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.data)
  return *data_;
}
inline void TaskInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TaskInfo.data)
}
inline void TaskInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TaskInfo.data)
}
inline void TaskInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskInfo.data)
}
inline ::std::string* TaskInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.data)
  return data_;
}
inline ::std::string* TaskInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.data)
}

// optional .mesos.Labels labels = 10;
inline bool TaskInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& TaskInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* TaskInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.labels)
  return labels_;
}
inline ::mesos::Labels* TaskInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.labels)
}

// optional .mesos.DiscoveryInfo discovery = 11;
inline bool TaskInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TaskInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TaskInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TaskInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& TaskInfo::discovery() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.discovery)
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
inline ::mesos::DiscoveryInfo* TaskInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) discovery_ = new ::mesos::DiscoveryInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.discovery)
  return discovery_;
}
inline ::mesos::DiscoveryInfo* TaskInfo::release_discovery() {
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.discovery)
}

// -------------------------------------------------------------------

// TaskGroupInfo

// repeated .mesos.TaskInfo tasks = 1;
inline int TaskGroupInfo::tasks_size() const {
  return tasks_.size();
}
inline void TaskGroupInfo::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::TaskInfo& TaskGroupInfo::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskGroupInfo.tasks)
  return tasks_.Get(index);
}
inline ::mesos::TaskInfo* TaskGroupInfo::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskGroupInfo.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::TaskInfo* TaskGroupInfo::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.TaskGroupInfo.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
TaskGroupInfo::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.TaskGroupInfo.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
TaskGroupInfo::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskGroupInfo.tasks)
  return &tasks_;
}

// -------------------------------------------------------------------

// Task

// required string name = 1;
inline bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:mesos.Task.name)
  return *name_;
}
inline void Task::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Task.name)
}
inline void Task::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Task.name)
}
inline void Task::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.name)
}
inline ::std::string* Task::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.name)
  return name_;
}
inline ::std::string* Task::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.name)
}

// required .mesos.TaskID task_id = 2;
inline bool Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Task::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Task::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.Task.task_id)
  return task_id_;
}
inline ::mesos::TaskID* Task::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.task_id)
}

// required .mesos.FrameworkID framework_id = 3;
inline bool Task::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Task::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Task::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.Task.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* Task::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.framework_id)
}

// optional .mesos.ExecutorID executor_id = 4;
inline bool Task::has_executor_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_executor_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Task::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Task::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.Task.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* Task::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.executor_id)
}

// required .mesos.SlaveID slave_id = 5;
inline bool Task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Task::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.Task.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Task::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Task::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.slave_id)
}

// required .mesos.TaskState state = 6;
inline bool Task::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Task::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Task::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Task::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState Task::state() const {
  // @@protoc_insertion_point(field_get:mesos.Task.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void Task::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.Task.state)
}

// repeated .mesos.Resource resources = 7;
inline int Task::resources_size() const {
  return resources_.size();
}
inline void Task::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Task::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Task.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Task::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Task.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Task::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Task.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Task::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Task.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Task::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Task.resources)
  return &resources_;
}

// repeated .mesos.TaskStatus statuses = 8;
inline int Task::statuses_size() const {
  return statuses_.size();
}
inline void Task::clear_statuses() {
  statuses_.Clear();
}
inline const ::mesos::TaskStatus& Task::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Task.statuses)
  return statuses_.Get(index);
}
inline ::mesos::TaskStatus* Task::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Task.statuses)
  return statuses_.Mutable(index);
}
inline ::mesos::TaskStatus* Task::add_statuses() {
  // @@protoc_insertion_point(field_add:mesos.Task.statuses)
  return statuses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
Task::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.Task.statuses)
  return statuses_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
Task::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Task.statuses)
  return &statuses_;
}

// optional .mesos.TaskState status_update_state = 9;
inline bool Task::has_status_update_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Task::set_has_status_update_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Task::clear_has_status_update_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Task::clear_status_update_state() {
  status_update_state_ = 6;
  clear_has_status_update_state();
}
inline ::mesos::TaskState Task::status_update_state() const {
  // @@protoc_insertion_point(field_get:mesos.Task.status_update_state)
  return static_cast< ::mesos::TaskState >(status_update_state_);
}
inline void Task::set_status_update_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_status_update_state();
  status_update_state_ = value;
  // @@protoc_insertion_point(field_set:mesos.Task.status_update_state)
}

// optional bytes status_update_uuid = 10;
inline bool Task::has_status_update_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Task::set_has_status_update_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Task::clear_has_status_update_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Task::clear_status_update_uuid() {
  if (status_update_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_update_uuid_->clear();
  }
  clear_has_status_update_uuid();
}
inline const ::std::string& Task::status_update_uuid() const {
  // @@protoc_insertion_point(field_get:mesos.Task.status_update_uuid)
  return *status_update_uuid_;
}
inline void Task::set_status_update_uuid(const ::std::string& value) {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_update_uuid_ = new ::std::string;
  }
  status_update_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Task.status_update_uuid)
}
inline void Task::set_status_update_uuid(const char* value) {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_update_uuid_ = new ::std::string;
  }
  status_update_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Task.status_update_uuid)
}
inline void Task::set_status_update_uuid(const void* value, size_t size) {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_update_uuid_ = new ::std::string;
  }
  status_update_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.status_update_uuid)
}
inline ::std::string* Task::mutable_status_update_uuid() {
  set_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_update_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.status_update_uuid)
  return status_update_uuid_;
}
inline ::std::string* Task::release_status_update_uuid() {
  clear_has_status_update_uuid();
  if (status_update_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = status_update_uuid_;
    status_update_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_status_update_uuid(::std::string* status_update_uuid) {
  if (status_update_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_update_uuid_;
  }
  if (status_update_uuid) {
    set_has_status_update_uuid();
    status_update_uuid_ = status_update_uuid;
  } else {
    clear_has_status_update_uuid();
    status_update_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.status_update_uuid)
}

// optional .mesos.Labels labels = 11;
inline bool Task::has_labels() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Task::set_has_labels() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Task::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Task::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Task.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.Task.labels)
  return labels_;
}
inline ::mesos::Labels* Task::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void Task::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.labels)
}

// optional .mesos.DiscoveryInfo discovery = 12;
inline bool Task::has_discovery() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Task::set_has_discovery() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Task::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Task::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
inline const ::mesos::DiscoveryInfo& Task::discovery() const {
  // @@protoc_insertion_point(field_get:mesos.Task.discovery)
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
inline ::mesos::DiscoveryInfo* Task::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) discovery_ = new ::mesos::DiscoveryInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Task.discovery)
  return discovery_;
}
inline ::mesos::DiscoveryInfo* Task::release_discovery() {
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
inline void Task::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.discovery)
}

// optional .mesos.ContainerInfo container = 13;
inline bool Task::has_container() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Task::set_has_container() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Task::clear_has_container() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Task::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::ContainerInfo& Task::container() const {
  // @@protoc_insertion_point(field_get:mesos.Task.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::ContainerInfo* Task::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::ContainerInfo;
  // @@protoc_insertion_point(field_mutable:mesos.Task.container)
  return container_;
}
inline ::mesos::ContainerInfo* Task::release_container() {
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void Task::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.container)
}

// optional string user = 14;
inline bool Task::has_user() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Task::set_has_user() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Task::clear_has_user() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Task::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Task::user() const {
  // @@protoc_insertion_point(field_get:mesos.Task.user)
  return *user_;
}
inline void Task::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Task.user)
}
inline void Task::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Task.user)
}
inline void Task::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.user)
}
inline ::std::string* Task::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.user)
  return user_;
}
inline ::std::string* Task::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.user)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Command

// optional int32 exit_code = 1;
inline bool CheckStatusInfo_Command::has_exit_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo_Command::set_has_exit_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo_Command::clear_has_exit_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo_Command::clear_exit_code() {
  exit_code_ = 0;
  clear_has_exit_code();
}
inline ::google::protobuf::int32 CheckStatusInfo_Command::exit_code() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Command.exit_code)
  return exit_code_;
}
inline void CheckStatusInfo_Command::set_exit_code(::google::protobuf::int32 value) {
  set_has_exit_code();
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Command.exit_code)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Http

// optional uint32 status_code = 1;
inline bool CheckStatusInfo_Http::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo_Http::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo_Http::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo_Http::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 CheckStatusInfo_Http::status_code() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Http.status_code)
  return status_code_;
}
inline void CheckStatusInfo_Http::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Http.status_code)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Tcp

// optional bool succeeded = 1;
inline bool CheckStatusInfo_Tcp::has_succeeded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo_Tcp::set_has_succeeded() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo_Tcp::clear_has_succeeded() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo_Tcp::clear_succeeded() {
  succeeded_ = false;
  clear_has_succeeded();
}
inline bool CheckStatusInfo_Tcp::succeeded() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Tcp.succeeded)
  return succeeded_;
}
inline void CheckStatusInfo_Tcp::set_succeeded(bool value) {
  set_has_succeeded();
  succeeded_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Tcp.succeeded)
}

// -------------------------------------------------------------------

// CheckStatusInfo

// optional .mesos.CheckInfo.Type type = 1;
inline bool CheckStatusInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckStatusInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckStatusInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckStatusInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::CheckInfo_Type CheckStatusInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.type)
  return static_cast< ::mesos::CheckInfo_Type >(type_);
}
inline void CheckStatusInfo::set_type(::mesos::CheckInfo_Type value) {
  assert(::mesos::CheckInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.type)
}

// optional .mesos.CheckStatusInfo.Command command = 2;
inline bool CheckStatusInfo::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckStatusInfo::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckStatusInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckStatusInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CheckStatusInfo_Command::Clear();
  clear_has_command();
}
inline const ::mesos::CheckStatusInfo_Command& CheckStatusInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CheckStatusInfo_Command* CheckStatusInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CheckStatusInfo_Command;
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.command)
  return command_;
}
inline ::mesos::CheckStatusInfo_Command* CheckStatusInfo::release_command() {
  clear_has_command();
  ::mesos::CheckStatusInfo_Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void CheckStatusInfo::set_allocated_command(::mesos::CheckStatusInfo_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.command)
}

// optional .mesos.CheckStatusInfo.Http http = 3;
inline bool CheckStatusInfo::has_http() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckStatusInfo::set_has_http() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckStatusInfo::clear_has_http() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckStatusInfo::clear_http() {
  if (http_ != NULL) http_->::mesos::CheckStatusInfo_Http::Clear();
  clear_has_http();
}
inline const ::mesos::CheckStatusInfo_Http& CheckStatusInfo::http() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.http)
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
inline ::mesos::CheckStatusInfo_Http* CheckStatusInfo::mutable_http() {
  set_has_http();
  if (http_ == NULL) http_ = new ::mesos::CheckStatusInfo_Http;
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.http)
  return http_;
}
inline ::mesos::CheckStatusInfo_Http* CheckStatusInfo::release_http() {
  clear_has_http();
  ::mesos::CheckStatusInfo_Http* temp = http_;
  http_ = NULL;
  return temp;
}
inline void CheckStatusInfo::set_allocated_http(::mesos::CheckStatusInfo_Http* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.http)
}

// optional .mesos.CheckStatusInfo.Tcp tcp = 4;
inline bool CheckStatusInfo::has_tcp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckStatusInfo::set_has_tcp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckStatusInfo::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckStatusInfo::clear_tcp() {
  if (tcp_ != NULL) tcp_->::mesos::CheckStatusInfo_Tcp::Clear();
  clear_has_tcp();
}
inline const ::mesos::CheckStatusInfo_Tcp& CheckStatusInfo::tcp() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.tcp)
  return tcp_ != NULL ? *tcp_ : *default_instance_->tcp_;
}
inline ::mesos::CheckStatusInfo_Tcp* CheckStatusInfo::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) tcp_ = new ::mesos::CheckStatusInfo_Tcp;
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.tcp)
  return tcp_;
}
inline ::mesos::CheckStatusInfo_Tcp* CheckStatusInfo::release_tcp() {
  clear_has_tcp();
  ::mesos::CheckStatusInfo_Tcp* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
inline void CheckStatusInfo::set_allocated_tcp(::mesos::CheckStatusInfo_Tcp* tcp) {
  delete tcp_;
  tcp_ = tcp;
  if (tcp) {
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.tcp)
}

// -------------------------------------------------------------------

// TaskStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskStatus::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.task_id)
  return task_id_;
}
inline ::mesos::TaskID* TaskStatus::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.task_id)
}

// required .mesos.TaskState state = 2;
inline bool TaskStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskStatus::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState TaskStatus::state() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.state)
  return static_cast< ::mesos::TaskState >(state_);
}
inline void TaskStatus::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.state)
}

// optional string message = 4;
inline bool TaskStatus::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskStatus::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskStatus::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& TaskStatus::message() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.message)
  return *message_;
}
inline void TaskStatus::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.message)
}
inline void TaskStatus::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.message)
}
inline void TaskStatus::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.message)
}
inline ::std::string* TaskStatus::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.message)
  return message_;
}
inline ::std::string* TaskStatus::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskStatus::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.message)
}

// optional .mesos.TaskStatus.Source source = 9;
inline bool TaskStatus::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskStatus::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskStatus::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::mesos::TaskStatus_Source TaskStatus::source() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.source)
  return static_cast< ::mesos::TaskStatus_Source >(source_);
}
inline void TaskStatus::set_source(::mesos::TaskStatus_Source value) {
  assert(::mesos::TaskStatus_Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.source)
}

// optional .mesos.TaskStatus.Reason reason = 10;
inline bool TaskStatus::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskStatus::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskStatus::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskStatus::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::mesos::TaskStatus_Reason TaskStatus::reason() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
inline void TaskStatus::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.reason)
}

// optional bytes data = 3;
inline bool TaskStatus::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskStatus::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskStatus::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskStatus::data() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.data)
  return *data_;
}
inline void TaskStatus::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.data)
}
inline void TaskStatus::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.data)
}
inline void TaskStatus::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.data)
}
inline ::std::string* TaskStatus::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.data)
  return data_;
}
inline ::std::string* TaskStatus::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskStatus::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.data)
}

// optional .mesos.SlaveID slave_id = 5;
inline bool TaskStatus::has_slave_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskStatus::set_has_slave_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskStatus::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskStatus::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskStatus::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskStatus::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* TaskStatus::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.slave_id)
}

// optional .mesos.ExecutorID executor_id = 7;
inline bool TaskStatus::has_executor_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskStatus::set_has_executor_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskStatus::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskStatus::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& TaskStatus::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* TaskStatus::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* TaskStatus::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.executor_id)
}

// optional double timestamp = 6;
inline bool TaskStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TaskStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.timestamp)
  return timestamp_;
}
inline void TaskStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.timestamp)
}

// optional bytes uuid = 11;
inline bool TaskStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskStatus::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& TaskStatus::uuid() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.uuid)
  return *uuid_;
}
inline void TaskStatus::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.uuid)
}
inline void TaskStatus::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.uuid)
}
inline void TaskStatus::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.uuid)
}
inline ::std::string* TaskStatus::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.uuid)
  return uuid_;
}
inline ::std::string* TaskStatus::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskStatus::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.uuid)
}

// optional bool healthy = 8;
inline bool TaskStatus::has_healthy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskStatus::set_has_healthy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskStatus::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskStatus::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
inline bool TaskStatus::healthy() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.healthy)
  return healthy_;
}
inline void TaskStatus::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.healthy)
}

// optional .mesos.CheckStatusInfo check_status = 15;
inline bool TaskStatus::has_check_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskStatus::set_has_check_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskStatus::clear_has_check_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskStatus::clear_check_status() {
  if (check_status_ != NULL) check_status_->::mesos::CheckStatusInfo::Clear();
  clear_has_check_status();
}
inline const ::mesos::CheckStatusInfo& TaskStatus::check_status() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.check_status)
  return check_status_ != NULL ? *check_status_ : *default_instance_->check_status_;
}
inline ::mesos::CheckStatusInfo* TaskStatus::mutable_check_status() {
  set_has_check_status();
  if (check_status_ == NULL) check_status_ = new ::mesos::CheckStatusInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.check_status)
  return check_status_;
}
inline ::mesos::CheckStatusInfo* TaskStatus::release_check_status() {
  clear_has_check_status();
  ::mesos::CheckStatusInfo* temp = check_status_;
  check_status_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_check_status(::mesos::CheckStatusInfo* check_status) {
  delete check_status_;
  check_status_ = check_status;
  if (check_status) {
    set_has_check_status();
  } else {
    clear_has_check_status();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.check_status)
}

// optional .mesos.Labels labels = 12;
inline bool TaskStatus::has_labels() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TaskStatus::set_has_labels() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TaskStatus::clear_has_labels() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TaskStatus::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& TaskStatus::labels() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* TaskStatus::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.labels)
  return labels_;
}
inline ::mesos::Labels* TaskStatus::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.labels)
}

// optional .mesos.ContainerStatus container_status = 13;
inline bool TaskStatus::has_container_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TaskStatus::set_has_container_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TaskStatus::clear_has_container_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TaskStatus::clear_container_status() {
  if (container_status_ != NULL) container_status_->::mesos::ContainerStatus::Clear();
  clear_has_container_status();
}
inline const ::mesos::ContainerStatus& TaskStatus::container_status() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.container_status)
  return container_status_ != NULL ? *container_status_ : *default_instance_->container_status_;
}
inline ::mesos::ContainerStatus* TaskStatus::mutable_container_status() {
  set_has_container_status();
  if (container_status_ == NULL) container_status_ = new ::mesos::ContainerStatus;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.container_status)
  return container_status_;
}
inline ::mesos::ContainerStatus* TaskStatus::release_container_status() {
  clear_has_container_status();
  ::mesos::ContainerStatus* temp = container_status_;
  container_status_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_container_status(::mesos::ContainerStatus* container_status) {
  delete container_status_;
  container_status_ = container_status;
  if (container_status) {
    set_has_container_status();
  } else {
    clear_has_container_status();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.container_status)
}

// optional .mesos.TimeInfo unreachable_time = 14;
inline bool TaskStatus::has_unreachable_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TaskStatus::set_has_unreachable_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TaskStatus::clear_has_unreachable_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TaskStatus::clear_unreachable_time() {
  if (unreachable_time_ != NULL) unreachable_time_->::mesos::TimeInfo::Clear();
  clear_has_unreachable_time();
}
inline const ::mesos::TimeInfo& TaskStatus::unreachable_time() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.unreachable_time)
  return unreachable_time_ != NULL ? *unreachable_time_ : *default_instance_->unreachable_time_;
}
inline ::mesos::TimeInfo* TaskStatus::mutable_unreachable_time() {
  set_has_unreachable_time();
  if (unreachable_time_ == NULL) unreachable_time_ = new ::mesos::TimeInfo;
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.unreachable_time)
  return unreachable_time_;
}
inline ::mesos::TimeInfo* TaskStatus::release_unreachable_time() {
  clear_has_unreachable_time();
  ::mesos::TimeInfo* temp = unreachable_time_;
  unreachable_time_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_unreachable_time(::mesos::TimeInfo* unreachable_time) {
  delete unreachable_time_;
  unreachable_time_ = unreachable_time;
  if (unreachable_time) {
    set_has_unreachable_time();
  } else {
    clear_has_unreachable_time();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.unreachable_time)
}

// -------------------------------------------------------------------

// Filters

// optional double refuse_seconds = 1 [default = 5];
inline bool Filters::has_refuse_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filters::set_has_refuse_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filters::clear_has_refuse_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 5;
  clear_has_refuse_seconds();
}
inline double Filters::refuse_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.Filters.refuse_seconds)
  return refuse_seconds_;
}
inline void Filters::set_refuse_seconds(double value) {
  set_has_refuse_seconds();
  refuse_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.Filters.refuse_seconds)
}

// -------------------------------------------------------------------

// Environment_Variable

// required string name = 1;
inline bool Environment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Variable::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Environment_Variable::name() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.name)
  return *name_;
}
inline void Environment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.name)
}
inline void Environment_Variable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Environment.Variable.name)
}
inline void Environment_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Environment.Variable.name)
}
inline ::std::string* Environment_Variable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.name)
  return name_;
}
inline ::std::string* Environment_Variable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Environment_Variable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.name)
}

// optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
inline bool Environment_Variable::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Variable::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Variable::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Variable::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::Environment_Variable_Type Environment_Variable::type() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.type)
  return static_cast< ::mesos::Environment_Variable_Type >(type_);
}
inline void Environment_Variable::set_type(::mesos::Environment_Variable_Type value) {
  assert(::mesos::Environment_Variable_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.type)
}

// optional string value = 2;
inline bool Environment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Environment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Environment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Environment_Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Environment_Variable::value() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.value)
  return *value_;
}
inline void Environment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.value)
}
inline void Environment_Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Environment.Variable.value)
}
inline void Environment_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Environment.Variable.value)
}
inline ::std::string* Environment_Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.value)
  return value_;
}
inline ::std::string* Environment_Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Environment_Variable::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.value)
}

// optional .mesos.Secret secret = 4;
inline bool Environment_Variable::has_secret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Environment_Variable::set_has_secret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Environment_Variable::clear_has_secret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Environment_Variable::clear_secret() {
  if (secret_ != NULL) secret_->::mesos::Secret::Clear();
  clear_has_secret();
}
inline const ::mesos::Secret& Environment_Variable::secret() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.secret)
  return secret_ != NULL ? *secret_ : *default_instance_->secret_;
}
inline ::mesos::Secret* Environment_Variable::mutable_secret() {
  set_has_secret();
  if (secret_ == NULL) secret_ = new ::mesos::Secret;
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.secret)
  return secret_;
}
inline ::mesos::Secret* Environment_Variable::release_secret() {
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  secret_ = NULL;
  return temp;
}
inline void Environment_Variable::set_allocated_secret(::mesos::Secret* secret) {
  delete secret_;
  secret_ = secret;
  if (secret) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.secret)
}

// -------------------------------------------------------------------

// Environment

// repeated .mesos.Environment.Variable variables = 1;
inline int Environment::variables_size() const {
  return variables_.size();
}
inline void Environment::clear_variables() {
  variables_.Clear();
}
inline const ::mesos::Environment_Variable& Environment::variables(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Environment.variables)
  return variables_.Get(index);
}
inline ::mesos::Environment_Variable* Environment::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Environment.variables)
  return variables_.Mutable(index);
}
inline ::mesos::Environment_Variable* Environment::add_variables() {
  // @@protoc_insertion_point(field_add:mesos.Environment.variables)
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
Environment::variables() const {
  // @@protoc_insertion_point(field_list:mesos.Environment.variables)
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
Environment::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Environment.variables)
  return &variables_;
}

// -------------------------------------------------------------------

// Parameter

// required string key = 1;
inline bool Parameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Parameter::key() const {
  // @@protoc_insertion_point(field_get:mesos.Parameter.key)
  return *key_;
}
inline void Parameter::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Parameter.key)
}
inline void Parameter::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Parameter.key)
}
inline void Parameter::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Parameter.key)
}
inline ::std::string* Parameter::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Parameter.key)
  return key_;
}
inline ::std::string* Parameter::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Parameter::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Parameter.key)
}

// required string value = 2;
inline bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Parameter::value() const {
  // @@protoc_insertion_point(field_get:mesos.Parameter.value)
  return *value_;
}
inline void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Parameter.value)
}
inline void Parameter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Parameter.value)
}
inline void Parameter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Parameter.value)
}
inline ::std::string* Parameter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Parameter.value)
  return value_;
}
inline ::std::string* Parameter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Parameter::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Parameter.value)
}

// -------------------------------------------------------------------

// Parameters

// repeated .mesos.Parameter parameter = 1;
inline int Parameters::parameter_size() const {
  return parameter_.size();
}
inline void Parameters::clear_parameter() {
  parameter_.Clear();
}
inline const ::mesos::Parameter& Parameters::parameter(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Parameters.parameter)
  return parameter_.Get(index);
}
inline ::mesos::Parameter* Parameters::mutable_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Parameters.parameter)
  return parameter_.Mutable(index);
}
inline ::mesos::Parameter* Parameters::add_parameter() {
  // @@protoc_insertion_point(field_add:mesos.Parameters.parameter)
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
Parameters::parameter() const {
  // @@protoc_insertion_point(field_list:mesos.Parameters.parameter)
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
Parameters::mutable_parameter() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Parameters.parameter)
  return &parameter_;
}

// -------------------------------------------------------------------

// Credential

// required string principal = 1;
inline bool Credential::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Credential::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Credential::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Credential::clear_principal() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& Credential::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Credential.principal)
  return *principal_;
}
inline void Credential::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Credential.principal)
}
inline void Credential::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Credential.principal)
}
inline void Credential::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Credential.principal)
}
inline ::std::string* Credential::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Credential.principal)
  return principal_;
}
inline ::std::string* Credential::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Credential::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Credential.principal)
}

// optional string secret = 2;
inline bool Credential::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Credential::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Credential::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Credential::clear_secret() {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& Credential::secret() const {
  // @@protoc_insertion_point(field_get:mesos.Credential.secret)
  return *secret_;
}
inline void Credential::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Credential.secret)
}
inline void Credential::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Credential.secret)
}
inline void Credential::set_secret(const char* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Credential.secret)
}
inline ::std::string* Credential::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Credential.secret)
  return secret_;
}
inline ::std::string* Credential::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Credential::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Credential.secret)
}

// -------------------------------------------------------------------

// Credentials

// repeated .mesos.Credential credentials = 1;
inline int Credentials::credentials_size() const {
  return credentials_.size();
}
inline void Credentials::clear_credentials() {
  credentials_.Clear();
}
inline const ::mesos::Credential& Credentials::credentials(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Credentials.credentials)
  return credentials_.Get(index);
}
inline ::mesos::Credential* Credentials::mutable_credentials(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Credentials.credentials)
  return credentials_.Mutable(index);
}
inline ::mesos::Credential* Credentials::add_credentials() {
  // @@protoc_insertion_point(field_add:mesos.Credentials.credentials)
  return credentials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
Credentials::credentials() const {
  // @@protoc_insertion_point(field_list:mesos.Credentials.credentials)
  return credentials_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
Credentials::mutable_credentials() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Credentials.credentials)
  return &credentials_;
}

// -------------------------------------------------------------------

// Secret_Reference

// required string name = 1;
inline bool Secret_Reference::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret_Reference::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret_Reference::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret_Reference::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Secret_Reference::name() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Reference.name)
  return *name_;
}
inline void Secret_Reference::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Secret.Reference.name)
}
inline void Secret_Reference::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Reference.name)
}
inline void Secret_Reference::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Reference.name)
}
inline ::std::string* Secret_Reference::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Reference.name)
  return name_;
}
inline ::std::string* Secret_Reference::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Secret_Reference::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Reference.name)
}

// optional string key = 2;
inline bool Secret_Reference::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret_Reference::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret_Reference::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret_Reference::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Secret_Reference::key() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Reference.key)
  return *key_;
}
inline void Secret_Reference::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Secret.Reference.key)
}
inline void Secret_Reference::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Reference.key)
}
inline void Secret_Reference::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Reference.key)
}
inline ::std::string* Secret_Reference::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Reference.key)
  return key_;
}
inline ::std::string* Secret_Reference::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Secret_Reference::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Reference.key)
}

// -------------------------------------------------------------------

// Secret_Value

// required bytes data = 1;
inline bool Secret_Value::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret_Value::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret_Value::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret_Value::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Secret_Value::data() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Value.data)
  return *data_;
}
inline void Secret_Value::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Secret.Value.data)
}
inline void Secret_Value::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Value.data)
}
inline void Secret_Value::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Value.data)
}
inline ::std::string* Secret_Value::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Value.data)
  return data_;
}
inline ::std::string* Secret_Value::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Secret_Value::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Value.data)
}

// -------------------------------------------------------------------

// Secret

// optional .mesos.Secret.Type type = 1;
inline bool Secret::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Secret_Type Secret::type() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.type)
  return static_cast< ::mesos::Secret_Type >(type_);
}
inline void Secret::set_type(::mesos::Secret_Type value) {
  assert(::mesos::Secret_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Secret.type)
}

// optional .mesos.Secret.Reference reference = 2;
inline bool Secret::has_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_reference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_reference() {
  if (reference_ != NULL) reference_->::mesos::Secret_Reference::Clear();
  clear_has_reference();
}
inline const ::mesos::Secret_Reference& Secret::reference() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.reference)
  return reference_ != NULL ? *reference_ : *default_instance_->reference_;
}
inline ::mesos::Secret_Reference* Secret::mutable_reference() {
  set_has_reference();
  if (reference_ == NULL) reference_ = new ::mesos::Secret_Reference;
  // @@protoc_insertion_point(field_mutable:mesos.Secret.reference)
  return reference_;
}
inline ::mesos::Secret_Reference* Secret::release_reference() {
  clear_has_reference();
  ::mesos::Secret_Reference* temp = reference_;
  reference_ = NULL;
  return temp;
}
inline void Secret::set_allocated_reference(::mesos::Secret_Reference* reference) {
  delete reference_;
  reference_ = reference;
  if (reference) {
    set_has_reference();
  } else {
    clear_has_reference();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.reference)
}

// optional .mesos.Secret.Value value = 3;
inline bool Secret::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret::clear_value() {
  if (value_ != NULL) value_->::mesos::Secret_Value::Clear();
  clear_has_value();
}
inline const ::mesos::Secret_Value& Secret::value() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::mesos::Secret_Value* Secret::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::mesos::Secret_Value;
  // @@protoc_insertion_point(field_mutable:mesos.Secret.value)
  return value_;
}
inline ::mesos::Secret_Value* Secret::release_value() {
  clear_has_value();
  ::mesos::Secret_Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Secret::set_allocated_value(::mesos::Secret_Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.value)
}

// -------------------------------------------------------------------

// RateLimit

// optional double qps = 1;
inline bool RateLimit::has_qps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RateLimit::set_has_qps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RateLimit::clear_has_qps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RateLimit::clear_qps() {
  qps_ = 0;
  clear_has_qps();
}
inline double RateLimit::qps() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.qps)
  return qps_;
}
inline void RateLimit::set_qps(double value) {
  set_has_qps();
  qps_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimit.qps)
}

// required string principal = 2;
inline bool RateLimit::has_principal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimit::set_has_principal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateLimit::clear_has_principal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateLimit::clear_principal() {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& RateLimit::principal() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.principal)
  return *principal_;
}
inline void RateLimit::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.RateLimit.principal)
}
inline void RateLimit::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.RateLimit.principal)
}
inline void RateLimit::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.RateLimit.principal)
}
inline ::std::string* RateLimit::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.RateLimit.principal)
  return principal_;
}
inline ::std::string* RateLimit::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RateLimit::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.RateLimit.principal)
}

// optional uint64 capacity = 3;
inline bool RateLimit::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RateLimit::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RateLimit::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RateLimit::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 RateLimit::capacity() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.capacity)
  return capacity_;
}
inline void RateLimit::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimit.capacity)
}

// -------------------------------------------------------------------

// RateLimits

// repeated .mesos.RateLimit limits = 1;
inline int RateLimits::limits_size() const {
  return limits_.size();
}
inline void RateLimits::clear_limits() {
  limits_.Clear();
}
inline const ::mesos::RateLimit& RateLimits::limits(int index) const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.limits)
  return limits_.Get(index);
}
inline ::mesos::RateLimit* RateLimits::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.RateLimits.limits)
  return limits_.Mutable(index);
}
inline ::mesos::RateLimit* RateLimits::add_limits() {
  // @@protoc_insertion_point(field_add:mesos.RateLimits.limits)
  return limits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
RateLimits::limits() const {
  // @@protoc_insertion_point(field_list:mesos.RateLimits.limits)
  return limits_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
RateLimits::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:mesos.RateLimits.limits)
  return &limits_;
}

// optional double aggregate_default_qps = 2;
inline bool RateLimits::has_aggregate_default_qps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateLimits::set_has_aggregate_default_qps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateLimits::clear_has_aggregate_default_qps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateLimits::clear_aggregate_default_qps() {
  aggregate_default_qps_ = 0;
  clear_has_aggregate_default_qps();
}
inline double RateLimits::aggregate_default_qps() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.aggregate_default_qps)
  return aggregate_default_qps_;
}
inline void RateLimits::set_aggregate_default_qps(double value) {
  set_has_aggregate_default_qps();
  aggregate_default_qps_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimits.aggregate_default_qps)
}

// optional uint64 aggregate_default_capacity = 3;
inline bool RateLimits::has_aggregate_default_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RateLimits::set_has_aggregate_default_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RateLimits::clear_has_aggregate_default_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RateLimits::clear_aggregate_default_capacity() {
  aggregate_default_capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_aggregate_default_capacity();
}
inline ::google::protobuf::uint64 RateLimits::aggregate_default_capacity() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.aggregate_default_capacity)
  return aggregate_default_capacity_;
}
inline void RateLimits::set_aggregate_default_capacity(::google::protobuf::uint64 value) {
  set_has_aggregate_default_capacity();
  aggregate_default_capacity_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimits.aggregate_default_capacity)
}

// -------------------------------------------------------------------

// Image_Appc

// required string name = 1;
inline bool Image_Appc::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image_Appc::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image_Appc::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image_Appc::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Image_Appc::name() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.name)
  return *name_;
}
inline void Image_Appc::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Image.Appc.name)
}
inline void Image_Appc::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Image.Appc.name)
}
inline void Image_Appc::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Appc.name)
}
inline ::std::string* Image_Appc::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.name)
  return name_;
}
inline ::std::string* Image_Appc::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Image_Appc::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.name)
}

// optional string id = 2;
inline bool Image_Appc::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image_Appc::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image_Appc::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image_Appc::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Image_Appc::id() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.id)
  return *id_;
}
inline void Image_Appc::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Image.Appc.id)
}
inline void Image_Appc::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Image.Appc.id)
}
inline void Image_Appc::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Appc.id)
}
inline ::std::string* Image_Appc::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.id)
  return id_;
}
inline ::std::string* Image_Appc::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Image_Appc::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.id)
}

// optional .mesos.Labels labels = 3;
inline bool Image_Appc::has_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image_Appc::set_has_labels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image_Appc::clear_has_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image_Appc::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Image_Appc::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* Image_Appc::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.labels)
  return labels_;
}
inline ::mesos::Labels* Image_Appc::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void Image_Appc::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.labels)
}

// -------------------------------------------------------------------

// Image_Docker

// required string name = 1;
inline bool Image_Docker::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image_Docker::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image_Docker::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image_Docker::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Image_Docker::name() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.name)
  return *name_;
}
inline void Image_Docker::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Image.Docker.name)
}
inline void Image_Docker::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Image.Docker.name)
}
inline void Image_Docker::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Docker.name)
}
inline ::std::string* Image_Docker::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.name)
  return name_;
}
inline ::std::string* Image_Docker::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Image_Docker::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.name)
}

// optional .mesos.Credential credential = 2 [deprecated = true];
inline bool Image_Docker::has_credential() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image_Docker::set_has_credential() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image_Docker::clear_has_credential() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image_Docker::clear_credential() {
  if (credential_ != NULL) credential_->::mesos::Credential::Clear();
  clear_has_credential();
}
inline const ::mesos::Credential& Image_Docker::credential() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.credential)
  return credential_ != NULL ? *credential_ : *default_instance_->credential_;
}
inline ::mesos::Credential* Image_Docker::mutable_credential() {
  set_has_credential();
  if (credential_ == NULL) credential_ = new ::mesos::Credential;
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.credential)
  return credential_;
}
inline ::mesos::Credential* Image_Docker::release_credential() {
  clear_has_credential();
  ::mesos::Credential* temp = credential_;
  credential_ = NULL;
  return temp;
}
inline void Image_Docker::set_allocated_credential(::mesos::Credential* credential) {
  delete credential_;
  credential_ = credential;
  if (credential) {
    set_has_credential();
  } else {
    clear_has_credential();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.credential)
}

// optional .mesos.Secret config = 3;
inline bool Image_Docker::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image_Docker::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image_Docker::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image_Docker::clear_config() {
  if (config_ != NULL) config_->::mesos::Secret::Clear();
  clear_has_config();
}
inline const ::mesos::Secret& Image_Docker::config() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::mesos::Secret* Image_Docker::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::mesos::Secret;
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.config)
  return config_;
}
inline ::mesos::Secret* Image_Docker::release_config() {
  clear_has_config();
  ::mesos::Secret* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Image_Docker::set_allocated_config(::mesos::Secret* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.config)
}

// -------------------------------------------------------------------

// Image

// required .mesos.Image.Type type = 1;
inline bool Image::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::Image_Type Image::type() const {
  // @@protoc_insertion_point(field_get:mesos.Image.type)
  return static_cast< ::mesos::Image_Type >(type_);
}
inline void Image::set_type(::mesos::Image_Type value) {
  assert(::mesos::Image_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Image.type)
}

// optional .mesos.Image.Appc appc = 2;
inline bool Image::has_appc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_appc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_appc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_appc() {
  if (appc_ != NULL) appc_->::mesos::Image_Appc::Clear();
  clear_has_appc();
}
inline const ::mesos::Image_Appc& Image::appc() const {
  // @@protoc_insertion_point(field_get:mesos.Image.appc)
  return appc_ != NULL ? *appc_ : *default_instance_->appc_;
}
inline ::mesos::Image_Appc* Image::mutable_appc() {
  set_has_appc();
  if (appc_ == NULL) appc_ = new ::mesos::Image_Appc;
  // @@protoc_insertion_point(field_mutable:mesos.Image.appc)
  return appc_;
}
inline ::mesos::Image_Appc* Image::release_appc() {
  clear_has_appc();
  ::mesos::Image_Appc* temp = appc_;
  appc_ = NULL;
  return temp;
}
inline void Image::set_allocated_appc(::mesos::Image_Appc* appc) {
  delete appc_;
  appc_ = appc;
  if (appc) {
    set_has_appc();
  } else {
    clear_has_appc();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.appc)
}

// optional .mesos.Image.Docker docker = 3;
inline bool Image::has_docker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_docker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_docker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_docker() {
  if (docker_ != NULL) docker_->::mesos::Image_Docker::Clear();
  clear_has_docker();
}
inline const ::mesos::Image_Docker& Image::docker() const {
  // @@protoc_insertion_point(field_get:mesos.Image.docker)
  return docker_ != NULL ? *docker_ : *default_instance_->docker_;
}
inline ::mesos::Image_Docker* Image::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) docker_ = new ::mesos::Image_Docker;
  // @@protoc_insertion_point(field_mutable:mesos.Image.docker)
  return docker_;
}
inline ::mesos::Image_Docker* Image::release_docker() {
  clear_has_docker();
  ::mesos::Image_Docker* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline void Image::set_allocated_docker(::mesos::Image_Docker* docker) {
  delete docker_;
  docker_ = docker;
  if (docker) {
    set_has_docker();
  } else {
    clear_has_docker();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.docker)
}

// optional bool cached = 4 [default = true];
inline bool Image::has_cached() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_cached() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_cached() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_cached() {
  cached_ = true;
  clear_has_cached();
}
inline bool Image::cached() const {
  // @@protoc_insertion_point(field_get:mesos.Image.cached)
  return cached_;
}
inline void Image::set_cached(bool value) {
  set_has_cached();
  cached_ = value;
  // @@protoc_insertion_point(field_set:mesos.Image.cached)
}

// -------------------------------------------------------------------

// Volume_Source_DockerVolume

// optional string driver = 1;
inline bool Volume_Source_DockerVolume::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source_DockerVolume::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source_DockerVolume::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source_DockerVolume::clear_driver() {
  if (driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driver_->clear();
  }
  clear_has_driver();
}
inline const ::std::string& Volume_Source_DockerVolume::driver() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.driver)
  return *driver_;
}
inline void Volume_Source_DockerVolume::set_driver(const ::std::string& value) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driver_ = new ::std::string;
  }
  driver_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.DockerVolume.driver)
}
inline void Volume_Source_DockerVolume::set_driver(const char* value) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driver_ = new ::std::string;
  }
  driver_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.DockerVolume.driver)
}
inline void Volume_Source_DockerVolume::set_driver(const char* value, size_t size) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driver_ = new ::std::string;
  }
  driver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.DockerVolume.driver)
}
inline ::std::string* Volume_Source_DockerVolume::mutable_driver() {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    driver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.driver)
  return driver_;
}
inline ::std::string* Volume_Source_DockerVolume::release_driver() {
  clear_has_driver();
  if (driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = driver_;
    driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Volume_Source_DockerVolume::set_allocated_driver(::std::string* driver) {
  if (driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete driver_;
  }
  if (driver) {
    set_has_driver();
    driver_ = driver;
  } else {
    clear_has_driver();
    driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.driver)
}

// required string name = 2;
inline bool Volume_Source_DockerVolume::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source_DockerVolume::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source_DockerVolume::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source_DockerVolume::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Volume_Source_DockerVolume::name() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.name)
  return *name_;
}
inline void Volume_Source_DockerVolume::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.DockerVolume.name)
}
inline void Volume_Source_DockerVolume::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.DockerVolume.name)
}
inline void Volume_Source_DockerVolume::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.DockerVolume.name)
}
inline ::std::string* Volume_Source_DockerVolume::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.name)
  return name_;
}
inline ::std::string* Volume_Source_DockerVolume::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Volume_Source_DockerVolume::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.name)
}

// optional .mesos.Parameters driver_options = 3;
inline bool Volume_Source_DockerVolume::has_driver_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume_Source_DockerVolume::set_has_driver_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume_Source_DockerVolume::clear_has_driver_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume_Source_DockerVolume::clear_driver_options() {
  if (driver_options_ != NULL) driver_options_->::mesos::Parameters::Clear();
  clear_has_driver_options();
}
inline const ::mesos::Parameters& Volume_Source_DockerVolume::driver_options() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.driver_options)
  return driver_options_ != NULL ? *driver_options_ : *default_instance_->driver_options_;
}
inline ::mesos::Parameters* Volume_Source_DockerVolume::mutable_driver_options() {
  set_has_driver_options();
  if (driver_options_ == NULL) driver_options_ = new ::mesos::Parameters;
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.driver_options)
  return driver_options_;
}
inline ::mesos::Parameters* Volume_Source_DockerVolume::release_driver_options() {
  clear_has_driver_options();
  ::mesos::Parameters* temp = driver_options_;
  driver_options_ = NULL;
  return temp;
}
inline void Volume_Source_DockerVolume::set_allocated_driver_options(::mesos::Parameters* driver_options) {
  delete driver_options_;
  driver_options_ = driver_options;
  if (driver_options) {
    set_has_driver_options();
  } else {
    clear_has_driver_options();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.driver_options)
}

// -------------------------------------------------------------------

// Volume_Source_SandboxPath

// optional .mesos.Volume.Source.SandboxPath.Type type = 1;
inline bool Volume_Source_SandboxPath::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source_SandboxPath::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source_SandboxPath::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source_SandboxPath::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::type() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.SandboxPath.type)
  return static_cast< ::mesos::Volume_Source_SandboxPath_Type >(type_);
}
inline void Volume_Source_SandboxPath::set_type(::mesos::Volume_Source_SandboxPath_Type value) {
  assert(::mesos::Volume_Source_SandboxPath_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.SandboxPath.type)
}

// required string path = 2;
inline bool Volume_Source_SandboxPath::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source_SandboxPath::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source_SandboxPath::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source_SandboxPath::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Volume_Source_SandboxPath::path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.SandboxPath.path)
  return *path_;
}
inline void Volume_Source_SandboxPath::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.SandboxPath.path)
}
inline void Volume_Source_SandboxPath::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.SandboxPath.path)
}
inline void Volume_Source_SandboxPath::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.SandboxPath.path)
}
inline ::std::string* Volume_Source_SandboxPath::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.SandboxPath.path)
  return path_;
}
inline ::std::string* Volume_Source_SandboxPath::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Volume_Source_SandboxPath::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.SandboxPath.path)
}

// -------------------------------------------------------------------

// Volume_Source

// optional .mesos.Volume.Source.Type type = 1;
inline bool Volume_Source::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume_Source::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume_Source::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume_Source::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Volume_Source_Type Volume_Source::type() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.type)
  return static_cast< ::mesos::Volume_Source_Type >(type_);
}
inline void Volume_Source::set_type(::mesos::Volume_Source_Type value) {
  assert(::mesos::Volume_Source_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.type)
}

// optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
inline bool Volume_Source::has_docker_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume_Source::set_has_docker_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume_Source::clear_has_docker_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume_Source::clear_docker_volume() {
  if (docker_volume_ != NULL) docker_volume_->::mesos::Volume_Source_DockerVolume::Clear();
  clear_has_docker_volume();
}
inline const ::mesos::Volume_Source_DockerVolume& Volume_Source::docker_volume() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.docker_volume)
  return docker_volume_ != NULL ? *docker_volume_ : *default_instance_->docker_volume_;
}
inline ::mesos::Volume_Source_DockerVolume* Volume_Source::mutable_docker_volume() {
  set_has_docker_volume();
  if (docker_volume_ == NULL) docker_volume_ = new ::mesos::Volume_Source_DockerVolume;
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.docker_volume)
  return docker_volume_;
}
inline ::mesos::Volume_Source_DockerVolume* Volume_Source::release_docker_volume() {
  clear_has_docker_volume();
  ::mesos::Volume_Source_DockerVolume* temp = docker_volume_;
  docker_volume_ = NULL;
  return temp;
}
inline void Volume_Source::set_allocated_docker_volume(::mesos::Volume_Source_DockerVolume* docker_volume) {
  delete docker_volume_;
  docker_volume_ = docker_volume;
  if (docker_volume) {
    set_has_docker_volume();
  } else {
    clear_has_docker_volume();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.docker_volume)
}

// optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
inline bool Volume_Source::has_sandbox_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume_Source::set_has_sandbox_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume_Source::clear_has_sandbox_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume_Source::clear_sandbox_path() {
  if (sandbox_path_ != NULL) sandbox_path_->::mesos::Volume_Source_SandboxPath::Clear();
  clear_has_sandbox_path();
}
inline const ::mesos::Volume_Source_SandboxPath& Volume_Source::sandbox_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.sandbox_path)
  return sandbox_path_ != NULL ? *sandbox_path_ : *default_instance_->sandbox_path_;
}
inline ::mesos::Volume_Source_SandboxPath* Volume_Source::mutable_sandbox_path() {
  set_has_sandbox_path();
  if (sandbox_path_ == NULL) sandbox_path_ = new ::mesos::Volume_Source_SandboxPath;
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.sandbox_path)
  return sandbox_path_;
}
inline ::mesos::Volume_Source_SandboxPath* Volume_Source::release_sandbox_path() {
  clear_has_sandbox_path();
  ::mesos::Volume_Source_SandboxPath* temp = sandbox_path_;
  sandbox_path_ = NULL;
  return temp;
}
inline void Volume_Source::set_allocated_sandbox_path(::mesos::Volume_Source_SandboxPath* sandbox_path) {
  delete sandbox_path_;
  sandbox_path_ = sandbox_path;
  if (sandbox_path) {
    set_has_sandbox_path();
  } else {
    clear_has_sandbox_path();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.sandbox_path)
}

// optional .mesos.Secret secret = 4;
inline bool Volume_Source::has_secret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Volume_Source::set_has_secret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Volume_Source::clear_has_secret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Volume_Source::clear_secret() {
  if (secret_ != NULL) secret_->::mesos::Secret::Clear();
  clear_has_secret();
}
inline const ::mesos::Secret& Volume_Source::secret() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.secret)
  return secret_ != NULL ? *secret_ : *default_instance_->secret_;
}
inline ::mesos::Secret* Volume_Source::mutable_secret() {
  set_has_secret();
  if (secret_ == NULL) secret_ = new ::mesos::Secret;
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.secret)
  return secret_;
}
inline ::mesos::Secret* Volume_Source::release_secret() {
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  secret_ = NULL;
  return temp;
}
inline void Volume_Source::set_allocated_secret(::mesos::Secret* secret) {
  delete secret_;
  secret_ = secret;
  if (secret) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.secret)
}

// -------------------------------------------------------------------

// Volume

// required .mesos.Volume.Mode mode = 3;
inline bool Volume::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::mesos::Volume_Mode Volume::mode() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.mode)
  return static_cast< ::mesos::Volume_Mode >(mode_);
}
inline void Volume::set_mode(::mesos::Volume_Mode value) {
  assert(::mesos::Volume_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.mode)
}

// required string container_path = 1;
inline bool Volume::has_container_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume::set_has_container_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume::clear_container_path() {
  if (container_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_path_->clear();
  }
  clear_has_container_path();
}
inline const ::std::string& Volume::container_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.container_path)
  return *container_path_;
}
inline void Volume::set_container_path(const ::std::string& value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Volume.container_path)
}
inline void Volume::set_container_path(const char* value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Volume.container_path)
}
inline void Volume::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.container_path)
}
inline ::std::string* Volume::mutable_container_path() {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.container_path)
  return container_path_;
}
inline ::std::string* Volume::release_container_path() {
  clear_has_container_path();
  if (container_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = container_path_;
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Volume::set_allocated_container_path(::std::string* container_path) {
  if (container_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete container_path_;
  }
  if (container_path) {
    set_has_container_path();
    container_path_ = container_path;
  } else {
    clear_has_container_path();
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.container_path)
}

// optional string host_path = 2;
inline bool Volume::has_host_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume::set_has_host_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume::clear_has_host_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume::clear_host_path() {
  if (host_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_path_->clear();
  }
  clear_has_host_path();
}
inline const ::std::string& Volume::host_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.host_path)
  return *host_path_;
}
inline void Volume::set_host_path(const ::std::string& value) {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_path_ = new ::std::string;
  }
  host_path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Volume.host_path)
}
inline void Volume::set_host_path(const char* value) {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_path_ = new ::std::string;
  }
  host_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Volume.host_path)
}
inline void Volume::set_host_path(const char* value, size_t size) {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_path_ = new ::std::string;
  }
  host_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.host_path)
}
inline ::std::string* Volume::mutable_host_path() {
  set_has_host_path();
  if (host_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.host_path)
  return host_path_;
}
inline ::std::string* Volume::release_host_path() {
  clear_has_host_path();
  if (host_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_path_;
    host_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Volume::set_allocated_host_path(::std::string* host_path) {
  if (host_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_path_;
  }
  if (host_path) {
    set_has_host_path();
    host_path_ = host_path;
  } else {
    clear_has_host_path();
    host_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.host_path)
}

// optional .mesos.Image image = 4;
inline bool Volume::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Volume::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Volume::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Volume::clear_image() {
  if (image_ != NULL) image_->::mesos::Image::Clear();
  clear_has_image();
}
inline const ::mesos::Image& Volume::image() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::mesos::Image* Volume::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::mesos::Image;
  // @@protoc_insertion_point(field_mutable:mesos.Volume.image)
  return image_;
}
inline ::mesos::Image* Volume::release_image() {
  clear_has_image();
  ::mesos::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void Volume::set_allocated_image(::mesos::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.image)
}

// optional .mesos.Volume.Source source = 5;
inline bool Volume::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Volume::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Volume::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Volume::clear_source() {
  if (source_ != NULL) source_->::mesos::Volume_Source::Clear();
  clear_has_source();
}
inline const ::mesos::Volume_Source& Volume::source() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::mesos::Volume_Source* Volume::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::mesos::Volume_Source;
  // @@protoc_insertion_point(field_mutable:mesos.Volume.source)
  return source_;
}
inline ::mesos::Volume_Source* Volume::release_source() {
  clear_has_source();
  ::mesos::Volume_Source* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Volume::set_allocated_source(::mesos::Volume_Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.source)
}

// -------------------------------------------------------------------

// NetworkInfo_IPAddress

// optional .mesos.NetworkInfo.Protocol protocol = 1;
inline bool NetworkInfo_IPAddress::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInfo_IPAddress::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInfo_IPAddress::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInfo_IPAddress::clear_protocol() {
  protocol_ = 1;
  clear_has_protocol();
}
inline ::mesos::NetworkInfo_Protocol NetworkInfo_IPAddress::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.IPAddress.protocol)
  return static_cast< ::mesos::NetworkInfo_Protocol >(protocol_);
}
inline void NetworkInfo_IPAddress::set_protocol(::mesos::NetworkInfo_Protocol value) {
  assert(::mesos::NetworkInfo_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.IPAddress.protocol)
}

// optional string ip_address = 2;
inline bool NetworkInfo_IPAddress::has_ip_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInfo_IPAddress::set_has_ip_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInfo_IPAddress::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInfo_IPAddress::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& NetworkInfo_IPAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.IPAddress.ip_address)
  return *ip_address_;
}
inline void NetworkInfo_IPAddress::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.IPAddress.ip_address)
}
inline void NetworkInfo_IPAddress::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.IPAddress.ip_address)
}
inline void NetworkInfo_IPAddress::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.IPAddress.ip_address)
}
inline ::std::string* NetworkInfo_IPAddress::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.IPAddress.ip_address)
  return ip_address_;
}
inline ::std::string* NetworkInfo_IPAddress::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NetworkInfo_IPAddress::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.IPAddress.ip_address)
}

// -------------------------------------------------------------------

// NetworkInfo_PortMapping

// required uint32 host_port = 1;
inline bool NetworkInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 NetworkInfo_PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.host_port)
  return host_port_;
}
inline void NetworkInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.host_port)
}

// required uint32 container_port = 2;
inline bool NetworkInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 NetworkInfo_PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.container_port)
  return container_port_;
}
inline void NetworkInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.container_port)
}

// optional string protocol = 3;
inline bool NetworkInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkInfo_PortMapping::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& NetworkInfo_PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.protocol)
  return *protocol_;
}
inline void NetworkInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.protocol)
}
inline void NetworkInfo_PortMapping::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.PortMapping.protocol)
}
inline void NetworkInfo_PortMapping::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.PortMapping.protocol)
}
inline ::std::string* NetworkInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.PortMapping.protocol)
  return protocol_;
}
inline ::std::string* NetworkInfo_PortMapping::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NetworkInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.PortMapping.protocol)
}

// -------------------------------------------------------------------

// NetworkInfo

// repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
inline int NetworkInfo::ip_addresses_size() const {
  return ip_addresses_.size();
}
inline void NetworkInfo::clear_ip_addresses() {
  ip_addresses_.Clear();
}
inline const ::mesos::NetworkInfo_IPAddress& NetworkInfo::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Get(index);
}
inline ::mesos::NetworkInfo_IPAddress* NetworkInfo::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Mutable(index);
}
inline ::mesos::NetworkInfo_IPAddress* NetworkInfo::add_ip_addresses() {
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >&
NetworkInfo::ip_addresses() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >*
NetworkInfo::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.ip_addresses)
  return &ip_addresses_;
}

// optional string name = 6;
inline bool NetworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NetworkInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.name)
  return *name_;
}
inline void NetworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.name)
}
inline void NetworkInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.name)
}
inline void NetworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.name)
}
inline ::std::string* NetworkInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.name)
  return name_;
}
inline ::std::string* NetworkInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NetworkInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.name)
}

// repeated string groups = 3;
inline int NetworkInfo::groups_size() const {
  return groups_.size();
}
inline void NetworkInfo::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& NetworkInfo::groups(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.groups)
  return groups_.Get(index);
}
inline ::std::string* NetworkInfo::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.groups)
  return groups_.Mutable(index);
}
inline void NetworkInfo::set_groups(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.groups)
  groups_.Mutable(index)->assign(value);
}
inline void NetworkInfo::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.groups)
}
inline void NetworkInfo::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.groups)
}
inline ::std::string* NetworkInfo::add_groups() {
  return groups_.Add();
}
inline void NetworkInfo::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.groups)
}
inline void NetworkInfo::add_groups(const char* value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.NetworkInfo.groups)
}
inline void NetworkInfo::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.NetworkInfo.groups)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkInfo::groups() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.groups)
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkInfo::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.groups)
  return &groups_;
}

// optional .mesos.Labels labels = 4;
inline bool NetworkInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetworkInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& NetworkInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* NetworkInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.labels)
  return labels_;
}
inline ::mesos::Labels* NetworkInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void NetworkInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.labels)
}

// repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
inline int NetworkInfo::port_mappings_size() const {
  return port_mappings_.size();
}
inline void NetworkInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::mesos::NetworkInfo_PortMapping& NetworkInfo::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Get(index);
}
inline ::mesos::NetworkInfo_PortMapping* NetworkInfo::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Mutable(index);
}
inline ::mesos::NetworkInfo_PortMapping* NetworkInfo::add_port_mappings() {
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >&
NetworkInfo::port_mappings() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.port_mappings)
  return port_mappings_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >*
NetworkInfo::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.port_mappings)
  return &port_mappings_;
}

// -------------------------------------------------------------------

// CapabilityInfo

// repeated .mesos.CapabilityInfo.Capability capabilities = 1;
inline int CapabilityInfo::capabilities_size() const {
  return capabilities_.size();
}
inline void CapabilityInfo::clear_capabilities() {
  capabilities_.Clear();
}
inline ::mesos::CapabilityInfo_Capability CapabilityInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CapabilityInfo.capabilities)
  return static_cast< ::mesos::CapabilityInfo_Capability >(capabilities_.Get(index));
}
inline void CapabilityInfo::set_capabilities(int index, ::mesos::CapabilityInfo_Capability value) {
  assert(::mesos::CapabilityInfo_Capability_IsValid(value));
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.CapabilityInfo.capabilities)
}
inline void CapabilityInfo::add_capabilities(::mesos::CapabilityInfo_Capability value) {
  assert(::mesos::CapabilityInfo_Capability_IsValid(value));
  capabilities_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.CapabilityInfo.capabilities)
}
inline const ::google::protobuf::RepeatedField<int>&
CapabilityInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.CapabilityInfo.capabilities)
  return capabilities_;
}
inline ::google::protobuf::RepeatedField<int>*
CapabilityInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CapabilityInfo.capabilities)
  return &capabilities_;
}

// -------------------------------------------------------------------

// LinuxInfo

// optional .mesos.CapabilityInfo capability_info = 1;
inline bool LinuxInfo::has_capability_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinuxInfo::set_has_capability_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinuxInfo::clear_has_capability_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinuxInfo::clear_capability_info() {
  if (capability_info_ != NULL) capability_info_->::mesos::CapabilityInfo::Clear();
  clear_has_capability_info();
}
inline const ::mesos::CapabilityInfo& LinuxInfo::capability_info() const {
  // @@protoc_insertion_point(field_get:mesos.LinuxInfo.capability_info)
  return capability_info_ != NULL ? *capability_info_ : *default_instance_->capability_info_;
}
inline ::mesos::CapabilityInfo* LinuxInfo::mutable_capability_info() {
  set_has_capability_info();
  if (capability_info_ == NULL) capability_info_ = new ::mesos::CapabilityInfo;
  // @@protoc_insertion_point(field_mutable:mesos.LinuxInfo.capability_info)
  return capability_info_;
}
inline ::mesos::CapabilityInfo* LinuxInfo::release_capability_info() {
  clear_has_capability_info();
  ::mesos::CapabilityInfo* temp = capability_info_;
  capability_info_ = NULL;
  return temp;
}
inline void LinuxInfo::set_allocated_capability_info(::mesos::CapabilityInfo* capability_info) {
  delete capability_info_;
  capability_info_ = capability_info;
  if (capability_info) {
    set_has_capability_info();
  } else {
    clear_has_capability_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.LinuxInfo.capability_info)
}

// -------------------------------------------------------------------

// RLimitInfo_RLimit

// optional .mesos.RLimitInfo.RLimit.Type type = 1;
inline bool RLimitInfo_RLimit::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RLimitInfo_RLimit::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RLimitInfo_RLimit::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RLimitInfo_RLimit::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::RLimitInfo_RLimit_Type RLimitInfo_RLimit::type() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.type)
  return static_cast< ::mesos::RLimitInfo_RLimit_Type >(type_);
}
inline void RLimitInfo_RLimit::set_type(::mesos::RLimitInfo_RLimit_Type value) {
  assert(::mesos::RLimitInfo_RLimit_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.type)
}

// optional uint64 hard = 2;
inline bool RLimitInfo_RLimit::has_hard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RLimitInfo_RLimit::set_has_hard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RLimitInfo_RLimit::clear_has_hard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RLimitInfo_RLimit::clear_hard() {
  hard_ = GOOGLE_ULONGLONG(0);
  clear_has_hard();
}
inline ::google::protobuf::uint64 RLimitInfo_RLimit::hard() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.hard)
  return hard_;
}
inline void RLimitInfo_RLimit::set_hard(::google::protobuf::uint64 value) {
  set_has_hard();
  hard_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.hard)
}

// optional uint64 soft = 3;
inline bool RLimitInfo_RLimit::has_soft() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RLimitInfo_RLimit::set_has_soft() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RLimitInfo_RLimit::clear_has_soft() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RLimitInfo_RLimit::clear_soft() {
  soft_ = GOOGLE_ULONGLONG(0);
  clear_has_soft();
}
inline ::google::protobuf::uint64 RLimitInfo_RLimit::soft() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.soft)
  return soft_;
}
inline void RLimitInfo_RLimit::set_soft(::google::protobuf::uint64 value) {
  set_has_soft();
  soft_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.soft)
}

// -------------------------------------------------------------------

// RLimitInfo

// repeated .mesos.RLimitInfo.RLimit rlimits = 1;
inline int RLimitInfo::rlimits_size() const {
  return rlimits_.size();
}
inline void RLimitInfo::clear_rlimits() {
  rlimits_.Clear();
}
inline const ::mesos::RLimitInfo_RLimit& RLimitInfo::rlimits(int index) const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.rlimits)
  return rlimits_.Get(index);
}
inline ::mesos::RLimitInfo_RLimit* RLimitInfo::mutable_rlimits(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.RLimitInfo.rlimits)
  return rlimits_.Mutable(index);
}
inline ::mesos::RLimitInfo_RLimit* RLimitInfo::add_rlimits() {
  // @@protoc_insertion_point(field_add:mesos.RLimitInfo.rlimits)
  return rlimits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >&
RLimitInfo::rlimits() const {
  // @@protoc_insertion_point(field_list:mesos.RLimitInfo.rlimits)
  return rlimits_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >*
RLimitInfo::mutable_rlimits() {
  // @@protoc_insertion_point(field_mutable_list:mesos.RLimitInfo.rlimits)
  return &rlimits_;
}

// -------------------------------------------------------------------

// TTYInfo_WindowSize

// required uint32 rows = 1;
inline bool TTYInfo_WindowSize::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTYInfo_WindowSize::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTYInfo_WindowSize::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTYInfo_WindowSize::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 TTYInfo_WindowSize::rows() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.WindowSize.rows)
  return rows_;
}
inline void TTYInfo_WindowSize::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
  // @@protoc_insertion_point(field_set:mesos.TTYInfo.WindowSize.rows)
}

// required uint32 columns = 2;
inline bool TTYInfo_WindowSize::has_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TTYInfo_WindowSize::set_has_columns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TTYInfo_WindowSize::clear_has_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TTYInfo_WindowSize::clear_columns() {
  columns_ = 0u;
  clear_has_columns();
}
inline ::google::protobuf::uint32 TTYInfo_WindowSize::columns() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.WindowSize.columns)
  return columns_;
}
inline void TTYInfo_WindowSize::set_columns(::google::protobuf::uint32 value) {
  set_has_columns();
  columns_ = value;
  // @@protoc_insertion_point(field_set:mesos.TTYInfo.WindowSize.columns)
}

// -------------------------------------------------------------------

// TTYInfo

// optional .mesos.TTYInfo.WindowSize window_size = 1;
inline bool TTYInfo::has_window_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTYInfo::set_has_window_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTYInfo::clear_has_window_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTYInfo::clear_window_size() {
  if (window_size_ != NULL) window_size_->::mesos::TTYInfo_WindowSize::Clear();
  clear_has_window_size();
}
inline const ::mesos::TTYInfo_WindowSize& TTYInfo::window_size() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.window_size)
  return window_size_ != NULL ? *window_size_ : *default_instance_->window_size_;
}
inline ::mesos::TTYInfo_WindowSize* TTYInfo::mutable_window_size() {
  set_has_window_size();
  if (window_size_ == NULL) window_size_ = new ::mesos::TTYInfo_WindowSize;
  // @@protoc_insertion_point(field_mutable:mesos.TTYInfo.window_size)
  return window_size_;
}
inline ::mesos::TTYInfo_WindowSize* TTYInfo::release_window_size() {
  clear_has_window_size();
  ::mesos::TTYInfo_WindowSize* temp = window_size_;
  window_size_ = NULL;
  return temp;
}
inline void TTYInfo::set_allocated_window_size(::mesos::TTYInfo_WindowSize* window_size) {
  delete window_size_;
  window_size_ = window_size;
  if (window_size) {
    set_has_window_size();
  } else {
    clear_has_window_size();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TTYInfo.window_size)
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo_PortMapping

// required uint32 host_port = 1;
inline bool ContainerInfo_DockerInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
inline ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.host_port)
  return host_port_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.host_port)
}

// required uint32 container_port = 2;
inline bool ContainerInfo_DockerInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
inline ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.container_port)
  return container_port_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.container_port)
}

// optional string protocol = 3;
inline bool ContainerInfo_DockerInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo_DockerInfo_PortMapping::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& ContainerInfo_DockerInfo_PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  return *protocol_;
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
inline void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  return protocol_;
}
inline ::std::string* ContainerInfo_DockerInfo_PortMapping::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerInfo_DockerInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo

// required string image = 1;
inline bool ContainerInfo_DockerInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_DockerInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_DockerInfo::clear_image() {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& ContainerInfo_DockerInfo::image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.image)
  return *image_;
}
inline void ContainerInfo_DockerInfo::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.image)
}
inline void ContainerInfo_DockerInfo::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.image)
}
inline void ContainerInfo_DockerInfo::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.image)
}
inline ::std::string* ContainerInfo_DockerInfo::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.image)
  return image_;
}
inline ::std::string* ContainerInfo_DockerInfo::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerInfo_DockerInfo::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.image)
}

// optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
inline bool ContainerInfo_DockerInfo::has_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo_DockerInfo::clear_has_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo_DockerInfo::clear_network() {
  network_ = 1;
  clear_has_network();
}
inline ::mesos::ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::network() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.network)
  return static_cast< ::mesos::ContainerInfo_DockerInfo_Network >(network_);
}
inline void ContainerInfo_DockerInfo::set_network(::mesos::ContainerInfo_DockerInfo_Network value) {
  assert(::mesos::ContainerInfo_DockerInfo_Network_IsValid(value));
  set_has_network();
  network_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.network)
}

// repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
inline int ContainerInfo_DockerInfo::port_mappings_size() const {
  return port_mappings_.size();
}
inline void ContainerInfo_DockerInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
inline const ::mesos::ContainerInfo_DockerInfo_PortMapping& ContainerInfo_DockerInfo::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Get(index);
}
inline ::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Mutable(index);
}
inline ::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::add_port_mappings() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
ContainerInfo_DockerInfo::port_mappings() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
ContainerInfo_DockerInfo::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.DockerInfo.port_mappings)
  return &port_mappings_;
}

// optional bool privileged = 4 [default = false];
inline bool ContainerInfo_DockerInfo::has_privileged() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_privileged() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInfo_DockerInfo::clear_has_privileged() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInfo_DockerInfo::clear_privileged() {
  privileged_ = false;
  clear_has_privileged();
}
inline bool ContainerInfo_DockerInfo::privileged() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.privileged)
  return privileged_;
}
inline void ContainerInfo_DockerInfo::set_privileged(bool value) {
  set_has_privileged();
  privileged_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.privileged)
}

// repeated .mesos.Parameter parameters = 5;
inline int ContainerInfo_DockerInfo::parameters_size() const {
  return parameters_.size();
}
inline void ContainerInfo_DockerInfo::clear_parameters() {
  parameters_.Clear();
}
inline const ::mesos::Parameter& ContainerInfo_DockerInfo::parameters(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Get(index);
}
inline ::mesos::Parameter* ContainerInfo_DockerInfo::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Mutable(index);
}
inline ::mesos::Parameter* ContainerInfo_DockerInfo::add_parameters() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
ContainerInfo_DockerInfo::parameters() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
ContainerInfo_DockerInfo::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.DockerInfo.parameters)
  return &parameters_;
}

// optional bool force_pull_image = 6;
inline bool ContainerInfo_DockerInfo::has_force_pull_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_force_pull_image() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContainerInfo_DockerInfo::clear_has_force_pull_image() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContainerInfo_DockerInfo::clear_force_pull_image() {
  force_pull_image_ = false;
  clear_has_force_pull_image();
}
inline bool ContainerInfo_DockerInfo::force_pull_image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.force_pull_image)
  return force_pull_image_;
}
inline void ContainerInfo_DockerInfo::set_force_pull_image(bool value) {
  set_has_force_pull_image();
  force_pull_image_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.force_pull_image)
}

// optional string volume_driver = 7 [deprecated = true];
inline bool ContainerInfo_DockerInfo::has_volume_driver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerInfo_DockerInfo::set_has_volume_driver() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerInfo_DockerInfo::clear_has_volume_driver() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerInfo_DockerInfo::clear_volume_driver() {
  if (volume_driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    volume_driver_->clear();
  }
  clear_has_volume_driver();
}
inline const ::std::string& ContainerInfo_DockerInfo::volume_driver() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.volume_driver)
  return *volume_driver_;
}
inline void ContainerInfo_DockerInfo::set_volume_driver(const ::std::string& value) {
  set_has_volume_driver();
  if (volume_driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    volume_driver_ = new ::std::string;
  }
  volume_driver_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.volume_driver)
}
inline void ContainerInfo_DockerInfo::set_volume_driver(const char* value) {
  set_has_volume_driver();
  if (volume_driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    volume_driver_ = new ::std::string;
  }
  volume_driver_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.volume_driver)
}
inline void ContainerInfo_DockerInfo::set_volume_driver(const char* value, size_t size) {
  set_has_volume_driver();
  if (volume_driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    volume_driver_ = new ::std::string;
  }
  volume_driver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.volume_driver)
}
inline ::std::string* ContainerInfo_DockerInfo::mutable_volume_driver() {
  set_has_volume_driver();
  if (volume_driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    volume_driver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.volume_driver)
  return volume_driver_;
}
inline ::std::string* ContainerInfo_DockerInfo::release_volume_driver() {
  clear_has_volume_driver();
  if (volume_driver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = volume_driver_;
    volume_driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerInfo_DockerInfo::set_allocated_volume_driver(::std::string* volume_driver) {
  if (volume_driver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete volume_driver_;
  }
  if (volume_driver) {
    set_has_volume_driver();
    volume_driver_ = volume_driver;
  } else {
    clear_has_volume_driver();
    volume_driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.volume_driver)
}

// -------------------------------------------------------------------

// ContainerInfo_MesosInfo

// optional .mesos.Image image = 1;
inline bool ContainerInfo_MesosInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo_MesosInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo_MesosInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo_MesosInfo::clear_image() {
  if (image_ != NULL) image_->::mesos::Image::Clear();
  clear_has_image();
}
inline const ::mesos::Image& ContainerInfo_MesosInfo::image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.MesosInfo.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::mesos::Image* ContainerInfo_MesosInfo::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::mesos::Image;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.MesosInfo.image)
  return image_;
}
inline ::mesos::Image* ContainerInfo_MesosInfo::release_image() {
  clear_has_image();
  ::mesos::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void ContainerInfo_MesosInfo::set_allocated_image(::mesos::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.MesosInfo.image)
}

// -------------------------------------------------------------------

// ContainerInfo

// required .mesos.ContainerInfo.Type type = 1;
inline bool ContainerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mesos::ContainerInfo_Type ContainerInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.type)
  return static_cast< ::mesos::ContainerInfo_Type >(type_);
}
inline void ContainerInfo::set_type(::mesos::ContainerInfo_Type value) {
  assert(::mesos::ContainerInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.type)
}

// repeated .mesos.Volume volumes = 2;
inline int ContainerInfo::volumes_size() const {
  return volumes_.size();
}
inline void ContainerInfo::clear_volumes() {
  volumes_.Clear();
}
inline const ::mesos::Volume& ContainerInfo::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.volumes)
  return volumes_.Get(index);
}
inline ::mesos::Volume* ContainerInfo::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.volumes)
  return volumes_.Mutable(index);
}
inline ::mesos::Volume* ContainerInfo::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.volumes)
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
ContainerInfo::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.volumes)
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
ContainerInfo::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.volumes)
  return &volumes_;
}

// optional string hostname = 4;
inline bool ContainerInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ContainerInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.hostname)
  return *hostname_;
}
inline void ContainerInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.hostname)
}
inline void ContainerInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.hostname)
}
inline void ContainerInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.hostname)
}
inline ::std::string* ContainerInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.hostname)
  return hostname_;
}
inline ::std::string* ContainerInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContainerInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.hostname)
}

// optional .mesos.ContainerInfo.DockerInfo docker = 3;
inline bool ContainerInfo::has_docker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerInfo::set_has_docker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerInfo::clear_has_docker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerInfo::clear_docker() {
  if (docker_ != NULL) docker_->::mesos::ContainerInfo_DockerInfo::Clear();
  clear_has_docker();
}
inline const ::mesos::ContainerInfo_DockerInfo& ContainerInfo::docker() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.docker)
  return docker_ != NULL ? *docker_ : *default_instance_->docker_;
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) docker_ = new ::mesos::ContainerInfo_DockerInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.docker)
  return docker_;
}
inline ::mesos::ContainerInfo_DockerInfo* ContainerInfo::release_docker() {
  clear_has_docker();
  ::mesos::ContainerInfo_DockerInfo* temp = docker_;
  docker_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker) {
  delete docker_;
  docker_ = docker;
  if (docker) {
    set_has_docker();
  } else {
    clear_has_docker();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.docker)
}

// optional .mesos.ContainerInfo.MesosInfo mesos = 5;
inline bool ContainerInfo::has_mesos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContainerInfo::set_has_mesos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContainerInfo::clear_has_mesos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContainerInfo::clear_mesos() {
  if (mesos_ != NULL) mesos_->::mesos::ContainerInfo_MesosInfo::Clear();
  clear_has_mesos();
}
inline const ::mesos::ContainerInfo_MesosInfo& ContainerInfo::mesos() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.mesos)
  return mesos_ != NULL ? *mesos_ : *default_instance_->mesos_;
}
inline ::mesos::ContainerInfo_MesosInfo* ContainerInfo::mutable_mesos() {
  set_has_mesos();
  if (mesos_ == NULL) mesos_ = new ::mesos::ContainerInfo_MesosInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.mesos)
  return mesos_;
}
inline ::mesos::ContainerInfo_MesosInfo* ContainerInfo::release_mesos() {
  clear_has_mesos();
  ::mesos::ContainerInfo_MesosInfo* temp = mesos_;
  mesos_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_mesos(::mesos::ContainerInfo_MesosInfo* mesos) {
  delete mesos_;
  mesos_ = mesos;
  if (mesos) {
    set_has_mesos();
  } else {
    clear_has_mesos();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.mesos)
}

// repeated .mesos.NetworkInfo network_infos = 7;
inline int ContainerInfo::network_infos_size() const {
  return network_infos_.size();
}
inline void ContainerInfo::clear_network_infos() {
  network_infos_.Clear();
}
inline const ::mesos::NetworkInfo& ContainerInfo::network_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.network_infos)
  return network_infos_.Get(index);
}
inline ::mesos::NetworkInfo* ContainerInfo::mutable_network_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.network_infos)
  return network_infos_.Mutable(index);
}
inline ::mesos::NetworkInfo* ContainerInfo::add_network_infos() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.network_infos)
  return network_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
ContainerInfo::network_infos() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.network_infos)
  return network_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
ContainerInfo::mutable_network_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.network_infos)
  return &network_infos_;
}

// optional .mesos.LinuxInfo linux_info = 8;
inline bool ContainerInfo::has_linux_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContainerInfo::set_has_linux_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContainerInfo::clear_has_linux_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContainerInfo::clear_linux_info() {
  if (linux_info_ != NULL) linux_info_->::mesos::LinuxInfo::Clear();
  clear_has_linux_info();
}
inline const ::mesos::LinuxInfo& ContainerInfo::linux_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.linux_info)
  return linux_info_ != NULL ? *linux_info_ : *default_instance_->linux_info_;
}
inline ::mesos::LinuxInfo* ContainerInfo::mutable_linux_info() {
  set_has_linux_info();
  if (linux_info_ == NULL) linux_info_ = new ::mesos::LinuxInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.linux_info)
  return linux_info_;
}
inline ::mesos::LinuxInfo* ContainerInfo::release_linux_info() {
  clear_has_linux_info();
  ::mesos::LinuxInfo* temp = linux_info_;
  linux_info_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_linux_info(::mesos::LinuxInfo* linux_info) {
  delete linux_info_;
  linux_info_ = linux_info;
  if (linux_info) {
    set_has_linux_info();
  } else {
    clear_has_linux_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.linux_info)
}

// optional .mesos.RLimitInfo rlimit_info = 9;
inline bool ContainerInfo::has_rlimit_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContainerInfo::set_has_rlimit_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContainerInfo::clear_has_rlimit_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContainerInfo::clear_rlimit_info() {
  if (rlimit_info_ != NULL) rlimit_info_->::mesos::RLimitInfo::Clear();
  clear_has_rlimit_info();
}
inline const ::mesos::RLimitInfo& ContainerInfo::rlimit_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.rlimit_info)
  return rlimit_info_ != NULL ? *rlimit_info_ : *default_instance_->rlimit_info_;
}
inline ::mesos::RLimitInfo* ContainerInfo::mutable_rlimit_info() {
  set_has_rlimit_info();
  if (rlimit_info_ == NULL) rlimit_info_ = new ::mesos::RLimitInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.rlimit_info)
  return rlimit_info_;
}
inline ::mesos::RLimitInfo* ContainerInfo::release_rlimit_info() {
  clear_has_rlimit_info();
  ::mesos::RLimitInfo* temp = rlimit_info_;
  rlimit_info_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_rlimit_info(::mesos::RLimitInfo* rlimit_info) {
  delete rlimit_info_;
  rlimit_info_ = rlimit_info;
  if (rlimit_info) {
    set_has_rlimit_info();
  } else {
    clear_has_rlimit_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.rlimit_info)
}

// optional .mesos.TTYInfo tty_info = 10;
inline bool ContainerInfo::has_tty_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContainerInfo::set_has_tty_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContainerInfo::clear_has_tty_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContainerInfo::clear_tty_info() {
  if (tty_info_ != NULL) tty_info_->::mesos::TTYInfo::Clear();
  clear_has_tty_info();
}
inline const ::mesos::TTYInfo& ContainerInfo::tty_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.tty_info)
  return tty_info_ != NULL ? *tty_info_ : *default_instance_->tty_info_;
}
inline ::mesos::TTYInfo* ContainerInfo::mutable_tty_info() {
  set_has_tty_info();
  if (tty_info_ == NULL) tty_info_ = new ::mesos::TTYInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.tty_info)
  return tty_info_;
}
inline ::mesos::TTYInfo* ContainerInfo::release_tty_info() {
  clear_has_tty_info();
  ::mesos::TTYInfo* temp = tty_info_;
  tty_info_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_tty_info(::mesos::TTYInfo* tty_info) {
  delete tty_info_;
  tty_info_ = tty_info;
  if (tty_info) {
    set_has_tty_info();
  } else {
    clear_has_tty_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.tty_info)
}

// -------------------------------------------------------------------

// ContainerStatus

// optional .mesos.ContainerID container_id = 4;
inline bool ContainerStatus::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerStatus::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerStatus::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerStatus::clear_container_id() {
  if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
  clear_has_container_id();
}
inline const ::mesos::ContainerID& ContainerStatus::container_id() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.container_id)
  return container_id_ != NULL ? *container_id_ : *default_instance_->container_id_;
}
inline ::mesos::ContainerID* ContainerStatus::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) container_id_ = new ::mesos::ContainerID;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.container_id)
  return container_id_;
}
inline ::mesos::ContainerID* ContainerStatus::release_container_id() {
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
inline void ContainerStatus::set_allocated_container_id(::mesos::ContainerID* container_id) {
  delete container_id_;
  container_id_ = container_id;
  if (container_id) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerStatus.container_id)
}

// repeated .mesos.NetworkInfo network_infos = 1;
inline int ContainerStatus::network_infos_size() const {
  return network_infos_.size();
}
inline void ContainerStatus::clear_network_infos() {
  network_infos_.Clear();
}
inline const ::mesos::NetworkInfo& ContainerStatus::network_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.network_infos)
  return network_infos_.Get(index);
}
inline ::mesos::NetworkInfo* ContainerStatus::mutable_network_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.network_infos)
  return network_infos_.Mutable(index);
}
inline ::mesos::NetworkInfo* ContainerStatus::add_network_infos() {
  // @@protoc_insertion_point(field_add:mesos.ContainerStatus.network_infos)
  return network_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
ContainerStatus::network_infos() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerStatus.network_infos)
  return network_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
ContainerStatus::mutable_network_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerStatus.network_infos)
  return &network_infos_;
}

// optional .mesos.CgroupInfo cgroup_info = 2;
inline bool ContainerStatus::has_cgroup_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerStatus::set_has_cgroup_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerStatus::clear_has_cgroup_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerStatus::clear_cgroup_info() {
  if (cgroup_info_ != NULL) cgroup_info_->::mesos::CgroupInfo::Clear();
  clear_has_cgroup_info();
}
inline const ::mesos::CgroupInfo& ContainerStatus::cgroup_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.cgroup_info)
  return cgroup_info_ != NULL ? *cgroup_info_ : *default_instance_->cgroup_info_;
}
inline ::mesos::CgroupInfo* ContainerStatus::mutable_cgroup_info() {
  set_has_cgroup_info();
  if (cgroup_info_ == NULL) cgroup_info_ = new ::mesos::CgroupInfo;
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.cgroup_info)
  return cgroup_info_;
}
inline ::mesos::CgroupInfo* ContainerStatus::release_cgroup_info() {
  clear_has_cgroup_info();
  ::mesos::CgroupInfo* temp = cgroup_info_;
  cgroup_info_ = NULL;
  return temp;
}
inline void ContainerStatus::set_allocated_cgroup_info(::mesos::CgroupInfo* cgroup_info) {
  delete cgroup_info_;
  cgroup_info_ = cgroup_info;
  if (cgroup_info) {
    set_has_cgroup_info();
  } else {
    clear_has_cgroup_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerStatus.cgroup_info)
}

// optional uint32 executor_pid = 3;
inline bool ContainerStatus::has_executor_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerStatus::set_has_executor_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerStatus::clear_has_executor_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerStatus::clear_executor_pid() {
  executor_pid_ = 0u;
  clear_has_executor_pid();
}
inline ::google::protobuf::uint32 ContainerStatus::executor_pid() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.executor_pid)
  return executor_pid_;
}
inline void ContainerStatus::set_executor_pid(::google::protobuf::uint32 value) {
  set_has_executor_pid();
  executor_pid_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerStatus.executor_pid)
}

// -------------------------------------------------------------------

// CgroupInfo_NetCls

// optional uint32 classid = 1;
inline bool CgroupInfo_NetCls::has_classid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo_NetCls::set_has_classid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo_NetCls::clear_has_classid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo_NetCls::clear_classid() {
  classid_ = 0u;
  clear_has_classid();
}
inline ::google::protobuf::uint32 CgroupInfo_NetCls::classid() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.NetCls.classid)
  return classid_;
}
inline void CgroupInfo_NetCls::set_classid(::google::protobuf::uint32 value) {
  set_has_classid();
  classid_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.NetCls.classid)
}

// -------------------------------------------------------------------

// CgroupInfo

// optional .mesos.CgroupInfo.NetCls net_cls = 1;
inline bool CgroupInfo::has_net_cls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CgroupInfo::set_has_net_cls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CgroupInfo::clear_has_net_cls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CgroupInfo::clear_net_cls() {
  if (net_cls_ != NULL) net_cls_->::mesos::CgroupInfo_NetCls::Clear();
  clear_has_net_cls();
}
inline const ::mesos::CgroupInfo_NetCls& CgroupInfo::net_cls() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.net_cls)
  return net_cls_ != NULL ? *net_cls_ : *default_instance_->net_cls_;
}
inline ::mesos::CgroupInfo_NetCls* CgroupInfo::mutable_net_cls() {
  set_has_net_cls();
  if (net_cls_ == NULL) net_cls_ = new ::mesos::CgroupInfo_NetCls;
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.net_cls)
  return net_cls_;
}
inline ::mesos::CgroupInfo_NetCls* CgroupInfo::release_net_cls() {
  clear_has_net_cls();
  ::mesos::CgroupInfo_NetCls* temp = net_cls_;
  net_cls_ = NULL;
  return temp;
}
inline void CgroupInfo::set_allocated_net_cls(::mesos::CgroupInfo_NetCls* net_cls) {
  delete net_cls_;
  net_cls_ = net_cls;
  if (net_cls) {
    set_has_net_cls();
  } else {
    clear_has_net_cls();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CgroupInfo.net_cls)
}

// -------------------------------------------------------------------

// Labels

// repeated .mesos.Label labels = 1;
inline int Labels::labels_size() const {
  return labels_.size();
}
inline void Labels::clear_labels() {
  labels_.Clear();
}
inline const ::mesos::Label& Labels::labels(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Labels.labels)
  return labels_.Get(index);
}
inline ::mesos::Label* Labels::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Labels.labels)
  return labels_.Mutable(index);
}
inline ::mesos::Label* Labels::add_labels() {
  // @@protoc_insertion_point(field_add:mesos.Labels.labels)
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
Labels::labels() const {
  // @@protoc_insertion_point(field_list:mesos.Labels.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Label >*
Labels::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Labels.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// Label

// required string key = 1;
inline bool Label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Label::key() const {
  // @@protoc_insertion_point(field_get:mesos.Label.key)
  return *key_;
}
inline void Label::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Label.key)
}
inline void Label::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Label.key)
}
inline void Label::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Label.key)
}
inline ::std::string* Label::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Label.key)
  return key_;
}
inline ::std::string* Label::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Label::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Label.key)
}

// optional string value = 2;
inline bool Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Label::value() const {
  // @@protoc_insertion_point(field_get:mesos.Label.value)
  return *value_;
}
inline void Label::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Label.value)
}
inline void Label::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Label.value)
}
inline void Label::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Label.value)
}
inline ::std::string* Label::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Label.value)
  return value_;
}
inline ::std::string* Label::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Label::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Label.value)
}

// -------------------------------------------------------------------

// Port

// required uint32 number = 1;
inline bool Port::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Port::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Port::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Port::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Port::number() const {
  // @@protoc_insertion_point(field_get:mesos.Port.number)
  return number_;
}
inline void Port::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:mesos.Port.number)
}

// optional string name = 2;
inline bool Port::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Port::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Port::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Port::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Port::name() const {
  // @@protoc_insertion_point(field_get:mesos.Port.name)
  return *name_;
}
inline void Port::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Port.name)
}
inline void Port::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Port.name)
}
inline void Port::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Port.name)
}
inline ::std::string* Port::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Port.name)
  return name_;
}
inline ::std::string* Port::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Port::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.name)
}

// optional string protocol = 3;
inline bool Port::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Port::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Port::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Port::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& Port::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.Port.protocol)
  return *protocol_;
}
inline void Port::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Port.protocol)
}
inline void Port::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Port.protocol)
}
inline void Port::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Port.protocol)
}
inline ::std::string* Port::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Port.protocol)
  return protocol_;
}
inline ::std::string* Port::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Port::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.protocol)
}

// optional .mesos.DiscoveryInfo.Visibility visibility = 4;
inline bool Port::has_visibility() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Port::set_has_visibility() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Port::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Port::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::mesos::DiscoveryInfo_Visibility Port::visibility() const {
  // @@protoc_insertion_point(field_get:mesos.Port.visibility)
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
inline void Port::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:mesos.Port.visibility)
}

// optional .mesos.Labels labels = 5;
inline bool Port::has_labels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Port::set_has_labels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Port::clear_has_labels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Port::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& Port::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Port.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* Port::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.Port.labels)
  return labels_;
}
inline ::mesos::Labels* Port::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void Port::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.labels)
}

// -------------------------------------------------------------------

// Ports

// repeated .mesos.Port ports = 1;
inline int Ports::ports_size() const {
  return ports_.size();
}
inline void Ports::clear_ports() {
  ports_.Clear();
}
inline const ::mesos::Port& Ports::ports(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Ports.ports)
  return ports_.Get(index);
}
inline ::mesos::Port* Ports::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Ports.ports)
  return ports_.Mutable(index);
}
inline ::mesos::Port* Ports::add_ports() {
  // @@protoc_insertion_point(field_add:mesos.Ports.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
Ports::ports() const {
  // @@protoc_insertion_point(field_list:mesos.Ports.ports)
  return ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Port >*
Ports::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Ports.ports)
  return &ports_;
}

// -------------------------------------------------------------------

// DiscoveryInfo

// required .mesos.DiscoveryInfo.Visibility visibility = 1;
inline bool DiscoveryInfo::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoveryInfo::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscoveryInfo::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscoveryInfo::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
inline ::mesos::DiscoveryInfo_Visibility DiscoveryInfo::visibility() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.visibility)
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
inline void DiscoveryInfo::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.visibility)
}

// optional string name = 2;
inline bool DiscoveryInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscoveryInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscoveryInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscoveryInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DiscoveryInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.name)
  return *name_;
}
inline void DiscoveryInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.name)
}
inline void DiscoveryInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.name)
}
inline void DiscoveryInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.name)
}
inline ::std::string* DiscoveryInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.name)
  return name_;
}
inline ::std::string* DiscoveryInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.name)
}

// optional string environment = 3;
inline bool DiscoveryInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscoveryInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscoveryInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscoveryInfo::clear_environment() {
  if (environment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    environment_->clear();
  }
  clear_has_environment();
}
inline const ::std::string& DiscoveryInfo::environment() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.environment)
  return *environment_;
}
inline void DiscoveryInfo::set_environment(const ::std::string& value) {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    environment_ = new ::std::string;
  }
  environment_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.environment)
}
inline void DiscoveryInfo::set_environment(const char* value) {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    environment_ = new ::std::string;
  }
  environment_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.environment)
}
inline void DiscoveryInfo::set_environment(const char* value, size_t size) {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    environment_ = new ::std::string;
  }
  environment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.environment)
}
inline ::std::string* DiscoveryInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    environment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.environment)
  return environment_;
}
inline ::std::string* DiscoveryInfo::release_environment() {
  clear_has_environment();
  if (environment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = environment_;
    environment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_environment(::std::string* environment) {
  if (environment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete environment_;
  }
  if (environment) {
    set_has_environment();
    environment_ = environment;
  } else {
    clear_has_environment();
    environment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.environment)
}

// optional string location = 4;
inline bool DiscoveryInfo::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscoveryInfo::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscoveryInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscoveryInfo::clear_location() {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& DiscoveryInfo::location() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.location)
  return *location_;
}
inline void DiscoveryInfo::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.location)
}
inline void DiscoveryInfo::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.location)
}
inline void DiscoveryInfo::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.location)
}
inline ::std::string* DiscoveryInfo::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.location)
  return location_;
}
inline ::std::string* DiscoveryInfo::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.location)
}

// optional string version = 5;
inline bool DiscoveryInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscoveryInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscoveryInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscoveryInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DiscoveryInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.version)
  return *version_;
}
inline void DiscoveryInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.version)
}
inline void DiscoveryInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.version)
}
inline void DiscoveryInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.version)
}
inline ::std::string* DiscoveryInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.version)
  return version_;
}
inline ::std::string* DiscoveryInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiscoveryInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.version)
}

// optional .mesos.Ports ports = 6;
inline bool DiscoveryInfo::has_ports() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiscoveryInfo::set_has_ports() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiscoveryInfo::clear_has_ports() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiscoveryInfo::clear_ports() {
  if (ports_ != NULL) ports_->::mesos::Ports::Clear();
  clear_has_ports();
}
inline const ::mesos::Ports& DiscoveryInfo::ports() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.ports)
  return ports_ != NULL ? *ports_ : *default_instance_->ports_;
}
inline ::mesos::Ports* DiscoveryInfo::mutable_ports() {
  set_has_ports();
  if (ports_ == NULL) ports_ = new ::mesos::Ports;
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.ports)
  return ports_;
}
inline ::mesos::Ports* DiscoveryInfo::release_ports() {
  clear_has_ports();
  ::mesos::Ports* temp = ports_;
  ports_ = NULL;
  return temp;
}
inline void DiscoveryInfo::set_allocated_ports(::mesos::Ports* ports) {
  delete ports_;
  ports_ = ports;
  if (ports) {
    set_has_ports();
  } else {
    clear_has_ports();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.ports)
}

// optional .mesos.Labels labels = 7;
inline bool DiscoveryInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiscoveryInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiscoveryInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiscoveryInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& DiscoveryInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* DiscoveryInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.labels)
  return labels_;
}
inline ::mesos::Labels* DiscoveryInfo::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void DiscoveryInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.labels)
}

// -------------------------------------------------------------------

// WeightInfo

// required double weight = 1;
inline bool WeightInfo::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeightInfo::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeightInfo::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeightInfo::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double WeightInfo::weight() const {
  // @@protoc_insertion_point(field_get:mesos.WeightInfo.weight)
  return weight_;
}
inline void WeightInfo::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:mesos.WeightInfo.weight)
}

// optional string role = 2;
inline bool WeightInfo::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeightInfo::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeightInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeightInfo::clear_role() {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& WeightInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.WeightInfo.role)
  return *role_;
}
inline void WeightInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.WeightInfo.role)
}
inline void WeightInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.WeightInfo.role)
}
inline void WeightInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.WeightInfo.role)
}
inline ::std::string* WeightInfo::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.WeightInfo.role)
  return role_;
}
inline ::std::string* WeightInfo::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WeightInfo::set_allocated_role(::std::string* role) {
  if (role_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.WeightInfo.role)
}

// -------------------------------------------------------------------

// VersionInfo

// required string version = 1;
inline bool VersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& VersionInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.version)
  return *version_;
}
inline void VersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.version)
}
inline void VersionInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.version)
}
inline void VersionInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.version)
}
inline ::std::string* VersionInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.version)
  return version_;
}
inline ::std::string* VersionInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.version)
}

// optional string build_date = 2;
inline bool VersionInfo::has_build_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionInfo::set_has_build_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionInfo::clear_has_build_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionInfo::clear_build_date() {
  if (build_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_date_->clear();
  }
  clear_has_build_date();
}
inline const ::std::string& VersionInfo::build_date() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_date)
  return *build_date_;
}
inline void VersionInfo::set_build_date(const ::std::string& value) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_date)
}
inline void VersionInfo::set_build_date(const char* value) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.build_date)
}
inline void VersionInfo::set_build_date(const char* value, size_t size) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.build_date)
}
inline ::std::string* VersionInfo::mutable_build_date() {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.build_date)
  return build_date_;
}
inline ::std::string* VersionInfo::release_build_date() {
  clear_has_build_date();
  if (build_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = build_date_;
    build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionInfo::set_allocated_build_date(::std::string* build_date) {
  if (build_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete build_date_;
  }
  if (build_date) {
    set_has_build_date();
    build_date_ = build_date;
  } else {
    clear_has_build_date();
    build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.build_date)
}

// optional double build_time = 3;
inline bool VersionInfo::has_build_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionInfo::set_has_build_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VersionInfo::clear_has_build_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VersionInfo::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
inline double VersionInfo::build_time() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_time)
  return build_time_;
}
inline void VersionInfo::set_build_time(double value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_time)
}

// optional string build_user = 4;
inline bool VersionInfo::has_build_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionInfo::set_has_build_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VersionInfo::clear_has_build_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VersionInfo::clear_build_user() {
  if (build_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_user_->clear();
  }
  clear_has_build_user();
}
inline const ::std::string& VersionInfo::build_user() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_user)
  return *build_user_;
}
inline void VersionInfo::set_build_user(const ::std::string& value) {
  set_has_build_user();
  if (build_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_user_ = new ::std::string;
  }
  build_user_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_user)
}
inline void VersionInfo::set_build_user(const char* value) {
  set_has_build_user();
  if (build_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_user_ = new ::std::string;
  }
  build_user_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.build_user)
}
inline void VersionInfo::set_build_user(const char* value, size_t size) {
  set_has_build_user();
  if (build_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_user_ = new ::std::string;
  }
  build_user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.build_user)
}
inline ::std::string* VersionInfo::mutable_build_user() {
  set_has_build_user();
  if (build_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.build_user)
  return build_user_;
}
inline ::std::string* VersionInfo::release_build_user() {
  clear_has_build_user();
  if (build_user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = build_user_;
    build_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionInfo::set_allocated_build_user(::std::string* build_user) {
  if (build_user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete build_user_;
  }
  if (build_user) {
    set_has_build_user();
    build_user_ = build_user;
  } else {
    clear_has_build_user();
    build_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.build_user)
}

// optional string git_sha = 5;
inline bool VersionInfo::has_git_sha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VersionInfo::set_has_git_sha() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VersionInfo::clear_has_git_sha() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VersionInfo::clear_git_sha() {
  if (git_sha_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_sha_->clear();
  }
  clear_has_git_sha();
}
inline const ::std::string& VersionInfo::git_sha() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_sha)
  return *git_sha_;
}
inline void VersionInfo::set_git_sha(const ::std::string& value) {
  set_has_git_sha();
  if (git_sha_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_sha_ = new ::std::string;
  }
  git_sha_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_sha)
}
inline void VersionInfo::set_git_sha(const char* value) {
  set_has_git_sha();
  if (git_sha_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_sha_ = new ::std::string;
  }
  git_sha_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_sha)
}
inline void VersionInfo::set_git_sha(const char* value, size_t size) {
  set_has_git_sha();
  if (git_sha_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_sha_ = new ::std::string;
  }
  git_sha_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_sha)
}
inline ::std::string* VersionInfo::mutable_git_sha() {
  set_has_git_sha();
  if (git_sha_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_sha_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_sha)
  return git_sha_;
}
inline ::std::string* VersionInfo::release_git_sha() {
  clear_has_git_sha();
  if (git_sha_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = git_sha_;
    git_sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionInfo::set_allocated_git_sha(::std::string* git_sha) {
  if (git_sha_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete git_sha_;
  }
  if (git_sha) {
    set_has_git_sha();
    git_sha_ = git_sha;
  } else {
    clear_has_git_sha();
    git_sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_sha)
}

// optional string git_branch = 6;
inline bool VersionInfo::has_git_branch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VersionInfo::set_has_git_branch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VersionInfo::clear_has_git_branch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VersionInfo::clear_git_branch() {
  if (git_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_branch_->clear();
  }
  clear_has_git_branch();
}
inline const ::std::string& VersionInfo::git_branch() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_branch)
  return *git_branch_;
}
inline void VersionInfo::set_git_branch(const ::std::string& value) {
  set_has_git_branch();
  if (git_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_branch_ = new ::std::string;
  }
  git_branch_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_branch)
}
inline void VersionInfo::set_git_branch(const char* value) {
  set_has_git_branch();
  if (git_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_branch_ = new ::std::string;
  }
  git_branch_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_branch)
}
inline void VersionInfo::set_git_branch(const char* value, size_t size) {
  set_has_git_branch();
  if (git_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_branch_ = new ::std::string;
  }
  git_branch_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_branch)
}
inline ::std::string* VersionInfo::mutable_git_branch() {
  set_has_git_branch();
  if (git_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_branch_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_branch)
  return git_branch_;
}
inline ::std::string* VersionInfo::release_git_branch() {
  clear_has_git_branch();
  if (git_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = git_branch_;
    git_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionInfo::set_allocated_git_branch(::std::string* git_branch) {
  if (git_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete git_branch_;
  }
  if (git_branch) {
    set_has_git_branch();
    git_branch_ = git_branch;
  } else {
    clear_has_git_branch();
    git_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_branch)
}

// optional string git_tag = 7;
inline bool VersionInfo::has_git_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VersionInfo::set_has_git_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VersionInfo::clear_has_git_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VersionInfo::clear_git_tag() {
  if (git_tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_tag_->clear();
  }
  clear_has_git_tag();
}
inline const ::std::string& VersionInfo::git_tag() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_tag)
  return *git_tag_;
}
inline void VersionInfo::set_git_tag(const ::std::string& value) {
  set_has_git_tag();
  if (git_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_tag_ = new ::std::string;
  }
  git_tag_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_tag)
}
inline void VersionInfo::set_git_tag(const char* value) {
  set_has_git_tag();
  if (git_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_tag_ = new ::std::string;
  }
  git_tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_tag)
}
inline void VersionInfo::set_git_tag(const char* value, size_t size) {
  set_has_git_tag();
  if (git_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_tag_ = new ::std::string;
  }
  git_tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_tag)
}
inline ::std::string* VersionInfo::mutable_git_tag() {
  set_has_git_tag();
  if (git_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    git_tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_tag)
  return git_tag_;
}
inline ::std::string* VersionInfo::release_git_tag() {
  clear_has_git_tag();
  if (git_tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = git_tag_;
    git_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionInfo::set_allocated_git_tag(::std::string* git_tag) {
  if (git_tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete git_tag_;
  }
  if (git_tag) {
    set_has_git_tag();
    git_tag_ = git_tag;
  } else {
    clear_has_git_tag();
    git_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_tag)
}

// -------------------------------------------------------------------

// Flag

// required string name = 1;
inline bool Flag::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Flag::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Flag::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Flag::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Flag::name() const {
  // @@protoc_insertion_point(field_get:mesos.Flag.name)
  return *name_;
}
inline void Flag::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Flag.name)
}
inline void Flag::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Flag.name)
}
inline void Flag::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Flag.name)
}
inline ::std::string* Flag::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Flag.name)
  return name_;
}
inline ::std::string* Flag::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Flag::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Flag.name)
}

// optional string value = 2;
inline bool Flag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Flag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Flag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Flag::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Flag::value() const {
  // @@protoc_insertion_point(field_get:mesos.Flag.value)
  return *value_;
}
inline void Flag::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Flag.value)
}
inline void Flag::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Flag.value)
}
inline void Flag::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Flag.value)
}
inline ::std::string* Flag::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Flag.value)
  return value_;
}
inline ::std::string* Flag::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Flag::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Flag.value)
}

// -------------------------------------------------------------------

// Role

// required string name = 1;
inline bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Role::name() const {
  // @@protoc_insertion_point(field_get:mesos.Role.name)
  return *name_;
}
inline void Role::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Role.name)
}
inline void Role::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Role.name)
}
inline void Role::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Role.name)
}
inline ::std::string* Role::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Role.name)
  return name_;
}
inline ::std::string* Role::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Role::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Role.name)
}

// required double weight = 2;
inline bool Role::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double Role::weight() const {
  // @@protoc_insertion_point(field_get:mesos.Role.weight)
  return weight_;
}
inline void Role::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:mesos.Role.weight)
}

// repeated .mesos.FrameworkID frameworks = 3;
inline int Role::frameworks_size() const {
  return frameworks_.size();
}
inline void Role::clear_frameworks() {
  frameworks_.Clear();
}
inline const ::mesos::FrameworkID& Role::frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Role.frameworks)
  return frameworks_.Get(index);
}
inline ::mesos::FrameworkID* Role::mutable_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Role.frameworks)
  return frameworks_.Mutable(index);
}
inline ::mesos::FrameworkID* Role::add_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.Role.frameworks)
  return frameworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >&
Role::frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.Role.frameworks)
  return frameworks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >*
Role::mutable_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Role.frameworks)
  return &frameworks_;
}

// repeated .mesos.Resource resources = 4;
inline int Role::resources_size() const {
  return resources_.size();
}
inline void Role::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Role::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Role.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* Role::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Role.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Role::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Role.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Role::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Role.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Role::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Role.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// Metric

// required string name = 1;
inline bool Metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metric::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Metric::name() const {
  // @@protoc_insertion_point(field_get:mesos.Metric.name)
  return *name_;
}
inline void Metric::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Metric.name)
}
inline void Metric::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Metric.name)
}
inline void Metric::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Metric.name)
}
inline ::std::string* Metric::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Metric.name)
  return name_;
}
inline ::std::string* Metric::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Metric::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Metric.name)
}

// optional double value = 2;
inline bool Metric::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Metric::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Metric::value() const {
  // @@protoc_insertion_point(field_get:mesos.Metric.value)
  return value_;
}
inline void Metric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.Metric.value)
}

// -------------------------------------------------------------------

// FileInfo

// required string path = 1;
inline bool FileInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& FileInfo::path() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.path)
  return *path_;
}
inline void FileInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FileInfo.path)
}
inline void FileInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.path)
}
inline void FileInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.path)
}
inline ::std::string* FileInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.path)
  return path_;
}
inline ::std::string* FileInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileInfo::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.path)
}

// optional int32 nlink = 2;
inline bool FileInfo::has_nlink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileInfo::set_has_nlink() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileInfo::clear_has_nlink() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileInfo::clear_nlink() {
  nlink_ = 0;
  clear_has_nlink();
}
inline ::google::protobuf::int32 FileInfo::nlink() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.nlink)
  return nlink_;
}
inline void FileInfo::set_nlink(::google::protobuf::int32 value) {
  set_has_nlink();
  nlink_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.nlink)
}

// optional uint64 size = 3;
inline bool FileInfo::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileInfo::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 FileInfo::size() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.size)
  return size_;
}
inline void FileInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.size)
}

// optional .mesos.TimeInfo mtime = 4;
inline bool FileInfo::has_mtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileInfo::set_has_mtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileInfo::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileInfo::clear_mtime() {
  if (mtime_ != NULL) mtime_->::mesos::TimeInfo::Clear();
  clear_has_mtime();
}
inline const ::mesos::TimeInfo& FileInfo::mtime() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.mtime)
  return mtime_ != NULL ? *mtime_ : *default_instance_->mtime_;
}
inline ::mesos::TimeInfo* FileInfo::mutable_mtime() {
  set_has_mtime();
  if (mtime_ == NULL) mtime_ = new ::mesos::TimeInfo;
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.mtime)
  return mtime_;
}
inline ::mesos::TimeInfo* FileInfo::release_mtime() {
  clear_has_mtime();
  ::mesos::TimeInfo* temp = mtime_;
  mtime_ = NULL;
  return temp;
}
inline void FileInfo::set_allocated_mtime(::mesos::TimeInfo* mtime) {
  delete mtime_;
  mtime_ = mtime;
  if (mtime) {
    set_has_mtime();
  } else {
    clear_has_mtime();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.mtime)
}

// optional uint32 mode = 5;
inline bool FileInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileInfo::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 FileInfo::mode() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.mode)
  return mode_;
}
inline void FileInfo::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.mode)
}

// optional string uid = 6;
inline bool FileInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& FileInfo::uid() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.uid)
  return *uid_;
}
inline void FileInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FileInfo.uid)
}
inline void FileInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.uid)
}
inline void FileInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.uid)
}
inline ::std::string* FileInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.uid)
  return uid_;
}
inline ::std::string* FileInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileInfo::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.uid)
}

// optional string gid = 7;
inline bool FileInfo::has_gid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileInfo::set_has_gid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileInfo::clear_has_gid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileInfo::clear_gid() {
  if (gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& FileInfo::gid() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.gid)
  return *gid_;
}
inline void FileInfo::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.FileInfo.gid)
}
inline void FileInfo::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.gid)
}
inline void FileInfo::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.gid)
}
inline ::std::string* FileInfo::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.gid)
  return gid_;
}
inline ::std::string* FileInfo::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileInfo::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.gid)
}

// -------------------------------------------------------------------

// Device

// required string path = 1;
inline bool Device::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Device::path() const {
  // @@protoc_insertion_point(field_get:mesos.Device.path)
  return *path_;
}
inline void Device::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.Device.path)
}
inline void Device::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Device.path)
}
inline void Device::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Device.path)
}
inline ::std::string* Device::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Device.path)
  return path_;
}
inline ::std::string* Device::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Device.path)
}

// -------------------------------------------------------------------

// DeviceAccess_Access

// optional bool read = 1;
inline bool DeviceAccess_Access::has_read() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAccess_Access::set_has_read() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAccess_Access::clear_has_read() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAccess_Access::clear_read() {
  read_ = false;
  clear_has_read();
}
inline bool DeviceAccess_Access::read() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.Access.read)
  return read_;
}
inline void DeviceAccess_Access::set_read(bool value) {
  set_has_read();
  read_ = value;
  // @@protoc_insertion_point(field_set:mesos.DeviceAccess.Access.read)
}

// optional bool write = 2;
inline bool DeviceAccess_Access::has_write() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAccess_Access::set_has_write() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAccess_Access::clear_has_write() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAccess_Access::clear_write() {
  write_ = false;
  clear_has_write();
}
inline bool DeviceAccess_Access::write() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.Access.write)
  return write_;
}
inline void DeviceAccess_Access::set_write(bool value) {
  set_has_write();
  write_ = value;
  // @@protoc_insertion_point(field_set:mesos.DeviceAccess.Access.write)
}

// optional bool mknod = 3;
inline bool DeviceAccess_Access::has_mknod() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceAccess_Access::set_has_mknod() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceAccess_Access::clear_has_mknod() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceAccess_Access::clear_mknod() {
  mknod_ = false;
  clear_has_mknod();
}
inline bool DeviceAccess_Access::mknod() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.Access.mknod)
  return mknod_;
}
inline void DeviceAccess_Access::set_mknod(bool value) {
  set_has_mknod();
  mknod_ = value;
  // @@protoc_insertion_point(field_set:mesos.DeviceAccess.Access.mknod)
}

// -------------------------------------------------------------------

// DeviceAccess

// required .mesos.Device device = 1;
inline bool DeviceAccess::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceAccess::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceAccess::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceAccess::clear_device() {
  if (device_ != NULL) device_->::mesos::Device::Clear();
  clear_has_device();
}
inline const ::mesos::Device& DeviceAccess::device() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.device)
  return device_ != NULL ? *device_ : *default_instance_->device_;
}
inline ::mesos::Device* DeviceAccess::mutable_device() {
  set_has_device();
  if (device_ == NULL) device_ = new ::mesos::Device;
  // @@protoc_insertion_point(field_mutable:mesos.DeviceAccess.device)
  return device_;
}
inline ::mesos::Device* DeviceAccess::release_device() {
  clear_has_device();
  ::mesos::Device* temp = device_;
  device_ = NULL;
  return temp;
}
inline void DeviceAccess::set_allocated_device(::mesos::Device* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DeviceAccess.device)
}

// required .mesos.DeviceAccess.Access access = 2;
inline bool DeviceAccess::has_access() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceAccess::set_has_access() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceAccess::clear_has_access() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceAccess::clear_access() {
  if (access_ != NULL) access_->::mesos::DeviceAccess_Access::Clear();
  clear_has_access();
}
inline const ::mesos::DeviceAccess_Access& DeviceAccess::access() const {
  // @@protoc_insertion_point(field_get:mesos.DeviceAccess.access)
  return access_ != NULL ? *access_ : *default_instance_->access_;
}
inline ::mesos::DeviceAccess_Access* DeviceAccess::mutable_access() {
  set_has_access();
  if (access_ == NULL) access_ = new ::mesos::DeviceAccess_Access;
  // @@protoc_insertion_point(field_mutable:mesos.DeviceAccess.access)
  return access_;
}
inline ::mesos::DeviceAccess_Access* DeviceAccess::release_access() {
  clear_has_access();
  ::mesos::DeviceAccess_Access* temp = access_;
  access_ = NULL;
  return temp;
}
inline void DeviceAccess::set_allocated_access(::mesos::DeviceAccess_Access* access) {
  delete access_;
  access_ = access;
  if (access) {
    set_has_access();
  } else {
    clear_has_access();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DeviceAccess.access)
}

// -------------------------------------------------------------------

// DeviceWhitelist

// repeated .mesos.DeviceAccess allowed_devices = 1;
inline int DeviceWhitelist::allowed_devices_size() const {
  return allowed_devices_.size();
}
inline void DeviceWhitelist::clear_allowed_devices() {
  allowed_devices_.Clear();
}
inline const ::mesos::DeviceAccess& DeviceWhitelist::allowed_devices(int index) const {
  // @@protoc_insertion_point(field_get:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_.Get(index);
}
inline ::mesos::DeviceAccess* DeviceWhitelist::mutable_allowed_devices(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_.Mutable(index);
}
inline ::mesos::DeviceAccess* DeviceWhitelist::add_allowed_devices() {
  // @@protoc_insertion_point(field_add:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >&
DeviceWhitelist::allowed_devices() const {
  // @@protoc_insertion_point(field_list:mesos.DeviceWhitelist.allowed_devices)
  return allowed_devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::DeviceAccess >*
DeviceWhitelist::mutable_allowed_devices() {
  // @@protoc_insertion_point(field_mutable_list:mesos.DeviceWhitelist.allowed_devices)
  return &allowed_devices_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::MachineInfo_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::MachineInfo_Mode>() {
  return ::mesos::MachineInfo_Mode_descriptor();
}
template <> struct is_proto_enum< ::mesos::FrameworkInfo_Capability_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::FrameworkInfo_Capability_Type>() {
  return ::mesos::FrameworkInfo_Capability_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::CheckInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::CheckInfo_Type>() {
  return ::mesos::CheckInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::HealthCheck_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::HealthCheck_Type>() {
  return ::mesos::HealthCheck_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::ExecutorInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ExecutorInfo_Type>() {
  return ::mesos::ExecutorInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::SlaveInfo_Capability_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::SlaveInfo_Capability_Type>() {
  return ::mesos::SlaveInfo_Capability_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Value_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Value_Type>() {
  return ::mesos::Value_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Resource_DiskInfo_Source_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Resource_DiskInfo_Source_Type>() {
  return ::mesos::Resource_DiskInfo_Source_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Offer_Operation_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Offer_Operation_Type>() {
  return ::mesos::Offer_Operation_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::TaskStatus_Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskStatus_Source>() {
  return ::mesos::TaskStatus_Source_descriptor();
}
template <> struct is_proto_enum< ::mesos::TaskStatus_Reason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskStatus_Reason>() {
  return ::mesos::TaskStatus_Reason_descriptor();
}
template <> struct is_proto_enum< ::mesos::Environment_Variable_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Environment_Variable_Type>() {
  return ::mesos::Environment_Variable_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Secret_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Secret_Type>() {
  return ::mesos::Secret_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Image_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Image_Type>() {
  return ::mesos::Image_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Volume_Source_SandboxPath_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Source_SandboxPath_Type>() {
  return ::mesos::Volume_Source_SandboxPath_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Volume_Source_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Source_Type>() {
  return ::mesos::Volume_Source_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::Volume_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Volume_Mode>() {
  return ::mesos::Volume_Mode_descriptor();
}
template <> struct is_proto_enum< ::mesos::NetworkInfo_Protocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::NetworkInfo_Protocol>() {
  return ::mesos::NetworkInfo_Protocol_descriptor();
}
template <> struct is_proto_enum< ::mesos::CapabilityInfo_Capability> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::CapabilityInfo_Capability>() {
  return ::mesos::CapabilityInfo_Capability_descriptor();
}
template <> struct is_proto_enum< ::mesos::RLimitInfo_RLimit_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::RLimitInfo_RLimit_Type>() {
  return ::mesos::RLimitInfo_RLimit_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::ContainerInfo_DockerInfo_Network> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ContainerInfo_DockerInfo_Network>() {
  return ::mesos::ContainerInfo_DockerInfo_Network_descriptor();
}
template <> struct is_proto_enum< ::mesos::ContainerInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ContainerInfo_Type>() {
  return ::mesos::ContainerInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::DiscoveryInfo_Visibility> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::DiscoveryInfo_Visibility>() {
  return ::mesos::DiscoveryInfo_Visibility_descriptor();
}
template <> struct is_proto_enum< ::mesos::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Status>() {
  return ::mesos::Status_descriptor();
}
template <> struct is_proto_enum< ::mesos::TaskState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskState>() {
  return ::mesos::TaskState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2eproto__INCLUDED
