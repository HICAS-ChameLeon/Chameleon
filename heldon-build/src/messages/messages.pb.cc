// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {
namespace internal {

namespace {

const ::google::protobuf::Descriptor* StatusUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdateRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdateRecord_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StatusUpdateRecord_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SubmitSchedulerRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubmitSchedulerRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubmitSchedulerResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubmitSchedulerResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorToFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorToFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkToExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkToExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReregisterFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReregisterFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkRegisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkRegisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkReregisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkReregisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnregisterFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnregisterFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeactivateFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeactivateFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceRequestMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceRequestMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceOffersMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceOffersMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* InverseOffersMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InverseOffersMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaunchTasksMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaunchTasksMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RescindResourceOfferMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RescindResourceOfferMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RescindInverseOfferMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RescindInverseOfferMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReviveOffersMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReviveOffersMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RunTaskMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RunTaskMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RunTaskGroupMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RunTaskGroupMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* KillTaskMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KillTaskMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdateMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdateMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* StatusUpdateAcknowledgementMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StatusUpdateAcknowledgementMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* LostSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LostSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReconcileTasksMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconcileTasksMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkErrorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkErrorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReregisterSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReregisterSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveRegisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveRegisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveReregisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveReregisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnregisterSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnregisterSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* MasterSlaveConnection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterSlaveConnection_reflection_ = NULL;
const ::google::protobuf::Descriptor* PingSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PingSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* PongSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PongSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShutdownFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShutdownFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShutdownExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShutdownExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateFrameworkMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateFrameworkMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckpointResourcesMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckpointResourcesMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateSlaveMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateSlaveMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorRegisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorRegisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorReregisteredMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorReregisteredMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExitedExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExitedExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReconnectExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconnectExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReregisterExecutorMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReregisterExecutorMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShutdownMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShutdownMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* Archive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Archive_reflection_ = NULL;
const ::google::protobuf::Descriptor* Archive_Framework_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Archive_Framework_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskHealthStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskHealthStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* HookExecuted_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HookExecuted_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  StatusUpdate_descriptor_ = file->message_type(0);
  static const int StatusUpdate_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, latest_state_),
  };
  StatusUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdate_descriptor_,
      StatusUpdate::default_instance_,
      StatusUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdate));
  StatusUpdateRecord_descriptor_ = file->message_type(1);
  static const int StatusUpdateRecord_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, uuid_),
  };
  StatusUpdateRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdateRecord_descriptor_,
      StatusUpdateRecord::default_instance_,
      StatusUpdateRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdateRecord));
  StatusUpdateRecord_Type_descriptor_ = StatusUpdateRecord_descriptor_->enum_type(0);
  SubmitSchedulerRequest_descriptor_ = file->message_type(2);
  static const int SubmitSchedulerRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerRequest, name_),
  };
  SubmitSchedulerRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubmitSchedulerRequest_descriptor_,
      SubmitSchedulerRequest::default_instance_,
      SubmitSchedulerRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubmitSchedulerRequest));
  SubmitSchedulerResponse_descriptor_ = file->message_type(3);
  static const int SubmitSchedulerResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerResponse, okay_),
  };
  SubmitSchedulerResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SubmitSchedulerResponse_descriptor_,
      SubmitSchedulerResponse::default_instance_,
      SubmitSchedulerResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubmitSchedulerResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SubmitSchedulerResponse));
  ExecutorToFrameworkMessage_descriptor_ = file->message_type(4);
  static const int ExecutorToFrameworkMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, data_),
  };
  ExecutorToFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorToFrameworkMessage_descriptor_,
      ExecutorToFrameworkMessage::default_instance_,
      ExecutorToFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorToFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorToFrameworkMessage));
  FrameworkToExecutorMessage_descriptor_ = file->message_type(5);
  static const int FrameworkToExecutorMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, data_),
  };
  FrameworkToExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkToExecutorMessage_descriptor_,
      FrameworkToExecutorMessage::default_instance_,
      FrameworkToExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkToExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkToExecutorMessage));
  RegisterFrameworkMessage_descriptor_ = file->message_type(6);
  static const int RegisterFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterFrameworkMessage, framework_),
  };
  RegisterFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterFrameworkMessage_descriptor_,
      RegisterFrameworkMessage::default_instance_,
      RegisterFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterFrameworkMessage));
  ReregisterFrameworkMessage_descriptor_ = file->message_type(7);
  static const int ReregisterFrameworkMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, framework_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, failover_),
  };
  ReregisterFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReregisterFrameworkMessage_descriptor_,
      ReregisterFrameworkMessage::default_instance_,
      ReregisterFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReregisterFrameworkMessage));
  FrameworkRegisteredMessage_descriptor_ = file->message_type(8);
  static const int FrameworkRegisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, master_info_),
  };
  FrameworkRegisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkRegisteredMessage_descriptor_,
      FrameworkRegisteredMessage::default_instance_,
      FrameworkRegisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkRegisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkRegisteredMessage));
  FrameworkReregisteredMessage_descriptor_ = file->message_type(9);
  static const int FrameworkReregisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, master_info_),
  };
  FrameworkReregisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkReregisteredMessage_descriptor_,
      FrameworkReregisteredMessage::default_instance_,
      FrameworkReregisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkReregisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkReregisteredMessage));
  UnregisterFrameworkMessage_descriptor_ = file->message_type(10);
  static const int UnregisterFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterFrameworkMessage, framework_id_),
  };
  UnregisterFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnregisterFrameworkMessage_descriptor_,
      UnregisterFrameworkMessage::default_instance_,
      UnregisterFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnregisterFrameworkMessage));
  DeactivateFrameworkMessage_descriptor_ = file->message_type(11);
  static const int DeactivateFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeactivateFrameworkMessage, framework_id_),
  };
  DeactivateFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeactivateFrameworkMessage_descriptor_,
      DeactivateFrameworkMessage::default_instance_,
      DeactivateFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeactivateFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeactivateFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeactivateFrameworkMessage));
  ResourceRequestMessage_descriptor_ = file->message_type(12);
  static const int ResourceRequestMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, requests_),
  };
  ResourceRequestMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceRequestMessage_descriptor_,
      ResourceRequestMessage::default_instance_,
      ResourceRequestMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceRequestMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceRequestMessage));
  ResourceOffersMessage_descriptor_ = file->message_type(13);
  static const int ResourceOffersMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, pids_),
  };
  ResourceOffersMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceOffersMessage_descriptor_,
      ResourceOffersMessage::default_instance_,
      ResourceOffersMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceOffersMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceOffersMessage));
  InverseOffersMessage_descriptor_ = file->message_type(14);
  static const int InverseOffersMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffersMessage, inverse_offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffersMessage, pids_),
  };
  InverseOffersMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InverseOffersMessage_descriptor_,
      InverseOffersMessage::default_instance_,
      InverseOffersMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffersMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffersMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InverseOffersMessage));
  LaunchTasksMessage_descriptor_ = file->message_type(15);
  static const int LaunchTasksMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, filters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, offer_ids_),
  };
  LaunchTasksMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LaunchTasksMessage_descriptor_,
      LaunchTasksMessage::default_instance_,
      LaunchTasksMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaunchTasksMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LaunchTasksMessage));
  RescindResourceOfferMessage_descriptor_ = file->message_type(16);
  static const int RescindResourceOfferMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindResourceOfferMessage, offer_id_),
  };
  RescindResourceOfferMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RescindResourceOfferMessage_descriptor_,
      RescindResourceOfferMessage::default_instance_,
      RescindResourceOfferMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindResourceOfferMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindResourceOfferMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RescindResourceOfferMessage));
  RescindInverseOfferMessage_descriptor_ = file->message_type(17);
  static const int RescindInverseOfferMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindInverseOfferMessage, inverse_offer_id_),
  };
  RescindInverseOfferMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RescindInverseOfferMessage_descriptor_,
      RescindInverseOfferMessage::default_instance_,
      RescindInverseOfferMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindInverseOfferMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RescindInverseOfferMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RescindInverseOfferMessage));
  ReviveOffersMessage_descriptor_ = file->message_type(18);
  static const int ReviveOffersMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, roles_),
  };
  ReviveOffersMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReviveOffersMessage_descriptor_,
      ReviveOffersMessage::default_instance_,
      ReviveOffersMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReviveOffersMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReviveOffersMessage));
  RunTaskMessage_descriptor_ = file->message_type(19);
  static const int RunTaskMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, framework_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, task_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, pid_),
  };
  RunTaskMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RunTaskMessage_descriptor_,
      RunTaskMessage::default_instance_,
      RunTaskMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RunTaskMessage));
  RunTaskGroupMessage_descriptor_ = file->message_type(20);
  static const int RunTaskGroupMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskGroupMessage, framework_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskGroupMessage, executor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskGroupMessage, task_group_),
  };
  RunTaskGroupMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RunTaskGroupMessage_descriptor_,
      RunTaskGroupMessage::default_instance_,
      RunTaskGroupMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskGroupMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunTaskGroupMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RunTaskGroupMessage));
  KillTaskMessage_descriptor_ = file->message_type(21);
  static const int KillTaskMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, kill_policy_),
  };
  KillTaskMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KillTaskMessage_descriptor_,
      KillTaskMessage::default_instance_,
      KillTaskMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillTaskMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KillTaskMessage));
  StatusUpdateMessage_descriptor_ = file->message_type(22);
  static const int StatusUpdateMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, pid_),
  };
  StatusUpdateMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdateMessage_descriptor_,
      StatusUpdateMessage::default_instance_,
      StatusUpdateMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdateMessage));
  StatusUpdateAcknowledgementMessage_descriptor_ = file->message_type(23);
  static const int StatusUpdateAcknowledgementMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, uuid_),
  };
  StatusUpdateAcknowledgementMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StatusUpdateAcknowledgementMessage_descriptor_,
      StatusUpdateAcknowledgementMessage::default_instance_,
      StatusUpdateAcknowledgementMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StatusUpdateAcknowledgementMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StatusUpdateAcknowledgementMessage));
  LostSlaveMessage_descriptor_ = file->message_type(24);
  static const int LostSlaveMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LostSlaveMessage, slave_id_),
  };
  LostSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LostSlaveMessage_descriptor_,
      LostSlaveMessage::default_instance_,
      LostSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LostSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LostSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LostSlaveMessage));
  ReconcileTasksMessage_descriptor_ = file->message_type(25);
  static const int ReconcileTasksMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, statuses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, framework_),
  };
  ReconcileTasksMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReconcileTasksMessage_descriptor_,
      ReconcileTasksMessage::default_instance_,
      ReconcileTasksMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconcileTasksMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReconcileTasksMessage));
  FrameworkErrorMessage_descriptor_ = file->message_type(26);
  static const int FrameworkErrorMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkErrorMessage, message_),
  };
  FrameworkErrorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkErrorMessage_descriptor_,
      FrameworkErrorMessage::default_instance_,
      FrameworkErrorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkErrorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkErrorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkErrorMessage));
  RegisterSlaveMessage_descriptor_ = file->message_type(27);
  static const int RegisterSlaveMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, slave_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, checkpointed_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, agent_capabilities_),
  };
  RegisterSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterSlaveMessage_descriptor_,
      RegisterSlaveMessage::default_instance_,
      RegisterSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterSlaveMessage));
  ReregisterSlaveMessage_descriptor_ = file->message_type(28);
  static const int ReregisterSlaveMessage_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, slave_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, checkpointed_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, executor_infos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, frameworks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, completed_frameworks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, agent_capabilities_),
  };
  ReregisterSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReregisterSlaveMessage_descriptor_,
      ReregisterSlaveMessage::default_instance_,
      ReregisterSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReregisterSlaveMessage));
  SlaveRegisteredMessage_descriptor_ = file->message_type(29);
  static const int SlaveRegisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, connection_),
  };
  SlaveRegisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveRegisteredMessage_descriptor_,
      SlaveRegisteredMessage::default_instance_,
      SlaveRegisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveRegisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveRegisteredMessage));
  SlaveReregisteredMessage_descriptor_ = file->message_type(30);
  static const int SlaveReregisteredMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, reconciliations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, connection_),
  };
  SlaveReregisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveReregisteredMessage_descriptor_,
      SlaveReregisteredMessage::default_instance_,
      SlaveReregisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveReregisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveReregisteredMessage));
  UnregisterSlaveMessage_descriptor_ = file->message_type(31);
  static const int UnregisterSlaveMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterSlaveMessage, slave_id_),
  };
  UnregisterSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnregisterSlaveMessage_descriptor_,
      UnregisterSlaveMessage::default_instance_,
      UnregisterSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnregisterSlaveMessage));
  MasterSlaveConnection_descriptor_ = file->message_type(32);
  static const int MasterSlaveConnection_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterSlaveConnection, total_ping_timeout_seconds_),
  };
  MasterSlaveConnection_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MasterSlaveConnection_descriptor_,
      MasterSlaveConnection::default_instance_,
      MasterSlaveConnection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterSlaveConnection, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterSlaveConnection, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MasterSlaveConnection));
  PingSlaveMessage_descriptor_ = file->message_type(33);
  static const int PingSlaveMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingSlaveMessage, connected_),
  };
  PingSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PingSlaveMessage_descriptor_,
      PingSlaveMessage::default_instance_,
      PingSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PingSlaveMessage));
  PongSlaveMessage_descriptor_ = file->message_type(34);
  static const int PongSlaveMessage_offsets_[1] = {
  };
  PongSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PongSlaveMessage_descriptor_,
      PongSlaveMessage::default_instance_,
      PongSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PongSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PongSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PongSlaveMessage));
  ShutdownFrameworkMessage_descriptor_ = file->message_type(35);
  static const int ShutdownFrameworkMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownFrameworkMessage, framework_id_),
  };
  ShutdownFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShutdownFrameworkMessage_descriptor_,
      ShutdownFrameworkMessage::default_instance_,
      ShutdownFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShutdownFrameworkMessage));
  ShutdownExecutorMessage_descriptor_ = file->message_type(36);
  static const int ShutdownExecutorMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, framework_id_),
  };
  ShutdownExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShutdownExecutorMessage_descriptor_,
      ShutdownExecutorMessage::default_instance_,
      ShutdownExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShutdownExecutorMessage));
  UpdateFrameworkMessage_descriptor_ = file->message_type(37);
  static const int UpdateFrameworkMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, framework_info_),
  };
  UpdateFrameworkMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateFrameworkMessage_descriptor_,
      UpdateFrameworkMessage::default_instance_,
      UpdateFrameworkMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateFrameworkMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateFrameworkMessage));
  CheckpointResourcesMessage_descriptor_ = file->message_type(38);
  static const int CheckpointResourcesMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointResourcesMessage, resources_),
  };
  CheckpointResourcesMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckpointResourcesMessage_descriptor_,
      CheckpointResourcesMessage::default_instance_,
      CheckpointResourcesMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointResourcesMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointResourcesMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckpointResourcesMessage));
  UpdateSlaveMessage_descriptor_ = file->message_type(39);
  static const int UpdateSlaveMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, oversubscribed_resources_),
  };
  UpdateSlaveMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateSlaveMessage_descriptor_,
      UpdateSlaveMessage::default_instance_,
      UpdateSlaveMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateSlaveMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateSlaveMessage));
  RegisterExecutorMessage_descriptor_ = file->message_type(40);
  static const int RegisterExecutorMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, executor_id_),
  };
  RegisterExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterExecutorMessage_descriptor_,
      RegisterExecutorMessage::default_instance_,
      RegisterExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterExecutorMessage));
  ExecutorRegisteredMessage_descriptor_ = file->message_type(41);
  static const int ExecutorRegisteredMessage_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, executor_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, framework_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, slave_info_),
  };
  ExecutorRegisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorRegisteredMessage_descriptor_,
      ExecutorRegisteredMessage::default_instance_,
      ExecutorRegisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorRegisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorRegisteredMessage));
  ExecutorReregisteredMessage_descriptor_ = file->message_type(42);
  static const int ExecutorReregisteredMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, slave_info_),
  };
  ExecutorReregisteredMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutorReregisteredMessage_descriptor_,
      ExecutorReregisteredMessage::default_instance_,
      ExecutorReregisteredMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorReregisteredMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutorReregisteredMessage));
  ExitedExecutorMessage_descriptor_ = file->message_type(43);
  static const int ExitedExecutorMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, status_),
  };
  ExitedExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExitedExecutorMessage_descriptor_,
      ExitedExecutorMessage::default_instance_,
      ExitedExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExitedExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExitedExecutorMessage));
  ReconnectExecutorMessage_descriptor_ = file->message_type(44);
  static const int ReconnectExecutorMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconnectExecutorMessage, slave_id_),
  };
  ReconnectExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReconnectExecutorMessage_descriptor_,
      ReconnectExecutorMessage::default_instance_,
      ReconnectExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconnectExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconnectExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReconnectExecutorMessage));
  ReregisterExecutorMessage_descriptor_ = file->message_type(45);
  static const int ReregisterExecutorMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, updates_),
  };
  ReregisterExecutorMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReregisterExecutorMessage_descriptor_,
      ReregisterExecutorMessage::default_instance_,
      ReregisterExecutorMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReregisterExecutorMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReregisterExecutorMessage));
  ShutdownMessage_descriptor_ = file->message_type(46);
  static const int ShutdownMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownMessage, message_),
  };
  ShutdownMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShutdownMessage_descriptor_,
      ShutdownMessage::default_instance_,
      ShutdownMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShutdownMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShutdownMessage));
  Archive_descriptor_ = file->message_type(47);
  static const int Archive_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive, frameworks_),
  };
  Archive_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Archive_descriptor_,
      Archive::default_instance_,
      Archive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Archive));
  Archive_Framework_descriptor_ = Archive_descriptor_->nested_type(0);
  static const int Archive_Framework_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, framework_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, tasks_),
  };
  Archive_Framework_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Archive_Framework_descriptor_,
      Archive_Framework::default_instance_,
      Archive_Framework_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Archive_Framework, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Archive_Framework));
  TaskHealthStatus_descriptor_ = file->message_type(48);
  static const int TaskHealthStatus_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, healthy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, kill_task_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, consecutive_failures_),
  };
  TaskHealthStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskHealthStatus_descriptor_,
      TaskHealthStatus::default_instance_,
      TaskHealthStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskHealthStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskHealthStatus));
  HookExecuted_descriptor_ = file->message_type(49);
  static const int HookExecuted_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HookExecuted, module_),
  };
  HookExecuted_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HookExecuted_descriptor_,
      HookExecuted::default_instance_,
      HookExecuted_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HookExecuted, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HookExecuted, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HookExecuted));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdate_descriptor_, &StatusUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdateRecord_descriptor_, &StatusUpdateRecord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubmitSchedulerRequest_descriptor_, &SubmitSchedulerRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SubmitSchedulerResponse_descriptor_, &SubmitSchedulerResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorToFrameworkMessage_descriptor_, &ExecutorToFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkToExecutorMessage_descriptor_, &FrameworkToExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterFrameworkMessage_descriptor_, &RegisterFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReregisterFrameworkMessage_descriptor_, &ReregisterFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkRegisteredMessage_descriptor_, &FrameworkRegisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkReregisteredMessage_descriptor_, &FrameworkReregisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnregisterFrameworkMessage_descriptor_, &UnregisterFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeactivateFrameworkMessage_descriptor_, &DeactivateFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceRequestMessage_descriptor_, &ResourceRequestMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceOffersMessage_descriptor_, &ResourceOffersMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InverseOffersMessage_descriptor_, &InverseOffersMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LaunchTasksMessage_descriptor_, &LaunchTasksMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RescindResourceOfferMessage_descriptor_, &RescindResourceOfferMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RescindInverseOfferMessage_descriptor_, &RescindInverseOfferMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReviveOffersMessage_descriptor_, &ReviveOffersMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RunTaskMessage_descriptor_, &RunTaskMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RunTaskGroupMessage_descriptor_, &RunTaskGroupMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KillTaskMessage_descriptor_, &KillTaskMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdateMessage_descriptor_, &StatusUpdateMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StatusUpdateAcknowledgementMessage_descriptor_, &StatusUpdateAcknowledgementMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LostSlaveMessage_descriptor_, &LostSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReconcileTasksMessage_descriptor_, &ReconcileTasksMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkErrorMessage_descriptor_, &FrameworkErrorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterSlaveMessage_descriptor_, &RegisterSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReregisterSlaveMessage_descriptor_, &ReregisterSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveRegisteredMessage_descriptor_, &SlaveRegisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveReregisteredMessage_descriptor_, &SlaveReregisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnregisterSlaveMessage_descriptor_, &UnregisterSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MasterSlaveConnection_descriptor_, &MasterSlaveConnection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PingSlaveMessage_descriptor_, &PingSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PongSlaveMessage_descriptor_, &PongSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShutdownFrameworkMessage_descriptor_, &ShutdownFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShutdownExecutorMessage_descriptor_, &ShutdownExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateFrameworkMessage_descriptor_, &UpdateFrameworkMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckpointResourcesMessage_descriptor_, &CheckpointResourcesMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateSlaveMessage_descriptor_, &UpdateSlaveMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterExecutorMessage_descriptor_, &RegisterExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorRegisteredMessage_descriptor_, &ExecutorRegisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutorReregisteredMessage_descriptor_, &ExecutorReregisteredMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExitedExecutorMessage_descriptor_, &ExitedExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReconnectExecutorMessage_descriptor_, &ReconnectExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReregisterExecutorMessage_descriptor_, &ReregisterExecutorMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShutdownMessage_descriptor_, &ShutdownMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Archive_descriptor_, &Archive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Archive_Framework_descriptor_, &Archive_Framework::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskHealthStatus_descriptor_, &TaskHealthStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HookExecuted_descriptor_, &HookExecuted::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete StatusUpdate::default_instance_;
  delete StatusUpdate_reflection_;
  delete StatusUpdateRecord::default_instance_;
  delete StatusUpdateRecord_reflection_;
  delete SubmitSchedulerRequest::default_instance_;
  delete SubmitSchedulerRequest_reflection_;
  delete SubmitSchedulerResponse::default_instance_;
  delete SubmitSchedulerResponse_reflection_;
  delete ExecutorToFrameworkMessage::default_instance_;
  delete ExecutorToFrameworkMessage_reflection_;
  delete FrameworkToExecutorMessage::default_instance_;
  delete FrameworkToExecutorMessage_reflection_;
  delete RegisterFrameworkMessage::default_instance_;
  delete RegisterFrameworkMessage_reflection_;
  delete ReregisterFrameworkMessage::default_instance_;
  delete ReregisterFrameworkMessage_reflection_;
  delete FrameworkRegisteredMessage::default_instance_;
  delete FrameworkRegisteredMessage_reflection_;
  delete FrameworkReregisteredMessage::default_instance_;
  delete FrameworkReregisteredMessage_reflection_;
  delete UnregisterFrameworkMessage::default_instance_;
  delete UnregisterFrameworkMessage_reflection_;
  delete DeactivateFrameworkMessage::default_instance_;
  delete DeactivateFrameworkMessage_reflection_;
  delete ResourceRequestMessage::default_instance_;
  delete ResourceRequestMessage_reflection_;
  delete ResourceOffersMessage::default_instance_;
  delete ResourceOffersMessage_reflection_;
  delete InverseOffersMessage::default_instance_;
  delete InverseOffersMessage_reflection_;
  delete LaunchTasksMessage::default_instance_;
  delete LaunchTasksMessage_reflection_;
  delete RescindResourceOfferMessage::default_instance_;
  delete RescindResourceOfferMessage_reflection_;
  delete RescindInverseOfferMessage::default_instance_;
  delete RescindInverseOfferMessage_reflection_;
  delete ReviveOffersMessage::default_instance_;
  delete ReviveOffersMessage_reflection_;
  delete RunTaskMessage::default_instance_;
  delete RunTaskMessage_reflection_;
  delete RunTaskGroupMessage::default_instance_;
  delete RunTaskGroupMessage_reflection_;
  delete KillTaskMessage::default_instance_;
  delete KillTaskMessage_reflection_;
  delete StatusUpdateMessage::default_instance_;
  delete StatusUpdateMessage_reflection_;
  delete StatusUpdateAcknowledgementMessage::default_instance_;
  delete StatusUpdateAcknowledgementMessage_reflection_;
  delete LostSlaveMessage::default_instance_;
  delete LostSlaveMessage_reflection_;
  delete ReconcileTasksMessage::default_instance_;
  delete ReconcileTasksMessage_reflection_;
  delete FrameworkErrorMessage::default_instance_;
  delete FrameworkErrorMessage_reflection_;
  delete RegisterSlaveMessage::default_instance_;
  delete RegisterSlaveMessage_reflection_;
  delete ReregisterSlaveMessage::default_instance_;
  delete ReregisterSlaveMessage_reflection_;
  delete SlaveRegisteredMessage::default_instance_;
  delete SlaveRegisteredMessage_reflection_;
  delete SlaveReregisteredMessage::default_instance_;
  delete SlaveReregisteredMessage_reflection_;
  delete UnregisterSlaveMessage::default_instance_;
  delete UnregisterSlaveMessage_reflection_;
  delete MasterSlaveConnection::default_instance_;
  delete MasterSlaveConnection_reflection_;
  delete PingSlaveMessage::default_instance_;
  delete PingSlaveMessage_reflection_;
  delete PongSlaveMessage::default_instance_;
  delete PongSlaveMessage_reflection_;
  delete ShutdownFrameworkMessage::default_instance_;
  delete ShutdownFrameworkMessage_reflection_;
  delete ShutdownExecutorMessage::default_instance_;
  delete ShutdownExecutorMessage_reflection_;
  delete UpdateFrameworkMessage::default_instance_;
  delete UpdateFrameworkMessage_reflection_;
  delete CheckpointResourcesMessage::default_instance_;
  delete CheckpointResourcesMessage_reflection_;
  delete UpdateSlaveMessage::default_instance_;
  delete UpdateSlaveMessage_reflection_;
  delete RegisterExecutorMessage::default_instance_;
  delete RegisterExecutorMessage_reflection_;
  delete ExecutorRegisteredMessage::default_instance_;
  delete ExecutorRegisteredMessage_reflection_;
  delete ExecutorReregisteredMessage::default_instance_;
  delete ExecutorReregisteredMessage_reflection_;
  delete ExitedExecutorMessage::default_instance_;
  delete ExitedExecutorMessage_reflection_;
  delete ReconnectExecutorMessage::default_instance_;
  delete ReconnectExecutorMessage_reflection_;
  delete ReregisterExecutorMessage::default_instance_;
  delete ReregisterExecutorMessage_reflection_;
  delete ShutdownMessage::default_instance_;
  delete ShutdownMessage_reflection_;
  delete Archive::default_instance_;
  delete Archive_reflection_;
  delete Archive_Framework::default_instance_;
  delete Archive_Framework_reflection_;
  delete TaskHealthStatus::default_instance_;
  delete TaskHealthStatus_reflection_;
  delete HookExecuted::default_instance_;
  delete HookExecuted_reflection_;
}

void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\022\016mesos.internal\032\013mesos."
    "proto\"\356\001\n\014StatusUpdate\022(\n\014framework_id\030\001"
    " \002(\0132\022.mesos.FrameworkID\022&\n\013executor_id\030"
    "\002 \001(\0132\021.mesos.ExecutorID\022 \n\010slave_id\030\003 \001"
    "(\0132\016.mesos.SlaveID\022!\n\006status\030\004 \002(\0132\021.mes"
    "os.TaskStatus\022\021\n\ttimestamp\030\005 \002(\001\022\014\n\004uuid"
    "\030\006 \001(\014\022&\n\014latest_state\030\007 \001(\0162\020.mesos.Tas"
    "kState\"\244\001\n\022StatusUpdateRecord\0225\n\004type\030\001 "
    "\002(\0162\'.mesos.internal.StatusUpdateRecord."
    "Type\022,\n\006update\030\002 \001(\0132\034.mesos.internal.St"
    "atusUpdate\022\014\n\004uuid\030\003 \001(\014\"\033\n\004Type\022\n\n\006UPDA"
    "TE\020\000\022\007\n\003ACK\020\001\"&\n\026SubmitSchedulerRequest\022"
    "\014\n\004name\030\001 \002(\t\"\'\n\027SubmitSchedulerResponse"
    "\022\014\n\004okay\030\001 \002(\010\"\236\001\n\032ExecutorToFrameworkMe"
    "ssage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\022"
    "(\n\014framework_id\030\002 \002(\0132\022.mesos.FrameworkI"
    "D\022&\n\013executor_id\030\003 \002(\0132\021.mesos.ExecutorI"
    "D\022\014\n\004data\030\004 \002(\014\"\236\001\n\032FrameworkToExecutorM"
    "essage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID"
    "\022(\n\014framework_id\030\002 \002(\0132\022.mesos.Framework"
    "ID\022&\n\013executor_id\030\003 \002(\0132\021.mesos.Executor"
    "ID\022\014\n\004data\030\004 \002(\014\"C\n\030RegisterFrameworkMes"
    "sage\022\'\n\tframework\030\001 \002(\0132\024.mesos.Framewor"
    "kInfo\"W\n\032ReregisterFrameworkMessage\022\'\n\tf"
    "ramework\030\002 \002(\0132\024.mesos.FrameworkInfo\022\020\n\010"
    "failover\030\003 \002(\010\"n\n\032FrameworkRegisteredMes"
    "sage\022(\n\014framework_id\030\001 \002(\0132\022.mesos.Frame"
    "workID\022&\n\013master_info\030\002 \002(\0132\021.mesos.Mast"
    "erInfo\"p\n\034FrameworkReregisteredMessage\022("
    "\n\014framework_id\030\001 \002(\0132\022.mesos.FrameworkID"
    "\022&\n\013master_info\030\002 \002(\0132\021.mesos.MasterInfo"
    "\"F\n\032UnregisterFrameworkMessage\022(\n\014framew"
    "ork_id\030\001 \002(\0132\022.mesos.FrameworkID\"F\n\032Deac"
    "tivateFrameworkMessage\022(\n\014framework_id\030\001"
    " \002(\0132\022.mesos.FrameworkID\"d\n\026ResourceRequ"
    "estMessage\022(\n\014framework_id\030\001 \002(\0132\022.mesos"
    ".FrameworkID\022 \n\010requests\030\002 \003(\0132\016.mesos.R"
    "equest\"C\n\025ResourceOffersMessage\022\034\n\006offer"
    "s\030\001 \003(\0132\014.mesos.Offer\022\014\n\004pids\030\002 \003(\t\"Q\n\024I"
    "nverseOffersMessage\022+\n\016inverse_offers\030\001 "
    "\003(\0132\023.mesos.InverseOffer\022\014\n\004pids\030\002 \003(\t\"\242"
    "\001\n\022LaunchTasksMessage\022(\n\014framework_id\030\001 "
    "\002(\0132\022.mesos.FrameworkID\022\036\n\005tasks\030\003 \003(\0132\017"
    ".mesos.TaskInfo\022\037\n\007filters\030\005 \002(\0132\016.mesos"
    ".Filters\022!\n\toffer_ids\030\006 \003(\0132\016.mesos.Offe"
    "rID\"\?\n\033RescindResourceOfferMessage\022 \n\010of"
    "fer_id\030\001 \002(\0132\016.mesos.OfferID\"F\n\032RescindI"
    "nverseOfferMessage\022(\n\020inverse_offer_id\030\001"
    " \002(\0132\016.mesos.OfferID\"N\n\023ReviveOffersMess"
    "age\022(\n\014framework_id\030\001 \002(\0132\022.mesos.Framew"
    "orkID\022\r\n\005roles\030\002 \003(\t\"\223\001\n\016RunTaskMessage\022"
    ",\n\014framework_id\030\001 \001(\0132\022.mesos.FrameworkI"
    "DB\002\030\001\022\'\n\tframework\030\002 \002(\0132\024.mesos.Framewo"
    "rkInfo\022\035\n\004task\030\004 \002(\0132\017.mesos.TaskInfo\022\013\n"
    "\003pid\030\003 \001(\t\"\217\001\n\023RunTaskGroupMessage\022\'\n\tfr"
    "amework\030\001 \002(\0132\024.mesos.FrameworkInfo\022%\n\010e"
    "xecutor\030\002 \002(\0132\023.mesos.ExecutorInfo\022(\n\nta"
    "sk_group\030\003 \002(\0132\024.mesos.TaskGroupInfo\"\203\001\n"
    "\017KillTaskMessage\022(\n\014framework_id\030\001 \002(\0132\022"
    ".mesos.FrameworkID\022\036\n\007task_id\030\002 \002(\0132\r.me"
    "sos.TaskID\022&\n\013kill_policy\030\003 \001(\0132\021.mesos."
    "KillPolicy\"P\n\023StatusUpdateMessage\022,\n\006upd"
    "ate\030\001 \002(\0132\034.mesos.internal.StatusUpdate\022"
    "\013\n\003pid\030\002 \001(\t\"\236\001\n\"StatusUpdateAcknowledge"
    "mentMessage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.Sl"
    "aveID\022(\n\014framework_id\030\002 \002(\0132\022.mesos.Fram"
    "eworkID\022\036\n\007task_id\030\003 \002(\0132\r.mesos.TaskID\022"
    "\014\n\004uuid\030\004 \002(\014\"4\n\020LostSlaveMessage\022 \n\010sla"
    "ve_id\030\001 \002(\0132\016.mesos.SlaveID\"\217\001\n\025Reconcil"
    "eTasksMessage\022(\n\014framework_id\030\001 \002(\0132\022.me"
    "sos.FrameworkID\022#\n\010statuses\030\002 \003(\0132\021.meso"
    "s.TaskStatus\022\'\n\tframework\030\003 \001(\0132\024.mesos."
    "FrameworkInfo\"(\n\025FrameworkErrorMessage\022\017"
    "\n\007message\030\002 \002(\t\"\262\001\n\024RegisterSlaveMessage"
    "\022\037\n\005slave\030\001 \002(\0132\020.mesos.SlaveInfo\022/\n\026che"
    "ckpointed_resources\030\003 \003(\0132\017.mesos.Resour"
    "ce\022\017\n\007version\030\002 \001(\t\0227\n\022agent_capabilitie"
    "s\030\004 \003(\0132\033.mesos.SlaveInfo.Capability\"\350\002\n"
    "\026ReregisterSlaveMessage\022\037\n\005slave\030\002 \002(\0132\020"
    ".mesos.SlaveInfo\022/\n\026checkpointed_resourc"
    "es\030\007 \003(\0132\017.mesos.Resource\022+\n\016executor_in"
    "fos\030\004 \003(\0132\023.mesos.ExecutorInfo\022\032\n\005tasks\030"
    "\003 \003(\0132\013.mesos.Task\022(\n\nframeworks\030\010 \003(\0132\024"
    ".mesos.FrameworkInfo\022\?\n\024completed_framew"
    "orks\030\005 \003(\0132!.mesos.internal.Archive.Fram"
    "ework\022\017\n\007version\030\006 \001(\t\0227\n\022agent_capabili"
    "ties\030\t \003(\0132\033.mesos.SlaveInfo.Capability\""
    "u\n\026SlaveRegisteredMessage\022 \n\010slave_id\030\001 "
    "\002(\0132\016.mesos.SlaveID\0229\n\nconnection\030\002 \001(\0132"
    "%.mesos.internal.MasterSlaveConnection\"\267"
    "\001\n\030SlaveReregisteredMessage\022 \n\010slave_id\030"
    "\001 \002(\0132\016.mesos.SlaveID\022>\n\017reconciliations"
    "\030\002 \003(\0132%.mesos.internal.ReconcileTasksMe"
    "ssage\0229\n\nconnection\030\003 \001(\0132%.mesos.intern"
    "al.MasterSlaveConnection\":\n\026UnregisterSl"
    "aveMessage\022 \n\010slave_id\030\001 \002(\0132\016.mesos.Sla"
    "veID\";\n\025MasterSlaveConnection\022\"\n\032total_p"
    "ing_timeout_seconds\030\001 \001(\001\"%\n\020PingSlaveMe"
    "ssage\022\021\n\tconnected\030\001 \002(\010\"\022\n\020PongSlaveMes"
    "sage\"D\n\030ShutdownFrameworkMessage\022(\n\014fram"
    "ework_id\030\001 \002(\0132\022.mesos.FrameworkID\"k\n\027Sh"
    "utdownExecutorMessage\022&\n\013executor_id\030\001 \001"
    "(\0132\021.mesos.ExecutorID\022(\n\014framework_id\030\002 "
    "\001(\0132\022.mesos.FrameworkID\"}\n\026UpdateFramewo"
    "rkMessage\022(\n\014framework_id\030\001 \002(\0132\022.mesos."
    "FrameworkID\022\013\n\003pid\030\002 \001(\t\022,\n\016framework_in"
    "fo\030\003 \001(\0132\024.mesos.FrameworkInfo\"@\n\032Checkp"
    "ointResourcesMessage\022\"\n\tresources\030\001 \003(\0132"
    "\017.mesos.Resource\"i\n\022UpdateSlaveMessage\022 "
    "\n\010slave_id\030\001 \002(\0132\016.mesos.SlaveID\0221\n\030over"
    "subscribed_resources\030\002 \003(\0132\017.mesos.Resou"
    "rce\"k\n\027RegisterExecutorMessage\022(\n\014framew"
    "ork_id\030\001 \002(\0132\022.mesos.FrameworkID\022&\n\013exec"
    "utor_id\030\002 \002(\0132\021.mesos.ExecutorID\"\347\001\n\031Exe"
    "cutorRegisteredMessage\022*\n\rexecutor_info\030"
    "\002 \002(\0132\023.mesos.ExecutorInfo\022(\n\014framework_"
    "id\030\003 \002(\0132\022.mesos.FrameworkID\022,\n\016framewor"
    "k_info\030\004 \002(\0132\024.mesos.FrameworkInfo\022 \n\010sl"
    "ave_id\030\005 \002(\0132\016.mesos.SlaveID\022$\n\nslave_in"
    "fo\030\006 \002(\0132\020.mesos.SlaveInfo\"e\n\033ExecutorRe"
    "registeredMessage\022 \n\010slave_id\030\001 \002(\0132\016.me"
    "sos.SlaveID\022$\n\nslave_info\030\002 \002(\0132\020.mesos."
    "SlaveInfo\"\233\001\n\025ExitedExecutorMessage\022 \n\010s"
    "lave_id\030\001 \002(\0132\016.mesos.SlaveID\022(\n\014framewo"
    "rk_id\030\002 \002(\0132\022.mesos.FrameworkID\022&\n\013execu"
    "tor_id\030\003 \002(\0132\021.mesos.ExecutorID\022\016\n\006statu"
    "s\030\004 \002(\005\"<\n\030ReconnectExecutorMessage\022 \n\010s"
    "lave_id\030\001 \002(\0132\016.mesos.SlaveID\"\274\001\n\031Reregi"
    "sterExecutorMessage\022&\n\013executor_id\030\001 \002(\013"
    "2\021.mesos.ExecutorID\022(\n\014framework_id\030\002 \002("
    "\0132\022.mesos.FrameworkID\022\036\n\005tasks\030\003 \003(\0132\017.m"
    "esos.TaskInfo\022-\n\007updates\030\004 \003(\0132\034.mesos.i"
    "nternal.StatusUpdate\"\"\n\017ShutdownMessage\022"
    "\017\n\007message\030\001 \001(\t\"\244\001\n\007Archive\0225\n\nframewor"
    "ks\030\001 \003(\0132!.mesos.internal.Archive.Framew"
    "ork\032b\n\tFramework\022,\n\016framework_info\030\001 \002(\013"
    "2\024.mesos.FrameworkInfo\022\013\n\003pid\030\002 \001(\t\022\032\n\005t"
    "asks\030\003 \003(\0132\013.mesos.Task\"{\n\020TaskHealthSta"
    "tus\022\036\n\007task_id\030\001 \002(\0132\r.mesos.TaskID\022\017\n\007h"
    "ealthy\030\002 \002(\010\022\030\n\tkill_task\030\003 \001(\010:\005false\022\034"
    "\n\024consecutive_failures\030\004 \001(\005\"\036\n\014HookExec"
    "uted\022\016\n\006module\030\001 \001(\t", 5660);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  StatusUpdate::default_instance_ = new StatusUpdate();
  StatusUpdateRecord::default_instance_ = new StatusUpdateRecord();
  SubmitSchedulerRequest::default_instance_ = new SubmitSchedulerRequest();
  SubmitSchedulerResponse::default_instance_ = new SubmitSchedulerResponse();
  ExecutorToFrameworkMessage::default_instance_ = new ExecutorToFrameworkMessage();
  FrameworkToExecutorMessage::default_instance_ = new FrameworkToExecutorMessage();
  RegisterFrameworkMessage::default_instance_ = new RegisterFrameworkMessage();
  ReregisterFrameworkMessage::default_instance_ = new ReregisterFrameworkMessage();
  FrameworkRegisteredMessage::default_instance_ = new FrameworkRegisteredMessage();
  FrameworkReregisteredMessage::default_instance_ = new FrameworkReregisteredMessage();
  UnregisterFrameworkMessage::default_instance_ = new UnregisterFrameworkMessage();
  DeactivateFrameworkMessage::default_instance_ = new DeactivateFrameworkMessage();
  ResourceRequestMessage::default_instance_ = new ResourceRequestMessage();
  ResourceOffersMessage::default_instance_ = new ResourceOffersMessage();
  InverseOffersMessage::default_instance_ = new InverseOffersMessage();
  LaunchTasksMessage::default_instance_ = new LaunchTasksMessage();
  RescindResourceOfferMessage::default_instance_ = new RescindResourceOfferMessage();
  RescindInverseOfferMessage::default_instance_ = new RescindInverseOfferMessage();
  ReviveOffersMessage::default_instance_ = new ReviveOffersMessage();
  RunTaskMessage::default_instance_ = new RunTaskMessage();
  RunTaskGroupMessage::default_instance_ = new RunTaskGroupMessage();
  KillTaskMessage::default_instance_ = new KillTaskMessage();
  StatusUpdateMessage::default_instance_ = new StatusUpdateMessage();
  StatusUpdateAcknowledgementMessage::default_instance_ = new StatusUpdateAcknowledgementMessage();
  LostSlaveMessage::default_instance_ = new LostSlaveMessage();
  ReconcileTasksMessage::default_instance_ = new ReconcileTasksMessage();
  FrameworkErrorMessage::default_instance_ = new FrameworkErrorMessage();
  RegisterSlaveMessage::default_instance_ = new RegisterSlaveMessage();
  ReregisterSlaveMessage::default_instance_ = new ReregisterSlaveMessage();
  SlaveRegisteredMessage::default_instance_ = new SlaveRegisteredMessage();
  SlaveReregisteredMessage::default_instance_ = new SlaveReregisteredMessage();
  UnregisterSlaveMessage::default_instance_ = new UnregisterSlaveMessage();
  MasterSlaveConnection::default_instance_ = new MasterSlaveConnection();
  PingSlaveMessage::default_instance_ = new PingSlaveMessage();
  PongSlaveMessage::default_instance_ = new PongSlaveMessage();
  ShutdownFrameworkMessage::default_instance_ = new ShutdownFrameworkMessage();
  ShutdownExecutorMessage::default_instance_ = new ShutdownExecutorMessage();
  UpdateFrameworkMessage::default_instance_ = new UpdateFrameworkMessage();
  CheckpointResourcesMessage::default_instance_ = new CheckpointResourcesMessage();
  UpdateSlaveMessage::default_instance_ = new UpdateSlaveMessage();
  RegisterExecutorMessage::default_instance_ = new RegisterExecutorMessage();
  ExecutorRegisteredMessage::default_instance_ = new ExecutorRegisteredMessage();
  ExecutorReregisteredMessage::default_instance_ = new ExecutorReregisteredMessage();
  ExitedExecutorMessage::default_instance_ = new ExitedExecutorMessage();
  ReconnectExecutorMessage::default_instance_ = new ReconnectExecutorMessage();
  ReregisterExecutorMessage::default_instance_ = new ReregisterExecutorMessage();
  ShutdownMessage::default_instance_ = new ShutdownMessage();
  Archive::default_instance_ = new Archive();
  Archive_Framework::default_instance_ = new Archive_Framework();
  TaskHealthStatus::default_instance_ = new TaskHealthStatus();
  HookExecuted::default_instance_ = new HookExecuted();
  StatusUpdate::default_instance_->InitAsDefaultInstance();
  StatusUpdateRecord::default_instance_->InitAsDefaultInstance();
  SubmitSchedulerRequest::default_instance_->InitAsDefaultInstance();
  SubmitSchedulerResponse::default_instance_->InitAsDefaultInstance();
  ExecutorToFrameworkMessage::default_instance_->InitAsDefaultInstance();
  FrameworkToExecutorMessage::default_instance_->InitAsDefaultInstance();
  RegisterFrameworkMessage::default_instance_->InitAsDefaultInstance();
  ReregisterFrameworkMessage::default_instance_->InitAsDefaultInstance();
  FrameworkRegisteredMessage::default_instance_->InitAsDefaultInstance();
  FrameworkReregisteredMessage::default_instance_->InitAsDefaultInstance();
  UnregisterFrameworkMessage::default_instance_->InitAsDefaultInstance();
  DeactivateFrameworkMessage::default_instance_->InitAsDefaultInstance();
  ResourceRequestMessage::default_instance_->InitAsDefaultInstance();
  ResourceOffersMessage::default_instance_->InitAsDefaultInstance();
  InverseOffersMessage::default_instance_->InitAsDefaultInstance();
  LaunchTasksMessage::default_instance_->InitAsDefaultInstance();
  RescindResourceOfferMessage::default_instance_->InitAsDefaultInstance();
  RescindInverseOfferMessage::default_instance_->InitAsDefaultInstance();
  ReviveOffersMessage::default_instance_->InitAsDefaultInstance();
  RunTaskMessage::default_instance_->InitAsDefaultInstance();
  RunTaskGroupMessage::default_instance_->InitAsDefaultInstance();
  KillTaskMessage::default_instance_->InitAsDefaultInstance();
  StatusUpdateMessage::default_instance_->InitAsDefaultInstance();
  StatusUpdateAcknowledgementMessage::default_instance_->InitAsDefaultInstance();
  LostSlaveMessage::default_instance_->InitAsDefaultInstance();
  ReconcileTasksMessage::default_instance_->InitAsDefaultInstance();
  FrameworkErrorMessage::default_instance_->InitAsDefaultInstance();
  RegisterSlaveMessage::default_instance_->InitAsDefaultInstance();
  ReregisterSlaveMessage::default_instance_->InitAsDefaultInstance();
  SlaveRegisteredMessage::default_instance_->InitAsDefaultInstance();
  SlaveReregisteredMessage::default_instance_->InitAsDefaultInstance();
  UnregisterSlaveMessage::default_instance_->InitAsDefaultInstance();
  MasterSlaveConnection::default_instance_->InitAsDefaultInstance();
  PingSlaveMessage::default_instance_->InitAsDefaultInstance();
  PongSlaveMessage::default_instance_->InitAsDefaultInstance();
  ShutdownFrameworkMessage::default_instance_->InitAsDefaultInstance();
  ShutdownExecutorMessage::default_instance_->InitAsDefaultInstance();
  UpdateFrameworkMessage::default_instance_->InitAsDefaultInstance();
  CheckpointResourcesMessage::default_instance_->InitAsDefaultInstance();
  UpdateSlaveMessage::default_instance_->InitAsDefaultInstance();
  RegisterExecutorMessage::default_instance_->InitAsDefaultInstance();
  ExecutorRegisteredMessage::default_instance_->InitAsDefaultInstance();
  ExecutorReregisteredMessage::default_instance_->InitAsDefaultInstance();
  ExitedExecutorMessage::default_instance_->InitAsDefaultInstance();
  ReconnectExecutorMessage::default_instance_->InitAsDefaultInstance();
  ReregisterExecutorMessage::default_instance_->InitAsDefaultInstance();
  ShutdownMessage::default_instance_->InitAsDefaultInstance();
  Archive::default_instance_->InitAsDefaultInstance();
  Archive_Framework::default_instance_->InitAsDefaultInstance();
  TaskHealthStatus::default_instance_->InitAsDefaultInstance();
  HookExecuted::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int StatusUpdate::kFrameworkIdFieldNumber;
const int StatusUpdate::kExecutorIdFieldNumber;
const int StatusUpdate::kSlaveIdFieldNumber;
const int StatusUpdate::kStatusFieldNumber;
const int StatusUpdate::kTimestampFieldNumber;
const int StatusUpdate::kUuidFieldNumber;
const int StatusUpdate::kLatestStateFieldNumber;
#endif  // !_MSC_VER

StatusUpdate::StatusUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.StatusUpdate)
}

void StatusUpdate::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  status_ = const_cast< ::mesos::TaskStatus*>(&::mesos::TaskStatus::default_instance());
}

StatusUpdate::StatusUpdate(const StatusUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.StatusUpdate)
}

void StatusUpdate::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  framework_id_ = NULL;
  executor_id_ = NULL;
  slave_id_ = NULL;
  status_ = NULL;
  timestamp_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  latest_state_ = 6;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdate::~StatusUpdate() {
  // @@protoc_insertion_point(destructor:mesos.internal.StatusUpdate)
  SharedDtor();
}

void StatusUpdate::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete framework_id_;
    delete executor_id_;
    delete slave_id_;
    delete status_;
  }
}

void StatusUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdate_descriptor_;
}

const StatusUpdate& StatusUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

StatusUpdate* StatusUpdate::default_instance_ = NULL;

StatusUpdate* StatusUpdate::New() const {
  return new StatusUpdate;
}

void StatusUpdate::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_status()) {
      if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
    }
    timestamp_ = 0;
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
    latest_state_ = 6;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.StatusUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (tag == 18) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 3;
      case 3: {
        if (tag == 26) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_status;
        break;
      }

      // required .mesos.TaskStatus status = 4;
      case 4: {
        if (tag == 34) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_timestamp;
        break;
      }

      // required double timestamp = 5;
      case 5: {
        if (tag == 41) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_uuid;
        break;
      }

      // optional bytes uuid = 6;
      case 6: {
        if (tag == 50) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_latest_state;
        break;
      }

      // optional .mesos.TaskState latest_state = 7;
      case 7: {
        if (tag == 56) {
         parse_latest_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_latest_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.StatusUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.StatusUpdate)
  return false;
#undef DO_
}

void StatusUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.StatusUpdate)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // optional .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->slave_id(), output);
  }

  // required .mesos.TaskStatus status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->status(), output);
  }

  // required double timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->timestamp(), output);
  }

  // optional bytes uuid = 6;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->uuid(), output);
  }

  // optional .mesos.TaskState latest_state = 7;
  if (has_latest_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->latest_state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.StatusUpdate)
}

::google::protobuf::uint8* StatusUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.StatusUpdate)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // optional .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->slave_id(), target);
  }

  // required .mesos.TaskStatus status = 4;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->status(), target);
  }

  // required double timestamp = 5;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->timestamp(), target);
  }

  // optional bytes uuid = 6;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->uuid(), target);
  }

  // optional .mesos.TaskState latest_state = 7;
  if (has_latest_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->latest_state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.StatusUpdate)
  return target;
}

int StatusUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional .mesos.SlaveID slave_id = 3;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.TaskStatus status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

    // required double timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional bytes uuid = 6;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional .mesos.TaskState latest_state = 7;
    if (has_latest_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->latest_state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdate::MergeFrom(const StatusUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_status()) {
      mutable_status()->::mesos::TaskStatus::MergeFrom(from.status());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_latest_state()) {
      set_latest_state(from.latest_state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdate::CopyFrom(const StatusUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdate::Swap(StatusUpdate* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(status_, other->status_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uuid_, other->uuid_);
    std::swap(latest_state_, other->latest_state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdate_descriptor_;
  metadata.reflection = StatusUpdate_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* StatusUpdateRecord_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateRecord_Type_descriptor_;
}
bool StatusUpdateRecord_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const StatusUpdateRecord_Type StatusUpdateRecord::UPDATE;
const StatusUpdateRecord_Type StatusUpdateRecord::ACK;
const StatusUpdateRecord_Type StatusUpdateRecord::Type_MIN;
const StatusUpdateRecord_Type StatusUpdateRecord::Type_MAX;
const int StatusUpdateRecord::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int StatusUpdateRecord::kTypeFieldNumber;
const int StatusUpdateRecord::kUpdateFieldNumber;
const int StatusUpdateRecord::kUuidFieldNumber;
#endif  // !_MSC_VER

StatusUpdateRecord::StatusUpdateRecord()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.StatusUpdateRecord)
}

void StatusUpdateRecord::InitAsDefaultInstance() {
  update_ = const_cast< ::mesos::internal::StatusUpdate*>(&::mesos::internal::StatusUpdate::default_instance());
}

StatusUpdateRecord::StatusUpdateRecord(const StatusUpdateRecord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.StatusUpdateRecord)
}

void StatusUpdateRecord::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  update_ = NULL;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdateRecord::~StatusUpdateRecord() {
  // @@protoc_insertion_point(destructor:mesos.internal.StatusUpdateRecord)
  SharedDtor();
}

void StatusUpdateRecord::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete update_;
  }
}

void StatusUpdateRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdateRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateRecord_descriptor_;
}

const StatusUpdateRecord& StatusUpdateRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

StatusUpdateRecord* StatusUpdateRecord::default_instance_ = NULL;

StatusUpdateRecord* StatusUpdateRecord::New() const {
  return new StatusUpdateRecord;
}

void StatusUpdateRecord::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 0;
    if (has_update()) {
      if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdateRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.StatusUpdateRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.internal.StatusUpdateRecord.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::internal::StatusUpdateRecord_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::internal::StatusUpdateRecord_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_update;
        break;
      }

      // optional .mesos.internal.StatusUpdate update = 2;
      case 2: {
        if (tag == 18) {
         parse_update:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_uuid;
        break;
      }

      // optional bytes uuid = 3;
      case 3: {
        if (tag == 26) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.StatusUpdateRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.StatusUpdateRecord)
  return false;
#undef DO_
}

void StatusUpdateRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.StatusUpdateRecord)
  // required .mesos.internal.StatusUpdateRecord.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.internal.StatusUpdate update = 2;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->update(), output);
  }

  // optional bytes uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.StatusUpdateRecord)
}

::google::protobuf::uint8* StatusUpdateRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.StatusUpdateRecord)
  // required .mesos.internal.StatusUpdateRecord.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.internal.StatusUpdate update = 2;
  if (has_update()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->update(), target);
  }

  // optional bytes uuid = 3;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.StatusUpdateRecord)
  return target;
}

int StatusUpdateRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.internal.StatusUpdateRecord.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.internal.StatusUpdate update = 2;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update());
    }

    // optional bytes uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdateRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdateRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdateRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdateRecord::MergeFrom(const StatusUpdateRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_update()) {
      mutable_update()->::mesos::internal::StatusUpdate::MergeFrom(from.update());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdateRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdateRecord::CopyFrom(const StatusUpdateRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdateRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_update()) {
    if (!this->update().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdateRecord::Swap(StatusUpdateRecord* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(update_, other->update_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdateRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdateRecord_descriptor_;
  metadata.reflection = StatusUpdateRecord_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SubmitSchedulerRequest::kNameFieldNumber;
#endif  // !_MSC_VER

SubmitSchedulerRequest::SubmitSchedulerRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.SubmitSchedulerRequest)
}

void SubmitSchedulerRequest::InitAsDefaultInstance() {
}

SubmitSchedulerRequest::SubmitSchedulerRequest(const SubmitSchedulerRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.SubmitSchedulerRequest)
}

void SubmitSchedulerRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubmitSchedulerRequest::~SubmitSchedulerRequest() {
  // @@protoc_insertion_point(destructor:mesos.internal.SubmitSchedulerRequest)
  SharedDtor();
}

void SubmitSchedulerRequest::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void SubmitSchedulerRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubmitSchedulerRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubmitSchedulerRequest_descriptor_;
}

const SubmitSchedulerRequest& SubmitSchedulerRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SubmitSchedulerRequest* SubmitSchedulerRequest::default_instance_ = NULL;

SubmitSchedulerRequest* SubmitSchedulerRequest::New() const {
  return new SubmitSchedulerRequest;
}

void SubmitSchedulerRequest::Clear() {
  if (has_name()) {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      name_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubmitSchedulerRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.SubmitSchedulerRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.SubmitSchedulerRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.SubmitSchedulerRequest)
  return false;
#undef DO_
}

void SubmitSchedulerRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.SubmitSchedulerRequest)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.SubmitSchedulerRequest)
}

::google::protobuf::uint8* SubmitSchedulerRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.SubmitSchedulerRequest)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.SubmitSchedulerRequest)
  return target;
}

int SubmitSchedulerRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubmitSchedulerRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubmitSchedulerRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubmitSchedulerRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubmitSchedulerRequest::MergeFrom(const SubmitSchedulerRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubmitSchedulerRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubmitSchedulerRequest::CopyFrom(const SubmitSchedulerRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubmitSchedulerRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubmitSchedulerRequest::Swap(SubmitSchedulerRequest* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubmitSchedulerRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubmitSchedulerRequest_descriptor_;
  metadata.reflection = SubmitSchedulerRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SubmitSchedulerResponse::kOkayFieldNumber;
#endif  // !_MSC_VER

SubmitSchedulerResponse::SubmitSchedulerResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.SubmitSchedulerResponse)
}

void SubmitSchedulerResponse::InitAsDefaultInstance() {
}

SubmitSchedulerResponse::SubmitSchedulerResponse(const SubmitSchedulerResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.SubmitSchedulerResponse)
}

void SubmitSchedulerResponse::SharedCtor() {
  _cached_size_ = 0;
  okay_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubmitSchedulerResponse::~SubmitSchedulerResponse() {
  // @@protoc_insertion_point(destructor:mesos.internal.SubmitSchedulerResponse)
  SharedDtor();
}

void SubmitSchedulerResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SubmitSchedulerResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubmitSchedulerResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubmitSchedulerResponse_descriptor_;
}

const SubmitSchedulerResponse& SubmitSchedulerResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SubmitSchedulerResponse* SubmitSchedulerResponse::default_instance_ = NULL;

SubmitSchedulerResponse* SubmitSchedulerResponse::New() const {
  return new SubmitSchedulerResponse;
}

void SubmitSchedulerResponse::Clear() {
  okay_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SubmitSchedulerResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.SubmitSchedulerResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool okay = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &okay_)));
          set_has_okay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.SubmitSchedulerResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.SubmitSchedulerResponse)
  return false;
#undef DO_
}

void SubmitSchedulerResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.SubmitSchedulerResponse)
  // required bool okay = 1;
  if (has_okay()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->okay(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.SubmitSchedulerResponse)
}

::google::protobuf::uint8* SubmitSchedulerResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.SubmitSchedulerResponse)
  // required bool okay = 1;
  if (has_okay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->okay(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.SubmitSchedulerResponse)
  return target;
}

int SubmitSchedulerResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool okay = 1;
    if (has_okay()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubmitSchedulerResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SubmitSchedulerResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SubmitSchedulerResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SubmitSchedulerResponse::MergeFrom(const SubmitSchedulerResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_okay()) {
      set_okay(from.okay());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SubmitSchedulerResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubmitSchedulerResponse::CopyFrom(const SubmitSchedulerResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubmitSchedulerResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubmitSchedulerResponse::Swap(SubmitSchedulerResponse* other) {
  if (other != this) {
    std::swap(okay_, other->okay_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SubmitSchedulerResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubmitSchedulerResponse_descriptor_;
  metadata.reflection = SubmitSchedulerResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorToFrameworkMessage::kSlaveIdFieldNumber;
const int ExecutorToFrameworkMessage::kFrameworkIdFieldNumber;
const int ExecutorToFrameworkMessage::kExecutorIdFieldNumber;
const int ExecutorToFrameworkMessage::kDataFieldNumber;
#endif  // !_MSC_VER

ExecutorToFrameworkMessage::ExecutorToFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ExecutorToFrameworkMessage)
}

void ExecutorToFrameworkMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

ExecutorToFrameworkMessage::ExecutorToFrameworkMessage(const ExecutorToFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ExecutorToFrameworkMessage)
}

void ExecutorToFrameworkMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorToFrameworkMessage::~ExecutorToFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ExecutorToFrameworkMessage)
  SharedDtor();
}

void ExecutorToFrameworkMessage::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete executor_id_;
  }
}

void ExecutorToFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorToFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorToFrameworkMessage_descriptor_;
}

const ExecutorToFrameworkMessage& ExecutorToFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ExecutorToFrameworkMessage* ExecutorToFrameworkMessage::default_instance_ = NULL;

ExecutorToFrameworkMessage* ExecutorToFrameworkMessage::New() const {
  return new ExecutorToFrameworkMessage;
}

void ExecutorToFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorToFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ExecutorToFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 3;
      case 3: {
        if (tag == 26) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ExecutorToFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ExecutorToFrameworkMessage)
  return false;
#undef DO_
}

void ExecutorToFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ExecutorToFrameworkMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->executor_id(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ExecutorToFrameworkMessage)
}

::google::protobuf::uint8* ExecutorToFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ExecutorToFrameworkMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->executor_id(), target);
  }

  // required bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ExecutorToFrameworkMessage)
  return target;
}

int ExecutorToFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 3;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorToFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorToFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorToFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorToFrameworkMessage::MergeFrom(const ExecutorToFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorToFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorToFrameworkMessage::CopyFrom(const ExecutorToFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorToFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void ExecutorToFrameworkMessage::Swap(ExecutorToFrameworkMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorToFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorToFrameworkMessage_descriptor_;
  metadata.reflection = ExecutorToFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkToExecutorMessage::kSlaveIdFieldNumber;
const int FrameworkToExecutorMessage::kFrameworkIdFieldNumber;
const int FrameworkToExecutorMessage::kExecutorIdFieldNumber;
const int FrameworkToExecutorMessage::kDataFieldNumber;
#endif  // !_MSC_VER

FrameworkToExecutorMessage::FrameworkToExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.FrameworkToExecutorMessage)
}

void FrameworkToExecutorMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

FrameworkToExecutorMessage::FrameworkToExecutorMessage(const FrameworkToExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.FrameworkToExecutorMessage)
}

void FrameworkToExecutorMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkToExecutorMessage::~FrameworkToExecutorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.FrameworkToExecutorMessage)
  SharedDtor();
}

void FrameworkToExecutorMessage::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete executor_id_;
  }
}

void FrameworkToExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkToExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkToExecutorMessage_descriptor_;
}

const FrameworkToExecutorMessage& FrameworkToExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

FrameworkToExecutorMessage* FrameworkToExecutorMessage::default_instance_ = NULL;

FrameworkToExecutorMessage* FrameworkToExecutorMessage::New() const {
  return new FrameworkToExecutorMessage;
}

void FrameworkToExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkToExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.FrameworkToExecutorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 3;
      case 3: {
        if (tag == 26) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // required bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.FrameworkToExecutorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.FrameworkToExecutorMessage)
  return false;
#undef DO_
}

void FrameworkToExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.FrameworkToExecutorMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->executor_id(), output);
  }

  // required bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.FrameworkToExecutorMessage)
}

::google::protobuf::uint8* FrameworkToExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.FrameworkToExecutorMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->executor_id(), target);
  }

  // required bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.FrameworkToExecutorMessage)
  return target;
}

int FrameworkToExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 3;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkToExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkToExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkToExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkToExecutorMessage::MergeFrom(const FrameworkToExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkToExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkToExecutorMessage::CopyFrom(const FrameworkToExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkToExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void FrameworkToExecutorMessage::Swap(FrameworkToExecutorMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkToExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkToExecutorMessage_descriptor_;
  metadata.reflection = FrameworkToExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterFrameworkMessage::kFrameworkFieldNumber;
#endif  // !_MSC_VER

RegisterFrameworkMessage::RegisterFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RegisterFrameworkMessage)
}

void RegisterFrameworkMessage::InitAsDefaultInstance() {
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

RegisterFrameworkMessage::RegisterFrameworkMessage(const RegisterFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RegisterFrameworkMessage)
}

void RegisterFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterFrameworkMessage::~RegisterFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RegisterFrameworkMessage)
  SharedDtor();
}

void RegisterFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_;
  }
}

void RegisterFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterFrameworkMessage_descriptor_;
}

const RegisterFrameworkMessage& RegisterFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RegisterFrameworkMessage* RegisterFrameworkMessage::default_instance_ = NULL;

RegisterFrameworkMessage* RegisterFrameworkMessage::New() const {
  return new RegisterFrameworkMessage;
}

void RegisterFrameworkMessage::Clear() {
  if (has_framework()) {
    if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RegisterFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RegisterFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RegisterFrameworkMessage)
  return false;
#undef DO_
}

void RegisterFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RegisterFrameworkMessage)
  // required .mesos.FrameworkInfo framework = 1;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RegisterFrameworkMessage)
}

::google::protobuf::uint8* RegisterFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RegisterFrameworkMessage)
  // required .mesos.FrameworkInfo framework = 1;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RegisterFrameworkMessage)
  return target;
}

int RegisterFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework = 1;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterFrameworkMessage::MergeFrom(const RegisterFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterFrameworkMessage::CopyFrom(const RegisterFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  return true;
}

void RegisterFrameworkMessage::Swap(RegisterFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_, other->framework_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterFrameworkMessage_descriptor_;
  metadata.reflection = RegisterFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReregisterFrameworkMessage::kFrameworkFieldNumber;
const int ReregisterFrameworkMessage::kFailoverFieldNumber;
#endif  // !_MSC_VER

ReregisterFrameworkMessage::ReregisterFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ReregisterFrameworkMessage)
}

void ReregisterFrameworkMessage::InitAsDefaultInstance() {
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

ReregisterFrameworkMessage::ReregisterFrameworkMessage(const ReregisterFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ReregisterFrameworkMessage)
}

void ReregisterFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_ = NULL;
  failover_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReregisterFrameworkMessage::~ReregisterFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ReregisterFrameworkMessage)
  SharedDtor();
}

void ReregisterFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_;
  }
}

void ReregisterFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReregisterFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReregisterFrameworkMessage_descriptor_;
}

const ReregisterFrameworkMessage& ReregisterFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ReregisterFrameworkMessage* ReregisterFrameworkMessage::default_instance_ = NULL;

ReregisterFrameworkMessage* ReregisterFrameworkMessage::New() const {
  return new ReregisterFrameworkMessage;
}

void ReregisterFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
    failover_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReregisterFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ReregisterFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_failover;
        break;
      }

      // required bool failover = 3;
      case 3: {
        if (tag == 24) {
         parse_failover:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &failover_)));
          set_has_failover();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ReregisterFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ReregisterFrameworkMessage)
  return false;
#undef DO_
}

void ReregisterFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ReregisterFrameworkMessage)
  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework(), output);
  }

  // required bool failover = 3;
  if (has_failover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->failover(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ReregisterFrameworkMessage)
}

::google::protobuf::uint8* ReregisterFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ReregisterFrameworkMessage)
  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework(), target);
  }

  // required bool failover = 3;
  if (has_failover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->failover(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ReregisterFrameworkMessage)
  return target;
}

int ReregisterFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework = 2;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

    // required bool failover = 3;
    if (has_failover()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReregisterFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReregisterFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReregisterFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReregisterFrameworkMessage::MergeFrom(const ReregisterFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
    if (from.has_failover()) {
      set_failover(from.failover());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReregisterFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReregisterFrameworkMessage::CopyFrom(const ReregisterFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReregisterFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  return true;
}

void ReregisterFrameworkMessage::Swap(ReregisterFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_, other->framework_);
    std::swap(failover_, other->failover_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReregisterFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReregisterFrameworkMessage_descriptor_;
  metadata.reflection = ReregisterFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkRegisteredMessage::kFrameworkIdFieldNumber;
const int FrameworkRegisteredMessage::kMasterInfoFieldNumber;
#endif  // !_MSC_VER

FrameworkRegisteredMessage::FrameworkRegisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.FrameworkRegisteredMessage)
}

void FrameworkRegisteredMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  master_info_ = const_cast< ::mesos::MasterInfo*>(&::mesos::MasterInfo::default_instance());
}

FrameworkRegisteredMessage::FrameworkRegisteredMessage(const FrameworkRegisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.FrameworkRegisteredMessage)
}

void FrameworkRegisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  master_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkRegisteredMessage::~FrameworkRegisteredMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.FrameworkRegisteredMessage)
  SharedDtor();
}

void FrameworkRegisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete master_info_;
  }
}

void FrameworkRegisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkRegisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkRegisteredMessage_descriptor_;
}

const FrameworkRegisteredMessage& FrameworkRegisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

FrameworkRegisteredMessage* FrameworkRegisteredMessage::default_instance_ = NULL;

FrameworkRegisteredMessage* FrameworkRegisteredMessage::New() const {
  return new FrameworkRegisteredMessage;
}

void FrameworkRegisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_master_info()) {
      if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkRegisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.FrameworkRegisteredMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_master_info;
        break;
      }

      // required .mesos.MasterInfo master_info = 2;
      case 2: {
        if (tag == 18) {
         parse_master_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.FrameworkRegisteredMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.FrameworkRegisteredMessage)
  return false;
#undef DO_
}

void FrameworkRegisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.FrameworkRegisteredMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->master_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.FrameworkRegisteredMessage)
}

::google::protobuf::uint8* FrameworkRegisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.FrameworkRegisteredMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->master_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.FrameworkRegisteredMessage)
  return target;
}

int FrameworkRegisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.MasterInfo master_info = 2;
    if (has_master_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkRegisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkRegisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkRegisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkRegisteredMessage::MergeFrom(const FrameworkRegisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_master_info()) {
      mutable_master_info()->::mesos::MasterInfo::MergeFrom(from.master_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkRegisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkRegisteredMessage::CopyFrom(const FrameworkRegisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkRegisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_master_info()) {
    if (!this->master_info().IsInitialized()) return false;
  }
  return true;
}

void FrameworkRegisteredMessage::Swap(FrameworkRegisteredMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(master_info_, other->master_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkRegisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkRegisteredMessage_descriptor_;
  metadata.reflection = FrameworkRegisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkReregisteredMessage::kFrameworkIdFieldNumber;
const int FrameworkReregisteredMessage::kMasterInfoFieldNumber;
#endif  // !_MSC_VER

FrameworkReregisteredMessage::FrameworkReregisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.FrameworkReregisteredMessage)
}

void FrameworkReregisteredMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  master_info_ = const_cast< ::mesos::MasterInfo*>(&::mesos::MasterInfo::default_instance());
}

FrameworkReregisteredMessage::FrameworkReregisteredMessage(const FrameworkReregisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.FrameworkReregisteredMessage)
}

void FrameworkReregisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  master_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkReregisteredMessage::~FrameworkReregisteredMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.FrameworkReregisteredMessage)
  SharedDtor();
}

void FrameworkReregisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete master_info_;
  }
}

void FrameworkReregisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkReregisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkReregisteredMessage_descriptor_;
}

const FrameworkReregisteredMessage& FrameworkReregisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

FrameworkReregisteredMessage* FrameworkReregisteredMessage::default_instance_ = NULL;

FrameworkReregisteredMessage* FrameworkReregisteredMessage::New() const {
  return new FrameworkReregisteredMessage;
}

void FrameworkReregisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_master_info()) {
      if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkReregisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.FrameworkReregisteredMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_master_info;
        break;
      }

      // required .mesos.MasterInfo master_info = 2;
      case 2: {
        if (tag == 18) {
         parse_master_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.FrameworkReregisteredMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.FrameworkReregisteredMessage)
  return false;
#undef DO_
}

void FrameworkReregisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.FrameworkReregisteredMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->master_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.FrameworkReregisteredMessage)
}

::google::protobuf::uint8* FrameworkReregisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.FrameworkReregisteredMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.MasterInfo master_info = 2;
  if (has_master_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->master_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.FrameworkReregisteredMessage)
  return target;
}

int FrameworkReregisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.MasterInfo master_info = 2;
    if (has_master_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkReregisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkReregisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkReregisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkReregisteredMessage::MergeFrom(const FrameworkReregisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_master_info()) {
      mutable_master_info()->::mesos::MasterInfo::MergeFrom(from.master_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkReregisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkReregisteredMessage::CopyFrom(const FrameworkReregisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkReregisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_master_info()) {
    if (!this->master_info().IsInitialized()) return false;
  }
  return true;
}

void FrameworkReregisteredMessage::Swap(FrameworkReregisteredMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(master_info_, other->master_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkReregisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkReregisteredMessage_descriptor_;
  metadata.reflection = FrameworkReregisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnregisterFrameworkMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

UnregisterFrameworkMessage::UnregisterFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.UnregisterFrameworkMessage)
}

void UnregisterFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

UnregisterFrameworkMessage::UnregisterFrameworkMessage(const UnregisterFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.UnregisterFrameworkMessage)
}

void UnregisterFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterFrameworkMessage::~UnregisterFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.UnregisterFrameworkMessage)
  SharedDtor();
}

void UnregisterFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void UnregisterFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnregisterFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnregisterFrameworkMessage_descriptor_;
}

const UnregisterFrameworkMessage& UnregisterFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

UnregisterFrameworkMessage* UnregisterFrameworkMessage::default_instance_ = NULL;

UnregisterFrameworkMessage* UnregisterFrameworkMessage::New() const {
  return new UnregisterFrameworkMessage;
}

void UnregisterFrameworkMessage::Clear() {
  if (has_framework_id()) {
    if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnregisterFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.UnregisterFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.UnregisterFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.UnregisterFrameworkMessage)
  return false;
#undef DO_
}

void UnregisterFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.UnregisterFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.UnregisterFrameworkMessage)
}

::google::protobuf::uint8* UnregisterFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.UnregisterFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.UnregisterFrameworkMessage)
  return target;
}

int UnregisterFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnregisterFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnregisterFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnregisterFrameworkMessage::MergeFrom(const UnregisterFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnregisterFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnregisterFrameworkMessage::CopyFrom(const UnregisterFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void UnregisterFrameworkMessage::Swap(UnregisterFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnregisterFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnregisterFrameworkMessage_descriptor_;
  metadata.reflection = UnregisterFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeactivateFrameworkMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

DeactivateFrameworkMessage::DeactivateFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.DeactivateFrameworkMessage)
}

void DeactivateFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

DeactivateFrameworkMessage::DeactivateFrameworkMessage(const DeactivateFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.DeactivateFrameworkMessage)
}

void DeactivateFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeactivateFrameworkMessage::~DeactivateFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.DeactivateFrameworkMessage)
  SharedDtor();
}

void DeactivateFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void DeactivateFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeactivateFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeactivateFrameworkMessage_descriptor_;
}

const DeactivateFrameworkMessage& DeactivateFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DeactivateFrameworkMessage* DeactivateFrameworkMessage::default_instance_ = NULL;

DeactivateFrameworkMessage* DeactivateFrameworkMessage::New() const {
  return new DeactivateFrameworkMessage;
}

void DeactivateFrameworkMessage::Clear() {
  if (has_framework_id()) {
    if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeactivateFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.DeactivateFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.DeactivateFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.DeactivateFrameworkMessage)
  return false;
#undef DO_
}

void DeactivateFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.DeactivateFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.DeactivateFrameworkMessage)
}

::google::protobuf::uint8* DeactivateFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.DeactivateFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.DeactivateFrameworkMessage)
  return target;
}

int DeactivateFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeactivateFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeactivateFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeactivateFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeactivateFrameworkMessage::MergeFrom(const DeactivateFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeactivateFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeactivateFrameworkMessage::CopyFrom(const DeactivateFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeactivateFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void DeactivateFrameworkMessage::Swap(DeactivateFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeactivateFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeactivateFrameworkMessage_descriptor_;
  metadata.reflection = DeactivateFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceRequestMessage::kFrameworkIdFieldNumber;
const int ResourceRequestMessage::kRequestsFieldNumber;
#endif  // !_MSC_VER

ResourceRequestMessage::ResourceRequestMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ResourceRequestMessage)
}

void ResourceRequestMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ResourceRequestMessage::ResourceRequestMessage(const ResourceRequestMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ResourceRequestMessage)
}

void ResourceRequestMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceRequestMessage::~ResourceRequestMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ResourceRequestMessage)
  SharedDtor();
}

void ResourceRequestMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ResourceRequestMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceRequestMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceRequestMessage_descriptor_;
}

const ResourceRequestMessage& ResourceRequestMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ResourceRequestMessage* ResourceRequestMessage::default_instance_ = NULL;

ResourceRequestMessage* ResourceRequestMessage::New() const {
  return new ResourceRequestMessage;
}

void ResourceRequestMessage::Clear() {
  if (has_framework_id()) {
    if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  }
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceRequestMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ResourceRequestMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        break;
      }

      // repeated .mesos.Request requests = 2;
      case 2: {
        if (tag == 18) {
         parse_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_requests()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ResourceRequestMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ResourceRequestMessage)
  return false;
#undef DO_
}

void ResourceRequestMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ResourceRequestMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated .mesos.Request requests = 2;
  for (int i = 0; i < this->requests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->requests(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ResourceRequestMessage)
}

::google::protobuf::uint8* ResourceRequestMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ResourceRequestMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated .mesos.Request requests = 2;
  for (int i = 0; i < this->requests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->requests(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ResourceRequestMessage)
  return target;
}

int ResourceRequestMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  // repeated .mesos.Request requests = 2;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceRequestMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceRequestMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceRequestMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceRequestMessage::MergeFrom(const ResourceRequestMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  requests_.MergeFrom(from.requests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceRequestMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceRequestMessage::CopyFrom(const ResourceRequestMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceRequestMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->requests())) return false;
  return true;
}

void ResourceRequestMessage::Swap(ResourceRequestMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    requests_.Swap(&other->requests_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceRequestMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceRequestMessage_descriptor_;
  metadata.reflection = ResourceRequestMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceOffersMessage::kOffersFieldNumber;
const int ResourceOffersMessage::kPidsFieldNumber;
#endif  // !_MSC_VER

ResourceOffersMessage::ResourceOffersMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ResourceOffersMessage)
}

void ResourceOffersMessage::InitAsDefaultInstance() {
}

ResourceOffersMessage::ResourceOffersMessage(const ResourceOffersMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ResourceOffersMessage)
}

void ResourceOffersMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceOffersMessage::~ResourceOffersMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ResourceOffersMessage)
  SharedDtor();
}

void ResourceOffersMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResourceOffersMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceOffersMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceOffersMessage_descriptor_;
}

const ResourceOffersMessage& ResourceOffersMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ResourceOffersMessage* ResourceOffersMessage::default_instance_ = NULL;

ResourceOffersMessage* ResourceOffersMessage::New() const {
  return new ResourceOffersMessage;
}

void ResourceOffersMessage::Clear() {
  offers_.Clear();
  pids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceOffersMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ResourceOffersMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Offer offers = 1;
      case 1: {
        if (tag == 10) {
         parse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_offers;
        if (input->ExpectTag(18)) goto parse_pids;
        break;
      }

      // repeated string pids = 2;
      case 2: {
        if (tag == 18) {
         parse_pids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_pids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pids(this->pids_size() - 1).data(),
            this->pids(this->pids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pids");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ResourceOffersMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ResourceOffersMessage)
  return false;
#undef DO_
}

void ResourceOffersMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ResourceOffersMessage)
  // repeated .mesos.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offers(i), output);
  }

  // repeated string pids = 2;
  for (int i = 0; i < this->pids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->pids(i).data(), this->pids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "pids");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ResourceOffersMessage)
}

::google::protobuf::uint8* ResourceOffersMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ResourceOffersMessage)
  // repeated .mesos.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offers(i), target);
  }

  // repeated string pids = 2;
  for (int i = 0; i < this->pids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pids(i).data(), this->pids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pids");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->pids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ResourceOffersMessage)
  return target;
}

int ResourceOffersMessage::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Offer offers = 1;
  total_size += 1 * this->offers_size();
  for (int i = 0; i < this->offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offers(i));
  }

  // repeated string pids = 2;
  total_size += 1 * this->pids_size();
  for (int i = 0; i < this->pids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->pids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceOffersMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceOffersMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceOffersMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceOffersMessage::MergeFrom(const ResourceOffersMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  offers_.MergeFrom(from.offers_);
  pids_.MergeFrom(from.pids_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceOffersMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceOffersMessage::CopyFrom(const ResourceOffersMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceOffersMessage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->offers())) return false;
  return true;
}

void ResourceOffersMessage::Swap(ResourceOffersMessage* other) {
  if (other != this) {
    offers_.Swap(&other->offers_);
    pids_.Swap(&other->pids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceOffersMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceOffersMessage_descriptor_;
  metadata.reflection = ResourceOffersMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InverseOffersMessage::kInverseOffersFieldNumber;
const int InverseOffersMessage::kPidsFieldNumber;
#endif  // !_MSC_VER

InverseOffersMessage::InverseOffersMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.InverseOffersMessage)
}

void InverseOffersMessage::InitAsDefaultInstance() {
}

InverseOffersMessage::InverseOffersMessage(const InverseOffersMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.InverseOffersMessage)
}

void InverseOffersMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InverseOffersMessage::~InverseOffersMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.InverseOffersMessage)
  SharedDtor();
}

void InverseOffersMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InverseOffersMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InverseOffersMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InverseOffersMessage_descriptor_;
}

const InverseOffersMessage& InverseOffersMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

InverseOffersMessage* InverseOffersMessage::default_instance_ = NULL;

InverseOffersMessage* InverseOffersMessage::New() const {
  return new InverseOffersMessage;
}

void InverseOffersMessage::Clear() {
  inverse_offers_.Clear();
  pids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InverseOffersMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.InverseOffersMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.InverseOffer inverse_offers = 1;
      case 1: {
        if (tag == 10) {
         parse_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inverse_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_inverse_offers;
        if (input->ExpectTag(18)) goto parse_pids;
        break;
      }

      // repeated string pids = 2;
      case 2: {
        if (tag == 18) {
         parse_pids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_pids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pids(this->pids_size() - 1).data(),
            this->pids(this->pids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pids");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.InverseOffersMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.InverseOffersMessage)
  return false;
#undef DO_
}

void InverseOffersMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.InverseOffersMessage)
  // repeated .mesos.InverseOffer inverse_offers = 1;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverse_offers(i), output);
  }

  // repeated string pids = 2;
  for (int i = 0; i < this->pids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->pids(i).data(), this->pids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "pids");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.InverseOffersMessage)
}

::google::protobuf::uint8* InverseOffersMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.InverseOffersMessage)
  // repeated .mesos.InverseOffer inverse_offers = 1;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverse_offers(i), target);
  }

  // repeated string pids = 2;
  for (int i = 0; i < this->pids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pids(i).data(), this->pids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pids");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->pids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.InverseOffersMessage)
  return target;
}

int InverseOffersMessage::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.InverseOffer inverse_offers = 1;
  total_size += 1 * this->inverse_offers_size();
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inverse_offers(i));
  }

  // repeated string pids = 2;
  total_size += 1 * this->pids_size();
  for (int i = 0; i < this->pids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->pids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InverseOffersMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InverseOffersMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InverseOffersMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InverseOffersMessage::MergeFrom(const InverseOffersMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  inverse_offers_.MergeFrom(from.inverse_offers_);
  pids_.MergeFrom(from.pids_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InverseOffersMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InverseOffersMessage::CopyFrom(const InverseOffersMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InverseOffersMessage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->inverse_offers())) return false;
  return true;
}

void InverseOffersMessage::Swap(InverseOffersMessage* other) {
  if (other != this) {
    inverse_offers_.Swap(&other->inverse_offers_);
    pids_.Swap(&other->pids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InverseOffersMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InverseOffersMessage_descriptor_;
  metadata.reflection = InverseOffersMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LaunchTasksMessage::kFrameworkIdFieldNumber;
const int LaunchTasksMessage::kTasksFieldNumber;
const int LaunchTasksMessage::kFiltersFieldNumber;
const int LaunchTasksMessage::kOfferIdsFieldNumber;
#endif  // !_MSC_VER

LaunchTasksMessage::LaunchTasksMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.LaunchTasksMessage)
}

void LaunchTasksMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  filters_ = const_cast< ::mesos::Filters*>(&::mesos::Filters::default_instance());
}

LaunchTasksMessage::LaunchTasksMessage(const LaunchTasksMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.LaunchTasksMessage)
}

void LaunchTasksMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaunchTasksMessage::~LaunchTasksMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.LaunchTasksMessage)
  SharedDtor();
}

void LaunchTasksMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete filters_;
  }
}

void LaunchTasksMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaunchTasksMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaunchTasksMessage_descriptor_;
}

const LaunchTasksMessage& LaunchTasksMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

LaunchTasksMessage* LaunchTasksMessage::default_instance_ = NULL;

LaunchTasksMessage* LaunchTasksMessage::New() const {
  return new LaunchTasksMessage;
}

void LaunchTasksMessage::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_filters()) {
      if (filters_ != NULL) filters_->::mesos::Filters::Clear();
    }
  }
  tasks_.Clear();
  offer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LaunchTasksMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.LaunchTasksMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.TaskInfo tasks = 3;
      case 3: {
        if (tag == 26) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectTag(42)) goto parse_filters;
        break;
      }

      // required .mesos.Filters filters = 5;
      case 5: {
        if (tag == 42) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_offer_ids;
        break;
      }

      // repeated .mesos.OfferID offer_ids = 6;
      case 6: {
        if (tag == 50) {
         parse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offer_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_offer_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.LaunchTasksMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.LaunchTasksMessage)
  return false;
#undef DO_
}

void LaunchTasksMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.LaunchTasksMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  // required .mesos.Filters filters = 5;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->filters(), output);
  }

  // repeated .mesos.OfferID offer_ids = 6;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->offer_ids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.LaunchTasksMessage)
}

::google::protobuf::uint8* LaunchTasksMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.LaunchTasksMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  // required .mesos.Filters filters = 5;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->filters(), target);
  }

  // repeated .mesos.OfferID offer_ids = 6;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->offer_ids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.LaunchTasksMessage)
  return target;
}

int LaunchTasksMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.Filters filters = 5;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.TaskInfo tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  // repeated .mesos.OfferID offer_ids = 6;
  total_size += 1 * this->offer_ids_size();
  for (int i = 0; i < this->offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offer_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaunchTasksMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LaunchTasksMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LaunchTasksMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaunchTasksMessage::MergeFrom(const LaunchTasksMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  offer_ids_.MergeFrom(from.offer_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_filters()) {
      mutable_filters()->::mesos::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LaunchTasksMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaunchTasksMessage::CopyFrom(const LaunchTasksMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaunchTasksMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->offer_ids())) return false;
  return true;
}

void LaunchTasksMessage::Swap(LaunchTasksMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    tasks_.Swap(&other->tasks_);
    std::swap(filters_, other->filters_);
    offer_ids_.Swap(&other->offer_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LaunchTasksMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaunchTasksMessage_descriptor_;
  metadata.reflection = LaunchTasksMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RescindResourceOfferMessage::kOfferIdFieldNumber;
#endif  // !_MSC_VER

RescindResourceOfferMessage::RescindResourceOfferMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RescindResourceOfferMessage)
}

void RescindResourceOfferMessage::InitAsDefaultInstance() {
  offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
}

RescindResourceOfferMessage::RescindResourceOfferMessage(const RescindResourceOfferMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RescindResourceOfferMessage)
}

void RescindResourceOfferMessage::SharedCtor() {
  _cached_size_ = 0;
  offer_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RescindResourceOfferMessage::~RescindResourceOfferMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RescindResourceOfferMessage)
  SharedDtor();
}

void RescindResourceOfferMessage::SharedDtor() {
  if (this != default_instance_) {
    delete offer_id_;
  }
}

void RescindResourceOfferMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RescindResourceOfferMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RescindResourceOfferMessage_descriptor_;
}

const RescindResourceOfferMessage& RescindResourceOfferMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RescindResourceOfferMessage* RescindResourceOfferMessage::default_instance_ = NULL;

RescindResourceOfferMessage* RescindResourceOfferMessage::New() const {
  return new RescindResourceOfferMessage;
}

void RescindResourceOfferMessage::Clear() {
  if (has_offer_id()) {
    if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RescindResourceOfferMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RescindResourceOfferMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID offer_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offer_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RescindResourceOfferMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RescindResourceOfferMessage)
  return false;
#undef DO_
}

void RescindResourceOfferMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RescindResourceOfferMessage)
  // required .mesos.OfferID offer_id = 1;
  if (has_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RescindResourceOfferMessage)
}

::google::protobuf::uint8* RescindResourceOfferMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RescindResourceOfferMessage)
  // required .mesos.OfferID offer_id = 1;
  if (has_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RescindResourceOfferMessage)
  return target;
}

int RescindResourceOfferMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID offer_id = 1;
    if (has_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offer_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RescindResourceOfferMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RescindResourceOfferMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RescindResourceOfferMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RescindResourceOfferMessage::MergeFrom(const RescindResourceOfferMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offer_id()) {
      mutable_offer_id()->::mesos::OfferID::MergeFrom(from.offer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RescindResourceOfferMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RescindResourceOfferMessage::CopyFrom(const RescindResourceOfferMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RescindResourceOfferMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_offer_id()) {
    if (!this->offer_id().IsInitialized()) return false;
  }
  return true;
}

void RescindResourceOfferMessage::Swap(RescindResourceOfferMessage* other) {
  if (other != this) {
    std::swap(offer_id_, other->offer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RescindResourceOfferMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RescindResourceOfferMessage_descriptor_;
  metadata.reflection = RescindResourceOfferMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RescindInverseOfferMessage::kInverseOfferIdFieldNumber;
#endif  // !_MSC_VER

RescindInverseOfferMessage::RescindInverseOfferMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RescindInverseOfferMessage)
}

void RescindInverseOfferMessage::InitAsDefaultInstance() {
  inverse_offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
}

RescindInverseOfferMessage::RescindInverseOfferMessage(const RescindInverseOfferMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RescindInverseOfferMessage)
}

void RescindInverseOfferMessage::SharedCtor() {
  _cached_size_ = 0;
  inverse_offer_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RescindInverseOfferMessage::~RescindInverseOfferMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RescindInverseOfferMessage)
  SharedDtor();
}

void RescindInverseOfferMessage::SharedDtor() {
  if (this != default_instance_) {
    delete inverse_offer_id_;
  }
}

void RescindInverseOfferMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RescindInverseOfferMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RescindInverseOfferMessage_descriptor_;
}

const RescindInverseOfferMessage& RescindInverseOfferMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RescindInverseOfferMessage* RescindInverseOfferMessage::default_instance_ = NULL;

RescindInverseOfferMessage* RescindInverseOfferMessage::New() const {
  return new RescindInverseOfferMessage;
}

void RescindInverseOfferMessage::Clear() {
  if (has_inverse_offer_id()) {
    if (inverse_offer_id_ != NULL) inverse_offer_id_->::mesos::OfferID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RescindInverseOfferMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RescindInverseOfferMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID inverse_offer_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inverse_offer_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RescindInverseOfferMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RescindInverseOfferMessage)
  return false;
#undef DO_
}

void RescindInverseOfferMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RescindInverseOfferMessage)
  // required .mesos.OfferID inverse_offer_id = 1;
  if (has_inverse_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverse_offer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RescindInverseOfferMessage)
}

::google::protobuf::uint8* RescindInverseOfferMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RescindInverseOfferMessage)
  // required .mesos.OfferID inverse_offer_id = 1;
  if (has_inverse_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverse_offer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RescindInverseOfferMessage)
  return target;
}

int RescindInverseOfferMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID inverse_offer_id = 1;
    if (has_inverse_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inverse_offer_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RescindInverseOfferMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RescindInverseOfferMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RescindInverseOfferMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RescindInverseOfferMessage::MergeFrom(const RescindInverseOfferMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_inverse_offer_id()) {
      mutable_inverse_offer_id()->::mesos::OfferID::MergeFrom(from.inverse_offer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RescindInverseOfferMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RescindInverseOfferMessage::CopyFrom(const RescindInverseOfferMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RescindInverseOfferMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_inverse_offer_id()) {
    if (!this->inverse_offer_id().IsInitialized()) return false;
  }
  return true;
}

void RescindInverseOfferMessage::Swap(RescindInverseOfferMessage* other) {
  if (other != this) {
    std::swap(inverse_offer_id_, other->inverse_offer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RescindInverseOfferMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RescindInverseOfferMessage_descriptor_;
  metadata.reflection = RescindInverseOfferMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReviveOffersMessage::kFrameworkIdFieldNumber;
const int ReviveOffersMessage::kRolesFieldNumber;
#endif  // !_MSC_VER

ReviveOffersMessage::ReviveOffersMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ReviveOffersMessage)
}

void ReviveOffersMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ReviveOffersMessage::ReviveOffersMessage(const ReviveOffersMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ReviveOffersMessage)
}

void ReviveOffersMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReviveOffersMessage::~ReviveOffersMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ReviveOffersMessage)
  SharedDtor();
}

void ReviveOffersMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ReviveOffersMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReviveOffersMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReviveOffersMessage_descriptor_;
}

const ReviveOffersMessage& ReviveOffersMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ReviveOffersMessage* ReviveOffersMessage::default_instance_ = NULL;

ReviveOffersMessage* ReviveOffersMessage::New() const {
  return new ReviveOffersMessage;
}

void ReviveOffersMessage::Clear() {
  if (has_framework_id()) {
    if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  }
  roles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReviveOffersMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ReviveOffersMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_roles;
        break;
      }

      // repeated string roles = 2;
      case 2: {
        if (tag == 18) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_roles()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->roles(this->roles_size() - 1).data(),
            this->roles(this->roles_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roles");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_roles;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ReviveOffersMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ReviveOffersMessage)
  return false;
#undef DO_
}

void ReviveOffersMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ReviveOffersMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated string roles = 2;
  for (int i = 0; i < this->roles_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->roles(i).data(), this->roles(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "roles");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->roles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ReviveOffersMessage)
}

::google::protobuf::uint8* ReviveOffersMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ReviveOffersMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated string roles = 2;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->roles(i).data(), this->roles(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roles");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->roles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ReviveOffersMessage)
  return target;
}

int ReviveOffersMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  // repeated string roles = 2;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->roles(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReviveOffersMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReviveOffersMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReviveOffersMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReviveOffersMessage::MergeFrom(const ReviveOffersMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  roles_.MergeFrom(from.roles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReviveOffersMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReviveOffersMessage::CopyFrom(const ReviveOffersMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReviveOffersMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void ReviveOffersMessage::Swap(ReviveOffersMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    roles_.Swap(&other->roles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReviveOffersMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReviveOffersMessage_descriptor_;
  metadata.reflection = ReviveOffersMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RunTaskMessage::kFrameworkIdFieldNumber;
const int RunTaskMessage::kFrameworkFieldNumber;
const int RunTaskMessage::kTaskFieldNumber;
const int RunTaskMessage::kPidFieldNumber;
#endif  // !_MSC_VER

RunTaskMessage::RunTaskMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RunTaskMessage)
}

void RunTaskMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
  task_ = const_cast< ::mesos::TaskInfo*>(&::mesos::TaskInfo::default_instance());
}

RunTaskMessage::RunTaskMessage(const RunTaskMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RunTaskMessage)
}

void RunTaskMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  framework_id_ = NULL;
  framework_ = NULL;
  task_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunTaskMessage::~RunTaskMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RunTaskMessage)
  SharedDtor();
}

void RunTaskMessage::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete framework_id_;
    delete framework_;
    delete task_;
  }
}

void RunTaskMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RunTaskMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RunTaskMessage_descriptor_;
}

const RunTaskMessage& RunTaskMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RunTaskMessage* RunTaskMessage::default_instance_ = NULL;

RunTaskMessage* RunTaskMessage::New() const {
  return new RunTaskMessage;
}

void RunTaskMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
    if (has_task()) {
      if (task_ != NULL) task_->::mesos::TaskInfo::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RunTaskMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RunTaskMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework;
        break;
      }

      // required .mesos.FrameworkInfo framework = 2;
      case 2: {
        if (tag == 18) {
         parse_framework:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pid;
        break;
      }

      // optional string pid = 3;
      case 3: {
        if (tag == 26) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_task;
        break;
      }

      // required .mesos.TaskInfo task = 4;
      case 4: {
        if (tag == 34) {
         parse_task:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RunTaskMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RunTaskMessage)
  return false;
#undef DO_
}

void RunTaskMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RunTaskMessage)
  // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework(), output);
  }

  // optional string pid = 3;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->pid(), output);
  }

  // required .mesos.TaskInfo task = 4;
  if (has_task()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->task(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RunTaskMessage)
}

::google::protobuf::uint8* RunTaskMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RunTaskMessage)
  // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.FrameworkInfo framework = 2;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework(), target);
  }

  // optional string pid = 3;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->pid(), target);
  }

  // required .mesos.TaskInfo task = 4;
  if (has_task()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->task(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RunTaskMessage)
  return target;
}

int RunTaskMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.FrameworkID framework_id = 1 [deprecated = true];
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.FrameworkInfo framework = 2;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

    // required .mesos.TaskInfo task = 4;
    if (has_task()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task());
    }

    // optional string pid = 3;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunTaskMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RunTaskMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RunTaskMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RunTaskMessage::MergeFrom(const RunTaskMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
    if (from.has_task()) {
      mutable_task()->::mesos::TaskInfo::MergeFrom(from.task());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RunTaskMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RunTaskMessage::CopyFrom(const RunTaskMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunTaskMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  if (has_task()) {
    if (!this->task().IsInitialized()) return false;
  }
  return true;
}

void RunTaskMessage::Swap(RunTaskMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(framework_, other->framework_);
    std::swap(task_, other->task_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RunTaskMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RunTaskMessage_descriptor_;
  metadata.reflection = RunTaskMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RunTaskGroupMessage::kFrameworkFieldNumber;
const int RunTaskGroupMessage::kExecutorFieldNumber;
const int RunTaskGroupMessage::kTaskGroupFieldNumber;
#endif  // !_MSC_VER

RunTaskGroupMessage::RunTaskGroupMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RunTaskGroupMessage)
}

void RunTaskGroupMessage::InitAsDefaultInstance() {
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
  executor_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  task_group_ = const_cast< ::mesos::TaskGroupInfo*>(&::mesos::TaskGroupInfo::default_instance());
}

RunTaskGroupMessage::RunTaskGroupMessage(const RunTaskGroupMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RunTaskGroupMessage)
}

void RunTaskGroupMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_ = NULL;
  executor_ = NULL;
  task_group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunTaskGroupMessage::~RunTaskGroupMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RunTaskGroupMessage)
  SharedDtor();
}

void RunTaskGroupMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_;
    delete executor_;
    delete task_group_;
  }
}

void RunTaskGroupMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RunTaskGroupMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RunTaskGroupMessage_descriptor_;
}

const RunTaskGroupMessage& RunTaskGroupMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RunTaskGroupMessage* RunTaskGroupMessage::default_instance_ = NULL;

RunTaskGroupMessage* RunTaskGroupMessage::New() const {
  return new RunTaskGroupMessage;
}

void RunTaskGroupMessage::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
    if (has_executor()) {
      if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
    }
    if (has_task_group()) {
      if (task_group_ != NULL) task_group_->::mesos::TaskGroupInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RunTaskGroupMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RunTaskGroupMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_executor;
        break;
      }

      // required .mesos.ExecutorInfo executor = 2;
      case 2: {
        if (tag == 18) {
         parse_executor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_task_group;
        break;
      }

      // required .mesos.TaskGroupInfo task_group = 3;
      case 3: {
        if (tag == 26) {
         parse_task_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_group()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RunTaskGroupMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RunTaskGroupMessage)
  return false;
#undef DO_
}

void RunTaskGroupMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RunTaskGroupMessage)
  // required .mesos.FrameworkInfo framework = 1;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework(), output);
  }

  // required .mesos.ExecutorInfo executor = 2;
  if (has_executor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor(), output);
  }

  // required .mesos.TaskGroupInfo task_group = 3;
  if (has_task_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->task_group(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RunTaskGroupMessage)
}

::google::protobuf::uint8* RunTaskGroupMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RunTaskGroupMessage)
  // required .mesos.FrameworkInfo framework = 1;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework(), target);
  }

  // required .mesos.ExecutorInfo executor = 2;
  if (has_executor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor(), target);
  }

  // required .mesos.TaskGroupInfo task_group = 3;
  if (has_task_group()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->task_group(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RunTaskGroupMessage)
  return target;
}

int RunTaskGroupMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework = 1;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

    // required .mesos.ExecutorInfo executor = 2;
    if (has_executor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor());
    }

    // required .mesos.TaskGroupInfo task_group = 3;
    if (has_task_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_group());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunTaskGroupMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RunTaskGroupMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RunTaskGroupMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RunTaskGroupMessage::MergeFrom(const RunTaskGroupMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
    if (from.has_executor()) {
      mutable_executor()->::mesos::ExecutorInfo::MergeFrom(from.executor());
    }
    if (from.has_task_group()) {
      mutable_task_group()->::mesos::TaskGroupInfo::MergeFrom(from.task_group());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RunTaskGroupMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RunTaskGroupMessage::CopyFrom(const RunTaskGroupMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunTaskGroupMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  if (has_executor()) {
    if (!this->executor().IsInitialized()) return false;
  }
  if (has_task_group()) {
    if (!this->task_group().IsInitialized()) return false;
  }
  return true;
}

void RunTaskGroupMessage::Swap(RunTaskGroupMessage* other) {
  if (other != this) {
    std::swap(framework_, other->framework_);
    std::swap(executor_, other->executor_);
    std::swap(task_group_, other->task_group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RunTaskGroupMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RunTaskGroupMessage_descriptor_;
  metadata.reflection = RunTaskGroupMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KillTaskMessage::kFrameworkIdFieldNumber;
const int KillTaskMessage::kTaskIdFieldNumber;
const int KillTaskMessage::kKillPolicyFieldNumber;
#endif  // !_MSC_VER

KillTaskMessage::KillTaskMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.KillTaskMessage)
}

void KillTaskMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  kill_policy_ = const_cast< ::mesos::KillPolicy*>(&::mesos::KillPolicy::default_instance());
}

KillTaskMessage::KillTaskMessage(const KillTaskMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.KillTaskMessage)
}

void KillTaskMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  task_id_ = NULL;
  kill_policy_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KillTaskMessage::~KillTaskMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.KillTaskMessage)
  SharedDtor();
}

void KillTaskMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete task_id_;
    delete kill_policy_;
  }
}

void KillTaskMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KillTaskMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KillTaskMessage_descriptor_;
}

const KillTaskMessage& KillTaskMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

KillTaskMessage* KillTaskMessage::default_instance_ = NULL;

KillTaskMessage* KillTaskMessage::New() const {
  return new KillTaskMessage;
}

void KillTaskMessage::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_kill_policy()) {
      if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KillTaskMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.KillTaskMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_kill_policy;
        break;
      }

      // optional .mesos.KillPolicy kill_policy = 3;
      case 3: {
        if (tag == 26) {
         parse_kill_policy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kill_policy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.KillTaskMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.KillTaskMessage)
  return false;
#undef DO_
}

void KillTaskMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.KillTaskMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  // optional .mesos.KillPolicy kill_policy = 3;
  if (has_kill_policy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->kill_policy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.KillTaskMessage)
}

::google::protobuf::uint8* KillTaskMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.KillTaskMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  // optional .mesos.KillPolicy kill_policy = 3;
  if (has_kill_policy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->kill_policy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.KillTaskMessage)
  return target;
}

int KillTaskMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // optional .mesos.KillPolicy kill_policy = 3;
    if (has_kill_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kill_policy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillTaskMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KillTaskMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KillTaskMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KillTaskMessage::MergeFrom(const KillTaskMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_kill_policy()) {
      mutable_kill_policy()->::mesos::KillPolicy::MergeFrom(from.kill_policy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KillTaskMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KillTaskMessage::CopyFrom(const KillTaskMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillTaskMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_kill_policy()) {
    if (!this->kill_policy().IsInitialized()) return false;
  }
  return true;
}

void KillTaskMessage::Swap(KillTaskMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(kill_policy_, other->kill_policy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KillTaskMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KillTaskMessage_descriptor_;
  metadata.reflection = KillTaskMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StatusUpdateMessage::kUpdateFieldNumber;
const int StatusUpdateMessage::kPidFieldNumber;
#endif  // !_MSC_VER

StatusUpdateMessage::StatusUpdateMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.StatusUpdateMessage)
}

void StatusUpdateMessage::InitAsDefaultInstance() {
  update_ = const_cast< ::mesos::internal::StatusUpdate*>(&::mesos::internal::StatusUpdate::default_instance());
}

StatusUpdateMessage::StatusUpdateMessage(const StatusUpdateMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.StatusUpdateMessage)
}

void StatusUpdateMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdateMessage::~StatusUpdateMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.StatusUpdateMessage)
  SharedDtor();
}

void StatusUpdateMessage::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete update_;
  }
}

void StatusUpdateMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdateMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateMessage_descriptor_;
}

const StatusUpdateMessage& StatusUpdateMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

StatusUpdateMessage* StatusUpdateMessage::default_instance_ = NULL;

StatusUpdateMessage* StatusUpdateMessage::New() const {
  return new StatusUpdateMessage;
}

void StatusUpdateMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_update()) {
      if (update_ != NULL) update_->::mesos::internal::StatusUpdate::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdateMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.StatusUpdateMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.internal.StatusUpdate update = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pid;
        break;
      }

      // optional string pid = 2;
      case 2: {
        if (tag == 18) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.StatusUpdateMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.StatusUpdateMessage)
  return false;
#undef DO_
}

void StatusUpdateMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.StatusUpdateMessage)
  // required .mesos.internal.StatusUpdate update = 1;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->update(), output);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.StatusUpdateMessage)
}

::google::protobuf::uint8* StatusUpdateMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.StatusUpdateMessage)
  // required .mesos.internal.StatusUpdate update = 1;
  if (has_update()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->update(), target);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.StatusUpdateMessage)
  return target;
}

int StatusUpdateMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.internal.StatusUpdate update = 1;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update());
    }

    // optional string pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdateMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdateMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdateMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdateMessage::MergeFrom(const StatusUpdateMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update()) {
      mutable_update()->::mesos::internal::StatusUpdate::MergeFrom(from.update());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdateMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdateMessage::CopyFrom(const StatusUpdateMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdateMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_update()) {
    if (!this->update().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdateMessage::Swap(StatusUpdateMessage* other) {
  if (other != this) {
    std::swap(update_, other->update_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdateMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdateMessage_descriptor_;
  metadata.reflection = StatusUpdateMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StatusUpdateAcknowledgementMessage::kSlaveIdFieldNumber;
const int StatusUpdateAcknowledgementMessage::kFrameworkIdFieldNumber;
const int StatusUpdateAcknowledgementMessage::kTaskIdFieldNumber;
const int StatusUpdateAcknowledgementMessage::kUuidFieldNumber;
#endif  // !_MSC_VER

StatusUpdateAcknowledgementMessage::StatusUpdateAcknowledgementMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.StatusUpdateAcknowledgementMessage)
}

void StatusUpdateAcknowledgementMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
}

StatusUpdateAcknowledgementMessage::StatusUpdateAcknowledgementMessage(const StatusUpdateAcknowledgementMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.StatusUpdateAcknowledgementMessage)
}

void StatusUpdateAcknowledgementMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  task_id_ = NULL;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusUpdateAcknowledgementMessage::~StatusUpdateAcknowledgementMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.StatusUpdateAcknowledgementMessage)
  SharedDtor();
}

void StatusUpdateAcknowledgementMessage::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete task_id_;
  }
}

void StatusUpdateAcknowledgementMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StatusUpdateAcknowledgementMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StatusUpdateAcknowledgementMessage_descriptor_;
}

const StatusUpdateAcknowledgementMessage& StatusUpdateAcknowledgementMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

StatusUpdateAcknowledgementMessage* StatusUpdateAcknowledgementMessage::default_instance_ = NULL;

StatusUpdateAcknowledgementMessage* StatusUpdateAcknowledgementMessage::New() const {
  return new StatusUpdateAcknowledgementMessage;
}

void StatusUpdateAcknowledgementMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StatusUpdateAcknowledgementMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.StatusUpdateAcknowledgementMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 3;
      case 3: {
        if (tag == 26) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_uuid;
        break;
      }

      // required bytes uuid = 4;
      case 4: {
        if (tag == 34) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.StatusUpdateAcknowledgementMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.StatusUpdateAcknowledgementMessage)
  return false;
#undef DO_
}

void StatusUpdateAcknowledgementMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.StatusUpdateAcknowledgementMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.TaskID task_id = 3;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->task_id(), output);
  }

  // required bytes uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.StatusUpdateAcknowledgementMessage)
}

::google::protobuf::uint8* StatusUpdateAcknowledgementMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.StatusUpdateAcknowledgementMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.TaskID task_id = 3;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->task_id(), target);
  }

  // required bytes uuid = 4;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.StatusUpdateAcknowledgementMessage)
  return target;
}

int StatusUpdateAcknowledgementMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.TaskID task_id = 3;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required bytes uuid = 4;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusUpdateAcknowledgementMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StatusUpdateAcknowledgementMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StatusUpdateAcknowledgementMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StatusUpdateAcknowledgementMessage::MergeFrom(const StatusUpdateAcknowledgementMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StatusUpdateAcknowledgementMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusUpdateAcknowledgementMessage::CopyFrom(const StatusUpdateAcknowledgementMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusUpdateAcknowledgementMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void StatusUpdateAcknowledgementMessage::Swap(StatusUpdateAcknowledgementMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StatusUpdateAcknowledgementMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StatusUpdateAcknowledgementMessage_descriptor_;
  metadata.reflection = StatusUpdateAcknowledgementMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LostSlaveMessage::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

LostSlaveMessage::LostSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.LostSlaveMessage)
}

void LostSlaveMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

LostSlaveMessage::LostSlaveMessage(const LostSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.LostSlaveMessage)
}

void LostSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LostSlaveMessage::~LostSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.LostSlaveMessage)
  SharedDtor();
}

void LostSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void LostSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LostSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LostSlaveMessage_descriptor_;
}

const LostSlaveMessage& LostSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

LostSlaveMessage* LostSlaveMessage::default_instance_ = NULL;

LostSlaveMessage* LostSlaveMessage::New() const {
  return new LostSlaveMessage;
}

void LostSlaveMessage::Clear() {
  if (has_slave_id()) {
    if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LostSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.LostSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.LostSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.LostSlaveMessage)
  return false;
#undef DO_
}

void LostSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.LostSlaveMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.LostSlaveMessage)
}

::google::protobuf::uint8* LostSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.LostSlaveMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.LostSlaveMessage)
  return target;
}

int LostSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LostSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LostSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LostSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LostSlaveMessage::MergeFrom(const LostSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LostSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LostSlaveMessage::CopyFrom(const LostSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LostSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void LostSlaveMessage::Swap(LostSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LostSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LostSlaveMessage_descriptor_;
  metadata.reflection = LostSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReconcileTasksMessage::kFrameworkIdFieldNumber;
const int ReconcileTasksMessage::kStatusesFieldNumber;
const int ReconcileTasksMessage::kFrameworkFieldNumber;
#endif  // !_MSC_VER

ReconcileTasksMessage::ReconcileTasksMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ReconcileTasksMessage)
}

void ReconcileTasksMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  framework_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

ReconcileTasksMessage::ReconcileTasksMessage(const ReconcileTasksMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ReconcileTasksMessage)
}

void ReconcileTasksMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  framework_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReconcileTasksMessage::~ReconcileTasksMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ReconcileTasksMessage)
  SharedDtor();
}

void ReconcileTasksMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete framework_;
  }
}

void ReconcileTasksMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconcileTasksMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconcileTasksMessage_descriptor_;
}

const ReconcileTasksMessage& ReconcileTasksMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ReconcileTasksMessage* ReconcileTasksMessage::default_instance_ = NULL;

ReconcileTasksMessage* ReconcileTasksMessage::New() const {
  return new ReconcileTasksMessage;
}

void ReconcileTasksMessage::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_framework()) {
      if (framework_ != NULL) framework_->::mesos::FrameworkInfo::Clear();
    }
  }
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReconcileTasksMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ReconcileTasksMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_statuses;
        break;
      }

      // repeated .mesos.TaskStatus statuses = 2;
      case 2: {
        if (tag == 18) {
         parse_statuses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_statuses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_statuses;
        if (input->ExpectTag(26)) goto parse_framework;
        break;
      }

      // optional .mesos.FrameworkInfo framework = 3;
      case 3: {
        if (tag == 26) {
         parse_framework:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ReconcileTasksMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ReconcileTasksMessage)
  return false;
#undef DO_
}

void ReconcileTasksMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ReconcileTasksMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // repeated .mesos.TaskStatus statuses = 2;
  for (int i = 0; i < this->statuses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->statuses(i), output);
  }

  // optional .mesos.FrameworkInfo framework = 3;
  if (has_framework()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ReconcileTasksMessage)
}

::google::protobuf::uint8* ReconcileTasksMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ReconcileTasksMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // repeated .mesos.TaskStatus statuses = 2;
  for (int i = 0; i < this->statuses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->statuses(i), target);
  }

  // optional .mesos.FrameworkInfo framework = 3;
  if (has_framework()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ReconcileTasksMessage)
  return target;
}

int ReconcileTasksMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.FrameworkInfo framework = 3;
    if (has_framework()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework());
    }

  }
  // repeated .mesos.TaskStatus statuses = 2;
  total_size += 1 * this->statuses_size();
  for (int i = 0; i < this->statuses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->statuses(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconcileTasksMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReconcileTasksMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReconcileTasksMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReconcileTasksMessage::MergeFrom(const ReconcileTasksMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_framework()) {
      mutable_framework()->::mesos::FrameworkInfo::MergeFrom(from.framework());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReconcileTasksMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconcileTasksMessage::CopyFrom(const ReconcileTasksMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconcileTasksMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->statuses())) return false;
  if (has_framework()) {
    if (!this->framework().IsInitialized()) return false;
  }
  return true;
}

void ReconcileTasksMessage::Swap(ReconcileTasksMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    statuses_.Swap(&other->statuses_);
    std::swap(framework_, other->framework_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReconcileTasksMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconcileTasksMessage_descriptor_;
  metadata.reflection = ReconcileTasksMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkErrorMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

FrameworkErrorMessage::FrameworkErrorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.FrameworkErrorMessage)
}

void FrameworkErrorMessage::InitAsDefaultInstance() {
}

FrameworkErrorMessage::FrameworkErrorMessage(const FrameworkErrorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.FrameworkErrorMessage)
}

void FrameworkErrorMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkErrorMessage::~FrameworkErrorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.FrameworkErrorMessage)
  SharedDtor();
}

void FrameworkErrorMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void FrameworkErrorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkErrorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkErrorMessage_descriptor_;
}

const FrameworkErrorMessage& FrameworkErrorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

FrameworkErrorMessage* FrameworkErrorMessage::default_instance_ = NULL;

FrameworkErrorMessage* FrameworkErrorMessage::New() const {
  return new FrameworkErrorMessage;
}

void FrameworkErrorMessage::Clear() {
  if (has_message()) {
    if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      message_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkErrorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.FrameworkErrorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string message = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.FrameworkErrorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.FrameworkErrorMessage)
  return false;
#undef DO_
}

void FrameworkErrorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.FrameworkErrorMessage)
  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.FrameworkErrorMessage)
}

::google::protobuf::uint8* FrameworkErrorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.FrameworkErrorMessage)
  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.FrameworkErrorMessage)
  return target;
}

int FrameworkErrorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkErrorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkErrorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkErrorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkErrorMessage::MergeFrom(const FrameworkErrorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkErrorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkErrorMessage::CopyFrom(const FrameworkErrorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkErrorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FrameworkErrorMessage::Swap(FrameworkErrorMessage* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkErrorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkErrorMessage_descriptor_;
  metadata.reflection = FrameworkErrorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterSlaveMessage::kSlaveFieldNumber;
const int RegisterSlaveMessage::kCheckpointedResourcesFieldNumber;
const int RegisterSlaveMessage::kVersionFieldNumber;
const int RegisterSlaveMessage::kAgentCapabilitiesFieldNumber;
#endif  // !_MSC_VER

RegisterSlaveMessage::RegisterSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RegisterSlaveMessage)
}

void RegisterSlaveMessage::InitAsDefaultInstance() {
  slave_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

RegisterSlaveMessage::RegisterSlaveMessage(const RegisterSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RegisterSlaveMessage)
}

void RegisterSlaveMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_ = NULL;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterSlaveMessage::~RegisterSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RegisterSlaveMessage)
  SharedDtor();
}

void RegisterSlaveMessage::SharedDtor() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (this != default_instance_) {
    delete slave_;
  }
}

void RegisterSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterSlaveMessage_descriptor_;
}

const RegisterSlaveMessage& RegisterSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RegisterSlaveMessage* RegisterSlaveMessage::default_instance_ = NULL;

RegisterSlaveMessage* RegisterSlaveMessage::New() const {
  return new RegisterSlaveMessage;
}

void RegisterSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_slave()) {
      if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
  }
  checkpointed_resources_.Clear();
  agent_capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RegisterSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveInfo slave = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_version;
        break;
      }

      // optional string version = 2;
      case 2: {
        if (tag == 18) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_checkpointed_resources;
        break;
      }

      // repeated .mesos.Resource checkpointed_resources = 3;
      case 3: {
        if (tag == 26) {
         parse_checkpointed_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_checkpointed_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_checkpointed_resources;
        if (input->ExpectTag(34)) goto parse_agent_capabilities;
        break;
      }

      // repeated .mesos.SlaveInfo.Capability agent_capabilities = 4;
      case 4: {
        if (tag == 34) {
         parse_agent_capabilities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_agent_capabilities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_agent_capabilities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RegisterSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RegisterSlaveMessage)
  return false;
#undef DO_
}

void RegisterSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RegisterSlaveMessage)
  // required .mesos.SlaveInfo slave = 1;
  if (has_slave()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave(), output);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->version(), output);
  }

  // repeated .mesos.Resource checkpointed_resources = 3;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->checkpointed_resources(i), output);
  }

  // repeated .mesos.SlaveInfo.Capability agent_capabilities = 4;
  for (int i = 0; i < this->agent_capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->agent_capabilities(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RegisterSlaveMessage)
}

::google::protobuf::uint8* RegisterSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RegisterSlaveMessage)
  // required .mesos.SlaveInfo slave = 1;
  if (has_slave()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave(), target);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->version(), target);
  }

  // repeated .mesos.Resource checkpointed_resources = 3;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->checkpointed_resources(i), target);
  }

  // repeated .mesos.SlaveInfo.Capability agent_capabilities = 4;
  for (int i = 0; i < this->agent_capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->agent_capabilities(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RegisterSlaveMessage)
  return target;
}

int RegisterSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveInfo slave = 1;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }

    // optional string version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  // repeated .mesos.Resource checkpointed_resources = 3;
  total_size += 1 * this->checkpointed_resources_size();
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->checkpointed_resources(i));
  }

  // repeated .mesos.SlaveInfo.Capability agent_capabilities = 4;
  total_size += 1 * this->agent_capabilities_size();
  for (int i = 0; i < this->agent_capabilities_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->agent_capabilities(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterSlaveMessage::MergeFrom(const RegisterSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  checkpointed_resources_.MergeFrom(from.checkpointed_resources_);
  agent_capabilities_.MergeFrom(from.agent_capabilities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave()) {
      mutable_slave()->::mesos::SlaveInfo::MergeFrom(from.slave());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterSlaveMessage::CopyFrom(const RegisterSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->checkpointed_resources())) return false;
  return true;
}

void RegisterSlaveMessage::Swap(RegisterSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_, other->slave_);
    checkpointed_resources_.Swap(&other->checkpointed_resources_);
    std::swap(version_, other->version_);
    agent_capabilities_.Swap(&other->agent_capabilities_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterSlaveMessage_descriptor_;
  metadata.reflection = RegisterSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReregisterSlaveMessage::kSlaveFieldNumber;
const int ReregisterSlaveMessage::kCheckpointedResourcesFieldNumber;
const int ReregisterSlaveMessage::kExecutorInfosFieldNumber;
const int ReregisterSlaveMessage::kTasksFieldNumber;
const int ReregisterSlaveMessage::kFrameworksFieldNumber;
const int ReregisterSlaveMessage::kCompletedFrameworksFieldNumber;
const int ReregisterSlaveMessage::kVersionFieldNumber;
const int ReregisterSlaveMessage::kAgentCapabilitiesFieldNumber;
#endif  // !_MSC_VER

ReregisterSlaveMessage::ReregisterSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ReregisterSlaveMessage)
}

void ReregisterSlaveMessage::InitAsDefaultInstance() {
  slave_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

ReregisterSlaveMessage::ReregisterSlaveMessage(const ReregisterSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ReregisterSlaveMessage)
}

void ReregisterSlaveMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_ = NULL;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReregisterSlaveMessage::~ReregisterSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ReregisterSlaveMessage)
  SharedDtor();
}

void ReregisterSlaveMessage::SharedDtor() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (this != default_instance_) {
    delete slave_;
  }
}

void ReregisterSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReregisterSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReregisterSlaveMessage_descriptor_;
}

const ReregisterSlaveMessage& ReregisterSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ReregisterSlaveMessage* ReregisterSlaveMessage::default_instance_ = NULL;

ReregisterSlaveMessage* ReregisterSlaveMessage::New() const {
  return new ReregisterSlaveMessage;
}

void ReregisterSlaveMessage::Clear() {
  if (_has_bits_[0 / 32] & 65) {
    if (has_slave()) {
      if (slave_ != NULL) slave_->::mesos::SlaveInfo::Clear();
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
  }
  checkpointed_resources_.Clear();
  executor_infos_.Clear();
  tasks_.Clear();
  frameworks_.Clear();
  completed_frameworks_.Clear();
  agent_capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReregisterSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ReregisterSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveInfo slave = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.Task tasks = 3;
      case 3: {
        if (tag == 26) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectTag(34)) goto parse_executor_infos;
        break;
      }

      // repeated .mesos.ExecutorInfo executor_infos = 4;
      case 4: {
        if (tag == 34) {
         parse_executor_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_executor_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_executor_infos;
        if (input->ExpectTag(42)) goto parse_completed_frameworks;
        break;
      }

      // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
      case 5: {
        if (tag == 42) {
         parse_completed_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_completed_frameworks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_completed_frameworks;
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }

      // optional string version = 6;
      case 6: {
        if (tag == 50) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_checkpointed_resources;
        break;
      }

      // repeated .mesos.Resource checkpointed_resources = 7;
      case 7: {
        if (tag == 58) {
         parse_checkpointed_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_checkpointed_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_checkpointed_resources;
        if (input->ExpectTag(66)) goto parse_frameworks;
        break;
      }

      // repeated .mesos.FrameworkInfo frameworks = 8;
      case 8: {
        if (tag == 66) {
         parse_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frameworks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_frameworks;
        if (input->ExpectTag(74)) goto parse_agent_capabilities;
        break;
      }

      // repeated .mesos.SlaveInfo.Capability agent_capabilities = 9;
      case 9: {
        if (tag == 74) {
         parse_agent_capabilities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_agent_capabilities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_agent_capabilities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ReregisterSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ReregisterSlaveMessage)
  return false;
#undef DO_
}

void ReregisterSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ReregisterSlaveMessage)
  // required .mesos.SlaveInfo slave = 2;
  if (has_slave()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave(), output);
  }

  // repeated .mesos.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  for (int i = 0; i < this->executor_infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->executor_infos(i), output);
  }

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  for (int i = 0; i < this->completed_frameworks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->completed_frameworks(i), output);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->version(), output);
  }

  // repeated .mesos.Resource checkpointed_resources = 7;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->checkpointed_resources(i), output);
  }

  // repeated .mesos.FrameworkInfo frameworks = 8;
  for (int i = 0; i < this->frameworks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->frameworks(i), output);
  }

  // repeated .mesos.SlaveInfo.Capability agent_capabilities = 9;
  for (int i = 0; i < this->agent_capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->agent_capabilities(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ReregisterSlaveMessage)
}

::google::protobuf::uint8* ReregisterSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ReregisterSlaveMessage)
  // required .mesos.SlaveInfo slave = 2;
  if (has_slave()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave(), target);
  }

  // repeated .mesos.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  for (int i = 0; i < this->executor_infos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->executor_infos(i), target);
  }

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  for (int i = 0; i < this->completed_frameworks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->completed_frameworks(i), target);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  // repeated .mesos.Resource checkpointed_resources = 7;
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->checkpointed_resources(i), target);
  }

  // repeated .mesos.FrameworkInfo frameworks = 8;
  for (int i = 0; i < this->frameworks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->frameworks(i), target);
  }

  // repeated .mesos.SlaveInfo.Capability agent_capabilities = 9;
  for (int i = 0; i < this->agent_capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->agent_capabilities(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ReregisterSlaveMessage)
  return target;
}

int ReregisterSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveInfo slave = 2;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }

    // optional string version = 6;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  // repeated .mesos.Resource checkpointed_resources = 7;
  total_size += 1 * this->checkpointed_resources_size();
  for (int i = 0; i < this->checkpointed_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->checkpointed_resources(i));
  }

  // repeated .mesos.ExecutorInfo executor_infos = 4;
  total_size += 1 * this->executor_infos_size();
  for (int i = 0; i < this->executor_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->executor_infos(i));
  }

  // repeated .mesos.Task tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  // repeated .mesos.FrameworkInfo frameworks = 8;
  total_size += 1 * this->frameworks_size();
  for (int i = 0; i < this->frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frameworks(i));
  }

  // repeated .mesos.internal.Archive.Framework completed_frameworks = 5;
  total_size += 1 * this->completed_frameworks_size();
  for (int i = 0; i < this->completed_frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->completed_frameworks(i));
  }

  // repeated .mesos.SlaveInfo.Capability agent_capabilities = 9;
  total_size += 1 * this->agent_capabilities_size();
  for (int i = 0; i < this->agent_capabilities_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->agent_capabilities(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReregisterSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReregisterSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReregisterSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReregisterSlaveMessage::MergeFrom(const ReregisterSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  checkpointed_resources_.MergeFrom(from.checkpointed_resources_);
  executor_infos_.MergeFrom(from.executor_infos_);
  tasks_.MergeFrom(from.tasks_);
  frameworks_.MergeFrom(from.frameworks_);
  completed_frameworks_.MergeFrom(from.completed_frameworks_);
  agent_capabilities_.MergeFrom(from.agent_capabilities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave()) {
      mutable_slave()->::mesos::SlaveInfo::MergeFrom(from.slave());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReregisterSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReregisterSlaveMessage::CopyFrom(const ReregisterSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReregisterSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->checkpointed_resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->executor_infos())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->frameworks())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->completed_frameworks())) return false;
  return true;
}

void ReregisterSlaveMessage::Swap(ReregisterSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_, other->slave_);
    checkpointed_resources_.Swap(&other->checkpointed_resources_);
    executor_infos_.Swap(&other->executor_infos_);
    tasks_.Swap(&other->tasks_);
    frameworks_.Swap(&other->frameworks_);
    completed_frameworks_.Swap(&other->completed_frameworks_);
    std::swap(version_, other->version_);
    agent_capabilities_.Swap(&other->agent_capabilities_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReregisterSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReregisterSlaveMessage_descriptor_;
  metadata.reflection = ReregisterSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveRegisteredMessage::kSlaveIdFieldNumber;
const int SlaveRegisteredMessage::kConnectionFieldNumber;
#endif  // !_MSC_VER

SlaveRegisteredMessage::SlaveRegisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.SlaveRegisteredMessage)
}

void SlaveRegisteredMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  connection_ = const_cast< ::mesos::internal::MasterSlaveConnection*>(&::mesos::internal::MasterSlaveConnection::default_instance());
}

SlaveRegisteredMessage::SlaveRegisteredMessage(const SlaveRegisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.SlaveRegisteredMessage)
}

void SlaveRegisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  connection_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveRegisteredMessage::~SlaveRegisteredMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.SlaveRegisteredMessage)
  SharedDtor();
}

void SlaveRegisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete connection_;
  }
}

void SlaveRegisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveRegisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveRegisteredMessage_descriptor_;
}

const SlaveRegisteredMessage& SlaveRegisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SlaveRegisteredMessage* SlaveRegisteredMessage::default_instance_ = NULL;

SlaveRegisteredMessage* SlaveRegisteredMessage::New() const {
  return new SlaveRegisteredMessage;
}

void SlaveRegisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_connection()) {
      if (connection_ != NULL) connection_->::mesos::internal::MasterSlaveConnection::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveRegisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.SlaveRegisteredMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_connection;
        break;
      }

      // optional .mesos.internal.MasterSlaveConnection connection = 2;
      case 2: {
        if (tag == 18) {
         parse_connection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.SlaveRegisteredMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.SlaveRegisteredMessage)
  return false;
#undef DO_
}

void SlaveRegisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.SlaveRegisteredMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 2;
  if (has_connection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->connection(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.SlaveRegisteredMessage)
}

::google::protobuf::uint8* SlaveRegisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.SlaveRegisteredMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 2;
  if (has_connection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->connection(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.SlaveRegisteredMessage)
  return target;
}

int SlaveRegisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.internal.MasterSlaveConnection connection = 2;
    if (has_connection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->connection());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveRegisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveRegisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveRegisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveRegisteredMessage::MergeFrom(const SlaveRegisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_connection()) {
      mutable_connection()->::mesos::internal::MasterSlaveConnection::MergeFrom(from.connection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveRegisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveRegisteredMessage::CopyFrom(const SlaveRegisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveRegisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void SlaveRegisteredMessage::Swap(SlaveRegisteredMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(connection_, other->connection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveRegisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveRegisteredMessage_descriptor_;
  metadata.reflection = SlaveRegisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveReregisteredMessage::kSlaveIdFieldNumber;
const int SlaveReregisteredMessage::kReconciliationsFieldNumber;
const int SlaveReregisteredMessage::kConnectionFieldNumber;
#endif  // !_MSC_VER

SlaveReregisteredMessage::SlaveReregisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.SlaveReregisteredMessage)
}

void SlaveReregisteredMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  connection_ = const_cast< ::mesos::internal::MasterSlaveConnection*>(&::mesos::internal::MasterSlaveConnection::default_instance());
}

SlaveReregisteredMessage::SlaveReregisteredMessage(const SlaveReregisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.SlaveReregisteredMessage)
}

void SlaveReregisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  connection_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveReregisteredMessage::~SlaveReregisteredMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.SlaveReregisteredMessage)
  SharedDtor();
}

void SlaveReregisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete connection_;
  }
}

void SlaveReregisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveReregisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveReregisteredMessage_descriptor_;
}

const SlaveReregisteredMessage& SlaveReregisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SlaveReregisteredMessage* SlaveReregisteredMessage::default_instance_ = NULL;

SlaveReregisteredMessage* SlaveReregisteredMessage::New() const {
  return new SlaveReregisteredMessage;
}

void SlaveReregisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_connection()) {
      if (connection_ != NULL) connection_->::mesos::internal::MasterSlaveConnection::Clear();
    }
  }
  reconciliations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveReregisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.SlaveReregisteredMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reconciliations;
        break;
      }

      // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
      case 2: {
        if (tag == 18) {
         parse_reconciliations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reconciliations()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reconciliations;
        if (input->ExpectTag(26)) goto parse_connection;
        break;
      }

      // optional .mesos.internal.MasterSlaveConnection connection = 3;
      case 3: {
        if (tag == 26) {
         parse_connection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_connection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.SlaveReregisteredMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.SlaveReregisteredMessage)
  return false;
#undef DO_
}

void SlaveReregisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.SlaveReregisteredMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  for (int i = 0; i < this->reconciliations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->reconciliations(i), output);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 3;
  if (has_connection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->connection(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.SlaveReregisteredMessage)
}

::google::protobuf::uint8* SlaveReregisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.SlaveReregisteredMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  for (int i = 0; i < this->reconciliations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->reconciliations(i), target);
  }

  // optional .mesos.internal.MasterSlaveConnection connection = 3;
  if (has_connection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->connection(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.SlaveReregisteredMessage)
  return target;
}

int SlaveReregisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.internal.MasterSlaveConnection connection = 3;
    if (has_connection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->connection());
    }

  }
  // repeated .mesos.internal.ReconcileTasksMessage reconciliations = 2;
  total_size += 1 * this->reconciliations_size();
  for (int i = 0; i < this->reconciliations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reconciliations(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveReregisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveReregisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveReregisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveReregisteredMessage::MergeFrom(const SlaveReregisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  reconciliations_.MergeFrom(from.reconciliations_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_connection()) {
      mutable_connection()->::mesos::internal::MasterSlaveConnection::MergeFrom(from.connection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveReregisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveReregisteredMessage::CopyFrom(const SlaveReregisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveReregisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->reconciliations())) return false;
  return true;
}

void SlaveReregisteredMessage::Swap(SlaveReregisteredMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    reconciliations_.Swap(&other->reconciliations_);
    std::swap(connection_, other->connection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveReregisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveReregisteredMessage_descriptor_;
  metadata.reflection = SlaveReregisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnregisterSlaveMessage::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

UnregisterSlaveMessage::UnregisterSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.UnregisterSlaveMessage)
}

void UnregisterSlaveMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

UnregisterSlaveMessage::UnregisterSlaveMessage(const UnregisterSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.UnregisterSlaveMessage)
}

void UnregisterSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterSlaveMessage::~UnregisterSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.UnregisterSlaveMessage)
  SharedDtor();
}

void UnregisterSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void UnregisterSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnregisterSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnregisterSlaveMessage_descriptor_;
}

const UnregisterSlaveMessage& UnregisterSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

UnregisterSlaveMessage* UnregisterSlaveMessage::default_instance_ = NULL;

UnregisterSlaveMessage* UnregisterSlaveMessage::New() const {
  return new UnregisterSlaveMessage;
}

void UnregisterSlaveMessage::Clear() {
  if (has_slave_id()) {
    if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnregisterSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.UnregisterSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.UnregisterSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.UnregisterSlaveMessage)
  return false;
#undef DO_
}

void UnregisterSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.UnregisterSlaveMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.UnregisterSlaveMessage)
}

::google::protobuf::uint8* UnregisterSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.UnregisterSlaveMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.UnregisterSlaveMessage)
  return target;
}

int UnregisterSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnregisterSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnregisterSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnregisterSlaveMessage::MergeFrom(const UnregisterSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnregisterSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnregisterSlaveMessage::CopyFrom(const UnregisterSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void UnregisterSlaveMessage::Swap(UnregisterSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnregisterSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnregisterSlaveMessage_descriptor_;
  metadata.reflection = UnregisterSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MasterSlaveConnection::kTotalPingTimeoutSecondsFieldNumber;
#endif  // !_MSC_VER

MasterSlaveConnection::MasterSlaveConnection()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.MasterSlaveConnection)
}

void MasterSlaveConnection::InitAsDefaultInstance() {
}

MasterSlaveConnection::MasterSlaveConnection(const MasterSlaveConnection& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.MasterSlaveConnection)
}

void MasterSlaveConnection::SharedCtor() {
  _cached_size_ = 0;
  total_ping_timeout_seconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterSlaveConnection::~MasterSlaveConnection() {
  // @@protoc_insertion_point(destructor:mesos.internal.MasterSlaveConnection)
  SharedDtor();
}

void MasterSlaveConnection::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MasterSlaveConnection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterSlaveConnection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterSlaveConnection_descriptor_;
}

const MasterSlaveConnection& MasterSlaveConnection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

MasterSlaveConnection* MasterSlaveConnection::default_instance_ = NULL;

MasterSlaveConnection* MasterSlaveConnection::New() const {
  return new MasterSlaveConnection;
}

void MasterSlaveConnection::Clear() {
  total_ping_timeout_seconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MasterSlaveConnection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.MasterSlaveConnection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double total_ping_timeout_seconds = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &total_ping_timeout_seconds_)));
          set_has_total_ping_timeout_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.MasterSlaveConnection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.MasterSlaveConnection)
  return false;
#undef DO_
}

void MasterSlaveConnection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.MasterSlaveConnection)
  // optional double total_ping_timeout_seconds = 1;
  if (has_total_ping_timeout_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->total_ping_timeout_seconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.MasterSlaveConnection)
}

::google::protobuf::uint8* MasterSlaveConnection::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.MasterSlaveConnection)
  // optional double total_ping_timeout_seconds = 1;
  if (has_total_ping_timeout_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->total_ping_timeout_seconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.MasterSlaveConnection)
  return target;
}

int MasterSlaveConnection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double total_ping_timeout_seconds = 1;
    if (has_total_ping_timeout_seconds()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterSlaveConnection::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MasterSlaveConnection* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MasterSlaveConnection*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MasterSlaveConnection::MergeFrom(const MasterSlaveConnection& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_total_ping_timeout_seconds()) {
      set_total_ping_timeout_seconds(from.total_ping_timeout_seconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MasterSlaveConnection::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterSlaveConnection::CopyFrom(const MasterSlaveConnection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterSlaveConnection::IsInitialized() const {

  return true;
}

void MasterSlaveConnection::Swap(MasterSlaveConnection* other) {
  if (other != this) {
    std::swap(total_ping_timeout_seconds_, other->total_ping_timeout_seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MasterSlaveConnection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterSlaveConnection_descriptor_;
  metadata.reflection = MasterSlaveConnection_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PingSlaveMessage::kConnectedFieldNumber;
#endif  // !_MSC_VER

PingSlaveMessage::PingSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.PingSlaveMessage)
}

void PingSlaveMessage::InitAsDefaultInstance() {
}

PingSlaveMessage::PingSlaveMessage(const PingSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.PingSlaveMessage)
}

void PingSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  connected_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PingSlaveMessage::~PingSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.PingSlaveMessage)
  SharedDtor();
}

void PingSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PingSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PingSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PingSlaveMessage_descriptor_;
}

const PingSlaveMessage& PingSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PingSlaveMessage* PingSlaveMessage::default_instance_ = NULL;

PingSlaveMessage* PingSlaveMessage::New() const {
  return new PingSlaveMessage;
}

void PingSlaveMessage::Clear() {
  connected_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PingSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.PingSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool connected = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
          set_has_connected();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.PingSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.PingSlaveMessage)
  return false;
#undef DO_
}

void PingSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.PingSlaveMessage)
  // required bool connected = 1;
  if (has_connected()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->connected(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.PingSlaveMessage)
}

::google::protobuf::uint8* PingSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.PingSlaveMessage)
  // required bool connected = 1;
  if (has_connected()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->connected(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.PingSlaveMessage)
  return target;
}

int PingSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool connected = 1;
    if (has_connected()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PingSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PingSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PingSlaveMessage::MergeFrom(const PingSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connected()) {
      set_connected(from.connected());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PingSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PingSlaveMessage::CopyFrom(const PingSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PingSlaveMessage::Swap(PingSlaveMessage* other) {
  if (other != this) {
    std::swap(connected_, other->connected_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PingSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PingSlaveMessage_descriptor_;
  metadata.reflection = PingSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PongSlaveMessage::PongSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.PongSlaveMessage)
}

void PongSlaveMessage::InitAsDefaultInstance() {
}

PongSlaveMessage::PongSlaveMessage(const PongSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.PongSlaveMessage)
}

void PongSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PongSlaveMessage::~PongSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.PongSlaveMessage)
  SharedDtor();
}

void PongSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PongSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PongSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PongSlaveMessage_descriptor_;
}

const PongSlaveMessage& PongSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PongSlaveMessage* PongSlaveMessage::default_instance_ = NULL;

PongSlaveMessage* PongSlaveMessage::New() const {
  return new PongSlaveMessage;
}

void PongSlaveMessage::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PongSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.PongSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.PongSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.PongSlaveMessage)
  return false;
#undef DO_
}

void PongSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.PongSlaveMessage)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.PongSlaveMessage)
}

::google::protobuf::uint8* PongSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.PongSlaveMessage)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.PongSlaveMessage)
  return target;
}

int PongSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PongSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PongSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PongSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PongSlaveMessage::MergeFrom(const PongSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PongSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PongSlaveMessage::CopyFrom(const PongSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PongSlaveMessage::IsInitialized() const {

  return true;
}

void PongSlaveMessage::Swap(PongSlaveMessage* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PongSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PongSlaveMessage_descriptor_;
  metadata.reflection = PongSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShutdownFrameworkMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

ShutdownFrameworkMessage::ShutdownFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ShutdownFrameworkMessage)
}

void ShutdownFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ShutdownFrameworkMessage::ShutdownFrameworkMessage(const ShutdownFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ShutdownFrameworkMessage)
}

void ShutdownFrameworkMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShutdownFrameworkMessage::~ShutdownFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ShutdownFrameworkMessage)
  SharedDtor();
}

void ShutdownFrameworkMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
  }
}

void ShutdownFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShutdownFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShutdownFrameworkMessage_descriptor_;
}

const ShutdownFrameworkMessage& ShutdownFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ShutdownFrameworkMessage* ShutdownFrameworkMessage::default_instance_ = NULL;

ShutdownFrameworkMessage* ShutdownFrameworkMessage::New() const {
  return new ShutdownFrameworkMessage;
}

void ShutdownFrameworkMessage::Clear() {
  if (has_framework_id()) {
    if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShutdownFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ShutdownFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ShutdownFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ShutdownFrameworkMessage)
  return false;
#undef DO_
}

void ShutdownFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ShutdownFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ShutdownFrameworkMessage)
}

::google::protobuf::uint8* ShutdownFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ShutdownFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ShutdownFrameworkMessage)
  return target;
}

int ShutdownFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShutdownFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShutdownFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShutdownFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShutdownFrameworkMessage::MergeFrom(const ShutdownFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShutdownFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShutdownFrameworkMessage::CopyFrom(const ShutdownFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void ShutdownFrameworkMessage::Swap(ShutdownFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShutdownFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShutdownFrameworkMessage_descriptor_;
  metadata.reflection = ShutdownFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShutdownExecutorMessage::kExecutorIdFieldNumber;
const int ShutdownExecutorMessage::kFrameworkIdFieldNumber;
#endif  // !_MSC_VER

ShutdownExecutorMessage::ShutdownExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ShutdownExecutorMessage)
}

void ShutdownExecutorMessage::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ShutdownExecutorMessage::ShutdownExecutorMessage(const ShutdownExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ShutdownExecutorMessage)
}

void ShutdownExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  executor_id_ = NULL;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShutdownExecutorMessage::~ShutdownExecutorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ShutdownExecutorMessage)
  SharedDtor();
}

void ShutdownExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete executor_id_;
    delete framework_id_;
  }
}

void ShutdownExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShutdownExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShutdownExecutorMessage_descriptor_;
}

const ShutdownExecutorMessage& ShutdownExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ShutdownExecutorMessage* ShutdownExecutorMessage::default_instance_ = NULL;

ShutdownExecutorMessage* ShutdownExecutorMessage::New() const {
  return new ShutdownExecutorMessage;
}

void ShutdownExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShutdownExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ShutdownExecutorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // optional .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ShutdownExecutorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ShutdownExecutorMessage)
  return false;
#undef DO_
}

void ShutdownExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ShutdownExecutorMessage)
  // optional .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // optional .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ShutdownExecutorMessage)
}

::google::protobuf::uint8* ShutdownExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ShutdownExecutorMessage)
  // optional .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // optional .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ShutdownExecutorMessage)
  return target;
}

int ShutdownExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShutdownExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShutdownExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShutdownExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShutdownExecutorMessage::MergeFrom(const ShutdownExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShutdownExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShutdownExecutorMessage::CopyFrom(const ShutdownExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownExecutorMessage::IsInitialized() const {

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  return true;
}

void ShutdownExecutorMessage::Swap(ShutdownExecutorMessage* other) {
  if (other != this) {
    std::swap(executor_id_, other->executor_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShutdownExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShutdownExecutorMessage_descriptor_;
  metadata.reflection = ShutdownExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateFrameworkMessage::kFrameworkIdFieldNumber;
const int UpdateFrameworkMessage::kPidFieldNumber;
const int UpdateFrameworkMessage::kFrameworkInfoFieldNumber;
#endif  // !_MSC_VER

UpdateFrameworkMessage::UpdateFrameworkMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.UpdateFrameworkMessage)
}

void UpdateFrameworkMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  framework_info_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

UpdateFrameworkMessage::UpdateFrameworkMessage(const UpdateFrameworkMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.UpdateFrameworkMessage)
}

void UpdateFrameworkMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  framework_id_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  framework_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateFrameworkMessage::~UpdateFrameworkMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.UpdateFrameworkMessage)
  SharedDtor();
}

void UpdateFrameworkMessage::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete framework_id_;
    delete framework_info_;
  }
}

void UpdateFrameworkMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateFrameworkMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateFrameworkMessage_descriptor_;
}

const UpdateFrameworkMessage& UpdateFrameworkMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

UpdateFrameworkMessage* UpdateFrameworkMessage::default_instance_ = NULL;

UpdateFrameworkMessage* UpdateFrameworkMessage::New() const {
  return new UpdateFrameworkMessage;
}

void UpdateFrameworkMessage::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pid_->clear();
      }
    }
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateFrameworkMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.UpdateFrameworkMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pid;
        break;
      }

      // optional string pid = 2;
      case 2: {
        if (tag == 18) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_framework_info;
        break;
      }

      // optional .mesos.FrameworkInfo framework_info = 3;
      case 3: {
        if (tag == 26) {
         parse_framework_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.UpdateFrameworkMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.UpdateFrameworkMessage)
  return false;
#undef DO_
}

void UpdateFrameworkMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.UpdateFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pid(), output);
  }

  // optional .mesos.FrameworkInfo framework_info = 3;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.UpdateFrameworkMessage)
}

::google::protobuf::uint8* UpdateFrameworkMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.UpdateFrameworkMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pid(), target);
  }

  // optional .mesos.FrameworkInfo framework_info = 3;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.UpdateFrameworkMessage)
  return target;
}

int UpdateFrameworkMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional string pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

    // optional .mesos.FrameworkInfo framework_info = 3;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateFrameworkMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateFrameworkMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateFrameworkMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateFrameworkMessage::MergeFrom(const UpdateFrameworkMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::FrameworkInfo::MergeFrom(from.framework_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateFrameworkMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateFrameworkMessage::CopyFrom(const UpdateFrameworkMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateFrameworkMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  return true;
}

void UpdateFrameworkMessage::Swap(UpdateFrameworkMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(pid_, other->pid_);
    std::swap(framework_info_, other->framework_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateFrameworkMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateFrameworkMessage_descriptor_;
  metadata.reflection = UpdateFrameworkMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckpointResourcesMessage::kResourcesFieldNumber;
#endif  // !_MSC_VER

CheckpointResourcesMessage::CheckpointResourcesMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.CheckpointResourcesMessage)
}

void CheckpointResourcesMessage::InitAsDefaultInstance() {
}

CheckpointResourcesMessage::CheckpointResourcesMessage(const CheckpointResourcesMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.CheckpointResourcesMessage)
}

void CheckpointResourcesMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckpointResourcesMessage::~CheckpointResourcesMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.CheckpointResourcesMessage)
  SharedDtor();
}

void CheckpointResourcesMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckpointResourcesMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckpointResourcesMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckpointResourcesMessage_descriptor_;
}

const CheckpointResourcesMessage& CheckpointResourcesMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

CheckpointResourcesMessage* CheckpointResourcesMessage::default_instance_ = NULL;

CheckpointResourcesMessage* CheckpointResourcesMessage::New() const {
  return new CheckpointResourcesMessage;
}

void CheckpointResourcesMessage::Clear() {
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckpointResourcesMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.CheckpointResourcesMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (tag == 10) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.CheckpointResourcesMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.CheckpointResourcesMessage)
  return false;
#undef DO_
}

void CheckpointResourcesMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.CheckpointResourcesMessage)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.CheckpointResourcesMessage)
}

::google::protobuf::uint8* CheckpointResourcesMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.CheckpointResourcesMessage)
  // repeated .mesos.Resource resources = 1;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.CheckpointResourcesMessage)
  return target;
}

int CheckpointResourcesMessage::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckpointResourcesMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckpointResourcesMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckpointResourcesMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckpointResourcesMessage::MergeFrom(const CheckpointResourcesMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckpointResourcesMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointResourcesMessage::CopyFrom(const CheckpointResourcesMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointResourcesMessage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void CheckpointResourcesMessage::Swap(CheckpointResourcesMessage* other) {
  if (other != this) {
    resources_.Swap(&other->resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckpointResourcesMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckpointResourcesMessage_descriptor_;
  metadata.reflection = CheckpointResourcesMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateSlaveMessage::kSlaveIdFieldNumber;
const int UpdateSlaveMessage::kOversubscribedResourcesFieldNumber;
#endif  // !_MSC_VER

UpdateSlaveMessage::UpdateSlaveMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.UpdateSlaveMessage)
}

void UpdateSlaveMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

UpdateSlaveMessage::UpdateSlaveMessage(const UpdateSlaveMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.UpdateSlaveMessage)
}

void UpdateSlaveMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateSlaveMessage::~UpdateSlaveMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.UpdateSlaveMessage)
  SharedDtor();
}

void UpdateSlaveMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void UpdateSlaveMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateSlaveMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateSlaveMessage_descriptor_;
}

const UpdateSlaveMessage& UpdateSlaveMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

UpdateSlaveMessage* UpdateSlaveMessage::default_instance_ = NULL;

UpdateSlaveMessage* UpdateSlaveMessage::New() const {
  return new UpdateSlaveMessage;
}

void UpdateSlaveMessage::Clear() {
  if (has_slave_id()) {
    if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  }
  oversubscribed_resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateSlaveMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.UpdateSlaveMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_oversubscribed_resources;
        break;
      }

      // repeated .mesos.Resource oversubscribed_resources = 2;
      case 2: {
        if (tag == 18) {
         parse_oversubscribed_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_oversubscribed_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_oversubscribed_resources;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.UpdateSlaveMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.UpdateSlaveMessage)
  return false;
#undef DO_
}

void UpdateSlaveMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.UpdateSlaveMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // repeated .mesos.Resource oversubscribed_resources = 2;
  for (int i = 0; i < this->oversubscribed_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->oversubscribed_resources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.UpdateSlaveMessage)
}

::google::protobuf::uint8* UpdateSlaveMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.UpdateSlaveMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // repeated .mesos.Resource oversubscribed_resources = 2;
  for (int i = 0; i < this->oversubscribed_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->oversubscribed_resources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.UpdateSlaveMessage)
  return target;
}

int UpdateSlaveMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  // repeated .mesos.Resource oversubscribed_resources = 2;
  total_size += 1 * this->oversubscribed_resources_size();
  for (int i = 0; i < this->oversubscribed_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->oversubscribed_resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateSlaveMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateSlaveMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateSlaveMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateSlaveMessage::MergeFrom(const UpdateSlaveMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  oversubscribed_resources_.MergeFrom(from.oversubscribed_resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateSlaveMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateSlaveMessage::CopyFrom(const UpdateSlaveMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateSlaveMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->oversubscribed_resources())) return false;
  return true;
}

void UpdateSlaveMessage::Swap(UpdateSlaveMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    oversubscribed_resources_.Swap(&other->oversubscribed_resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateSlaveMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateSlaveMessage_descriptor_;
  metadata.reflection = UpdateSlaveMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterExecutorMessage::kFrameworkIdFieldNumber;
const int RegisterExecutorMessage::kExecutorIdFieldNumber;
#endif  // !_MSC_VER

RegisterExecutorMessage::RegisterExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.RegisterExecutorMessage)
}

void RegisterExecutorMessage::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

RegisterExecutorMessage::RegisterExecutorMessage(const RegisterExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.RegisterExecutorMessage)
}

void RegisterExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  executor_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterExecutorMessage::~RegisterExecutorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.RegisterExecutorMessage)
  SharedDtor();
}

void RegisterExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete executor_id_;
  }
}

void RegisterExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterExecutorMessage_descriptor_;
}

const RegisterExecutorMessage& RegisterExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RegisterExecutorMessage* RegisterExecutorMessage::default_instance_ = NULL;

RegisterExecutorMessage* RegisterExecutorMessage::New() const {
  return new RegisterExecutorMessage;
}

void RegisterExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.RegisterExecutorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (tag == 18) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.RegisterExecutorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.RegisterExecutorMessage)
  return false;
#undef DO_
}

void RegisterExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.RegisterExecutorMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.RegisterExecutorMessage)
}

::google::protobuf::uint8* RegisterExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.RegisterExecutorMessage)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.RegisterExecutorMessage)
  return target;
}

int RegisterExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterExecutorMessage::MergeFrom(const RegisterExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterExecutorMessage::CopyFrom(const RegisterExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void RegisterExecutorMessage::Swap(RegisterExecutorMessage* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterExecutorMessage_descriptor_;
  metadata.reflection = RegisterExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorRegisteredMessage::kExecutorInfoFieldNumber;
const int ExecutorRegisteredMessage::kFrameworkIdFieldNumber;
const int ExecutorRegisteredMessage::kFrameworkInfoFieldNumber;
const int ExecutorRegisteredMessage::kSlaveIdFieldNumber;
const int ExecutorRegisteredMessage::kSlaveInfoFieldNumber;
#endif  // !_MSC_VER

ExecutorRegisteredMessage::ExecutorRegisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ExecutorRegisteredMessage)
}

void ExecutorRegisteredMessage::InitAsDefaultInstance() {
  executor_info_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  framework_info_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  slave_info_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

ExecutorRegisteredMessage::ExecutorRegisteredMessage(const ExecutorRegisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ExecutorRegisteredMessage)
}

void ExecutorRegisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  executor_info_ = NULL;
  framework_id_ = NULL;
  framework_info_ = NULL;
  slave_id_ = NULL;
  slave_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorRegisteredMessage::~ExecutorRegisteredMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ExecutorRegisteredMessage)
  SharedDtor();
}

void ExecutorRegisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete executor_info_;
    delete framework_id_;
    delete framework_info_;
    delete slave_id_;
    delete slave_info_;
  }
}

void ExecutorRegisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorRegisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorRegisteredMessage_descriptor_;
}

const ExecutorRegisteredMessage& ExecutorRegisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ExecutorRegisteredMessage* ExecutorRegisteredMessage::default_instance_ = NULL;

ExecutorRegisteredMessage* ExecutorRegisteredMessage::New() const {
  return new ExecutorRegisteredMessage;
}

void ExecutorRegisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_executor_info()) {
      if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_slave_info()) {
      if (slave_info_ != NULL) slave_info_->::mesos::SlaveInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorRegisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ExecutorRegisteredMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorInfo executor_info = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (tag == 26) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_framework_info;
        break;
      }

      // required .mesos.FrameworkInfo framework_info = 4;
      case 4: {
        if (tag == 34) {
         parse_framework_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 5;
      case 5: {
        if (tag == 42) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_slave_info;
        break;
      }

      // required .mesos.SlaveInfo slave_info = 6;
      case 6: {
        if (tag == 50) {
         parse_slave_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ExecutorRegisteredMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ExecutorRegisteredMessage)
  return false;
#undef DO_
}

void ExecutorRegisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ExecutorRegisteredMessage)
  // required .mesos.ExecutorInfo executor_info = 2;
  if (has_executor_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_info(), output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->framework_id(), output);
  }

  // required .mesos.FrameworkInfo framework_info = 4;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->framework_info(), output);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->slave_id(), output);
  }

  // required .mesos.SlaveInfo slave_info = 6;
  if (has_slave_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->slave_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ExecutorRegisteredMessage)
}

::google::protobuf::uint8* ExecutorRegisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ExecutorRegisteredMessage)
  // required .mesos.ExecutorInfo executor_info = 2;
  if (has_executor_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_info(), target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->framework_id(), target);
  }

  // required .mesos.FrameworkInfo framework_info = 4;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->framework_info(), target);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->slave_id(), target);
  }

  // required .mesos.SlaveInfo slave_info = 6;
  if (has_slave_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->slave_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ExecutorRegisteredMessage)
  return target;
}

int ExecutorRegisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorInfo executor_info = 2;
    if (has_executor_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_info());
    }

    // required .mesos.FrameworkID framework_id = 3;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.FrameworkInfo framework_info = 4;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

    // required .mesos.SlaveID slave_id = 5;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.SlaveInfo slave_info = 6;
    if (has_slave_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorRegisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorRegisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorRegisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorRegisteredMessage::MergeFrom(const ExecutorRegisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_info()) {
      mutable_executor_info()->::mesos::ExecutorInfo::MergeFrom(from.executor_info());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::FrameworkInfo::MergeFrom(from.framework_info());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_slave_info()) {
      mutable_slave_info()->::mesos::SlaveInfo::MergeFrom(from.slave_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorRegisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorRegisteredMessage::CopyFrom(const ExecutorRegisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorRegisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_executor_info()) {
    if (!this->executor_info().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_slave_info()) {
    if (!this->slave_info().IsInitialized()) return false;
  }
  return true;
}

void ExecutorRegisteredMessage::Swap(ExecutorRegisteredMessage* other) {
  if (other != this) {
    std::swap(executor_info_, other->executor_info_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(framework_info_, other->framework_info_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(slave_info_, other->slave_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorRegisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorRegisteredMessage_descriptor_;
  metadata.reflection = ExecutorRegisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutorReregisteredMessage::kSlaveIdFieldNumber;
const int ExecutorReregisteredMessage::kSlaveInfoFieldNumber;
#endif  // !_MSC_VER

ExecutorReregisteredMessage::ExecutorReregisteredMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ExecutorReregisteredMessage)
}

void ExecutorReregisteredMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  slave_info_ = const_cast< ::mesos::SlaveInfo*>(&::mesos::SlaveInfo::default_instance());
}

ExecutorReregisteredMessage::ExecutorReregisteredMessage(const ExecutorReregisteredMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ExecutorReregisteredMessage)
}

void ExecutorReregisteredMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  slave_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorReregisteredMessage::~ExecutorReregisteredMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ExecutorReregisteredMessage)
  SharedDtor();
}

void ExecutorReregisteredMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete slave_info_;
  }
}

void ExecutorReregisteredMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorReregisteredMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorReregisteredMessage_descriptor_;
}

const ExecutorReregisteredMessage& ExecutorReregisteredMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ExecutorReregisteredMessage* ExecutorReregisteredMessage::default_instance_ = NULL;

ExecutorReregisteredMessage* ExecutorReregisteredMessage::New() const {
  return new ExecutorReregisteredMessage;
}

void ExecutorReregisteredMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_slave_info()) {
      if (slave_info_ != NULL) slave_info_->::mesos::SlaveInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutorReregisteredMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ExecutorReregisteredMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_slave_info;
        break;
      }

      // required .mesos.SlaveInfo slave_info = 2;
      case 2: {
        if (tag == 18) {
         parse_slave_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ExecutorReregisteredMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ExecutorReregisteredMessage)
  return false;
#undef DO_
}

void ExecutorReregisteredMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ExecutorReregisteredMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.SlaveInfo slave_info = 2;
  if (has_slave_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ExecutorReregisteredMessage)
}

::google::protobuf::uint8* ExecutorReregisteredMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ExecutorReregisteredMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.SlaveInfo slave_info = 2;
  if (has_slave_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ExecutorReregisteredMessage)
  return target;
}

int ExecutorReregisteredMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.SlaveInfo slave_info = 2;
    if (has_slave_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorReregisteredMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutorReregisteredMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutorReregisteredMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutorReregisteredMessage::MergeFrom(const ExecutorReregisteredMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_slave_info()) {
      mutable_slave_info()->::mesos::SlaveInfo::MergeFrom(from.slave_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutorReregisteredMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorReregisteredMessage::CopyFrom(const ExecutorReregisteredMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorReregisteredMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_slave_info()) {
    if (!this->slave_info().IsInitialized()) return false;
  }
  return true;
}

void ExecutorReregisteredMessage::Swap(ExecutorReregisteredMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(slave_info_, other->slave_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutorReregisteredMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorReregisteredMessage_descriptor_;
  metadata.reflection = ExecutorReregisteredMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExitedExecutorMessage::kSlaveIdFieldNumber;
const int ExitedExecutorMessage::kFrameworkIdFieldNumber;
const int ExitedExecutorMessage::kExecutorIdFieldNumber;
const int ExitedExecutorMessage::kStatusFieldNumber;
#endif  // !_MSC_VER

ExitedExecutorMessage::ExitedExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ExitedExecutorMessage)
}

void ExitedExecutorMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

ExitedExecutorMessage::ExitedExecutorMessage(const ExitedExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ExitedExecutorMessage)
}

void ExitedExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitedExecutorMessage::~ExitedExecutorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ExitedExecutorMessage)
  SharedDtor();
}

void ExitedExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete framework_id_;
    delete executor_id_;
  }
}

void ExitedExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExitedExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExitedExecutorMessage_descriptor_;
}

const ExitedExecutorMessage& ExitedExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ExitedExecutorMessage* ExitedExecutorMessage::default_instance_ = NULL;

ExitedExecutorMessage* ExitedExecutorMessage::New() const {
  return new ExitedExecutorMessage;
}

void ExitedExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExitedExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ExitedExecutorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 3;
      case 3: {
        if (tag == 26) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_status;
        break;
      }

      // required int32 status = 4;
      case 4: {
        if (tag == 32) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ExitedExecutorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ExitedExecutorMessage)
  return false;
#undef DO_
}

void ExitedExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ExitedExecutorMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->executor_id(), output);
  }

  // required int32 status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ExitedExecutorMessage)
}

::google::protobuf::uint8* ExitedExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ExitedExecutorMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 3;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->executor_id(), target);
  }

  // required int32 status = 4;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ExitedExecutorMessage)
  return target;
}

int ExitedExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .mesos.ExecutorID executor_id = 3;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required int32 status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitedExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExitedExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExitedExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExitedExecutorMessage::MergeFrom(const ExitedExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExitedExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExitedExecutorMessage::CopyFrom(const ExitedExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitedExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void ExitedExecutorMessage::Swap(ExitedExecutorMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(framework_id_, other->framework_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExitedExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExitedExecutorMessage_descriptor_;
  metadata.reflection = ExitedExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReconnectExecutorMessage::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

ReconnectExecutorMessage::ReconnectExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ReconnectExecutorMessage)
}

void ReconnectExecutorMessage::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

ReconnectExecutorMessage::ReconnectExecutorMessage(const ReconnectExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ReconnectExecutorMessage)
}

void ReconnectExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReconnectExecutorMessage::~ReconnectExecutorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ReconnectExecutorMessage)
  SharedDtor();
}

void ReconnectExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void ReconnectExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconnectExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconnectExecutorMessage_descriptor_;
}

const ReconnectExecutorMessage& ReconnectExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ReconnectExecutorMessage* ReconnectExecutorMessage::default_instance_ = NULL;

ReconnectExecutorMessage* ReconnectExecutorMessage::New() const {
  return new ReconnectExecutorMessage;
}

void ReconnectExecutorMessage::Clear() {
  if (has_slave_id()) {
    if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReconnectExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ReconnectExecutorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ReconnectExecutorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ReconnectExecutorMessage)
  return false;
#undef DO_
}

void ReconnectExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ReconnectExecutorMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ReconnectExecutorMessage)
}

::google::protobuf::uint8* ReconnectExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ReconnectExecutorMessage)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ReconnectExecutorMessage)
  return target;
}

int ReconnectExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconnectExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReconnectExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReconnectExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReconnectExecutorMessage::MergeFrom(const ReconnectExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReconnectExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconnectExecutorMessage::CopyFrom(const ReconnectExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconnectExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void ReconnectExecutorMessage::Swap(ReconnectExecutorMessage* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReconnectExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconnectExecutorMessage_descriptor_;
  metadata.reflection = ReconnectExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReregisterExecutorMessage::kExecutorIdFieldNumber;
const int ReregisterExecutorMessage::kFrameworkIdFieldNumber;
const int ReregisterExecutorMessage::kTasksFieldNumber;
const int ReregisterExecutorMessage::kUpdatesFieldNumber;
#endif  // !_MSC_VER

ReregisterExecutorMessage::ReregisterExecutorMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ReregisterExecutorMessage)
}

void ReregisterExecutorMessage::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
}

ReregisterExecutorMessage::ReregisterExecutorMessage(const ReregisterExecutorMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ReregisterExecutorMessage)
}

void ReregisterExecutorMessage::SharedCtor() {
  _cached_size_ = 0;
  executor_id_ = NULL;
  framework_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReregisterExecutorMessage::~ReregisterExecutorMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ReregisterExecutorMessage)
  SharedDtor();
}

void ReregisterExecutorMessage::SharedDtor() {
  if (this != default_instance_) {
    delete executor_id_;
    delete framework_id_;
  }
}

void ReregisterExecutorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReregisterExecutorMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReregisterExecutorMessage_descriptor_;
}

const ReregisterExecutorMessage& ReregisterExecutorMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ReregisterExecutorMessage* ReregisterExecutorMessage::default_instance_ = NULL;

ReregisterExecutorMessage* ReregisterExecutorMessage::New() const {
  return new ReregisterExecutorMessage;
}

void ReregisterExecutorMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
  }
  tasks_.Clear();
  updates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReregisterExecutorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ReregisterExecutorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.TaskInfo tasks = 3;
      case 3: {
        if (tag == 26) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectTag(34)) goto parse_updates;
        break;
      }

      // repeated .mesos.internal.StatusUpdate updates = 4;
      case 4: {
        if (tag == 34) {
         parse_updates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updates()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_updates;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ReregisterExecutorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ReregisterExecutorMessage)
  return false;
#undef DO_
}

void ReregisterExecutorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ReregisterExecutorMessage)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->framework_id(), output);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  // repeated .mesos.internal.StatusUpdate updates = 4;
  for (int i = 0; i < this->updates_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->updates(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ReregisterExecutorMessage)
}

::google::protobuf::uint8* ReregisterExecutorMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ReregisterExecutorMessage)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->framework_id(), target);
  }

  // repeated .mesos.TaskInfo tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  // repeated .mesos.internal.StatusUpdate updates = 4;
  for (int i = 0; i < this->updates_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->updates(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ReregisterExecutorMessage)
  return target;
}

int ReregisterExecutorMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required .mesos.FrameworkID framework_id = 2;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

  }
  // repeated .mesos.TaskInfo tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  // repeated .mesos.internal.StatusUpdate updates = 4;
  total_size += 1 * this->updates_size();
  for (int i = 0; i < this->updates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updates(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReregisterExecutorMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReregisterExecutorMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReregisterExecutorMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReregisterExecutorMessage::MergeFrom(const ReregisterExecutorMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  updates_.MergeFrom(from.updates_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReregisterExecutorMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReregisterExecutorMessage::CopyFrom(const ReregisterExecutorMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReregisterExecutorMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->updates())) return false;
  return true;
}

void ReregisterExecutorMessage::Swap(ReregisterExecutorMessage* other) {
  if (other != this) {
    std::swap(executor_id_, other->executor_id_);
    std::swap(framework_id_, other->framework_id_);
    tasks_.Swap(&other->tasks_);
    updates_.Swap(&other->updates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReregisterExecutorMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReregisterExecutorMessage_descriptor_;
  metadata.reflection = ReregisterExecutorMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShutdownMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

ShutdownMessage::ShutdownMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.ShutdownMessage)
}

void ShutdownMessage::InitAsDefaultInstance() {
}

ShutdownMessage::ShutdownMessage(const ShutdownMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.ShutdownMessage)
}

void ShutdownMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShutdownMessage::~ShutdownMessage() {
  // @@protoc_insertion_point(destructor:mesos.internal.ShutdownMessage)
  SharedDtor();
}

void ShutdownMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void ShutdownMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShutdownMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShutdownMessage_descriptor_;
}

const ShutdownMessage& ShutdownMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ShutdownMessage* ShutdownMessage::default_instance_ = NULL;

ShutdownMessage* ShutdownMessage::New() const {
  return new ShutdownMessage;
}

void ShutdownMessage::Clear() {
  if (has_message()) {
    if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      message_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShutdownMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.ShutdownMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.ShutdownMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.ShutdownMessage)
  return false;
#undef DO_
}

void ShutdownMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.ShutdownMessage)
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.ShutdownMessage)
}

::google::protobuf::uint8* ShutdownMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.ShutdownMessage)
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.ShutdownMessage)
  return target;
}

int ShutdownMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShutdownMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShutdownMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShutdownMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShutdownMessage::MergeFrom(const ShutdownMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShutdownMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShutdownMessage::CopyFrom(const ShutdownMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownMessage::IsInitialized() const {

  return true;
}

void ShutdownMessage::Swap(ShutdownMessage* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShutdownMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShutdownMessage_descriptor_;
  metadata.reflection = ShutdownMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Archive_Framework::kFrameworkInfoFieldNumber;
const int Archive_Framework::kPidFieldNumber;
const int Archive_Framework::kTasksFieldNumber;
#endif  // !_MSC_VER

Archive_Framework::Archive_Framework()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.Archive.Framework)
}

void Archive_Framework::InitAsDefaultInstance() {
  framework_info_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

Archive_Framework::Archive_Framework(const Archive_Framework& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.Archive.Framework)
}

void Archive_Framework::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  framework_info_ = NULL;
  pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Archive_Framework::~Archive_Framework() {
  // @@protoc_insertion_point(destructor:mesos.internal.Archive.Framework)
  SharedDtor();
}

void Archive_Framework::SharedDtor() {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (this != default_instance_) {
    delete framework_info_;
  }
}

void Archive_Framework::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Archive_Framework::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Archive_Framework_descriptor_;
}

const Archive_Framework& Archive_Framework::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Archive_Framework* Archive_Framework::default_instance_ = NULL;

Archive_Framework* Archive_Framework::New() const {
  return new Archive_Framework;
}

void Archive_Framework::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
    }
    if (has_pid()) {
      if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pid_->clear();
      }
    }
  }
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Archive_Framework::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.Archive.Framework)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pid;
        break;
      }

      // optional string pid = 2;
      case 2: {
        if (tag == 18) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "pid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        break;
      }

      // repeated .mesos.Task tasks = 3;
      case 3: {
        if (tag == 26) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tasks;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.Archive.Framework)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.Archive.Framework)
  return false;
#undef DO_
}

void Archive_Framework::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.Archive.Framework)
  // required .mesos.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_info(), output);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pid(), output);
  }

  // repeated .mesos.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.Archive.Framework)
}

::google::protobuf::uint8* Archive_Framework::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.Archive.Framework)
  // required .mesos.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_info(), target);
  }

  // optional string pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "pid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pid(), target);
  }

  // repeated .mesos.Task tasks = 3;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.Archive.Framework)
  return target;
}

int Archive_Framework::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework_info = 1;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

    // optional string pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

  }
  // repeated .mesos.Task tasks = 3;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Archive_Framework::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Archive_Framework* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Archive_Framework*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Archive_Framework::MergeFrom(const Archive_Framework& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::FrameworkInfo::MergeFrom(from.framework_info());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Archive_Framework::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Archive_Framework::CopyFrom(const Archive_Framework& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Archive_Framework::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void Archive_Framework::Swap(Archive_Framework* other) {
  if (other != this) {
    std::swap(framework_info_, other->framework_info_);
    std::swap(pid_, other->pid_);
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Archive_Framework::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Archive_Framework_descriptor_;
  metadata.reflection = Archive_Framework_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Archive::kFrameworksFieldNumber;
#endif  // !_MSC_VER

Archive::Archive()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.Archive)
}

void Archive::InitAsDefaultInstance() {
}

Archive::Archive(const Archive& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.Archive)
}

void Archive::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Archive::~Archive() {
  // @@protoc_insertion_point(destructor:mesos.internal.Archive)
  SharedDtor();
}

void Archive::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Archive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Archive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Archive_descriptor_;
}

const Archive& Archive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Archive* Archive::default_instance_ = NULL;

Archive* Archive::New() const {
  return new Archive;
}

void Archive::Clear() {
  frameworks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Archive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.Archive)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.internal.Archive.Framework frameworks = 1;
      case 1: {
        if (tag == 10) {
         parse_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frameworks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_frameworks;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.Archive)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.Archive)
  return false;
#undef DO_
}

void Archive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.Archive)
  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  for (int i = 0; i < this->frameworks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->frameworks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.Archive)
}

::google::protobuf::uint8* Archive::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.Archive)
  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  for (int i = 0; i < this->frameworks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->frameworks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.Archive)
  return target;
}

int Archive::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.internal.Archive.Framework frameworks = 1;
  total_size += 1 * this->frameworks_size();
  for (int i = 0; i < this->frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frameworks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Archive::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Archive* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Archive*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Archive::MergeFrom(const Archive& from) {
  GOOGLE_CHECK_NE(&from, this);
  frameworks_.MergeFrom(from.frameworks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Archive::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Archive::CopyFrom(const Archive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Archive::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->frameworks())) return false;
  return true;
}

void Archive::Swap(Archive* other) {
  if (other != this) {
    frameworks_.Swap(&other->frameworks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Archive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Archive_descriptor_;
  metadata.reflection = Archive_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskHealthStatus::kTaskIdFieldNumber;
const int TaskHealthStatus::kHealthyFieldNumber;
const int TaskHealthStatus::kKillTaskFieldNumber;
const int TaskHealthStatus::kConsecutiveFailuresFieldNumber;
#endif  // !_MSC_VER

TaskHealthStatus::TaskHealthStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.TaskHealthStatus)
}

void TaskHealthStatus::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
}

TaskHealthStatus::TaskHealthStatus(const TaskHealthStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.TaskHealthStatus)
}

void TaskHealthStatus::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = NULL;
  healthy_ = false;
  kill_task_ = false;
  consecutive_failures_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskHealthStatus::~TaskHealthStatus() {
  // @@protoc_insertion_point(destructor:mesos.internal.TaskHealthStatus)
  SharedDtor();
}

void TaskHealthStatus::SharedDtor() {
  if (this != default_instance_) {
    delete task_id_;
  }
}

void TaskHealthStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskHealthStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskHealthStatus_descriptor_;
}

const TaskHealthStatus& TaskHealthStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TaskHealthStatus* TaskHealthStatus::default_instance_ = NULL;

TaskHealthStatus* TaskHealthStatus::New() const {
  return new TaskHealthStatus;
}

void TaskHealthStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TaskHealthStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(healthy_, consecutive_failures_);
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskHealthStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.TaskHealthStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskID task_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_healthy;
        break;
      }

      // required bool healthy = 2;
      case 2: {
        if (tag == 16) {
         parse_healthy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &healthy_)));
          set_has_healthy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_kill_task;
        break;
      }

      // optional bool kill_task = 3 [default = false];
      case 3: {
        if (tag == 24) {
         parse_kill_task:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kill_task_)));
          set_has_kill_task();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_consecutive_failures;
        break;
      }

      // optional int32 consecutive_failures = 4;
      case 4: {
        if (tag == 32) {
         parse_consecutive_failures:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &consecutive_failures_)));
          set_has_consecutive_failures();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.TaskHealthStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.TaskHealthStatus)
  return false;
#undef DO_
}

void TaskHealthStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.TaskHealthStatus)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // required bool healthy = 2;
  if (has_healthy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->healthy(), output);
  }

  // optional bool kill_task = 3 [default = false];
  if (has_kill_task()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->kill_task(), output);
  }

  // optional int32 consecutive_failures = 4;
  if (has_consecutive_failures()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->consecutive_failures(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.TaskHealthStatus)
}

::google::protobuf::uint8* TaskHealthStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.TaskHealthStatus)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // required bool healthy = 2;
  if (has_healthy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->healthy(), target);
  }

  // optional bool kill_task = 3 [default = false];
  if (has_kill_task()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->kill_task(), target);
  }

  // optional int32 consecutive_failures = 4;
  if (has_consecutive_failures()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->consecutive_failures(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.TaskHealthStatus)
  return target;
}

int TaskHealthStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required bool healthy = 2;
    if (has_healthy()) {
      total_size += 1 + 1;
    }

    // optional bool kill_task = 3 [default = false];
    if (has_kill_task()) {
      total_size += 1 + 1;
    }

    // optional int32 consecutive_failures = 4;
    if (has_consecutive_failures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->consecutive_failures());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskHealthStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskHealthStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskHealthStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskHealthStatus::MergeFrom(const TaskHealthStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_healthy()) {
      set_healthy(from.healthy());
    }
    if (from.has_kill_task()) {
      set_kill_task(from.kill_task());
    }
    if (from.has_consecutive_failures()) {
      set_consecutive_failures(from.consecutive_failures());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskHealthStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskHealthStatus::CopyFrom(const TaskHealthStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskHealthStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void TaskHealthStatus::Swap(TaskHealthStatus* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(healthy_, other->healthy_);
    std::swap(kill_task_, other->kill_task_);
    std::swap(consecutive_failures_, other->consecutive_failures_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskHealthStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskHealthStatus_descriptor_;
  metadata.reflection = TaskHealthStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HookExecuted::kModuleFieldNumber;
#endif  // !_MSC_VER

HookExecuted::HookExecuted()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.internal.HookExecuted)
}

void HookExecuted::InitAsDefaultInstance() {
}

HookExecuted::HookExecuted(const HookExecuted& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.internal.HookExecuted)
}

void HookExecuted::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HookExecuted::~HookExecuted() {
  // @@protoc_insertion_point(destructor:mesos.internal.HookExecuted)
  SharedDtor();
}

void HookExecuted::SharedDtor() {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete module_;
  }
  if (this != default_instance_) {
  }
}

void HookExecuted::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HookExecuted::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HookExecuted_descriptor_;
}

const HookExecuted& HookExecuted::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

HookExecuted* HookExecuted::default_instance_ = NULL;

HookExecuted* HookExecuted::New() const {
  return new HookExecuted;
}

void HookExecuted::Clear() {
  if (has_module()) {
    if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      module_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HookExecuted::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.internal.HookExecuted)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string module = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_module()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->module().data(), this->module().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "module");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.internal.HookExecuted)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.internal.HookExecuted)
  return false;
#undef DO_
}

void HookExecuted::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.internal.HookExecuted)
  // optional string module = 1;
  if (has_module()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->module().data(), this->module().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "module");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->module(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.internal.HookExecuted)
}

::google::protobuf::uint8* HookExecuted::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.internal.HookExecuted)
  // optional string module = 1;
  if (has_module()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->module().data(), this->module().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "module");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->module(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.internal.HookExecuted)
  return target;
}

int HookExecuted::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string module = 1;
    if (has_module()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->module());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HookExecuted::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HookExecuted* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HookExecuted*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HookExecuted::MergeFrom(const HookExecuted& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_module()) {
      set_module(from.module());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HookExecuted::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HookExecuted::CopyFrom(const HookExecuted& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HookExecuted::IsInitialized() const {

  return true;
}

void HookExecuted::Swap(HookExecuted* other) {
  if (other != this) {
    std::swap(module_, other->module_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HookExecuted::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HookExecuted_descriptor_;
  metadata.reflection = HookExecuted_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace internal
}  // namespace mesos

// @@protoc_insertion_point(global_scope)
