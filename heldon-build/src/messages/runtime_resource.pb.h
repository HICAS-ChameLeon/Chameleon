// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: runtime_resource.proto

#ifndef PROTOBUF_runtime_5fresource_2eproto__INCLUDED
#define PROTOBUF_runtime_5fresource_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_runtime_5fresource_2eproto();
void protobuf_AssignDesc_runtime_5fresource_2eproto();
void protobuf_ShutdownFile_runtime_5fresource_2eproto();

class RuntimeResourcesMessage;
class CPUUsage;
class MemoryUsage;
class DiskUsage;
class NetUsage;

// ===================================================================

class RuntimeResourcesMessage : public ::google::protobuf::Message {
 public:
  RuntimeResourcesMessage();
  virtual ~RuntimeResourcesMessage();

  RuntimeResourcesMessage(const RuntimeResourcesMessage& from);

  inline RuntimeResourcesMessage& operator=(const RuntimeResourcesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeResourcesMessage& default_instance();

  void Swap(RuntimeResourcesMessage* other);

  // implements Message ----------------------------------------------

  RuntimeResourcesMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RuntimeResourcesMessage& from);
  void MergeFrom(const RuntimeResourcesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::std::string& slave_id() const;
  inline void set_slave_id(const ::std::string& value);
  inline void set_slave_id(const char* value);
  inline void set_slave_id(const char* value, size_t size);
  inline ::std::string* mutable_slave_id();
  inline ::std::string* release_slave_id();
  inline void set_allocated_slave_id(::std::string* slave_id);

  // required .CPUUsage cpu_usage = 2;
  inline bool has_cpu_usage() const;
  inline void clear_cpu_usage();
  static const int kCpuUsageFieldNumber = 2;
  inline const ::CPUUsage& cpu_usage() const;
  inline ::CPUUsage* mutable_cpu_usage();
  inline ::CPUUsage* release_cpu_usage();
  inline void set_allocated_cpu_usage(::CPUUsage* cpu_usage);

  // required .MemoryUsage mem_usage = 3;
  inline bool has_mem_usage() const;
  inline void clear_mem_usage();
  static const int kMemUsageFieldNumber = 3;
  inline const ::MemoryUsage& mem_usage() const;
  inline ::MemoryUsage* mutable_mem_usage();
  inline ::MemoryUsage* release_mem_usage();
  inline void set_allocated_mem_usage(::MemoryUsage* mem_usage);

  // required .DiskUsage disk_usage = 4;
  inline bool has_disk_usage() const;
  inline void clear_disk_usage();
  static const int kDiskUsageFieldNumber = 4;
  inline const ::DiskUsage& disk_usage() const;
  inline ::DiskUsage* mutable_disk_usage();
  inline ::DiskUsage* release_disk_usage();
  inline void set_allocated_disk_usage(::DiskUsage* disk_usage);

  // required .NetUsage net_usage = 5;
  inline bool has_net_usage() const;
  inline void clear_net_usage();
  static const int kNetUsageFieldNumber = 5;
  inline const ::NetUsage& net_usage() const;
  inline ::NetUsage* mutable_net_usage();
  inline ::NetUsage* release_net_usage();
  inline void set_allocated_net_usage(::NetUsage* net_usage);

  // required string slave_uuid = 6;
  inline bool has_slave_uuid() const;
  inline void clear_slave_uuid();
  static const int kSlaveUuidFieldNumber = 6;
  inline const ::std::string& slave_uuid() const;
  inline void set_slave_uuid(const ::std::string& value);
  inline void set_slave_uuid(const char* value);
  inline void set_slave_uuid(const char* value, size_t size);
  inline ::std::string* mutable_slave_uuid();
  inline ::std::string* release_slave_uuid();
  inline void set_allocated_slave_uuid(::std::string* slave_uuid);

  // @@protoc_insertion_point(class_scope:RuntimeResourcesMessage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_cpu_usage();
  inline void clear_has_cpu_usage();
  inline void set_has_mem_usage();
  inline void clear_has_mem_usage();
  inline void set_has_disk_usage();
  inline void clear_has_disk_usage();
  inline void set_has_net_usage();
  inline void clear_has_net_usage();
  inline void set_has_slave_uuid();
  inline void clear_has_slave_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* slave_id_;
  ::CPUUsage* cpu_usage_;
  ::MemoryUsage* mem_usage_;
  ::DiskUsage* disk_usage_;
  ::NetUsage* net_usage_;
  ::std::string* slave_uuid_;
  friend void  protobuf_AddDesc_runtime_5fresource_2eproto();
  friend void protobuf_AssignDesc_runtime_5fresource_2eproto();
  friend void protobuf_ShutdownFile_runtime_5fresource_2eproto();

  void InitAsDefaultInstance();
  static RuntimeResourcesMessage* default_instance_;
};
// -------------------------------------------------------------------

class CPUUsage : public ::google::protobuf::Message {
 public:
  CPUUsage();
  virtual ~CPUUsage();

  CPUUsage(const CPUUsage& from);

  inline CPUUsage& operator=(const CPUUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPUUsage& default_instance();

  void Swap(CPUUsage* other);

  // implements Message ----------------------------------------------

  CPUUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPUUsage& from);
  void MergeFrom(const CPUUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float cpu_used = 1;
  inline bool has_cpu_used() const;
  inline void clear_cpu_used();
  static const int kCpuUsedFieldNumber = 1;
  inline float cpu_used() const;
  inline void set_cpu_used(float value);

  // @@protoc_insertion_point(class_scope:CPUUsage)
 private:
  inline void set_has_cpu_used();
  inline void clear_has_cpu_used();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float cpu_used_;
  friend void  protobuf_AddDesc_runtime_5fresource_2eproto();
  friend void protobuf_AssignDesc_runtime_5fresource_2eproto();
  friend void protobuf_ShutdownFile_runtime_5fresource_2eproto();

  void InitAsDefaultInstance();
  static CPUUsage* default_instance_;
};
// -------------------------------------------------------------------

class MemoryUsage : public ::google::protobuf::Message {
 public:
  MemoryUsage();
  virtual ~MemoryUsage();

  MemoryUsage(const MemoryUsage& from);

  inline MemoryUsage& operator=(const MemoryUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemoryUsage& default_instance();

  void Swap(MemoryUsage* other);

  // implements Message ----------------------------------------------

  MemoryUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemoryUsage& from);
  void MergeFrom(const MemoryUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mem_total = 1;
  inline bool has_mem_total() const;
  inline void clear_mem_total();
  static const int kMemTotalFieldNumber = 1;
  inline ::google::protobuf::uint32 mem_total() const;
  inline void set_mem_total(::google::protobuf::uint32 value);

  // required uint32 mem_free = 2;
  inline bool has_mem_free() const;
  inline void clear_mem_free();
  static const int kMemFreeFieldNumber = 2;
  inline ::google::protobuf::uint32 mem_free() const;
  inline void set_mem_free(::google::protobuf::uint32 value);

  // required uint32 mem_available = 3;
  inline bool has_mem_available() const;
  inline void clear_mem_available();
  static const int kMemAvailableFieldNumber = 3;
  inline ::google::protobuf::uint32 mem_available() const;
  inline void set_mem_available(::google::protobuf::uint32 value);

  // required uint32 buffers = 4;
  inline bool has_buffers() const;
  inline void clear_buffers();
  static const int kBuffersFieldNumber = 4;
  inline ::google::protobuf::uint32 buffers() const;
  inline void set_buffers(::google::protobuf::uint32 value);

  // required uint32 cached = 5;
  inline bool has_cached() const;
  inline void clear_cached();
  static const int kCachedFieldNumber = 5;
  inline ::google::protobuf::uint32 cached() const;
  inline void set_cached(::google::protobuf::uint32 value);

  // required uint32 swap_total = 6;
  inline bool has_swap_total() const;
  inline void clear_swap_total();
  static const int kSwapTotalFieldNumber = 6;
  inline ::google::protobuf::uint32 swap_total() const;
  inline void set_swap_total(::google::protobuf::uint32 value);

  // required uint32 swap_free = 7;
  inline bool has_swap_free() const;
  inline void clear_swap_free();
  static const int kSwapFreeFieldNumber = 7;
  inline ::google::protobuf::uint32 swap_free() const;
  inline void set_swap_free(::google::protobuf::uint32 value);

  // optional uint32 hugepagesize = 8;
  inline bool has_hugepagesize() const;
  inline void clear_hugepagesize();
  static const int kHugepagesizeFieldNumber = 8;
  inline ::google::protobuf::uint32 hugepagesize() const;
  inline void set_hugepagesize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MemoryUsage)
 private:
  inline void set_has_mem_total();
  inline void clear_has_mem_total();
  inline void set_has_mem_free();
  inline void clear_has_mem_free();
  inline void set_has_mem_available();
  inline void clear_has_mem_available();
  inline void set_has_buffers();
  inline void clear_has_buffers();
  inline void set_has_cached();
  inline void clear_has_cached();
  inline void set_has_swap_total();
  inline void clear_has_swap_total();
  inline void set_has_swap_free();
  inline void clear_has_swap_free();
  inline void set_has_hugepagesize();
  inline void clear_has_hugepagesize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 mem_total_;
  ::google::protobuf::uint32 mem_free_;
  ::google::protobuf::uint32 mem_available_;
  ::google::protobuf::uint32 buffers_;
  ::google::protobuf::uint32 cached_;
  ::google::protobuf::uint32 swap_total_;
  ::google::protobuf::uint32 swap_free_;
  ::google::protobuf::uint32 hugepagesize_;
  friend void  protobuf_AddDesc_runtime_5fresource_2eproto();
  friend void protobuf_AssignDesc_runtime_5fresource_2eproto();
  friend void protobuf_ShutdownFile_runtime_5fresource_2eproto();

  void InitAsDefaultInstance();
  static MemoryUsage* default_instance_;
};
// -------------------------------------------------------------------

class DiskUsage : public ::google::protobuf::Message {
 public:
  DiskUsage();
  virtual ~DiskUsage();

  DiskUsage(const DiskUsage& from);

  inline DiskUsage& operator=(const DiskUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskUsage& default_instance();

  void Swap(DiskUsage* other);

  // implements Message ----------------------------------------------

  DiskUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskUsage& from);
  void MergeFrom(const DiskUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 disk_available = 1;
  inline bool has_disk_available() const;
  inline void clear_disk_available();
  static const int kDiskAvailableFieldNumber = 1;
  inline ::google::protobuf::uint32 disk_available() const;
  inline void set_disk_available(::google::protobuf::uint32 value);

  // required double available_percent = 2;
  inline bool has_available_percent() const;
  inline void clear_available_percent();
  static const int kAvailablePercentFieldNumber = 2;
  inline double available_percent() const;
  inline void set_available_percent(double value);

  // @@protoc_insertion_point(class_scope:DiskUsage)
 private:
  inline void set_has_disk_available();
  inline void clear_has_disk_available();
  inline void set_has_available_percent();
  inline void clear_has_available_percent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double available_percent_;
  ::google::protobuf::uint32 disk_available_;
  friend void  protobuf_AddDesc_runtime_5fresource_2eproto();
  friend void protobuf_AssignDesc_runtime_5fresource_2eproto();
  friend void protobuf_ShutdownFile_runtime_5fresource_2eproto();

  void InitAsDefaultInstance();
  static DiskUsage* default_instance_;
};
// -------------------------------------------------------------------

class NetUsage : public ::google::protobuf::Message {
 public:
  NetUsage();
  virtual ~NetUsage();

  NetUsage(const NetUsage& from);

  inline NetUsage& operator=(const NetUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetUsage& default_instance();

  void Swap(NetUsage* other);

  // implements Message ----------------------------------------------

  NetUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetUsage& from);
  void MergeFrom(const NetUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float net_used = 1;
  inline bool has_net_used() const;
  inline void clear_net_used();
  static const int kNetUsedFieldNumber = 1;
  inline float net_used() const;
  inline void set_net_used(float value);

  // @@protoc_insertion_point(class_scope:NetUsage)
 private:
  inline void set_has_net_used();
  inline void clear_has_net_used();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float net_used_;
  friend void  protobuf_AddDesc_runtime_5fresource_2eproto();
  friend void protobuf_AssignDesc_runtime_5fresource_2eproto();
  friend void protobuf_ShutdownFile_runtime_5fresource_2eproto();

  void InitAsDefaultInstance();
  static NetUsage* default_instance_;
};
// ===================================================================


// ===================================================================

// RuntimeResourcesMessage

// required string slave_id = 1;
inline bool RuntimeResourcesMessage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RuntimeResourcesMessage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RuntimeResourcesMessage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RuntimeResourcesMessage::clear_slave_id() {
  if (slave_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_->clear();
  }
  clear_has_slave_id();
}
inline const ::std::string& RuntimeResourcesMessage::slave_id() const {
  // @@protoc_insertion_point(field_get:RuntimeResourcesMessage.slave_id)
  return *slave_id_;
}
inline void RuntimeResourcesMessage::set_slave_id(const ::std::string& value) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(value);
  // @@protoc_insertion_point(field_set:RuntimeResourcesMessage.slave_id)
}
inline void RuntimeResourcesMessage::set_slave_id(const char* value) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RuntimeResourcesMessage.slave_id)
}
inline void RuntimeResourcesMessage::set_slave_id(const char* value, size_t size) {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  slave_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RuntimeResourcesMessage.slave_id)
}
inline ::std::string* RuntimeResourcesMessage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RuntimeResourcesMessage.slave_id)
  return slave_id_;
}
inline ::std::string* RuntimeResourcesMessage::release_slave_id() {
  clear_has_slave_id();
  if (slave_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_id_;
    slave_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RuntimeResourcesMessage::set_allocated_slave_id(::std::string* slave_id) {
  if (slave_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_id_;
  }
  if (slave_id) {
    set_has_slave_id();
    slave_id_ = slave_id;
  } else {
    clear_has_slave_id();
    slave_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RuntimeResourcesMessage.slave_id)
}

// required .CPUUsage cpu_usage = 2;
inline bool RuntimeResourcesMessage::has_cpu_usage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RuntimeResourcesMessage::set_has_cpu_usage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RuntimeResourcesMessage::clear_has_cpu_usage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RuntimeResourcesMessage::clear_cpu_usage() {
  if (cpu_usage_ != NULL) cpu_usage_->::CPUUsage::Clear();
  clear_has_cpu_usage();
}
inline const ::CPUUsage& RuntimeResourcesMessage::cpu_usage() const {
  // @@protoc_insertion_point(field_get:RuntimeResourcesMessage.cpu_usage)
  return cpu_usage_ != NULL ? *cpu_usage_ : *default_instance_->cpu_usage_;
}
inline ::CPUUsage* RuntimeResourcesMessage::mutable_cpu_usage() {
  set_has_cpu_usage();
  if (cpu_usage_ == NULL) cpu_usage_ = new ::CPUUsage;
  // @@protoc_insertion_point(field_mutable:RuntimeResourcesMessage.cpu_usage)
  return cpu_usage_;
}
inline ::CPUUsage* RuntimeResourcesMessage::release_cpu_usage() {
  clear_has_cpu_usage();
  ::CPUUsage* temp = cpu_usage_;
  cpu_usage_ = NULL;
  return temp;
}
inline void RuntimeResourcesMessage::set_allocated_cpu_usage(::CPUUsage* cpu_usage) {
  delete cpu_usage_;
  cpu_usage_ = cpu_usage;
  if (cpu_usage) {
    set_has_cpu_usage();
  } else {
    clear_has_cpu_usage();
  }
  // @@protoc_insertion_point(field_set_allocated:RuntimeResourcesMessage.cpu_usage)
}

// required .MemoryUsage mem_usage = 3;
inline bool RuntimeResourcesMessage::has_mem_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RuntimeResourcesMessage::set_has_mem_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RuntimeResourcesMessage::clear_has_mem_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RuntimeResourcesMessage::clear_mem_usage() {
  if (mem_usage_ != NULL) mem_usage_->::MemoryUsage::Clear();
  clear_has_mem_usage();
}
inline const ::MemoryUsage& RuntimeResourcesMessage::mem_usage() const {
  // @@protoc_insertion_point(field_get:RuntimeResourcesMessage.mem_usage)
  return mem_usage_ != NULL ? *mem_usage_ : *default_instance_->mem_usage_;
}
inline ::MemoryUsage* RuntimeResourcesMessage::mutable_mem_usage() {
  set_has_mem_usage();
  if (mem_usage_ == NULL) mem_usage_ = new ::MemoryUsage;
  // @@protoc_insertion_point(field_mutable:RuntimeResourcesMessage.mem_usage)
  return mem_usage_;
}
inline ::MemoryUsage* RuntimeResourcesMessage::release_mem_usage() {
  clear_has_mem_usage();
  ::MemoryUsage* temp = mem_usage_;
  mem_usage_ = NULL;
  return temp;
}
inline void RuntimeResourcesMessage::set_allocated_mem_usage(::MemoryUsage* mem_usage) {
  delete mem_usage_;
  mem_usage_ = mem_usage;
  if (mem_usage) {
    set_has_mem_usage();
  } else {
    clear_has_mem_usage();
  }
  // @@protoc_insertion_point(field_set_allocated:RuntimeResourcesMessage.mem_usage)
}

// required .DiskUsage disk_usage = 4;
inline bool RuntimeResourcesMessage::has_disk_usage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RuntimeResourcesMessage::set_has_disk_usage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RuntimeResourcesMessage::clear_has_disk_usage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RuntimeResourcesMessage::clear_disk_usage() {
  if (disk_usage_ != NULL) disk_usage_->::DiskUsage::Clear();
  clear_has_disk_usage();
}
inline const ::DiskUsage& RuntimeResourcesMessage::disk_usage() const {
  // @@protoc_insertion_point(field_get:RuntimeResourcesMessage.disk_usage)
  return disk_usage_ != NULL ? *disk_usage_ : *default_instance_->disk_usage_;
}
inline ::DiskUsage* RuntimeResourcesMessage::mutable_disk_usage() {
  set_has_disk_usage();
  if (disk_usage_ == NULL) disk_usage_ = new ::DiskUsage;
  // @@protoc_insertion_point(field_mutable:RuntimeResourcesMessage.disk_usage)
  return disk_usage_;
}
inline ::DiskUsage* RuntimeResourcesMessage::release_disk_usage() {
  clear_has_disk_usage();
  ::DiskUsage* temp = disk_usage_;
  disk_usage_ = NULL;
  return temp;
}
inline void RuntimeResourcesMessage::set_allocated_disk_usage(::DiskUsage* disk_usage) {
  delete disk_usage_;
  disk_usage_ = disk_usage;
  if (disk_usage) {
    set_has_disk_usage();
  } else {
    clear_has_disk_usage();
  }
  // @@protoc_insertion_point(field_set_allocated:RuntimeResourcesMessage.disk_usage)
}

// required .NetUsage net_usage = 5;
inline bool RuntimeResourcesMessage::has_net_usage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RuntimeResourcesMessage::set_has_net_usage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RuntimeResourcesMessage::clear_has_net_usage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RuntimeResourcesMessage::clear_net_usage() {
  if (net_usage_ != NULL) net_usage_->::NetUsage::Clear();
  clear_has_net_usage();
}
inline const ::NetUsage& RuntimeResourcesMessage::net_usage() const {
  // @@protoc_insertion_point(field_get:RuntimeResourcesMessage.net_usage)
  return net_usage_ != NULL ? *net_usage_ : *default_instance_->net_usage_;
}
inline ::NetUsage* RuntimeResourcesMessage::mutable_net_usage() {
  set_has_net_usage();
  if (net_usage_ == NULL) net_usage_ = new ::NetUsage;
  // @@protoc_insertion_point(field_mutable:RuntimeResourcesMessage.net_usage)
  return net_usage_;
}
inline ::NetUsage* RuntimeResourcesMessage::release_net_usage() {
  clear_has_net_usage();
  ::NetUsage* temp = net_usage_;
  net_usage_ = NULL;
  return temp;
}
inline void RuntimeResourcesMessage::set_allocated_net_usage(::NetUsage* net_usage) {
  delete net_usage_;
  net_usage_ = net_usage;
  if (net_usage) {
    set_has_net_usage();
  } else {
    clear_has_net_usage();
  }
  // @@protoc_insertion_point(field_set_allocated:RuntimeResourcesMessage.net_usage)
}

// required string slave_uuid = 6;
inline bool RuntimeResourcesMessage::has_slave_uuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RuntimeResourcesMessage::set_has_slave_uuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RuntimeResourcesMessage::clear_has_slave_uuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RuntimeResourcesMessage::clear_slave_uuid() {
  if (slave_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_->clear();
  }
  clear_has_slave_uuid();
}
inline const ::std::string& RuntimeResourcesMessage::slave_uuid() const {
  // @@protoc_insertion_point(field_get:RuntimeResourcesMessage.slave_uuid)
  return *slave_uuid_;
}
inline void RuntimeResourcesMessage::set_slave_uuid(const ::std::string& value) {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  slave_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:RuntimeResourcesMessage.slave_uuid)
}
inline void RuntimeResourcesMessage::set_slave_uuid(const char* value) {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  slave_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:RuntimeResourcesMessage.slave_uuid)
}
inline void RuntimeResourcesMessage::set_slave_uuid(const char* value, size_t size) {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  slave_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RuntimeResourcesMessage.slave_uuid)
}
inline ::std::string* RuntimeResourcesMessage::mutable_slave_uuid() {
  set_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RuntimeResourcesMessage.slave_uuid)
  return slave_uuid_;
}
inline ::std::string* RuntimeResourcesMessage::release_slave_uuid() {
  clear_has_slave_uuid();
  if (slave_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_uuid_;
    slave_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RuntimeResourcesMessage::set_allocated_slave_uuid(::std::string* slave_uuid) {
  if (slave_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_uuid_;
  }
  if (slave_uuid) {
    set_has_slave_uuid();
    slave_uuid_ = slave_uuid;
  } else {
    clear_has_slave_uuid();
    slave_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RuntimeResourcesMessage.slave_uuid)
}

// -------------------------------------------------------------------

// CPUUsage

// required float cpu_used = 1;
inline bool CPUUsage::has_cpu_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPUUsage::set_has_cpu_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPUUsage::clear_has_cpu_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPUUsage::clear_cpu_used() {
  cpu_used_ = 0;
  clear_has_cpu_used();
}
inline float CPUUsage::cpu_used() const {
  // @@protoc_insertion_point(field_get:CPUUsage.cpu_used)
  return cpu_used_;
}
inline void CPUUsage::set_cpu_used(float value) {
  set_has_cpu_used();
  cpu_used_ = value;
  // @@protoc_insertion_point(field_set:CPUUsage.cpu_used)
}

// -------------------------------------------------------------------

// MemoryUsage

// required uint32 mem_total = 1;
inline bool MemoryUsage::has_mem_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemoryUsage::set_has_mem_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemoryUsage::clear_has_mem_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemoryUsage::clear_mem_total() {
  mem_total_ = 0u;
  clear_has_mem_total();
}
inline ::google::protobuf::uint32 MemoryUsage::mem_total() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.mem_total)
  return mem_total_;
}
inline void MemoryUsage::set_mem_total(::google::protobuf::uint32 value) {
  set_has_mem_total();
  mem_total_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.mem_total)
}

// required uint32 mem_free = 2;
inline bool MemoryUsage::has_mem_free() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryUsage::set_has_mem_free() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryUsage::clear_has_mem_free() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryUsage::clear_mem_free() {
  mem_free_ = 0u;
  clear_has_mem_free();
}
inline ::google::protobuf::uint32 MemoryUsage::mem_free() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.mem_free)
  return mem_free_;
}
inline void MemoryUsage::set_mem_free(::google::protobuf::uint32 value) {
  set_has_mem_free();
  mem_free_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.mem_free)
}

// required uint32 mem_available = 3;
inline bool MemoryUsage::has_mem_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryUsage::set_has_mem_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemoryUsage::clear_has_mem_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemoryUsage::clear_mem_available() {
  mem_available_ = 0u;
  clear_has_mem_available();
}
inline ::google::protobuf::uint32 MemoryUsage::mem_available() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.mem_available)
  return mem_available_;
}
inline void MemoryUsage::set_mem_available(::google::protobuf::uint32 value) {
  set_has_mem_available();
  mem_available_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.mem_available)
}

// required uint32 buffers = 4;
inline bool MemoryUsage::has_buffers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemoryUsage::set_has_buffers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemoryUsage::clear_has_buffers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemoryUsage::clear_buffers() {
  buffers_ = 0u;
  clear_has_buffers();
}
inline ::google::protobuf::uint32 MemoryUsage::buffers() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.buffers)
  return buffers_;
}
inline void MemoryUsage::set_buffers(::google::protobuf::uint32 value) {
  set_has_buffers();
  buffers_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.buffers)
}

// required uint32 cached = 5;
inline bool MemoryUsage::has_cached() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemoryUsage::set_has_cached() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemoryUsage::clear_has_cached() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemoryUsage::clear_cached() {
  cached_ = 0u;
  clear_has_cached();
}
inline ::google::protobuf::uint32 MemoryUsage::cached() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.cached)
  return cached_;
}
inline void MemoryUsage::set_cached(::google::protobuf::uint32 value) {
  set_has_cached();
  cached_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.cached)
}

// required uint32 swap_total = 6;
inline bool MemoryUsage::has_swap_total() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemoryUsage::set_has_swap_total() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemoryUsage::clear_has_swap_total() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemoryUsage::clear_swap_total() {
  swap_total_ = 0u;
  clear_has_swap_total();
}
inline ::google::protobuf::uint32 MemoryUsage::swap_total() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.swap_total)
  return swap_total_;
}
inline void MemoryUsage::set_swap_total(::google::protobuf::uint32 value) {
  set_has_swap_total();
  swap_total_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.swap_total)
}

// required uint32 swap_free = 7;
inline bool MemoryUsage::has_swap_free() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemoryUsage::set_has_swap_free() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemoryUsage::clear_has_swap_free() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemoryUsage::clear_swap_free() {
  swap_free_ = 0u;
  clear_has_swap_free();
}
inline ::google::protobuf::uint32 MemoryUsage::swap_free() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.swap_free)
  return swap_free_;
}
inline void MemoryUsage::set_swap_free(::google::protobuf::uint32 value) {
  set_has_swap_free();
  swap_free_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.swap_free)
}

// optional uint32 hugepagesize = 8;
inline bool MemoryUsage::has_hugepagesize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemoryUsage::set_has_hugepagesize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemoryUsage::clear_has_hugepagesize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemoryUsage::clear_hugepagesize() {
  hugepagesize_ = 0u;
  clear_has_hugepagesize();
}
inline ::google::protobuf::uint32 MemoryUsage::hugepagesize() const {
  // @@protoc_insertion_point(field_get:MemoryUsage.hugepagesize)
  return hugepagesize_;
}
inline void MemoryUsage::set_hugepagesize(::google::protobuf::uint32 value) {
  set_has_hugepagesize();
  hugepagesize_ = value;
  // @@protoc_insertion_point(field_set:MemoryUsage.hugepagesize)
}

// -------------------------------------------------------------------

// DiskUsage

// required uint32 disk_available = 1;
inline bool DiskUsage::has_disk_available() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskUsage::set_has_disk_available() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskUsage::clear_has_disk_available() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskUsage::clear_disk_available() {
  disk_available_ = 0u;
  clear_has_disk_available();
}
inline ::google::protobuf::uint32 DiskUsage::disk_available() const {
  // @@protoc_insertion_point(field_get:DiskUsage.disk_available)
  return disk_available_;
}
inline void DiskUsage::set_disk_available(::google::protobuf::uint32 value) {
  set_has_disk_available();
  disk_available_ = value;
  // @@protoc_insertion_point(field_set:DiskUsage.disk_available)
}

// required double available_percent = 2;
inline bool DiskUsage::has_available_percent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskUsage::set_has_available_percent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskUsage::clear_has_available_percent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskUsage::clear_available_percent() {
  available_percent_ = 0;
  clear_has_available_percent();
}
inline double DiskUsage::available_percent() const {
  // @@protoc_insertion_point(field_get:DiskUsage.available_percent)
  return available_percent_;
}
inline void DiskUsage::set_available_percent(double value) {
  set_has_available_percent();
  available_percent_ = value;
  // @@protoc_insertion_point(field_set:DiskUsage.available_percent)
}

// -------------------------------------------------------------------

// NetUsage

// required float net_used = 1;
inline bool NetUsage::has_net_used() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetUsage::set_has_net_used() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetUsage::clear_has_net_used() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetUsage::clear_net_used() {
  net_used_ = 0;
  clear_has_net_used();
}
inline float NetUsage::net_used() const {
  // @@protoc_insertion_point(field_get:NetUsage.net_used)
  return net_used_;
}
inline void NetUsage::set_net_used(float value) {
  set_has_net_used();
  net_used_ = value;
  // @@protoc_insertion_point(field_set:NetUsage.net_used)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_runtime_5fresource_2eproto__INCLUDED
