// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scheduler.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "scheduler.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {
namespace scheduler {

namespace {

const ::google::protobuf::Descriptor* Event_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Subscribed_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Subscribed_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Offers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Offers_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_InverseOffers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_InverseOffers_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Rescind_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Rescind_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_RescindInverseOffer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_RescindInverseOffer_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Update_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Update_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Message_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Failure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Failure_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_Error_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Event_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Call_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Subscribe_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Subscribe_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Accept_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Accept_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Decline_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Decline_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_AcceptInverseOffers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_AcceptInverseOffers_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_DeclineInverseOffers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_DeclineInverseOffers_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Revive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Revive_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Kill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Kill_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Shutdown_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Shutdown_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Acknowledge_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Acknowledge_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Reconcile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Reconcile_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Reconcile_Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Reconcile_Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Message_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Request_reflection_ = NULL;
const ::google::protobuf::Descriptor* Call_Suppress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Call_Suppress_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Call_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_scheduler_2eproto() {
  protobuf_AddDesc_scheduler_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "scheduler.proto");
  GOOGLE_CHECK(file != NULL);
  Event_descriptor_ = file->message_type(0);
  static const int Event_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, subscribed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, inverse_offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, rescind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, rescind_inverse_offer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, failure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, error_),
  };
  Event_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_descriptor_,
      Event::default_instance_,
      Event_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event));
  Event_Subscribed_descriptor_ = Event_descriptor_->nested_type(0);
  static const int Event_Subscribed_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, heartbeat_interval_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, master_info_),
  };
  Event_Subscribed_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Subscribed_descriptor_,
      Event_Subscribed::default_instance_,
      Event_Subscribed_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Subscribed, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Subscribed));
  Event_Offers_descriptor_ = Event_descriptor_->nested_type(1);
  static const int Event_Offers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, offers_),
  };
  Event_Offers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Offers_descriptor_,
      Event_Offers::default_instance_,
      Event_Offers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Offers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Offers));
  Event_InverseOffers_descriptor_ = Event_descriptor_->nested_type(2);
  static const int Event_InverseOffers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_InverseOffers, inverse_offers_),
  };
  Event_InverseOffers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_InverseOffers_descriptor_,
      Event_InverseOffers::default_instance_,
      Event_InverseOffers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_InverseOffers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_InverseOffers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_InverseOffers));
  Event_Rescind_descriptor_ = Event_descriptor_->nested_type(3);
  static const int Event_Rescind_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Rescind, offer_id_),
  };
  Event_Rescind_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Rescind_descriptor_,
      Event_Rescind::default_instance_,
      Event_Rescind_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Rescind, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Rescind, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Rescind));
  Event_RescindInverseOffer_descriptor_ = Event_descriptor_->nested_type(4);
  static const int Event_RescindInverseOffer_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_RescindInverseOffer, inverse_offer_id_),
  };
  Event_RescindInverseOffer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_RescindInverseOffer_descriptor_,
      Event_RescindInverseOffer::default_instance_,
      Event_RescindInverseOffer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_RescindInverseOffer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_RescindInverseOffer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_RescindInverseOffer));
  Event_Update_descriptor_ = Event_descriptor_->nested_type(5);
  static const int Event_Update_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Update, status_),
  };
  Event_Update_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Update_descriptor_,
      Event_Update::default_instance_,
      Event_Update_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Update, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Update, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Update));
  Event_Message_descriptor_ = Event_descriptor_->nested_type(6);
  static const int Event_Message_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, data_),
  };
  Event_Message_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Message_descriptor_,
      Event_Message::default_instance_,
      Event_Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Message, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Message));
  Event_Failure_descriptor_ = Event_descriptor_->nested_type(7);
  static const int Event_Failure_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, status_),
  };
  Event_Failure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Failure_descriptor_,
      Event_Failure::default_instance_,
      Event_Failure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Failure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Failure));
  Event_Error_descriptor_ = Event_descriptor_->nested_type(8);
  static const int Event_Error_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Error, message_),
  };
  Event_Error_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_Error_descriptor_,
      Event_Error::default_instance_,
      Event_Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Error, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event_Error, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event_Error));
  Event_Type_descriptor_ = Event_descriptor_->enum_type(0);
  Call_descriptor_ = file->message_type(1);
  static const int Call_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, subscribe_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, accept_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, decline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, accept_inverse_offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, decline_inverse_offers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, revive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, kill_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, shutdown_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, acknowledge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, reconcile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, suppress_),
  };
  Call_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_descriptor_,
      Call::default_instance_,
      Call_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call));
  Call_Subscribe_descriptor_ = Call_descriptor_->nested_type(0);
  static const int Call_Subscribe_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, framework_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, force_),
  };
  Call_Subscribe_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Subscribe_descriptor_,
      Call_Subscribe::default_instance_,
      Call_Subscribe_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Subscribe, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Subscribe));
  Call_Accept_descriptor_ = Call_descriptor_->nested_type(1);
  static const int Call_Accept_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, offer_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, operations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, filters_),
  };
  Call_Accept_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Accept_descriptor_,
      Call_Accept::default_instance_,
      Call_Accept_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Accept, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Accept));
  Call_Decline_descriptor_ = Call_descriptor_->nested_type(2);
  static const int Call_Decline_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, offer_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, filters_),
  };
  Call_Decline_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Decline_descriptor_,
      Call_Decline::default_instance_,
      Call_Decline_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Decline, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Decline));
  Call_AcceptInverseOffers_descriptor_ = Call_descriptor_->nested_type(3);
  static const int Call_AcceptInverseOffers_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_AcceptInverseOffers, inverse_offer_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_AcceptInverseOffers, filters_),
  };
  Call_AcceptInverseOffers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_AcceptInverseOffers_descriptor_,
      Call_AcceptInverseOffers::default_instance_,
      Call_AcceptInverseOffers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_AcceptInverseOffers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_AcceptInverseOffers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_AcceptInverseOffers));
  Call_DeclineInverseOffers_descriptor_ = Call_descriptor_->nested_type(4);
  static const int Call_DeclineInverseOffers_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_DeclineInverseOffers, inverse_offer_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_DeclineInverseOffers, filters_),
  };
  Call_DeclineInverseOffers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_DeclineInverseOffers_descriptor_,
      Call_DeclineInverseOffers::default_instance_,
      Call_DeclineInverseOffers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_DeclineInverseOffers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_DeclineInverseOffers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_DeclineInverseOffers));
  Call_Revive_descriptor_ = Call_descriptor_->nested_type(5);
  static const int Call_Revive_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Revive, roles_),
  };
  Call_Revive_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Revive_descriptor_,
      Call_Revive::default_instance_,
      Call_Revive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Revive, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Revive, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Revive));
  Call_Kill_descriptor_ = Call_descriptor_->nested_type(6);
  static const int Call_Kill_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, kill_policy_),
  };
  Call_Kill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Kill_descriptor_,
      Call_Kill::default_instance_,
      Call_Kill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Kill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Kill));
  Call_Shutdown_descriptor_ = Call_descriptor_->nested_type(7);
  static const int Call_Shutdown_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, slave_id_),
  };
  Call_Shutdown_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Shutdown_descriptor_,
      Call_Shutdown::default_instance_,
      Call_Shutdown_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Shutdown, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Shutdown));
  Call_Acknowledge_descriptor_ = Call_descriptor_->nested_type(8);
  static const int Call_Acknowledge_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, uuid_),
  };
  Call_Acknowledge_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Acknowledge_descriptor_,
      Call_Acknowledge::default_instance_,
      Call_Acknowledge_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Acknowledge, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Acknowledge));
  Call_Reconcile_descriptor_ = Call_descriptor_->nested_type(9);
  static const int Call_Reconcile_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile, tasks_),
  };
  Call_Reconcile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Reconcile_descriptor_,
      Call_Reconcile::default_instance_,
      Call_Reconcile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Reconcile));
  Call_Reconcile_Task_descriptor_ = Call_Reconcile_descriptor_->nested_type(0);
  static const int Call_Reconcile_Task_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, slave_id_),
  };
  Call_Reconcile_Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Reconcile_Task_descriptor_,
      Call_Reconcile_Task::default_instance_,
      Call_Reconcile_Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Reconcile_Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Reconcile_Task));
  Call_Message_descriptor_ = Call_descriptor_->nested_type(10);
  static const int Call_Message_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, data_),
  };
  Call_Message_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Message_descriptor_,
      Call_Message::default_instance_,
      Call_Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Message, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Message));
  Call_Request_descriptor_ = Call_descriptor_->nested_type(11);
  static const int Call_Request_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Request, requests_),
  };
  Call_Request_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Request_descriptor_,
      Call_Request::default_instance_,
      Call_Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Request, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Request, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Request));
  Call_Suppress_descriptor_ = Call_descriptor_->nested_type(12);
  static const int Call_Suppress_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Suppress, roles_),
  };
  Call_Suppress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Call_Suppress_descriptor_,
      Call_Suppress::default_instance_,
      Call_Suppress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Suppress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Call_Suppress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Call_Suppress));
  Call_Type_descriptor_ = Call_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_scheduler_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_descriptor_, &Event::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Subscribed_descriptor_, &Event_Subscribed::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Offers_descriptor_, &Event_Offers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_InverseOffers_descriptor_, &Event_InverseOffers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Rescind_descriptor_, &Event_Rescind::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_RescindInverseOffer_descriptor_, &Event_RescindInverseOffer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Update_descriptor_, &Event_Update::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Message_descriptor_, &Event_Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Failure_descriptor_, &Event_Failure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_Error_descriptor_, &Event_Error::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_descriptor_, &Call::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Subscribe_descriptor_, &Call_Subscribe::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Accept_descriptor_, &Call_Accept::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Decline_descriptor_, &Call_Decline::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_AcceptInverseOffers_descriptor_, &Call_AcceptInverseOffers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_DeclineInverseOffers_descriptor_, &Call_DeclineInverseOffers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Revive_descriptor_, &Call_Revive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Kill_descriptor_, &Call_Kill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Shutdown_descriptor_, &Call_Shutdown::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Acknowledge_descriptor_, &Call_Acknowledge::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Reconcile_descriptor_, &Call_Reconcile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Reconcile_Task_descriptor_, &Call_Reconcile_Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Message_descriptor_, &Call_Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Request_descriptor_, &Call_Request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Call_Suppress_descriptor_, &Call_Suppress::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_scheduler_2eproto() {
  delete Event::default_instance_;
  delete Event_reflection_;
  delete Event_Subscribed::default_instance_;
  delete Event_Subscribed_reflection_;
  delete Event_Offers::default_instance_;
  delete Event_Offers_reflection_;
  delete Event_InverseOffers::default_instance_;
  delete Event_InverseOffers_reflection_;
  delete Event_Rescind::default_instance_;
  delete Event_Rescind_reflection_;
  delete Event_RescindInverseOffer::default_instance_;
  delete Event_RescindInverseOffer_reflection_;
  delete Event_Update::default_instance_;
  delete Event_Update_reflection_;
  delete Event_Message::default_instance_;
  delete Event_Message_reflection_;
  delete Event_Failure::default_instance_;
  delete Event_Failure_reflection_;
  delete Event_Error::default_instance_;
  delete Event_Error_reflection_;
  delete Call::default_instance_;
  delete Call_reflection_;
  delete Call_Subscribe::default_instance_;
  delete Call_Subscribe_reflection_;
  delete Call_Accept::default_instance_;
  delete Call_Accept_reflection_;
  delete Call_Decline::default_instance_;
  delete Call_Decline_reflection_;
  delete Call_AcceptInverseOffers::default_instance_;
  delete Call_AcceptInverseOffers_reflection_;
  delete Call_DeclineInverseOffers::default_instance_;
  delete Call_DeclineInverseOffers_reflection_;
  delete Call_Revive::default_instance_;
  delete Call_Revive_reflection_;
  delete Call_Kill::default_instance_;
  delete Call_Kill_reflection_;
  delete Call_Shutdown::default_instance_;
  delete Call_Shutdown_reflection_;
  delete Call_Acknowledge::default_instance_;
  delete Call_Acknowledge_reflection_;
  delete Call_Reconcile::default_instance_;
  delete Call_Reconcile_reflection_;
  delete Call_Reconcile_Task::default_instance_;
  delete Call_Reconcile_Task_reflection_;
  delete Call_Message::default_instance_;
  delete Call_Message_reflection_;
  delete Call_Request::default_instance_;
  delete Call_Request_reflection_;
  delete Call_Suppress::default_instance_;
  delete Call_Suppress_reflection_;
}

void protobuf_AddDesc_scheduler_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017scheduler.proto\022\017mesos.scheduler\032\013meso"
    "s.proto\"\246\n\n\005Event\022)\n\004type\030\001 \001(\0162\033.mesos."
    "scheduler.Event.Type\0225\n\nsubscribed\030\002 \001(\013"
    "2!.mesos.scheduler.Event.Subscribed\022-\n\006o"
    "ffers\030\003 \001(\0132\035.mesos.scheduler.Event.Offe"
    "rs\022<\n\016inverse_offers\030\t \001(\0132$.mesos.sched"
    "uler.Event.InverseOffers\022/\n\007rescind\030\004 \001("
    "\0132\036.mesos.scheduler.Event.Rescind\022I\n\025res"
    "cind_inverse_offer\030\n \001(\0132*.mesos.schedul"
    "er.Event.RescindInverseOffer\022-\n\006update\030\005"
    " \001(\0132\035.mesos.scheduler.Event.Update\022/\n\007m"
    "essage\030\006 \001(\0132\036.mesos.scheduler.Event.Mes"
    "sage\022/\n\007failure\030\007 \001(\0132\036.mesos.scheduler."
    "Event.Failure\022+\n\005error\030\010 \001(\0132\034.mesos.sch"
    "eduler.Event.Error\032\202\001\n\nSubscribed\022(\n\014fra"
    "mework_id\030\001 \002(\0132\022.mesos.FrameworkID\022\"\n\032h"
    "eartbeat_interval_seconds\030\002 \001(\001\022&\n\013maste"
    "r_info\030\003 \001(\0132\021.mesos.MasterInfo\032&\n\006Offer"
    "s\022\034\n\006offers\030\001 \003(\0132\014.mesos.Offer\032<\n\rInver"
    "seOffers\022+\n\016inverse_offers\030\001 \003(\0132\023.mesos"
    ".InverseOffer\032+\n\007Rescind\022 \n\010offer_id\030\001 \002"
    "(\0132\016.mesos.OfferID\032\?\n\023RescindInverseOffe"
    "r\022(\n\020inverse_offer_id\030\001 \002(\0132\016.mesos.Offe"
    "rID\032+\n\006Update\022!\n\006status\030\001 \002(\0132\021.mesos.Ta"
    "skStatus\032a\n\007Message\022 \n\010slave_id\030\001 \002(\0132\016."
    "mesos.SlaveID\022&\n\013executor_id\030\002 \002(\0132\021.mes"
    "os.ExecutorID\022\014\n\004data\030\003 \002(\014\032c\n\007Failure\022 "
    "\n\010slave_id\030\001 \001(\0132\016.mesos.SlaveID\022&\n\013exec"
    "utor_id\030\002 \001(\0132\021.mesos.ExecutorID\022\016\n\006stat"
    "us\030\003 \001(\005\032\030\n\005Error\022\017\n\007message\030\001 \002(\t\"\253\001\n\004T"
    "ype\022\013\n\007UNKNOWN\020\000\022\016\n\nSUBSCRIBED\020\001\022\n\n\006OFFE"
    "RS\020\002\022\022\n\016INVERSE_OFFERS\020\t\022\013\n\007RESCIND\020\003\022\031\n"
    "\025RESCIND_INVERSE_OFFER\020\n\022\n\n\006UPDATE\020\004\022\013\n\007"
    "MESSAGE\020\005\022\013\n\007FAILURE\020\006\022\t\n\005ERROR\020\007\022\r\n\tHEA"
    "RTBEAT\020\010\"\313\020\n\004Call\022(\n\014framework_id\030\001 \001(\0132"
    "\022.mesos.FrameworkID\022(\n\004type\030\002 \001(\0162\032.meso"
    "s.scheduler.Call.Type\0222\n\tsubscribe\030\003 \001(\013"
    "2\037.mesos.scheduler.Call.Subscribe\022,\n\006acc"
    "ept\030\004 \001(\0132\034.mesos.scheduler.Call.Accept\022"
    ".\n\007decline\030\005 \001(\0132\035.mesos.scheduler.Call."
    "Decline\022H\n\025accept_inverse_offers\030\r \001(\0132)"
    ".mesos.scheduler.Call.AcceptInverseOffer"
    "s\022J\n\026decline_inverse_offers\030\016 \001(\0132*.meso"
    "s.scheduler.Call.DeclineInverseOffers\022,\n"
    "\006revive\030\017 \001(\0132\034.mesos.scheduler.Call.Rev"
    "ive\022(\n\004kill\030\006 \001(\0132\032.mesos.scheduler.Call"
    ".Kill\0220\n\010shutdown\030\007 \001(\0132\036.mesos.schedule"
    "r.Call.Shutdown\0226\n\013acknowledge\030\010 \001(\0132!.m"
    "esos.scheduler.Call.Acknowledge\0222\n\trecon"
    "cile\030\t \001(\0132\037.mesos.scheduler.Call.Reconc"
    "ile\022.\n\007message\030\n \001(\0132\035.mesos.scheduler.C"
    "all.Message\022.\n\007request\030\013 \001(\0132\035.mesos.sch"
    "eduler.Call.Request\0220\n\010suppress\030\020 \001(\0132\036."
    "mesos.scheduler.Call.Suppress\032H\n\tSubscri"
    "be\022,\n\016framework_info\030\001 \002(\0132\024.mesos.Frame"
    "workInfo\022\r\n\005force\030\002 \001(\010\032x\n\006Accept\022!\n\toff"
    "er_ids\030\001 \003(\0132\016.mesos.OfferID\022*\n\noperatio"
    "ns\030\002 \003(\0132\026.mesos.Offer.Operation\022\037\n\007filt"
    "ers\030\003 \001(\0132\016.mesos.Filters\032M\n\007Decline\022!\n\t"
    "offer_ids\030\001 \003(\0132\016.mesos.OfferID\022\037\n\007filte"
    "rs\030\002 \001(\0132\016.mesos.Filters\032a\n\023AcceptInvers"
    "eOffers\022)\n\021inverse_offer_ids\030\001 \003(\0132\016.mes"
    "os.OfferID\022\037\n\007filters\030\002 \001(\0132\016.mesos.Filt"
    "ers\032b\n\024DeclineInverseOffers\022)\n\021inverse_o"
    "ffer_ids\030\001 \003(\0132\016.mesos.OfferID\022\037\n\007filter"
    "s\030\002 \001(\0132\016.mesos.Filters\032\027\n\006Revive\022\r\n\005rol"
    "es\030\001 \003(\t\032p\n\004Kill\022\036\n\007task_id\030\001 \002(\0132\r.meso"
    "s.TaskID\022 \n\010slave_id\030\002 \001(\0132\016.mesos.Slave"
    "ID\022&\n\013kill_policy\030\003 \001(\0132\021.mesos.KillPoli"
    "cy\032T\n\010Shutdown\022&\n\013executor_id\030\001 \002(\0132\021.me"
    "sos.ExecutorID\022 \n\010slave_id\030\002 \002(\0132\016.mesos"
    ".SlaveID\032]\n\013Acknowledge\022 \n\010slave_id\030\001 \002("
    "\0132\016.mesos.SlaveID\022\036\n\007task_id\030\002 \002(\0132\r.mes"
    "os.TaskID\022\014\n\004uuid\030\003 \002(\014\032\212\001\n\tReconcile\0223\n"
    "\005tasks\030\001 \003(\0132$.mesos.scheduler.Call.Reco"
    "ncile.Task\032H\n\004Task\022\036\n\007task_id\030\001 \002(\0132\r.me"
    "sos.TaskID\022 \n\010slave_id\030\002 \001(\0132\016.mesos.Sla"
    "veID\032a\n\007Message\022 \n\010slave_id\030\001 \002(\0132\016.meso"
    "s.SlaveID\022&\n\013executor_id\030\002 \002(\0132\021.mesos.E"
    "xecutorID\022\014\n\004data\030\003 \002(\014\032+\n\007Request\022 \n\010re"
    "quests\030\001 \003(\0132\016.mesos.Request\032\031\n\010Suppress"
    "\022\r\n\005roles\030\001 \003(\t\"\354\001\n\004Type\022\013\n\007UNKNOWN\020\000\022\r\n"
    "\tSUBSCRIBE\020\001\022\014\n\010TEARDOWN\020\002\022\n\n\006ACCEPT\020\003\022\013"
    "\n\007DECLINE\020\004\022\031\n\025ACCEPT_INVERSE_OFFERS\020\r\022\032"
    "\n\026DECLINE_INVERSE_OFFERS\020\016\022\n\n\006REVIVE\020\005\022\010"
    "\n\004KILL\020\006\022\014\n\010SHUTDOWN\020\007\022\017\n\013ACKNOWLEDGE\020\010\022"
    "\r\n\tRECONCILE\020\t\022\013\n\007MESSAGE\020\n\022\013\n\007REQUEST\020\013"
    "\022\014\n\010SUPPRESS\020\014B$\n\032org.apache.mesos.sched"
    "ulerB\006Protos", 3532);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "scheduler.proto", &protobuf_RegisterTypes);
  Event::default_instance_ = new Event();
  Event_Subscribed::default_instance_ = new Event_Subscribed();
  Event_Offers::default_instance_ = new Event_Offers();
  Event_InverseOffers::default_instance_ = new Event_InverseOffers();
  Event_Rescind::default_instance_ = new Event_Rescind();
  Event_RescindInverseOffer::default_instance_ = new Event_RescindInverseOffer();
  Event_Update::default_instance_ = new Event_Update();
  Event_Message::default_instance_ = new Event_Message();
  Event_Failure::default_instance_ = new Event_Failure();
  Event_Error::default_instance_ = new Event_Error();
  Call::default_instance_ = new Call();
  Call_Subscribe::default_instance_ = new Call_Subscribe();
  Call_Accept::default_instance_ = new Call_Accept();
  Call_Decline::default_instance_ = new Call_Decline();
  Call_AcceptInverseOffers::default_instance_ = new Call_AcceptInverseOffers();
  Call_DeclineInverseOffers::default_instance_ = new Call_DeclineInverseOffers();
  Call_Revive::default_instance_ = new Call_Revive();
  Call_Kill::default_instance_ = new Call_Kill();
  Call_Shutdown::default_instance_ = new Call_Shutdown();
  Call_Acknowledge::default_instance_ = new Call_Acknowledge();
  Call_Reconcile::default_instance_ = new Call_Reconcile();
  Call_Reconcile_Task::default_instance_ = new Call_Reconcile_Task();
  Call_Message::default_instance_ = new Call_Message();
  Call_Request::default_instance_ = new Call_Request();
  Call_Suppress::default_instance_ = new Call_Suppress();
  Event::default_instance_->InitAsDefaultInstance();
  Event_Subscribed::default_instance_->InitAsDefaultInstance();
  Event_Offers::default_instance_->InitAsDefaultInstance();
  Event_InverseOffers::default_instance_->InitAsDefaultInstance();
  Event_Rescind::default_instance_->InitAsDefaultInstance();
  Event_RescindInverseOffer::default_instance_->InitAsDefaultInstance();
  Event_Update::default_instance_->InitAsDefaultInstance();
  Event_Message::default_instance_->InitAsDefaultInstance();
  Event_Failure::default_instance_->InitAsDefaultInstance();
  Event_Error::default_instance_->InitAsDefaultInstance();
  Call::default_instance_->InitAsDefaultInstance();
  Call_Subscribe::default_instance_->InitAsDefaultInstance();
  Call_Accept::default_instance_->InitAsDefaultInstance();
  Call_Decline::default_instance_->InitAsDefaultInstance();
  Call_AcceptInverseOffers::default_instance_->InitAsDefaultInstance();
  Call_DeclineInverseOffers::default_instance_->InitAsDefaultInstance();
  Call_Revive::default_instance_->InitAsDefaultInstance();
  Call_Kill::default_instance_->InitAsDefaultInstance();
  Call_Shutdown::default_instance_->InitAsDefaultInstance();
  Call_Acknowledge::default_instance_->InitAsDefaultInstance();
  Call_Reconcile::default_instance_->InitAsDefaultInstance();
  Call_Reconcile_Task::default_instance_->InitAsDefaultInstance();
  Call_Message::default_instance_->InitAsDefaultInstance();
  Call_Request::default_instance_->InitAsDefaultInstance();
  Call_Suppress::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_scheduler_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_scheduler_2eproto {
  StaticDescriptorInitializer_scheduler_2eproto() {
    protobuf_AddDesc_scheduler_2eproto();
  }
} static_descriptor_initializer_scheduler_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Type_descriptor_;
}
bool Event_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Event_Type Event::UNKNOWN;
const Event_Type Event::SUBSCRIBED;
const Event_Type Event::OFFERS;
const Event_Type Event::INVERSE_OFFERS;
const Event_Type Event::RESCIND;
const Event_Type Event::RESCIND_INVERSE_OFFER;
const Event_Type Event::UPDATE;
const Event_Type Event::MESSAGE;
const Event_Type Event::FAILURE;
const Event_Type Event::ERROR;
const Event_Type Event::HEARTBEAT;
const Event_Type Event::Type_MIN;
const Event_Type Event::Type_MAX;
const int Event::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Event_Subscribed::kFrameworkIdFieldNumber;
const int Event_Subscribed::kHeartbeatIntervalSecondsFieldNumber;
const int Event_Subscribed::kMasterInfoFieldNumber;
#endif  // !_MSC_VER

Event_Subscribed::Event_Subscribed()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Subscribed)
}

void Event_Subscribed::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  master_info_ = const_cast< ::mesos::MasterInfo*>(&::mesos::MasterInfo::default_instance());
}

Event_Subscribed::Event_Subscribed(const Event_Subscribed& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Subscribed)
}

void Event_Subscribed::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  heartbeat_interval_seconds_ = 0;
  master_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Subscribed::~Event_Subscribed() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Subscribed)
  SharedDtor();
}

void Event_Subscribed::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete master_info_;
  }
}

void Event_Subscribed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Subscribed::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Subscribed_descriptor_;
}

const Event_Subscribed& Event_Subscribed::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Subscribed* Event_Subscribed::default_instance_ = NULL;

Event_Subscribed* Event_Subscribed::New() const {
  return new Event_Subscribed;
}

void Event_Subscribed::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    heartbeat_interval_seconds_ = 0;
    if (has_master_info()) {
      if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Subscribed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Subscribed)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_heartbeat_interval_seconds;
        break;
      }

      // optional double heartbeat_interval_seconds = 2;
      case 2: {
        if (tag == 17) {
         parse_heartbeat_interval_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heartbeat_interval_seconds_)));
          set_has_heartbeat_interval_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_master_info;
        break;
      }

      // optional .mesos.MasterInfo master_info = 3;
      case 3: {
        if (tag == 26) {
         parse_master_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Subscribed)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Subscribed)
  return false;
#undef DO_
}

void Event_Subscribed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Subscribed)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional double heartbeat_interval_seconds = 2;
  if (has_heartbeat_interval_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->heartbeat_interval_seconds(), output);
  }

  // optional .mesos.MasterInfo master_info = 3;
  if (has_master_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->master_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Subscribed)
}

::google::protobuf::uint8* Event_Subscribed::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Subscribed)
  // required .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional double heartbeat_interval_seconds = 2;
  if (has_heartbeat_interval_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->heartbeat_interval_seconds(), target);
  }

  // optional .mesos.MasterInfo master_info = 3;
  if (has_master_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->master_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Subscribed)
  return target;
}

int Event_Subscribed::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional double heartbeat_interval_seconds = 2;
    if (has_heartbeat_interval_seconds()) {
      total_size += 1 + 8;
    }

    // optional .mesos.MasterInfo master_info = 3;
    if (has_master_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Subscribed::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Subscribed* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Subscribed*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Subscribed::MergeFrom(const Event_Subscribed& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_heartbeat_interval_seconds()) {
      set_heartbeat_interval_seconds(from.heartbeat_interval_seconds());
    }
    if (from.has_master_info()) {
      mutable_master_info()->::mesos::MasterInfo::MergeFrom(from.master_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Subscribed::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Subscribed::CopyFrom(const Event_Subscribed& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Subscribed::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_master_info()) {
    if (!this->master_info().IsInitialized()) return false;
  }
  return true;
}

void Event_Subscribed::Swap(Event_Subscribed* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(heartbeat_interval_seconds_, other->heartbeat_interval_seconds_);
    std::swap(master_info_, other->master_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Subscribed::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Subscribed_descriptor_;
  metadata.reflection = Event_Subscribed_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Offers::kOffersFieldNumber;
#endif  // !_MSC_VER

Event_Offers::Event_Offers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Offers)
}

void Event_Offers::InitAsDefaultInstance() {
}

Event_Offers::Event_Offers(const Event_Offers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Offers)
}

void Event_Offers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Offers::~Event_Offers() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Offers)
  SharedDtor();
}

void Event_Offers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Event_Offers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Offers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Offers_descriptor_;
}

const Event_Offers& Event_Offers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Offers* Event_Offers::default_instance_ = NULL;

Event_Offers* Event_Offers::New() const {
  return new Event_Offers;
}

void Event_Offers::Clear() {
  offers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Offers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Offers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Offer offers = 1;
      case 1: {
        if (tag == 10) {
         parse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_offers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Offers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Offers)
  return false;
#undef DO_
}

void Event_Offers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Offers)
  // repeated .mesos.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Offers)
}

::google::protobuf::uint8* Event_Offers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Offers)
  // repeated .mesos.Offer offers = 1;
  for (int i = 0; i < this->offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Offers)
  return target;
}

int Event_Offers::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Offer offers = 1;
  total_size += 1 * this->offers_size();
  for (int i = 0; i < this->offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Offers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Offers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Offers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Offers::MergeFrom(const Event_Offers& from) {
  GOOGLE_CHECK_NE(&from, this);
  offers_.MergeFrom(from.offers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Offers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Offers::CopyFrom(const Event_Offers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Offers::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->offers())) return false;
  return true;
}

void Event_Offers::Swap(Event_Offers* other) {
  if (other != this) {
    offers_.Swap(&other->offers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Offers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Offers_descriptor_;
  metadata.reflection = Event_Offers_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_InverseOffers::kInverseOffersFieldNumber;
#endif  // !_MSC_VER

Event_InverseOffers::Event_InverseOffers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.InverseOffers)
}

void Event_InverseOffers::InitAsDefaultInstance() {
}

Event_InverseOffers::Event_InverseOffers(const Event_InverseOffers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.InverseOffers)
}

void Event_InverseOffers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_InverseOffers::~Event_InverseOffers() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.InverseOffers)
  SharedDtor();
}

void Event_InverseOffers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Event_InverseOffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_InverseOffers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_InverseOffers_descriptor_;
}

const Event_InverseOffers& Event_InverseOffers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_InverseOffers* Event_InverseOffers::default_instance_ = NULL;

Event_InverseOffers* Event_InverseOffers::New() const {
  return new Event_InverseOffers;
}

void Event_InverseOffers::Clear() {
  inverse_offers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_InverseOffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.InverseOffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.InverseOffer inverse_offers = 1;
      case 1: {
        if (tag == 10) {
         parse_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inverse_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_inverse_offers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.InverseOffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.InverseOffers)
  return false;
#undef DO_
}

void Event_InverseOffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.InverseOffers)
  // repeated .mesos.InverseOffer inverse_offers = 1;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverse_offers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.InverseOffers)
}

::google::protobuf::uint8* Event_InverseOffers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.InverseOffers)
  // repeated .mesos.InverseOffer inverse_offers = 1;
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverse_offers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.InverseOffers)
  return target;
}

int Event_InverseOffers::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.InverseOffer inverse_offers = 1;
  total_size += 1 * this->inverse_offers_size();
  for (int i = 0; i < this->inverse_offers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inverse_offers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_InverseOffers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_InverseOffers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_InverseOffers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_InverseOffers::MergeFrom(const Event_InverseOffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  inverse_offers_.MergeFrom(from.inverse_offers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_InverseOffers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_InverseOffers::CopyFrom(const Event_InverseOffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_InverseOffers::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->inverse_offers())) return false;
  return true;
}

void Event_InverseOffers::Swap(Event_InverseOffers* other) {
  if (other != this) {
    inverse_offers_.Swap(&other->inverse_offers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_InverseOffers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_InverseOffers_descriptor_;
  metadata.reflection = Event_InverseOffers_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Rescind::kOfferIdFieldNumber;
#endif  // !_MSC_VER

Event_Rescind::Event_Rescind()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Rescind)
}

void Event_Rescind::InitAsDefaultInstance() {
  offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
}

Event_Rescind::Event_Rescind(const Event_Rescind& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Rescind)
}

void Event_Rescind::SharedCtor() {
  _cached_size_ = 0;
  offer_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Rescind::~Event_Rescind() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Rescind)
  SharedDtor();
}

void Event_Rescind::SharedDtor() {
  if (this != default_instance_) {
    delete offer_id_;
  }
}

void Event_Rescind::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Rescind::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Rescind_descriptor_;
}

const Event_Rescind& Event_Rescind::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Rescind* Event_Rescind::default_instance_ = NULL;

Event_Rescind* Event_Rescind::New() const {
  return new Event_Rescind;
}

void Event_Rescind::Clear() {
  if (has_offer_id()) {
    if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Rescind::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Rescind)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID offer_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offer_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Rescind)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Rescind)
  return false;
#undef DO_
}

void Event_Rescind::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Rescind)
  // required .mesos.OfferID offer_id = 1;
  if (has_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Rescind)
}

::google::protobuf::uint8* Event_Rescind::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Rescind)
  // required .mesos.OfferID offer_id = 1;
  if (has_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Rescind)
  return target;
}

int Event_Rescind::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID offer_id = 1;
    if (has_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offer_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Rescind::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Rescind* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Rescind*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Rescind::MergeFrom(const Event_Rescind& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offer_id()) {
      mutable_offer_id()->::mesos::OfferID::MergeFrom(from.offer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Rescind::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Rescind::CopyFrom(const Event_Rescind& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Rescind::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_offer_id()) {
    if (!this->offer_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Rescind::Swap(Event_Rescind* other) {
  if (other != this) {
    std::swap(offer_id_, other->offer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Rescind::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Rescind_descriptor_;
  metadata.reflection = Event_Rescind_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_RescindInverseOffer::kInverseOfferIdFieldNumber;
#endif  // !_MSC_VER

Event_RescindInverseOffer::Event_RescindInverseOffer()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.RescindInverseOffer)
}

void Event_RescindInverseOffer::InitAsDefaultInstance() {
  inverse_offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
}

Event_RescindInverseOffer::Event_RescindInverseOffer(const Event_RescindInverseOffer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.RescindInverseOffer)
}

void Event_RescindInverseOffer::SharedCtor() {
  _cached_size_ = 0;
  inverse_offer_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_RescindInverseOffer::~Event_RescindInverseOffer() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.RescindInverseOffer)
  SharedDtor();
}

void Event_RescindInverseOffer::SharedDtor() {
  if (this != default_instance_) {
    delete inverse_offer_id_;
  }
}

void Event_RescindInverseOffer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_RescindInverseOffer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_RescindInverseOffer_descriptor_;
}

const Event_RescindInverseOffer& Event_RescindInverseOffer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_RescindInverseOffer* Event_RescindInverseOffer::default_instance_ = NULL;

Event_RescindInverseOffer* Event_RescindInverseOffer::New() const {
  return new Event_RescindInverseOffer;
}

void Event_RescindInverseOffer::Clear() {
  if (has_inverse_offer_id()) {
    if (inverse_offer_id_ != NULL) inverse_offer_id_->::mesos::OfferID::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_RescindInverseOffer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.RescindInverseOffer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID inverse_offer_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inverse_offer_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.RescindInverseOffer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.RescindInverseOffer)
  return false;
#undef DO_
}

void Event_RescindInverseOffer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.RescindInverseOffer)
  // required .mesos.OfferID inverse_offer_id = 1;
  if (has_inverse_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverse_offer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.RescindInverseOffer)
}

::google::protobuf::uint8* Event_RescindInverseOffer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.RescindInverseOffer)
  // required .mesos.OfferID inverse_offer_id = 1;
  if (has_inverse_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverse_offer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.RescindInverseOffer)
  return target;
}

int Event_RescindInverseOffer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.OfferID inverse_offer_id = 1;
    if (has_inverse_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inverse_offer_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_RescindInverseOffer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_RescindInverseOffer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_RescindInverseOffer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_RescindInverseOffer::MergeFrom(const Event_RescindInverseOffer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_inverse_offer_id()) {
      mutable_inverse_offer_id()->::mesos::OfferID::MergeFrom(from.inverse_offer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_RescindInverseOffer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_RescindInverseOffer::CopyFrom(const Event_RescindInverseOffer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_RescindInverseOffer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_inverse_offer_id()) {
    if (!this->inverse_offer_id().IsInitialized()) return false;
  }
  return true;
}

void Event_RescindInverseOffer::Swap(Event_RescindInverseOffer* other) {
  if (other != this) {
    std::swap(inverse_offer_id_, other->inverse_offer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_RescindInverseOffer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_RescindInverseOffer_descriptor_;
  metadata.reflection = Event_RescindInverseOffer_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Update::kStatusFieldNumber;
#endif  // !_MSC_VER

Event_Update::Event_Update()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Update)
}

void Event_Update::InitAsDefaultInstance() {
  status_ = const_cast< ::mesos::TaskStatus*>(&::mesos::TaskStatus::default_instance());
}

Event_Update::Event_Update(const Event_Update& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Update)
}

void Event_Update::SharedCtor() {
  _cached_size_ = 0;
  status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Update::~Event_Update() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Update)
  SharedDtor();
}

void Event_Update::SharedDtor() {
  if (this != default_instance_) {
    delete status_;
  }
}

void Event_Update::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Update::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Update_descriptor_;
}

const Event_Update& Event_Update::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Update* Event_Update::default_instance_ = NULL;

Event_Update* Event_Update::New() const {
  return new Event_Update;
}

void Event_Update::Clear() {
  if (has_status()) {
    if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Update)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskStatus status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Update)
  return false;
#undef DO_
}

void Event_Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Update)
  // required .mesos.TaskStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Update)
}

::google::protobuf::uint8* Event_Update::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Update)
  // required .mesos.TaskStatus status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Update)
  return target;
}

int Event_Update::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TaskStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Update::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Update* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Update*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Update::MergeFrom(const Event_Update& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      mutable_status()->::mesos::TaskStatus::MergeFrom(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Update::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Update::CopyFrom(const Event_Update& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_status()) {
    if (!this->status().IsInitialized()) return false;
  }
  return true;
}

void Event_Update::Swap(Event_Update* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Update::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Update_descriptor_;
  metadata.reflection = Event_Update_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Message::kSlaveIdFieldNumber;
const int Event_Message::kExecutorIdFieldNumber;
const int Event_Message::kDataFieldNumber;
#endif  // !_MSC_VER

Event_Message::Event_Message()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Message)
}

void Event_Message::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

Event_Message::Event_Message(const Event_Message& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Message)
}

void Event_Message::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Message::~Event_Message() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Message)
  SharedDtor();
}

void Event_Message::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete executor_id_;
  }
}

void Event_Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Message_descriptor_;
}

const Event_Message& Event_Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Message* Event_Message::default_instance_ = NULL;

Event_Message* Event_Message::New() const {
  return new Event_Message;
}

void Event_Message::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (tag == 18) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Message)
  return false;
#undef DO_
}

void Event_Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Message)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Message)
}

::google::protobuf::uint8* Event_Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Message)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Message)
  return target;
}

int Event_Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Message::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Message* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Message*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Message::MergeFrom(const Event_Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Message::CopyFrom(const Event_Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Message::Swap(Event_Message* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Message_descriptor_;
  metadata.reflection = Event_Message_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Failure::kSlaveIdFieldNumber;
const int Event_Failure::kExecutorIdFieldNumber;
const int Event_Failure::kStatusFieldNumber;
#endif  // !_MSC_VER

Event_Failure::Event_Failure()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Failure)
}

void Event_Failure::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

Event_Failure::Event_Failure(const Event_Failure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Failure)
}

void Event_Failure::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  executor_id_ = NULL;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Failure::~Event_Failure() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Failure)
  SharedDtor();
}

void Event_Failure::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
    delete executor_id_;
  }
}

void Event_Failure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Failure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Failure_descriptor_;
}

const Event_Failure& Event_Failure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Failure* Event_Failure::default_instance_ = NULL;

Event_Failure* Event_Failure::New() const {
  return new Event_Failure;
}

void Event_Failure::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Failure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Failure)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (tag == 18) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // optional int32 status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Failure)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Failure)
  return false;
#undef DO_
}

void Event_Failure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Failure)
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // optional .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // optional int32 status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Failure)
}

::google::protobuf::uint8* Event_Failure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Failure)
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // optional .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // optional int32 status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Failure)
  return target;
}

int Event_Failure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // optional int32 status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Failure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Failure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Failure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Failure::MergeFrom(const Event_Failure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Failure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Failure::CopyFrom(const Event_Failure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Failure::IsInitialized() const {

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void Event_Failure::Swap(Event_Failure* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Failure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Failure_descriptor_;
  metadata.reflection = Event_Failure_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event_Error::kMessageFieldNumber;
#endif  // !_MSC_VER

Event_Error::Event_Error()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event.Error)
}

void Event_Error::InitAsDefaultInstance() {
}

Event_Error::Event_Error(const Event_Error& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event.Error)
}

void Event_Error::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event_Error::~Event_Error() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event.Error)
  SharedDtor();
}

void Event_Error::SharedDtor() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Event_Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event_Error::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_Error_descriptor_;
}

const Event_Error& Event_Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event_Error* Event_Error::default_instance_ = NULL;

Event_Error* Event_Error::New() const {
  return new Event_Error;
}

void Event_Error::Clear() {
  if (has_message()) {
    if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      message_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event_Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event.Error)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string message = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event.Error)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event.Error)
  return false;
#undef DO_
}

void Event_Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event.Error)
  // required string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event.Error)
}

::google::protobuf::uint8* Event_Error::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event.Error)
  // required string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event.Error)
  return target;
}

int Event_Error::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event_Error::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event_Error* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event_Error*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event_Error::MergeFrom(const Event_Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event_Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event_Error::CopyFrom(const Event_Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event_Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Event_Error::Swap(Event_Error* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event_Error::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_Error_descriptor_;
  metadata.reflection = Event_Error_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Event::kTypeFieldNumber;
const int Event::kSubscribedFieldNumber;
const int Event::kOffersFieldNumber;
const int Event::kInverseOffersFieldNumber;
const int Event::kRescindFieldNumber;
const int Event::kRescindInverseOfferFieldNumber;
const int Event::kUpdateFieldNumber;
const int Event::kMessageFieldNumber;
const int Event::kFailureFieldNumber;
const int Event::kErrorFieldNumber;
#endif  // !_MSC_VER

Event::Event()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Event)
}

void Event::InitAsDefaultInstance() {
  subscribed_ = const_cast< ::mesos::scheduler::Event_Subscribed*>(&::mesos::scheduler::Event_Subscribed::default_instance());
  offers_ = const_cast< ::mesos::scheduler::Event_Offers*>(&::mesos::scheduler::Event_Offers::default_instance());
  inverse_offers_ = const_cast< ::mesos::scheduler::Event_InverseOffers*>(&::mesos::scheduler::Event_InverseOffers::default_instance());
  rescind_ = const_cast< ::mesos::scheduler::Event_Rescind*>(&::mesos::scheduler::Event_Rescind::default_instance());
  rescind_inverse_offer_ = const_cast< ::mesos::scheduler::Event_RescindInverseOffer*>(&::mesos::scheduler::Event_RescindInverseOffer::default_instance());
  update_ = const_cast< ::mesos::scheduler::Event_Update*>(&::mesos::scheduler::Event_Update::default_instance());
  message_ = const_cast< ::mesos::scheduler::Event_Message*>(&::mesos::scheduler::Event_Message::default_instance());
  failure_ = const_cast< ::mesos::scheduler::Event_Failure*>(&::mesos::scheduler::Event_Failure::default_instance());
  error_ = const_cast< ::mesos::scheduler::Event_Error*>(&::mesos::scheduler::Event_Error::default_instance());
}

Event::Event(const Event& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Event)
}

void Event::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  subscribed_ = NULL;
  offers_ = NULL;
  inverse_offers_ = NULL;
  rescind_ = NULL;
  rescind_inverse_offer_ = NULL;
  update_ = NULL;
  message_ = NULL;
  failure_ = NULL;
  error_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Event)
  SharedDtor();
}

void Event::SharedDtor() {
  if (this != default_instance_) {
    delete subscribed_;
    delete offers_;
    delete inverse_offers_;
    delete rescind_;
    delete rescind_inverse_offer_;
    delete update_;
    delete message_;
    delete failure_;
    delete error_;
  }
}

void Event::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_descriptor_;
}

const Event& Event::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Event* Event::default_instance_ = NULL;

Event* Event::New() const {
  return new Event;
}

void Event::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    type_ = 0;
    if (has_subscribed()) {
      if (subscribed_ != NULL) subscribed_->::mesos::scheduler::Event_Subscribed::Clear();
    }
    if (has_offers()) {
      if (offers_ != NULL) offers_->::mesos::scheduler::Event_Offers::Clear();
    }
    if (has_inverse_offers()) {
      if (inverse_offers_ != NULL) inverse_offers_->::mesos::scheduler::Event_InverseOffers::Clear();
    }
    if (has_rescind()) {
      if (rescind_ != NULL) rescind_->::mesos::scheduler::Event_Rescind::Clear();
    }
    if (has_rescind_inverse_offer()) {
      if (rescind_inverse_offer_ != NULL) rescind_inverse_offer_->::mesos::scheduler::Event_RescindInverseOffer::Clear();
    }
    if (has_update()) {
      if (update_ != NULL) update_->::mesos::scheduler::Event_Update::Clear();
    }
    if (has_message()) {
      if (message_ != NULL) message_->::mesos::scheduler::Event_Message::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 768) {
    if (has_failure()) {
      if (failure_ != NULL) failure_->::mesos::scheduler::Event_Failure::Clear();
    }
    if (has_error()) {
      if (error_ != NULL) error_->::mesos::scheduler::Event_Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Event)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.scheduler.Event.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::scheduler::Event_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::scheduler::Event_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_subscribed;
        break;
      }

      // optional .mesos.scheduler.Event.Subscribed subscribed = 2;
      case 2: {
        if (tag == 18) {
         parse_subscribed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_offers;
        break;
      }

      // optional .mesos.scheduler.Event.Offers offers = 3;
      case 3: {
        if (tag == 26) {
         parse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_rescind;
        break;
      }

      // optional .mesos.scheduler.Event.Rescind rescind = 4;
      case 4: {
        if (tag == 34) {
         parse_rescind:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rescind()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_update;
        break;
      }

      // optional .mesos.scheduler.Event.Update update = 5;
      case 5: {
        if (tag == 42) {
         parse_update:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_update()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_message;
        break;
      }

      // optional .mesos.scheduler.Event.Message message = 6;
      case 6: {
        if (tag == 50) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_failure;
        break;
      }

      // optional .mesos.scheduler.Event.Failure failure = 7;
      case 7: {
        if (tag == 58) {
         parse_failure:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_failure()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_error;
        break;
      }

      // optional .mesos.scheduler.Event.Error error = 8;
      case 8: {
        if (tag == 66) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_inverse_offers;
        break;
      }

      // optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
      case 9: {
        if (tag == 74) {
         parse_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inverse_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_rescind_inverse_offer;
        break;
      }

      // optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
      case 10: {
        if (tag == 82) {
         parse_rescind_inverse_offer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rescind_inverse_offer()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Event)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Event)
  return false;
#undef DO_
}

void Event::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Event)
  // optional .mesos.scheduler.Event.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.scheduler.Event.Subscribed subscribed = 2;
  if (has_subscribed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->subscribed(), output);
  }

  // optional .mesos.scheduler.Event.Offers offers = 3;
  if (has_offers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->offers(), output);
  }

  // optional .mesos.scheduler.Event.Rescind rescind = 4;
  if (has_rescind()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->rescind(), output);
  }

  // optional .mesos.scheduler.Event.Update update = 5;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->update(), output);
  }

  // optional .mesos.scheduler.Event.Message message = 6;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->message(), output);
  }

  // optional .mesos.scheduler.Event.Failure failure = 7;
  if (has_failure()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->failure(), output);
  }

  // optional .mesos.scheduler.Event.Error error = 8;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->error(), output);
  }

  // optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
  if (has_inverse_offers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->inverse_offers(), output);
  }

  // optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
  if (has_rescind_inverse_offer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->rescind_inverse_offer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Event)
}

::google::protobuf::uint8* Event::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Event)
  // optional .mesos.scheduler.Event.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.scheduler.Event.Subscribed subscribed = 2;
  if (has_subscribed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->subscribed(), target);
  }

  // optional .mesos.scheduler.Event.Offers offers = 3;
  if (has_offers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->offers(), target);
  }

  // optional .mesos.scheduler.Event.Rescind rescind = 4;
  if (has_rescind()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->rescind(), target);
  }

  // optional .mesos.scheduler.Event.Update update = 5;
  if (has_update()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->update(), target);
  }

  // optional .mesos.scheduler.Event.Message message = 6;
  if (has_message()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->message(), target);
  }

  // optional .mesos.scheduler.Event.Failure failure = 7;
  if (has_failure()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->failure(), target);
  }

  // optional .mesos.scheduler.Event.Error error = 8;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->error(), target);
  }

  // optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
  if (has_inverse_offers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->inverse_offers(), target);
  }

  // optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
  if (has_rescind_inverse_offer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->rescind_inverse_offer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Event)
  return target;
}

int Event::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.scheduler.Event.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.scheduler.Event.Subscribed subscribed = 2;
    if (has_subscribed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->subscribed());
    }

    // optional .mesos.scheduler.Event.Offers offers = 3;
    if (has_offers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offers());
    }

    // optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
    if (has_inverse_offers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inverse_offers());
    }

    // optional .mesos.scheduler.Event.Rescind rescind = 4;
    if (has_rescind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rescind());
    }

    // optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
    if (has_rescind_inverse_offer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rescind_inverse_offer());
    }

    // optional .mesos.scheduler.Event.Update update = 5;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->update());
    }

    // optional .mesos.scheduler.Event.Message message = 6;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.scheduler.Event.Failure failure = 7;
    if (has_failure()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->failure());
    }

    // optional .mesos.scheduler.Event.Error error = 8;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event::MergeFrom(const Event& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_subscribed()) {
      mutable_subscribed()->::mesos::scheduler::Event_Subscribed::MergeFrom(from.subscribed());
    }
    if (from.has_offers()) {
      mutable_offers()->::mesos::scheduler::Event_Offers::MergeFrom(from.offers());
    }
    if (from.has_inverse_offers()) {
      mutable_inverse_offers()->::mesos::scheduler::Event_InverseOffers::MergeFrom(from.inverse_offers());
    }
    if (from.has_rescind()) {
      mutable_rescind()->::mesos::scheduler::Event_Rescind::MergeFrom(from.rescind());
    }
    if (from.has_rescind_inverse_offer()) {
      mutable_rescind_inverse_offer()->::mesos::scheduler::Event_RescindInverseOffer::MergeFrom(from.rescind_inverse_offer());
    }
    if (from.has_update()) {
      mutable_update()->::mesos::scheduler::Event_Update::MergeFrom(from.update());
    }
    if (from.has_message()) {
      mutable_message()->::mesos::scheduler::Event_Message::MergeFrom(from.message());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_failure()) {
      mutable_failure()->::mesos::scheduler::Event_Failure::MergeFrom(from.failure());
    }
    if (from.has_error()) {
      mutable_error()->::mesos::scheduler::Event_Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event::CopyFrom(const Event& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {

  if (has_subscribed()) {
    if (!this->subscribed().IsInitialized()) return false;
  }
  if (has_offers()) {
    if (!this->offers().IsInitialized()) return false;
  }
  if (has_inverse_offers()) {
    if (!this->inverse_offers().IsInitialized()) return false;
  }
  if (has_rescind()) {
    if (!this->rescind().IsInitialized()) return false;
  }
  if (has_rescind_inverse_offer()) {
    if (!this->rescind_inverse_offer().IsInitialized()) return false;
  }
  if (has_update()) {
    if (!this->update().IsInitialized()) return false;
  }
  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  if (has_failure()) {
    if (!this->failure().IsInitialized()) return false;
  }
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

void Event::Swap(Event* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(subscribed_, other->subscribed_);
    std::swap(offers_, other->offers_);
    std::swap(inverse_offers_, other->inverse_offers_);
    std::swap(rescind_, other->rescind_);
    std::swap(rescind_inverse_offer_, other->rescind_inverse_offer_);
    std::swap(update_, other->update_);
    std::swap(message_, other->message_);
    std::swap(failure_, other->failure_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_descriptor_;
  metadata.reflection = Event_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Type_descriptor_;
}
bool Call_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Call_Type Call::UNKNOWN;
const Call_Type Call::SUBSCRIBE;
const Call_Type Call::TEARDOWN;
const Call_Type Call::ACCEPT;
const Call_Type Call::DECLINE;
const Call_Type Call::ACCEPT_INVERSE_OFFERS;
const Call_Type Call::DECLINE_INVERSE_OFFERS;
const Call_Type Call::REVIVE;
const Call_Type Call::KILL;
const Call_Type Call::SHUTDOWN;
const Call_Type Call::ACKNOWLEDGE;
const Call_Type Call::RECONCILE;
const Call_Type Call::MESSAGE;
const Call_Type Call::REQUEST;
const Call_Type Call::SUPPRESS;
const Call_Type Call::Type_MIN;
const Call_Type Call::Type_MAX;
const int Call::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Call_Subscribe::kFrameworkInfoFieldNumber;
const int Call_Subscribe::kForceFieldNumber;
#endif  // !_MSC_VER

Call_Subscribe::Call_Subscribe()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Subscribe)
}

void Call_Subscribe::InitAsDefaultInstance() {
  framework_info_ = const_cast< ::mesos::FrameworkInfo*>(&::mesos::FrameworkInfo::default_instance());
}

Call_Subscribe::Call_Subscribe(const Call_Subscribe& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Subscribe)
}

void Call_Subscribe::SharedCtor() {
  _cached_size_ = 0;
  framework_info_ = NULL;
  force_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Subscribe::~Call_Subscribe() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Subscribe)
  SharedDtor();
}

void Call_Subscribe::SharedDtor() {
  if (this != default_instance_) {
    delete framework_info_;
  }
}

void Call_Subscribe::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Subscribe::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Subscribe_descriptor_;
}

const Call_Subscribe& Call_Subscribe::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Subscribe* Call_Subscribe::default_instance_ = NULL;

Call_Subscribe* Call_Subscribe::New() const {
  return new Call_Subscribe;
}

void Call_Subscribe::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_framework_info()) {
      if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
    }
    force_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Subscribe::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Subscribe)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.FrameworkInfo framework_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_force;
        break;
      }

      // optional bool force = 2;
      case 2: {
        if (tag == 16) {
         parse_force:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &force_)));
          set_has_force();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Subscribe)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Subscribe)
  return false;
#undef DO_
}

void Call_Subscribe::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Subscribe)
  // required .mesos.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_info(), output);
  }

  // optional bool force = 2;
  if (has_force()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->force(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Subscribe)
}

::google::protobuf::uint8* Call_Subscribe::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Subscribe)
  // required .mesos.FrameworkInfo framework_info = 1;
  if (has_framework_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_info(), target);
  }

  // optional bool force = 2;
  if (has_force()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->force(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Subscribe)
  return target;
}

int Call_Subscribe::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.FrameworkInfo framework_info = 1;
    if (has_framework_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_info());
    }

    // optional bool force = 2;
    if (has_force()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Subscribe::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Subscribe* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Subscribe*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Subscribe::MergeFrom(const Call_Subscribe& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_info()) {
      mutable_framework_info()->::mesos::FrameworkInfo::MergeFrom(from.framework_info());
    }
    if (from.has_force()) {
      set_force(from.force());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Subscribe::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Subscribe::CopyFrom(const Call_Subscribe& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Subscribe::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_framework_info()) {
    if (!this->framework_info().IsInitialized()) return false;
  }
  return true;
}

void Call_Subscribe::Swap(Call_Subscribe* other) {
  if (other != this) {
    std::swap(framework_info_, other->framework_info_);
    std::swap(force_, other->force_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Subscribe::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Subscribe_descriptor_;
  metadata.reflection = Call_Subscribe_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Accept::kOfferIdsFieldNumber;
const int Call_Accept::kOperationsFieldNumber;
const int Call_Accept::kFiltersFieldNumber;
#endif  // !_MSC_VER

Call_Accept::Call_Accept()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Accept)
}

void Call_Accept::InitAsDefaultInstance() {
  filters_ = const_cast< ::mesos::Filters*>(&::mesos::Filters::default_instance());
}

Call_Accept::Call_Accept(const Call_Accept& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Accept)
}

void Call_Accept::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Accept::~Call_Accept() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Accept)
  SharedDtor();
}

void Call_Accept::SharedDtor() {
  if (this != default_instance_) {
    delete filters_;
  }
}

void Call_Accept::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Accept::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Accept_descriptor_;
}

const Call_Accept& Call_Accept::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Accept* Call_Accept::default_instance_ = NULL;

Call_Accept* Call_Accept::New() const {
  return new Call_Accept;
}

void Call_Accept::Clear() {
  if (has_filters()) {
    if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  }
  offer_ids_.Clear();
  operations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Accept::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Accept)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.OfferID offer_ids = 1;
      case 1: {
        if (tag == 10) {
         parse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offer_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_offer_ids;
        if (input->ExpectTag(18)) goto parse_operations;
        break;
      }

      // repeated .mesos.Offer.Operation operations = 2;
      case 2: {
        if (tag == 18) {
         parse_operations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_operations()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_operations;
        if (input->ExpectTag(26)) goto parse_filters;
        break;
      }

      // optional .mesos.Filters filters = 3;
      case 3: {
        if (tag == 26) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Accept)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Accept)
  return false;
#undef DO_
}

void Call_Accept::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Accept)
  // repeated .mesos.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_ids(i), output);
  }

  // repeated .mesos.Offer.Operation operations = 2;
  for (int i = 0; i < this->operations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->operations(i), output);
  }

  // optional .mesos.Filters filters = 3;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->filters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Accept)
}

::google::protobuf::uint8* Call_Accept::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Accept)
  // repeated .mesos.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_ids(i), target);
  }

  // repeated .mesos.Offer.Operation operations = 2;
  for (int i = 0; i < this->operations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->operations(i), target);
  }

  // optional .mesos.Filters filters = 3;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->filters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Accept)
  return target;
}

int Call_Accept::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional .mesos.Filters filters = 3;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.OfferID offer_ids = 1;
  total_size += 1 * this->offer_ids_size();
  for (int i = 0; i < this->offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offer_ids(i));
  }

  // repeated .mesos.Offer.Operation operations = 2;
  total_size += 1 * this->operations_size();
  for (int i = 0; i < this->operations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->operations(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Accept::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Accept* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Accept*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Accept::MergeFrom(const Call_Accept& from) {
  GOOGLE_CHECK_NE(&from, this);
  offer_ids_.MergeFrom(from.offer_ids_);
  operations_.MergeFrom(from.operations_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_filters()) {
      mutable_filters()->::mesos::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Accept::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Accept::CopyFrom(const Call_Accept& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Accept::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->offer_ids())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operations())) return false;
  return true;
}

void Call_Accept::Swap(Call_Accept* other) {
  if (other != this) {
    offer_ids_.Swap(&other->offer_ids_);
    operations_.Swap(&other->operations_);
    std::swap(filters_, other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Accept::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Accept_descriptor_;
  metadata.reflection = Call_Accept_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Decline::kOfferIdsFieldNumber;
const int Call_Decline::kFiltersFieldNumber;
#endif  // !_MSC_VER

Call_Decline::Call_Decline()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Decline)
}

void Call_Decline::InitAsDefaultInstance() {
  filters_ = const_cast< ::mesos::Filters*>(&::mesos::Filters::default_instance());
}

Call_Decline::Call_Decline(const Call_Decline& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Decline)
}

void Call_Decline::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Decline::~Call_Decline() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Decline)
  SharedDtor();
}

void Call_Decline::SharedDtor() {
  if (this != default_instance_) {
    delete filters_;
  }
}

void Call_Decline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Decline::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Decline_descriptor_;
}

const Call_Decline& Call_Decline::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Decline* Call_Decline::default_instance_ = NULL;

Call_Decline* Call_Decline::New() const {
  return new Call_Decline;
}

void Call_Decline::Clear() {
  if (has_filters()) {
    if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  }
  offer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Decline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Decline)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.OfferID offer_ids = 1;
      case 1: {
        if (tag == 10) {
         parse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offer_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_offer_ids;
        if (input->ExpectTag(18)) goto parse_filters;
        break;
      }

      // optional .mesos.Filters filters = 2;
      case 2: {
        if (tag == 18) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Decline)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Decline)
  return false;
#undef DO_
}

void Call_Decline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Decline)
  // repeated .mesos.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->offer_ids(i), output);
  }

  // optional .mesos.Filters filters = 2;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->filters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Decline)
}

::google::protobuf::uint8* Call_Decline::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Decline)
  // repeated .mesos.OfferID offer_ids = 1;
  for (int i = 0; i < this->offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->offer_ids(i), target);
  }

  // optional .mesos.Filters filters = 2;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->filters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Decline)
  return target;
}

int Call_Decline::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .mesos.Filters filters = 2;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.OfferID offer_ids = 1;
  total_size += 1 * this->offer_ids_size();
  for (int i = 0; i < this->offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offer_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Decline::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Decline* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Decline*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Decline::MergeFrom(const Call_Decline& from) {
  GOOGLE_CHECK_NE(&from, this);
  offer_ids_.MergeFrom(from.offer_ids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_filters()) {
      mutable_filters()->::mesos::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Decline::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Decline::CopyFrom(const Call_Decline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Decline::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->offer_ids())) return false;
  return true;
}

void Call_Decline::Swap(Call_Decline* other) {
  if (other != this) {
    offer_ids_.Swap(&other->offer_ids_);
    std::swap(filters_, other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Decline::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Decline_descriptor_;
  metadata.reflection = Call_Decline_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_AcceptInverseOffers::kInverseOfferIdsFieldNumber;
const int Call_AcceptInverseOffers::kFiltersFieldNumber;
#endif  // !_MSC_VER

Call_AcceptInverseOffers::Call_AcceptInverseOffers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.AcceptInverseOffers)
}

void Call_AcceptInverseOffers::InitAsDefaultInstance() {
  filters_ = const_cast< ::mesos::Filters*>(&::mesos::Filters::default_instance());
}

Call_AcceptInverseOffers::Call_AcceptInverseOffers(const Call_AcceptInverseOffers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.AcceptInverseOffers)
}

void Call_AcceptInverseOffers::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_AcceptInverseOffers::~Call_AcceptInverseOffers() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.AcceptInverseOffers)
  SharedDtor();
}

void Call_AcceptInverseOffers::SharedDtor() {
  if (this != default_instance_) {
    delete filters_;
  }
}

void Call_AcceptInverseOffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_AcceptInverseOffers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_AcceptInverseOffers_descriptor_;
}

const Call_AcceptInverseOffers& Call_AcceptInverseOffers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_AcceptInverseOffers* Call_AcceptInverseOffers::default_instance_ = NULL;

Call_AcceptInverseOffers* Call_AcceptInverseOffers::New() const {
  return new Call_AcceptInverseOffers;
}

void Call_AcceptInverseOffers::Clear() {
  if (has_filters()) {
    if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  }
  inverse_offer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_AcceptInverseOffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.AcceptInverseOffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.OfferID inverse_offer_ids = 1;
      case 1: {
        if (tag == 10) {
         parse_inverse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inverse_offer_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_inverse_offer_ids;
        if (input->ExpectTag(18)) goto parse_filters;
        break;
      }

      // optional .mesos.Filters filters = 2;
      case 2: {
        if (tag == 18) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.AcceptInverseOffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.AcceptInverseOffers)
  return false;
#undef DO_
}

void Call_AcceptInverseOffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.AcceptInverseOffers)
  // repeated .mesos.OfferID inverse_offer_ids = 1;
  for (int i = 0; i < this->inverse_offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverse_offer_ids(i), output);
  }

  // optional .mesos.Filters filters = 2;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->filters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.AcceptInverseOffers)
}

::google::protobuf::uint8* Call_AcceptInverseOffers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.AcceptInverseOffers)
  // repeated .mesos.OfferID inverse_offer_ids = 1;
  for (int i = 0; i < this->inverse_offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverse_offer_ids(i), target);
  }

  // optional .mesos.Filters filters = 2;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->filters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.AcceptInverseOffers)
  return target;
}

int Call_AcceptInverseOffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .mesos.Filters filters = 2;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.OfferID inverse_offer_ids = 1;
  total_size += 1 * this->inverse_offer_ids_size();
  for (int i = 0; i < this->inverse_offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inverse_offer_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_AcceptInverseOffers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_AcceptInverseOffers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_AcceptInverseOffers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_AcceptInverseOffers::MergeFrom(const Call_AcceptInverseOffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  inverse_offer_ids_.MergeFrom(from.inverse_offer_ids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_filters()) {
      mutable_filters()->::mesos::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_AcceptInverseOffers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_AcceptInverseOffers::CopyFrom(const Call_AcceptInverseOffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_AcceptInverseOffers::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->inverse_offer_ids())) return false;
  return true;
}

void Call_AcceptInverseOffers::Swap(Call_AcceptInverseOffers* other) {
  if (other != this) {
    inverse_offer_ids_.Swap(&other->inverse_offer_ids_);
    std::swap(filters_, other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_AcceptInverseOffers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_AcceptInverseOffers_descriptor_;
  metadata.reflection = Call_AcceptInverseOffers_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_DeclineInverseOffers::kInverseOfferIdsFieldNumber;
const int Call_DeclineInverseOffers::kFiltersFieldNumber;
#endif  // !_MSC_VER

Call_DeclineInverseOffers::Call_DeclineInverseOffers()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.DeclineInverseOffers)
}

void Call_DeclineInverseOffers::InitAsDefaultInstance() {
  filters_ = const_cast< ::mesos::Filters*>(&::mesos::Filters::default_instance());
}

Call_DeclineInverseOffers::Call_DeclineInverseOffers(const Call_DeclineInverseOffers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.DeclineInverseOffers)
}

void Call_DeclineInverseOffers::SharedCtor() {
  _cached_size_ = 0;
  filters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_DeclineInverseOffers::~Call_DeclineInverseOffers() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.DeclineInverseOffers)
  SharedDtor();
}

void Call_DeclineInverseOffers::SharedDtor() {
  if (this != default_instance_) {
    delete filters_;
  }
}

void Call_DeclineInverseOffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_DeclineInverseOffers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_DeclineInverseOffers_descriptor_;
}

const Call_DeclineInverseOffers& Call_DeclineInverseOffers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_DeclineInverseOffers* Call_DeclineInverseOffers::default_instance_ = NULL;

Call_DeclineInverseOffers* Call_DeclineInverseOffers::New() const {
  return new Call_DeclineInverseOffers;
}

void Call_DeclineInverseOffers::Clear() {
  if (has_filters()) {
    if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  }
  inverse_offer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_DeclineInverseOffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.DeclineInverseOffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.OfferID inverse_offer_ids = 1;
      case 1: {
        if (tag == 10) {
         parse_inverse_offer_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inverse_offer_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_inverse_offer_ids;
        if (input->ExpectTag(18)) goto parse_filters;
        break;
      }

      // optional .mesos.Filters filters = 2;
      case 2: {
        if (tag == 18) {
         parse_filters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.DeclineInverseOffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.DeclineInverseOffers)
  return false;
#undef DO_
}

void Call_DeclineInverseOffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.DeclineInverseOffers)
  // repeated .mesos.OfferID inverse_offer_ids = 1;
  for (int i = 0; i < this->inverse_offer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inverse_offer_ids(i), output);
  }

  // optional .mesos.Filters filters = 2;
  if (has_filters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->filters(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.DeclineInverseOffers)
}

::google::protobuf::uint8* Call_DeclineInverseOffers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.DeclineInverseOffers)
  // repeated .mesos.OfferID inverse_offer_ids = 1;
  for (int i = 0; i < this->inverse_offer_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inverse_offer_ids(i), target);
  }

  // optional .mesos.Filters filters = 2;
  if (has_filters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->filters(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.DeclineInverseOffers)
  return target;
}

int Call_DeclineInverseOffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .mesos.Filters filters = 2;
    if (has_filters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filters());
    }

  }
  // repeated .mesos.OfferID inverse_offer_ids = 1;
  total_size += 1 * this->inverse_offer_ids_size();
  for (int i = 0; i < this->inverse_offer_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inverse_offer_ids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_DeclineInverseOffers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_DeclineInverseOffers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_DeclineInverseOffers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_DeclineInverseOffers::MergeFrom(const Call_DeclineInverseOffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  inverse_offer_ids_.MergeFrom(from.inverse_offer_ids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_filters()) {
      mutable_filters()->::mesos::Filters::MergeFrom(from.filters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_DeclineInverseOffers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_DeclineInverseOffers::CopyFrom(const Call_DeclineInverseOffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_DeclineInverseOffers::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->inverse_offer_ids())) return false;
  return true;
}

void Call_DeclineInverseOffers::Swap(Call_DeclineInverseOffers* other) {
  if (other != this) {
    inverse_offer_ids_.Swap(&other->inverse_offer_ids_);
    std::swap(filters_, other->filters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_DeclineInverseOffers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_DeclineInverseOffers_descriptor_;
  metadata.reflection = Call_DeclineInverseOffers_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Revive::kRolesFieldNumber;
#endif  // !_MSC_VER

Call_Revive::Call_Revive()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Revive)
}

void Call_Revive::InitAsDefaultInstance() {
}

Call_Revive::Call_Revive(const Call_Revive& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Revive)
}

void Call_Revive::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Revive::~Call_Revive() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Revive)
  SharedDtor();
}

void Call_Revive::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Call_Revive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Revive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Revive_descriptor_;
}

const Call_Revive& Call_Revive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Revive* Call_Revive::default_instance_ = NULL;

Call_Revive* Call_Revive::New() const {
  return new Call_Revive;
}

void Call_Revive::Clear() {
  roles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Revive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Revive)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string roles = 1;
      case 1: {
        if (tag == 10) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_roles()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->roles(this->roles_size() - 1).data(),
            this->roles(this->roles_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roles");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_roles;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Revive)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Revive)
  return false;
#undef DO_
}

void Call_Revive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Revive)
  // repeated string roles = 1;
  for (int i = 0; i < this->roles_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->roles(i).data(), this->roles(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "roles");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->roles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Revive)
}

::google::protobuf::uint8* Call_Revive::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Revive)
  // repeated string roles = 1;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->roles(i).data(), this->roles(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roles");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->roles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Revive)
  return target;
}

int Call_Revive::ByteSize() const {
  int total_size = 0;

  // repeated string roles = 1;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->roles(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Revive::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Revive* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Revive*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Revive::MergeFrom(const Call_Revive& from) {
  GOOGLE_CHECK_NE(&from, this);
  roles_.MergeFrom(from.roles_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Revive::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Revive::CopyFrom(const Call_Revive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Revive::IsInitialized() const {

  return true;
}

void Call_Revive::Swap(Call_Revive* other) {
  if (other != this) {
    roles_.Swap(&other->roles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Revive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Revive_descriptor_;
  metadata.reflection = Call_Revive_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Kill::kTaskIdFieldNumber;
const int Call_Kill::kSlaveIdFieldNumber;
const int Call_Kill::kKillPolicyFieldNumber;
#endif  // !_MSC_VER

Call_Kill::Call_Kill()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Kill)
}

void Call_Kill::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  kill_policy_ = const_cast< ::mesos::KillPolicy*>(&::mesos::KillPolicy::default_instance());
}

Call_Kill::Call_Kill(const Call_Kill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Kill)
}

void Call_Kill::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = NULL;
  slave_id_ = NULL;
  kill_policy_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Kill::~Call_Kill() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Kill)
  SharedDtor();
}

void Call_Kill::SharedDtor() {
  if (this != default_instance_) {
    delete task_id_;
    delete slave_id_;
    delete kill_policy_;
  }
}

void Call_Kill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Kill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Kill_descriptor_;
}

const Call_Kill& Call_Kill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Kill* Call_Kill::default_instance_ = NULL;

Call_Kill* Call_Kill::New() const {
  return new Call_Kill;
}

void Call_Kill::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_kill_policy()) {
      if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Kill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Kill)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskID task_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 2;
      case 2: {
        if (tag == 18) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_kill_policy;
        break;
      }

      // optional .mesos.KillPolicy kill_policy = 3;
      case 3: {
        if (tag == 26) {
         parse_kill_policy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kill_policy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Kill)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Kill)
  return false;
#undef DO_
}

void Call_Kill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Kill)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_id(), output);
  }

  // optional .mesos.KillPolicy kill_policy = 3;
  if (has_kill_policy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->kill_policy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Kill)
}

::google::protobuf::uint8* Call_Kill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Kill)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_id(), target);
  }

  // optional .mesos.KillPolicy kill_policy = 3;
  if (has_kill_policy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->kill_policy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Kill)
  return target;
}

int Call_Kill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // optional .mesos.SlaveID slave_id = 2;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.KillPolicy kill_policy = 3;
    if (has_kill_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kill_policy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Kill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Kill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Kill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Kill::MergeFrom(const Call_Kill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_kill_policy()) {
      mutable_kill_policy()->::mesos::KillPolicy::MergeFrom(from.kill_policy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Kill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Kill::CopyFrom(const Call_Kill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Kill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_kill_policy()) {
    if (!this->kill_policy().IsInitialized()) return false;
  }
  return true;
}

void Call_Kill::Swap(Call_Kill* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(kill_policy_, other->kill_policy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Kill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Kill_descriptor_;
  metadata.reflection = Call_Kill_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Shutdown::kExecutorIdFieldNumber;
const int Call_Shutdown::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

Call_Shutdown::Call_Shutdown()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Shutdown)
}

void Call_Shutdown::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

Call_Shutdown::Call_Shutdown(const Call_Shutdown& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Shutdown)
}

void Call_Shutdown::SharedCtor() {
  _cached_size_ = 0;
  executor_id_ = NULL;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Shutdown::~Call_Shutdown() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Shutdown)
  SharedDtor();
}

void Call_Shutdown::SharedDtor() {
  if (this != default_instance_) {
    delete executor_id_;
    delete slave_id_;
  }
}

void Call_Shutdown::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Shutdown::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Shutdown_descriptor_;
}

const Call_Shutdown& Call_Shutdown::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Shutdown* Call_Shutdown::default_instance_ = NULL;

Call_Shutdown* Call_Shutdown::New() const {
  return new Call_Shutdown;
}

void Call_Shutdown::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Shutdown::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Shutdown)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 2;
      case 2: {
        if (tag == 18) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Shutdown)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Shutdown)
  return false;
#undef DO_
}

void Call_Shutdown::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Shutdown)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executor_id(), output);
  }

  // required .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Shutdown)
}

::google::protobuf::uint8* Call_Shutdown::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Shutdown)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->executor_id(), target);
  }

  // required .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Shutdown)
  return target;
}

int Call_Shutdown::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.ExecutorID executor_id = 1;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required .mesos.SlaveID slave_id = 2;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Shutdown::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Shutdown* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Shutdown*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Shutdown::MergeFrom(const Call_Shutdown& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Shutdown::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Shutdown::CopyFrom(const Call_Shutdown& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Shutdown::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Shutdown::Swap(Call_Shutdown* other) {
  if (other != this) {
    std::swap(executor_id_, other->executor_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Shutdown::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Shutdown_descriptor_;
  metadata.reflection = Call_Shutdown_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Acknowledge::kSlaveIdFieldNumber;
const int Call_Acknowledge::kTaskIdFieldNumber;
const int Call_Acknowledge::kUuidFieldNumber;
#endif  // !_MSC_VER

Call_Acknowledge::Call_Acknowledge()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Acknowledge)
}

void Call_Acknowledge::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
}

Call_Acknowledge::Call_Acknowledge(const Call_Acknowledge& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Acknowledge)
}

void Call_Acknowledge::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_id_ = NULL;
  task_id_ = NULL;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Acknowledge::~Call_Acknowledge() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Acknowledge)
  SharedDtor();
}

void Call_Acknowledge::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete task_id_;
  }
}

void Call_Acknowledge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Acknowledge::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Acknowledge_descriptor_;
}

const Call_Acknowledge& Call_Acknowledge::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Acknowledge* Call_Acknowledge::default_instance_ = NULL;

Call_Acknowledge* Call_Acknowledge::New() const {
  return new Call_Acknowledge;
}

void Call_Acknowledge::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Acknowledge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Acknowledge)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_uuid;
        break;
      }

      // required bytes uuid = 3;
      case 3: {
        if (tag == 26) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Acknowledge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Acknowledge)
  return false;
#undef DO_
}

void Call_Acknowledge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Acknowledge)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_id(), output);
  }

  // required bytes uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Acknowledge)
}

::google::protobuf::uint8* Call_Acknowledge::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Acknowledge)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_id(), target);
  }

  // required bytes uuid = 3;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Acknowledge)
  return target;
}

int Call_Acknowledge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.TaskID task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // required bytes uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Acknowledge::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Acknowledge* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Acknowledge*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Acknowledge::MergeFrom(const Call_Acknowledge& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Acknowledge::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Acknowledge::CopyFrom(const Call_Acknowledge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Acknowledge::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Acknowledge::Swap(Call_Acknowledge* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Acknowledge::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Acknowledge_descriptor_;
  metadata.reflection = Call_Acknowledge_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Reconcile_Task::kTaskIdFieldNumber;
const int Call_Reconcile_Task::kSlaveIdFieldNumber;
#endif  // !_MSC_VER

Call_Reconcile_Task::Call_Reconcile_Task()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Reconcile.Task)
}

void Call_Reconcile_Task::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

Call_Reconcile_Task::Call_Reconcile_Task(const Call_Reconcile_Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Reconcile.Task)
}

void Call_Reconcile_Task::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = NULL;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Reconcile_Task::~Call_Reconcile_Task() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Reconcile.Task)
  SharedDtor();
}

void Call_Reconcile_Task::SharedDtor() {
  if (this != default_instance_) {
    delete task_id_;
    delete slave_id_;
  }
}

void Call_Reconcile_Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Reconcile_Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Reconcile_Task_descriptor_;
}

const Call_Reconcile_Task& Call_Reconcile_Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Reconcile_Task* Call_Reconcile_Task::default_instance_ = NULL;

Call_Reconcile_Task* Call_Reconcile_Task::New() const {
  return new Call_Reconcile_Task;
}

void Call_Reconcile_Task::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Reconcile_Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Reconcile.Task)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskID task_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 2;
      case 2: {
        if (tag == 18) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Reconcile.Task)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Reconcile.Task)
  return false;
#undef DO_
}

void Call_Reconcile_Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Reconcile.Task)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_id(), output);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Reconcile.Task)
}

::google::protobuf::uint8* Call_Reconcile_Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Reconcile.Task)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->task_id(), target);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Reconcile.Task)
  return target;
}

int Call_Reconcile_Task::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.TaskID task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_id());
    }

    // optional .mesos.SlaveID slave_id = 2;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Reconcile_Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Reconcile_Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Reconcile_Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Reconcile_Task::MergeFrom(const Call_Reconcile_Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Reconcile_Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Reconcile_Task::CopyFrom(const Call_Reconcile_Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Reconcile_Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_task_id()) {
    if (!this->task_id().IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Reconcile_Task::Swap(Call_Reconcile_Task* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Reconcile_Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Reconcile_Task_descriptor_;
  metadata.reflection = Call_Reconcile_Task_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Reconcile::kTasksFieldNumber;
#endif  // !_MSC_VER

Call_Reconcile::Call_Reconcile()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Reconcile)
}

void Call_Reconcile::InitAsDefaultInstance() {
}

Call_Reconcile::Call_Reconcile(const Call_Reconcile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Reconcile)
}

void Call_Reconcile::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Reconcile::~Call_Reconcile() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Reconcile)
  SharedDtor();
}

void Call_Reconcile::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Call_Reconcile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Reconcile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Reconcile_descriptor_;
}

const Call_Reconcile& Call_Reconcile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Reconcile* Call_Reconcile::default_instance_ = NULL;

Call_Reconcile* Call_Reconcile::New() const {
  return new Call_Reconcile;
}

void Call_Reconcile::Clear() {
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Reconcile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Reconcile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
      case 1: {
        if (tag == 10) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_tasks;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Reconcile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Reconcile)
  return false;
#undef DO_
}

void Call_Reconcile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Reconcile)
  // repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Reconcile)
}

::google::protobuf::uint8* Call_Reconcile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Reconcile)
  // repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Reconcile)
  return target;
}

int Call_Reconcile::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Reconcile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Reconcile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Reconcile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Reconcile::MergeFrom(const Call_Reconcile& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Reconcile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Reconcile::CopyFrom(const Call_Reconcile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Reconcile::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void Call_Reconcile::Swap(Call_Reconcile* other) {
  if (other != this) {
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Reconcile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Reconcile_descriptor_;
  metadata.reflection = Call_Reconcile_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Message::kSlaveIdFieldNumber;
const int Call_Message::kExecutorIdFieldNumber;
const int Call_Message::kDataFieldNumber;
#endif  // !_MSC_VER

Call_Message::Call_Message()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Message)
}

void Call_Message::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
}

Call_Message::Call_Message(const Call_Message& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Message)
}

void Call_Message::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  slave_id_ = NULL;
  executor_id_ = NULL;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Message::~Call_Message() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Message)
  SharedDtor();
}

void Call_Message::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete executor_id_;
  }
}

void Call_Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Message_descriptor_;
}

const Call_Message& Call_Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Message* Call_Message::default_instance_ = NULL;

Call_Message* Call_Message::New() const {
  return new Call_Message;
}

void Call_Message::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_executor_id;
        break;
      }

      // required .mesos.ExecutorID executor_id = 2;
      case 2: {
        if (tag == 18) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Message)
  return false;
#undef DO_
}

void Call_Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Message)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->executor_id(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Message)
}

::google::protobuf::uint8* Call_Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Message)
  // required .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // required .mesos.ExecutorID executor_id = 2;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->executor_id(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Message)
  return target;
}

int Call_Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // required .mesos.ExecutorID executor_id = 2;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->executor_id());
    }

    // required bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Message::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Message* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Message*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Message::MergeFrom(const Call_Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Message::CopyFrom(const Call_Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id().IsInitialized()) return false;
  }
  return true;
}

void Call_Message::Swap(Call_Message* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(executor_id_, other->executor_id_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Message_descriptor_;
  metadata.reflection = Call_Message_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Request::kRequestsFieldNumber;
#endif  // !_MSC_VER

Call_Request::Call_Request()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Request)
}

void Call_Request::InitAsDefaultInstance() {
}

Call_Request::Call_Request(const Call_Request& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Request)
}

void Call_Request::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Request::~Call_Request() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Request)
  SharedDtor();
}

void Call_Request::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Call_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Request_descriptor_;
}

const Call_Request& Call_Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Request* Call_Request::default_instance_ = NULL;

Call_Request* Call_Request::New() const {
  return new Call_Request;
}

void Call_Request::Clear() {
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Request requests = 1;
      case 1: {
        if (tag == 10) {
         parse_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_requests()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_requests;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Request)
  return false;
#undef DO_
}

void Call_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Request)
  // repeated .mesos.Request requests = 1;
  for (int i = 0; i < this->requests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->requests(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Request)
}

::google::protobuf::uint8* Call_Request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Request)
  // repeated .mesos.Request requests = 1;
  for (int i = 0; i < this->requests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->requests(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Request)
  return target;
}

int Call_Request::ByteSize() const {
  int total_size = 0;

  // repeated .mesos.Request requests = 1;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Request::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Request* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Request*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Request::MergeFrom(const Call_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  requests_.MergeFrom(from.requests_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Request::CopyFrom(const Call_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Request::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->requests())) return false;
  return true;
}

void Call_Request::Swap(Call_Request* other) {
  if (other != this) {
    requests_.Swap(&other->requests_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Request_descriptor_;
  metadata.reflection = Call_Request_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call_Suppress::kRolesFieldNumber;
#endif  // !_MSC_VER

Call_Suppress::Call_Suppress()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call.Suppress)
}

void Call_Suppress::InitAsDefaultInstance() {
}

Call_Suppress::Call_Suppress(const Call_Suppress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call.Suppress)
}

void Call_Suppress::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call_Suppress::~Call_Suppress() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call.Suppress)
  SharedDtor();
}

void Call_Suppress::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Call_Suppress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call_Suppress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_Suppress_descriptor_;
}

const Call_Suppress& Call_Suppress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call_Suppress* Call_Suppress::default_instance_ = NULL;

Call_Suppress* Call_Suppress::New() const {
  return new Call_Suppress;
}

void Call_Suppress::Clear() {
  roles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call_Suppress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call.Suppress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string roles = 1;
      case 1: {
        if (tag == 10) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_roles()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->roles(this->roles_size() - 1).data(),
            this->roles(this->roles_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "roles");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_roles;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call.Suppress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call.Suppress)
  return false;
#undef DO_
}

void Call_Suppress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call.Suppress)
  // repeated string roles = 1;
  for (int i = 0; i < this->roles_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->roles(i).data(), this->roles(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "roles");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->roles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call.Suppress)
}

::google::protobuf::uint8* Call_Suppress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call.Suppress)
  // repeated string roles = 1;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->roles(i).data(), this->roles(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "roles");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->roles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call.Suppress)
  return target;
}

int Call_Suppress::ByteSize() const {
  int total_size = 0;

  // repeated string roles = 1;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->roles(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call_Suppress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call_Suppress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call_Suppress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call_Suppress::MergeFrom(const Call_Suppress& from) {
  GOOGLE_CHECK_NE(&from, this);
  roles_.MergeFrom(from.roles_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call_Suppress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call_Suppress::CopyFrom(const Call_Suppress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call_Suppress::IsInitialized() const {

  return true;
}

void Call_Suppress::Swap(Call_Suppress* other) {
  if (other != this) {
    roles_.Swap(&other->roles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call_Suppress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_Suppress_descriptor_;
  metadata.reflection = Call_Suppress_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Call::kFrameworkIdFieldNumber;
const int Call::kTypeFieldNumber;
const int Call::kSubscribeFieldNumber;
const int Call::kAcceptFieldNumber;
const int Call::kDeclineFieldNumber;
const int Call::kAcceptInverseOffersFieldNumber;
const int Call::kDeclineInverseOffersFieldNumber;
const int Call::kReviveFieldNumber;
const int Call::kKillFieldNumber;
const int Call::kShutdownFieldNumber;
const int Call::kAcknowledgeFieldNumber;
const int Call::kReconcileFieldNumber;
const int Call::kMessageFieldNumber;
const int Call::kRequestFieldNumber;
const int Call::kSuppressFieldNumber;
#endif  // !_MSC_VER

Call::Call()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.scheduler.Call)
}

void Call::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  subscribe_ = const_cast< ::mesos::scheduler::Call_Subscribe*>(&::mesos::scheduler::Call_Subscribe::default_instance());
  accept_ = const_cast< ::mesos::scheduler::Call_Accept*>(&::mesos::scheduler::Call_Accept::default_instance());
  decline_ = const_cast< ::mesos::scheduler::Call_Decline*>(&::mesos::scheduler::Call_Decline::default_instance());
  accept_inverse_offers_ = const_cast< ::mesos::scheduler::Call_AcceptInverseOffers*>(&::mesos::scheduler::Call_AcceptInverseOffers::default_instance());
  decline_inverse_offers_ = const_cast< ::mesos::scheduler::Call_DeclineInverseOffers*>(&::mesos::scheduler::Call_DeclineInverseOffers::default_instance());
  revive_ = const_cast< ::mesos::scheduler::Call_Revive*>(&::mesos::scheduler::Call_Revive::default_instance());
  kill_ = const_cast< ::mesos::scheduler::Call_Kill*>(&::mesos::scheduler::Call_Kill::default_instance());
  shutdown_ = const_cast< ::mesos::scheduler::Call_Shutdown*>(&::mesos::scheduler::Call_Shutdown::default_instance());
  acknowledge_ = const_cast< ::mesos::scheduler::Call_Acknowledge*>(&::mesos::scheduler::Call_Acknowledge::default_instance());
  reconcile_ = const_cast< ::mesos::scheduler::Call_Reconcile*>(&::mesos::scheduler::Call_Reconcile::default_instance());
  message_ = const_cast< ::mesos::scheduler::Call_Message*>(&::mesos::scheduler::Call_Message::default_instance());
  request_ = const_cast< ::mesos::scheduler::Call_Request*>(&::mesos::scheduler::Call_Request::default_instance());
  suppress_ = const_cast< ::mesos::scheduler::Call_Suppress*>(&::mesos::scheduler::Call_Suppress::default_instance());
}

Call::Call(const Call& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.scheduler.Call)
}

void Call::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  type_ = 0;
  subscribe_ = NULL;
  accept_ = NULL;
  decline_ = NULL;
  accept_inverse_offers_ = NULL;
  decline_inverse_offers_ = NULL;
  revive_ = NULL;
  kill_ = NULL;
  shutdown_ = NULL;
  acknowledge_ = NULL;
  reconcile_ = NULL;
  message_ = NULL;
  request_ = NULL;
  suppress_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Call::~Call() {
  // @@protoc_insertion_point(destructor:mesos.scheduler.Call)
  SharedDtor();
}

void Call::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete subscribe_;
    delete accept_;
    delete decline_;
    delete accept_inverse_offers_;
    delete decline_inverse_offers_;
    delete revive_;
    delete kill_;
    delete shutdown_;
    delete acknowledge_;
    delete reconcile_;
    delete message_;
    delete request_;
    delete suppress_;
  }
}

void Call::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Call::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Call_descriptor_;
}

const Call& Call::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_scheduler_2eproto();
  return *default_instance_;
}

Call* Call::default_instance_ = NULL;

Call* Call::New() const {
  return new Call;
}

void Call::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    type_ = 0;
    if (has_subscribe()) {
      if (subscribe_ != NULL) subscribe_->::mesos::scheduler::Call_Subscribe::Clear();
    }
    if (has_accept()) {
      if (accept_ != NULL) accept_->::mesos::scheduler::Call_Accept::Clear();
    }
    if (has_decline()) {
      if (decline_ != NULL) decline_->::mesos::scheduler::Call_Decline::Clear();
    }
    if (has_accept_inverse_offers()) {
      if (accept_inverse_offers_ != NULL) accept_inverse_offers_->::mesos::scheduler::Call_AcceptInverseOffers::Clear();
    }
    if (has_decline_inverse_offers()) {
      if (decline_inverse_offers_ != NULL) decline_inverse_offers_->::mesos::scheduler::Call_DeclineInverseOffers::Clear();
    }
    if (has_revive()) {
      if (revive_ != NULL) revive_->::mesos::scheduler::Call_Revive::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 32512) {
    if (has_kill()) {
      if (kill_ != NULL) kill_->::mesos::scheduler::Call_Kill::Clear();
    }
    if (has_shutdown()) {
      if (shutdown_ != NULL) shutdown_->::mesos::scheduler::Call_Shutdown::Clear();
    }
    if (has_acknowledge()) {
      if (acknowledge_ != NULL) acknowledge_->::mesos::scheduler::Call_Acknowledge::Clear();
    }
    if (has_reconcile()) {
      if (reconcile_ != NULL) reconcile_->::mesos::scheduler::Call_Reconcile::Clear();
    }
    if (has_message()) {
      if (message_ != NULL) message_->::mesos::scheduler::Call_Message::Clear();
    }
    if (has_request()) {
      if (request_ != NULL) request_->::mesos::scheduler::Call_Request::Clear();
    }
    if (has_suppress()) {
      if (suppress_ != NULL) suppress_->::mesos::scheduler::Call_Suppress::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Call::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.scheduler.Call)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .mesos.scheduler.Call.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::scheduler::Call_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::scheduler::Call_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_subscribe;
        break;
      }

      // optional .mesos.scheduler.Call.Subscribe subscribe = 3;
      case 3: {
        if (tag == 26) {
         parse_subscribe:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_accept;
        break;
      }

      // optional .mesos.scheduler.Call.Accept accept = 4;
      case 4: {
        if (tag == 34) {
         parse_accept:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accept()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_decline;
        break;
      }

      // optional .mesos.scheduler.Call.Decline decline = 5;
      case 5: {
        if (tag == 42) {
         parse_decline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decline()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_kill;
        break;
      }

      // optional .mesos.scheduler.Call.Kill kill = 6;
      case 6: {
        if (tag == 50) {
         parse_kill:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kill()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_shutdown;
        break;
      }

      // optional .mesos.scheduler.Call.Shutdown shutdown = 7;
      case 7: {
        if (tag == 58) {
         parse_shutdown:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shutdown()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_acknowledge;
        break;
      }

      // optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
      case 8: {
        if (tag == 66) {
         parse_acknowledge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_acknowledge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_reconcile;
        break;
      }

      // optional .mesos.scheduler.Call.Reconcile reconcile = 9;
      case 9: {
        if (tag == 74) {
         parse_reconcile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reconcile()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_message;
        break;
      }

      // optional .mesos.scheduler.Call.Message message = 10;
      case 10: {
        if (tag == 82) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_request;
        break;
      }

      // optional .mesos.scheduler.Call.Request request = 11;
      case 11: {
        if (tag == 90) {
         parse_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_accept_inverse_offers;
        break;
      }

      // optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
      case 13: {
        if (tag == 106) {
         parse_accept_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accept_inverse_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_decline_inverse_offers;
        break;
      }

      // optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
      case 14: {
        if (tag == 114) {
         parse_decline_inverse_offers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decline_inverse_offers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_revive;
        break;
      }

      // optional .mesos.scheduler.Call.Revive revive = 15;
      case 15: {
        if (tag == 122) {
         parse_revive:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_revive()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_suppress;
        break;
      }

      // optional .mesos.scheduler.Call.Suppress suppress = 16;
      case 16: {
        if (tag == 130) {
         parse_suppress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_suppress()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.scheduler.Call)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.scheduler.Call)
  return false;
#undef DO_
}

void Call::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.scheduler.Call)
  // optional .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // optional .mesos.scheduler.Call.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mesos.scheduler.Call.Subscribe subscribe = 3;
  if (has_subscribe()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->subscribe(), output);
  }

  // optional .mesos.scheduler.Call.Accept accept = 4;
  if (has_accept()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->accept(), output);
  }

  // optional .mesos.scheduler.Call.Decline decline = 5;
  if (has_decline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->decline(), output);
  }

  // optional .mesos.scheduler.Call.Kill kill = 6;
  if (has_kill()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->kill(), output);
  }

  // optional .mesos.scheduler.Call.Shutdown shutdown = 7;
  if (has_shutdown()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->shutdown(), output);
  }

  // optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
  if (has_acknowledge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->acknowledge(), output);
  }

  // optional .mesos.scheduler.Call.Reconcile reconcile = 9;
  if (has_reconcile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->reconcile(), output);
  }

  // optional .mesos.scheduler.Call.Message message = 10;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->message(), output);
  }

  // optional .mesos.scheduler.Call.Request request = 11;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->request(), output);
  }

  // optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
  if (has_accept_inverse_offers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->accept_inverse_offers(), output);
  }

  // optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
  if (has_decline_inverse_offers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->decline_inverse_offers(), output);
  }

  // optional .mesos.scheduler.Call.Revive revive = 15;
  if (has_revive()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->revive(), output);
  }

  // optional .mesos.scheduler.Call.Suppress suppress = 16;
  if (has_suppress()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->suppress(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.scheduler.Call)
}

::google::protobuf::uint8* Call::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.scheduler.Call)
  // optional .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // optional .mesos.scheduler.Call.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .mesos.scheduler.Call.Subscribe subscribe = 3;
  if (has_subscribe()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->subscribe(), target);
  }

  // optional .mesos.scheduler.Call.Accept accept = 4;
  if (has_accept()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->accept(), target);
  }

  // optional .mesos.scheduler.Call.Decline decline = 5;
  if (has_decline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->decline(), target);
  }

  // optional .mesos.scheduler.Call.Kill kill = 6;
  if (has_kill()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->kill(), target);
  }

  // optional .mesos.scheduler.Call.Shutdown shutdown = 7;
  if (has_shutdown()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->shutdown(), target);
  }

  // optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
  if (has_acknowledge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->acknowledge(), target);
  }

  // optional .mesos.scheduler.Call.Reconcile reconcile = 9;
  if (has_reconcile()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->reconcile(), target);
  }

  // optional .mesos.scheduler.Call.Message message = 10;
  if (has_message()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->message(), target);
  }

  // optional .mesos.scheduler.Call.Request request = 11;
  if (has_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->request(), target);
  }

  // optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
  if (has_accept_inverse_offers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->accept_inverse_offers(), target);
  }

  // optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
  if (has_decline_inverse_offers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->decline_inverse_offers(), target);
  }

  // optional .mesos.scheduler.Call.Revive revive = 15;
  if (has_revive()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->revive(), target);
  }

  // optional .mesos.scheduler.Call.Suppress suppress = 16;
  if (has_suppress()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, this->suppress(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.scheduler.Call)
  return target;
}

int Call::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // optional .mesos.scheduler.Call.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.scheduler.Call.Subscribe subscribe = 3;
    if (has_subscribe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->subscribe());
    }

    // optional .mesos.scheduler.Call.Accept accept = 4;
    if (has_accept()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accept());
    }

    // optional .mesos.scheduler.Call.Decline decline = 5;
    if (has_decline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decline());
    }

    // optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
    if (has_accept_inverse_offers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accept_inverse_offers());
    }

    // optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
    if (has_decline_inverse_offers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decline_inverse_offers());
    }

    // optional .mesos.scheduler.Call.Revive revive = 15;
    if (has_revive()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->revive());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.scheduler.Call.Kill kill = 6;
    if (has_kill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kill());
    }

    // optional .mesos.scheduler.Call.Shutdown shutdown = 7;
    if (has_shutdown()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shutdown());
    }

    // optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
    if (has_acknowledge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->acknowledge());
    }

    // optional .mesos.scheduler.Call.Reconcile reconcile = 9;
    if (has_reconcile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->reconcile());
    }

    // optional .mesos.scheduler.Call.Message message = 10;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

    // optional .mesos.scheduler.Call.Request request = 11;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request());
    }

    // optional .mesos.scheduler.Call.Suppress suppress = 16;
    if (has_suppress()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->suppress());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Call::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Call* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Call*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Call::MergeFrom(const Call& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_subscribe()) {
      mutable_subscribe()->::mesos::scheduler::Call_Subscribe::MergeFrom(from.subscribe());
    }
    if (from.has_accept()) {
      mutable_accept()->::mesos::scheduler::Call_Accept::MergeFrom(from.accept());
    }
    if (from.has_decline()) {
      mutable_decline()->::mesos::scheduler::Call_Decline::MergeFrom(from.decline());
    }
    if (from.has_accept_inverse_offers()) {
      mutable_accept_inverse_offers()->::mesos::scheduler::Call_AcceptInverseOffers::MergeFrom(from.accept_inverse_offers());
    }
    if (from.has_decline_inverse_offers()) {
      mutable_decline_inverse_offers()->::mesos::scheduler::Call_DeclineInverseOffers::MergeFrom(from.decline_inverse_offers());
    }
    if (from.has_revive()) {
      mutable_revive()->::mesos::scheduler::Call_Revive::MergeFrom(from.revive());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_kill()) {
      mutable_kill()->::mesos::scheduler::Call_Kill::MergeFrom(from.kill());
    }
    if (from.has_shutdown()) {
      mutable_shutdown()->::mesos::scheduler::Call_Shutdown::MergeFrom(from.shutdown());
    }
    if (from.has_acknowledge()) {
      mutable_acknowledge()->::mesos::scheduler::Call_Acknowledge::MergeFrom(from.acknowledge());
    }
    if (from.has_reconcile()) {
      mutable_reconcile()->::mesos::scheduler::Call_Reconcile::MergeFrom(from.reconcile());
    }
    if (from.has_message()) {
      mutable_message()->::mesos::scheduler::Call_Message::MergeFrom(from.message());
    }
    if (from.has_request()) {
      mutable_request()->::mesos::scheduler::Call_Request::MergeFrom(from.request());
    }
    if (from.has_suppress()) {
      mutable_suppress()->::mesos::scheduler::Call_Suppress::MergeFrom(from.suppress());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Call::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Call::CopyFrom(const Call& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Call::IsInitialized() const {

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_subscribe()) {
    if (!this->subscribe().IsInitialized()) return false;
  }
  if (has_accept()) {
    if (!this->accept().IsInitialized()) return false;
  }
  if (has_decline()) {
    if (!this->decline().IsInitialized()) return false;
  }
  if (has_accept_inverse_offers()) {
    if (!this->accept_inverse_offers().IsInitialized()) return false;
  }
  if (has_decline_inverse_offers()) {
    if (!this->decline_inverse_offers().IsInitialized()) return false;
  }
  if (has_kill()) {
    if (!this->kill().IsInitialized()) return false;
  }
  if (has_shutdown()) {
    if (!this->shutdown().IsInitialized()) return false;
  }
  if (has_acknowledge()) {
    if (!this->acknowledge().IsInitialized()) return false;
  }
  if (has_reconcile()) {
    if (!this->reconcile().IsInitialized()) return false;
  }
  if (has_message()) {
    if (!this->message().IsInitialized()) return false;
  }
  if (has_request()) {
    if (!this->request().IsInitialized()) return false;
  }
  return true;
}

void Call::Swap(Call* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(type_, other->type_);
    std::swap(subscribe_, other->subscribe_);
    std::swap(accept_, other->accept_);
    std::swap(decline_, other->decline_);
    std::swap(accept_inverse_offers_, other->accept_inverse_offers_);
    std::swap(decline_inverse_offers_, other->decline_inverse_offers_);
    std::swap(revive_, other->revive_);
    std::swap(kill_, other->kill_);
    std::swap(shutdown_, other->shutdown_);
    std::swap(acknowledge_, other->acknowledge_);
    std::swap(reconcile_, other->reconcile_);
    std::swap(message_, other->message_);
    std::swap(request_, other->request_);
    std::swap(suppress_, other->suppress_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Call::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Call_descriptor_;
  metadata.reflection = Call_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace scheduler
}  // namespace mesos

// @@protoc_insertion_point(global_scope)
