// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scheduler.proto

#ifndef PROTOBUF_scheduler_2eproto__INCLUDED
#define PROTOBUF_scheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace mesos {
namespace scheduler {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_scheduler_2eproto();
void protobuf_AssignDesc_scheduler_2eproto();
void protobuf_ShutdownFile_scheduler_2eproto();

class Event;
class Event_Subscribed;
class Event_Offers;
class Event_InverseOffers;
class Event_Rescind;
class Event_RescindInverseOffer;
class Event_Update;
class Event_Message;
class Event_Failure;
class Event_Error;
class Call;
class Call_Subscribe;
class Call_Accept;
class Call_Decline;
class Call_AcceptInverseOffers;
class Call_DeclineInverseOffers;
class Call_Revive;
class Call_Kill;
class Call_Shutdown;
class Call_Acknowledge;
class Call_Reconcile;
class Call_Reconcile_Task;
class Call_Message;
class Call_Request;
class Call_Suppress;

enum Event_Type {
  Event_Type_UNKNOWN = 0,
  Event_Type_SUBSCRIBED = 1,
  Event_Type_OFFERS = 2,
  Event_Type_INVERSE_OFFERS = 9,
  Event_Type_RESCIND = 3,
  Event_Type_RESCIND_INVERSE_OFFER = 10,
  Event_Type_UPDATE = 4,
  Event_Type_MESSAGE = 5,
  Event_Type_FAILURE = 6,
  Event_Type_ERROR = 7,
  Event_Type_HEARTBEAT = 8
};
bool Event_Type_IsValid(int value);
const Event_Type Event_Type_Type_MIN = Event_Type_UNKNOWN;
const Event_Type Event_Type_Type_MAX = Event_Type_RESCIND_INVERSE_OFFER;
const int Event_Type_Type_ARRAYSIZE = Event_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_Type_descriptor();
inline const ::std::string& Event_Type_Name(Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_Type_descriptor(), value);
}
inline bool Event_Type_Parse(
    const ::std::string& name, Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_Type>(
    Event_Type_descriptor(), name, value);
}
enum Call_Type {
  Call_Type_UNKNOWN = 0,
  Call_Type_SUBSCRIBE = 1,
  Call_Type_TEARDOWN = 2,
  Call_Type_ACCEPT = 3,
  Call_Type_DECLINE = 4,
  Call_Type_ACCEPT_INVERSE_OFFERS = 13,
  Call_Type_DECLINE_INVERSE_OFFERS = 14,
  Call_Type_REVIVE = 5,
  Call_Type_KILL = 6,
  Call_Type_SHUTDOWN = 7,
  Call_Type_ACKNOWLEDGE = 8,
  Call_Type_RECONCILE = 9,
  Call_Type_MESSAGE = 10,
  Call_Type_REQUEST = 11,
  Call_Type_SUPPRESS = 12
};
bool Call_Type_IsValid(int value);
const Call_Type Call_Type_Type_MIN = Call_Type_UNKNOWN;
const Call_Type Call_Type_Type_MAX = Call_Type_DECLINE_INVERSE_OFFERS;
const int Call_Type_Type_ARRAYSIZE = Call_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Call_Type_descriptor();
inline const ::std::string& Call_Type_Name(Call_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Call_Type_descriptor(), value);
}
inline bool Call_Type_Parse(
    const ::std::string& name, Call_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Call_Type>(
    Call_Type_descriptor(), name, value);
}
// ===================================================================

class Event_Subscribed : public ::google::protobuf::Message {
 public:
  Event_Subscribed();
  virtual ~Event_Subscribed();

  Event_Subscribed(const Event_Subscribed& from);

  inline Event_Subscribed& operator=(const Event_Subscribed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Subscribed& default_instance();

  void Swap(Event_Subscribed* other);

  // implements Message ----------------------------------------------

  Event_Subscribed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Subscribed& from);
  void MergeFrom(const Event_Subscribed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional double heartbeat_interval_seconds = 2;
  inline bool has_heartbeat_interval_seconds() const;
  inline void clear_heartbeat_interval_seconds();
  static const int kHeartbeatIntervalSecondsFieldNumber = 2;
  inline double heartbeat_interval_seconds() const;
  inline void set_heartbeat_interval_seconds(double value);

  // optional .mesos.MasterInfo master_info = 3;
  inline bool has_master_info() const;
  inline void clear_master_info();
  static const int kMasterInfoFieldNumber = 3;
  inline const ::mesos::MasterInfo& master_info() const;
  inline ::mesos::MasterInfo* mutable_master_info();
  inline ::mesos::MasterInfo* release_master_info();
  inline void set_allocated_master_info(::mesos::MasterInfo* master_info);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Subscribed)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_heartbeat_interval_seconds();
  inline void clear_has_heartbeat_interval_seconds();
  inline void set_has_master_info();
  inline void clear_has_master_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  double heartbeat_interval_seconds_;
  ::mesos::MasterInfo* master_info_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Subscribed* default_instance_;
};
// -------------------------------------------------------------------

class Event_Offers : public ::google::protobuf::Message {
 public:
  Event_Offers();
  virtual ~Event_Offers();

  Event_Offers(const Event_Offers& from);

  inline Event_Offers& operator=(const Event_Offers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Offers& default_instance();

  void Swap(Event_Offers* other);

  // implements Message ----------------------------------------------

  Event_Offers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Offers& from);
  void MergeFrom(const Event_Offers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Offer offers = 1;
  inline int offers_size() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 1;
  inline const ::mesos::Offer& offers(int index) const;
  inline ::mesos::Offer* mutable_offers(int index);
  inline ::mesos::Offer* add_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
      offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
      mutable_offers();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Offers)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer > offers_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Offers* default_instance_;
};
// -------------------------------------------------------------------

class Event_InverseOffers : public ::google::protobuf::Message {
 public:
  Event_InverseOffers();
  virtual ~Event_InverseOffers();

  Event_InverseOffers(const Event_InverseOffers& from);

  inline Event_InverseOffers& operator=(const Event_InverseOffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_InverseOffers& default_instance();

  void Swap(Event_InverseOffers* other);

  // implements Message ----------------------------------------------

  Event_InverseOffers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_InverseOffers& from);
  void MergeFrom(const Event_InverseOffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.InverseOffer inverse_offers = 1;
  inline int inverse_offers_size() const;
  inline void clear_inverse_offers();
  static const int kInverseOffersFieldNumber = 1;
  inline const ::mesos::InverseOffer& inverse_offers(int index) const;
  inline ::mesos::InverseOffer* mutable_inverse_offers(int index);
  inline ::mesos::InverseOffer* add_inverse_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
      inverse_offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
      mutable_inverse_offers();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.InverseOffers)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer > inverse_offers_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_InverseOffers* default_instance_;
};
// -------------------------------------------------------------------

class Event_Rescind : public ::google::protobuf::Message {
 public:
  Event_Rescind();
  virtual ~Event_Rescind();

  Event_Rescind(const Event_Rescind& from);

  inline Event_Rescind& operator=(const Event_Rescind& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Rescind& default_instance();

  void Swap(Event_Rescind* other);

  // implements Message ----------------------------------------------

  Event_Rescind* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Rescind& from);
  void MergeFrom(const Event_Rescind& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID offer_id = 1;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 1;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  inline ::mesos::OfferID* release_offer_id();
  inline void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Rescind)
 private:
  inline void set_has_offer_id();
  inline void clear_has_offer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::OfferID* offer_id_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Rescind* default_instance_;
};
// -------------------------------------------------------------------

class Event_RescindInverseOffer : public ::google::protobuf::Message {
 public:
  Event_RescindInverseOffer();
  virtual ~Event_RescindInverseOffer();

  Event_RescindInverseOffer(const Event_RescindInverseOffer& from);

  inline Event_RescindInverseOffer& operator=(const Event_RescindInverseOffer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_RescindInverseOffer& default_instance();

  void Swap(Event_RescindInverseOffer* other);

  // implements Message ----------------------------------------------

  Event_RescindInverseOffer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_RescindInverseOffer& from);
  void MergeFrom(const Event_RescindInverseOffer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID inverse_offer_id = 1;
  inline bool has_inverse_offer_id() const;
  inline void clear_inverse_offer_id();
  static const int kInverseOfferIdFieldNumber = 1;
  inline const ::mesos::OfferID& inverse_offer_id() const;
  inline ::mesos::OfferID* mutable_inverse_offer_id();
  inline ::mesos::OfferID* release_inverse_offer_id();
  inline void set_allocated_inverse_offer_id(::mesos::OfferID* inverse_offer_id);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.RescindInverseOffer)
 private:
  inline void set_has_inverse_offer_id();
  inline void clear_has_inverse_offer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::OfferID* inverse_offer_id_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_RescindInverseOffer* default_instance_;
};
// -------------------------------------------------------------------

class Event_Update : public ::google::protobuf::Message {
 public:
  Event_Update();
  virtual ~Event_Update();

  Event_Update(const Event_Update& from);

  inline Event_Update& operator=(const Event_Update& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Update& default_instance();

  void Swap(Event_Update* other);

  // implements Message ----------------------------------------------

  Event_Update* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Update& from);
  void MergeFrom(const Event_Update& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::mesos::TaskStatus& status() const;
  inline ::mesos::TaskStatus* mutable_status();
  inline ::mesos::TaskStatus* release_status();
  inline void set_allocated_status(::mesos::TaskStatus* status);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Update)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::TaskStatus* status_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Update* default_instance_;
};
// -------------------------------------------------------------------

class Event_Message : public ::google::protobuf::Message {
 public:
  Event_Message();
  virtual ~Event_Message();

  Event_Message(const Event_Message& from);

  inline Event_Message& operator=(const Event_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Message& default_instance();

  void Swap(Event_Message* other);

  // implements Message ----------------------------------------------

  Event_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Message& from);
  void MergeFrom(const Event_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Message)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Message* default_instance_;
};
// -------------------------------------------------------------------

class Event_Failure : public ::google::protobuf::Message {
 public:
  Event_Failure();
  virtual ~Event_Failure();

  Event_Failure(const Event_Failure& from);

  inline Event_Failure& operator=(const Event_Failure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Failure& default_instance();

  void Swap(Event_Failure* other);

  // implements Message ----------------------------------------------

  Event_Failure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Failure& from);
  void MergeFrom(const Event_Failure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Failure)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Failure* default_instance_;
};
// -------------------------------------------------------------------

class Event_Error : public ::google::protobuf::Message {
 public:
  Event_Error();
  virtual ~Event_Error();

  Event_Error(const Event_Error& from);

  inline Event_Error& operator=(const Event_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event_Error& default_instance();

  void Swap(Event_Error* other);

  // implements Message ----------------------------------------------

  Event_Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event_Error& from);
  void MergeFrom(const Event_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event.Error)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event_Error* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Event_Subscribed Subscribed;
  typedef Event_Offers Offers;
  typedef Event_InverseOffers InverseOffers;
  typedef Event_Rescind Rescind;
  typedef Event_RescindInverseOffer RescindInverseOffer;
  typedef Event_Update Update;
  typedef Event_Message Message;
  typedef Event_Failure Failure;
  typedef Event_Error Error;

  typedef Event_Type Type;
  static const Type UNKNOWN = Event_Type_UNKNOWN;
  static const Type SUBSCRIBED = Event_Type_SUBSCRIBED;
  static const Type OFFERS = Event_Type_OFFERS;
  static const Type INVERSE_OFFERS = Event_Type_INVERSE_OFFERS;
  static const Type RESCIND = Event_Type_RESCIND;
  static const Type RESCIND_INVERSE_OFFER = Event_Type_RESCIND_INVERSE_OFFER;
  static const Type UPDATE = Event_Type_UPDATE;
  static const Type MESSAGE = Event_Type_MESSAGE;
  static const Type FAILURE = Event_Type_FAILURE;
  static const Type ERROR = Event_Type_ERROR;
  static const Type HEARTBEAT = Event_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return Event_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Event_Type_Type_MIN;
  static const Type Type_MAX =
    Event_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Event_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Event_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Event_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Event_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.scheduler.Event.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::scheduler::Event_Type type() const;
  inline void set_type(::mesos::scheduler::Event_Type value);

  // optional .mesos.scheduler.Event.Subscribed subscribed = 2;
  inline bool has_subscribed() const;
  inline void clear_subscribed();
  static const int kSubscribedFieldNumber = 2;
  inline const ::mesos::scheduler::Event_Subscribed& subscribed() const;
  inline ::mesos::scheduler::Event_Subscribed* mutable_subscribed();
  inline ::mesos::scheduler::Event_Subscribed* release_subscribed();
  inline void set_allocated_subscribed(::mesos::scheduler::Event_Subscribed* subscribed);

  // optional .mesos.scheduler.Event.Offers offers = 3;
  inline bool has_offers() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 3;
  inline const ::mesos::scheduler::Event_Offers& offers() const;
  inline ::mesos::scheduler::Event_Offers* mutable_offers();
  inline ::mesos::scheduler::Event_Offers* release_offers();
  inline void set_allocated_offers(::mesos::scheduler::Event_Offers* offers);

  // optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
  inline bool has_inverse_offers() const;
  inline void clear_inverse_offers();
  static const int kInverseOffersFieldNumber = 9;
  inline const ::mesos::scheduler::Event_InverseOffers& inverse_offers() const;
  inline ::mesos::scheduler::Event_InverseOffers* mutable_inverse_offers();
  inline ::mesos::scheduler::Event_InverseOffers* release_inverse_offers();
  inline void set_allocated_inverse_offers(::mesos::scheduler::Event_InverseOffers* inverse_offers);

  // optional .mesos.scheduler.Event.Rescind rescind = 4;
  inline bool has_rescind() const;
  inline void clear_rescind();
  static const int kRescindFieldNumber = 4;
  inline const ::mesos::scheduler::Event_Rescind& rescind() const;
  inline ::mesos::scheduler::Event_Rescind* mutable_rescind();
  inline ::mesos::scheduler::Event_Rescind* release_rescind();
  inline void set_allocated_rescind(::mesos::scheduler::Event_Rescind* rescind);

  // optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
  inline bool has_rescind_inverse_offer() const;
  inline void clear_rescind_inverse_offer();
  static const int kRescindInverseOfferFieldNumber = 10;
  inline const ::mesos::scheduler::Event_RescindInverseOffer& rescind_inverse_offer() const;
  inline ::mesos::scheduler::Event_RescindInverseOffer* mutable_rescind_inverse_offer();
  inline ::mesos::scheduler::Event_RescindInverseOffer* release_rescind_inverse_offer();
  inline void set_allocated_rescind_inverse_offer(::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer);

  // optional .mesos.scheduler.Event.Update update = 5;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 5;
  inline const ::mesos::scheduler::Event_Update& update() const;
  inline ::mesos::scheduler::Event_Update* mutable_update();
  inline ::mesos::scheduler::Event_Update* release_update();
  inline void set_allocated_update(::mesos::scheduler::Event_Update* update);

  // optional .mesos.scheduler.Event.Message message = 6;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 6;
  inline const ::mesos::scheduler::Event_Message& message() const;
  inline ::mesos::scheduler::Event_Message* mutable_message();
  inline ::mesos::scheduler::Event_Message* release_message();
  inline void set_allocated_message(::mesos::scheduler::Event_Message* message);

  // optional .mesos.scheduler.Event.Failure failure = 7;
  inline bool has_failure() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 7;
  inline const ::mesos::scheduler::Event_Failure& failure() const;
  inline ::mesos::scheduler::Event_Failure* mutable_failure();
  inline ::mesos::scheduler::Event_Failure* release_failure();
  inline void set_allocated_failure(::mesos::scheduler::Event_Failure* failure);

  // optional .mesos.scheduler.Event.Error error = 8;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 8;
  inline const ::mesos::scheduler::Event_Error& error() const;
  inline ::mesos::scheduler::Event_Error* mutable_error();
  inline ::mesos::scheduler::Event_Error* release_error();
  inline void set_allocated_error(::mesos::scheduler::Event_Error* error);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Event)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_subscribed();
  inline void clear_has_subscribed();
  inline void set_has_offers();
  inline void clear_has_offers();
  inline void set_has_inverse_offers();
  inline void clear_has_inverse_offers();
  inline void set_has_rescind();
  inline void clear_has_rescind();
  inline void set_has_rescind_inverse_offer();
  inline void clear_has_rescind_inverse_offer();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_failure();
  inline void clear_has_failure();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::scheduler::Event_Subscribed* subscribed_;
  ::mesos::scheduler::Event_Offers* offers_;
  ::mesos::scheduler::Event_InverseOffers* inverse_offers_;
  ::mesos::scheduler::Event_Rescind* rescind_;
  ::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer_;
  ::mesos::scheduler::Event_Update* update_;
  ::mesos::scheduler::Event_Message* message_;
  ::mesos::scheduler::Event_Failure* failure_;
  ::mesos::scheduler::Event_Error* error_;
  int type_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class Call_Subscribe : public ::google::protobuf::Message {
 public:
  Call_Subscribe();
  virtual ~Call_Subscribe();

  Call_Subscribe(const Call_Subscribe& from);

  inline Call_Subscribe& operator=(const Call_Subscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Subscribe& default_instance();

  void Swap(Call_Subscribe* other);

  // implements Message ----------------------------------------------

  Call_Subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Subscribe& from);
  void MergeFrom(const Call_Subscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.FrameworkInfo framework_info = 1;
  inline bool has_framework_info() const;
  inline void clear_framework_info();
  static const int kFrameworkInfoFieldNumber = 1;
  inline const ::mesos::FrameworkInfo& framework_info() const;
  inline ::mesos::FrameworkInfo* mutable_framework_info();
  inline ::mesos::FrameworkInfo* release_framework_info();
  inline void set_allocated_framework_info(::mesos::FrameworkInfo* framework_info);

  // optional bool force = 2;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 2;
  inline bool force() const;
  inline void set_force(bool value);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Subscribe)
 private:
  inline void set_has_framework_info();
  inline void clear_has_framework_info();
  inline void set_has_force();
  inline void clear_has_force();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::FrameworkInfo* framework_info_;
  bool force_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Subscribe* default_instance_;
};
// -------------------------------------------------------------------

class Call_Accept : public ::google::protobuf::Message {
 public:
  Call_Accept();
  virtual ~Call_Accept();

  Call_Accept(const Call_Accept& from);

  inline Call_Accept& operator=(const Call_Accept& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Accept& default_instance();

  void Swap(Call_Accept* other);

  // implements Message ----------------------------------------------

  Call_Accept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Accept& from);
  void MergeFrom(const Call_Accept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID offer_ids = 1;
  inline int offer_ids_size() const;
  inline void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 1;
  inline const ::mesos::OfferID& offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_offer_ids(int index);
  inline ::mesos::OfferID* add_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();

  // repeated .mesos.Offer.Operation operations = 2;
  inline int operations_size() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 2;
  inline const ::mesos::Offer_Operation& operations(int index) const;
  inline ::mesos::Offer_Operation* mutable_operations(int index);
  inline ::mesos::Offer_Operation* add_operations();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >&
      operations() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >*
      mutable_operations();

  // optional .mesos.Filters filters = 3;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 3;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Accept)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation > operations_;
  ::mesos::Filters* filters_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Accept* default_instance_;
};
// -------------------------------------------------------------------

class Call_Decline : public ::google::protobuf::Message {
 public:
  Call_Decline();
  virtual ~Call_Decline();

  Call_Decline(const Call_Decline& from);

  inline Call_Decline& operator=(const Call_Decline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Decline& default_instance();

  void Swap(Call_Decline* other);

  // implements Message ----------------------------------------------

  Call_Decline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Decline& from);
  void MergeFrom(const Call_Decline& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID offer_ids = 1;
  inline int offer_ids_size() const;
  inline void clear_offer_ids();
  static const int kOfferIdsFieldNumber = 1;
  inline const ::mesos::OfferID& offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_offer_ids(int index);
  inline ::mesos::OfferID* add_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_offer_ids();

  // optional .mesos.Filters filters = 2;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 2;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Decline)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > offer_ids_;
  ::mesos::Filters* filters_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Decline* default_instance_;
};
// -------------------------------------------------------------------

class Call_AcceptInverseOffers : public ::google::protobuf::Message {
 public:
  Call_AcceptInverseOffers();
  virtual ~Call_AcceptInverseOffers();

  Call_AcceptInverseOffers(const Call_AcceptInverseOffers& from);

  inline Call_AcceptInverseOffers& operator=(const Call_AcceptInverseOffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_AcceptInverseOffers& default_instance();

  void Swap(Call_AcceptInverseOffers* other);

  // implements Message ----------------------------------------------

  Call_AcceptInverseOffers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_AcceptInverseOffers& from);
  void MergeFrom(const Call_AcceptInverseOffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID inverse_offer_ids = 1;
  inline int inverse_offer_ids_size() const;
  inline void clear_inverse_offer_ids();
  static const int kInverseOfferIdsFieldNumber = 1;
  inline const ::mesos::OfferID& inverse_offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_inverse_offer_ids(int index);
  inline ::mesos::OfferID* add_inverse_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      inverse_offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_inverse_offer_ids();

  // optional .mesos.Filters filters = 2;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 2;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.AcceptInverseOffers)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > inverse_offer_ids_;
  ::mesos::Filters* filters_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_AcceptInverseOffers* default_instance_;
};
// -------------------------------------------------------------------

class Call_DeclineInverseOffers : public ::google::protobuf::Message {
 public:
  Call_DeclineInverseOffers();
  virtual ~Call_DeclineInverseOffers();

  Call_DeclineInverseOffers(const Call_DeclineInverseOffers& from);

  inline Call_DeclineInverseOffers& operator=(const Call_DeclineInverseOffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_DeclineInverseOffers& default_instance();

  void Swap(Call_DeclineInverseOffers* other);

  // implements Message ----------------------------------------------

  Call_DeclineInverseOffers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_DeclineInverseOffers& from);
  void MergeFrom(const Call_DeclineInverseOffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.OfferID inverse_offer_ids = 1;
  inline int inverse_offer_ids_size() const;
  inline void clear_inverse_offer_ids();
  static const int kInverseOfferIdsFieldNumber = 1;
  inline const ::mesos::OfferID& inverse_offer_ids(int index) const;
  inline ::mesos::OfferID* mutable_inverse_offer_ids(int index);
  inline ::mesos::OfferID* add_inverse_offer_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
      inverse_offer_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
      mutable_inverse_offer_ids();

  // optional .mesos.Filters filters = 2;
  inline bool has_filters() const;
  inline void clear_filters();
  static const int kFiltersFieldNumber = 2;
  inline const ::mesos::Filters& filters() const;
  inline ::mesos::Filters* mutable_filters();
  inline ::mesos::Filters* release_filters();
  inline void set_allocated_filters(::mesos::Filters* filters);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.DeclineInverseOffers)
 private:
  inline void set_has_filters();
  inline void clear_has_filters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::OfferID > inverse_offer_ids_;
  ::mesos::Filters* filters_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_DeclineInverseOffers* default_instance_;
};
// -------------------------------------------------------------------

class Call_Revive : public ::google::protobuf::Message {
 public:
  Call_Revive();
  virtual ~Call_Revive();

  Call_Revive(const Call_Revive& from);

  inline Call_Revive& operator=(const Call_Revive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Revive& default_instance();

  void Swap(Call_Revive* other);

  // implements Message ----------------------------------------------

  Call_Revive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Revive& from);
  void MergeFrom(const Call_Revive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roles = 1;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 1;
  inline const ::std::string& roles(int index) const;
  inline ::std::string* mutable_roles(int index);
  inline void set_roles(int index, const ::std::string& value);
  inline void set_roles(int index, const char* value);
  inline void set_roles(int index, const char* value, size_t size);
  inline ::std::string* add_roles();
  inline void add_roles(const ::std::string& value);
  inline void add_roles(const char* value);
  inline void add_roles(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Revive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Revive* default_instance_;
};
// -------------------------------------------------------------------

class Call_Kill : public ::google::protobuf::Message {
 public:
  Call_Kill();
  virtual ~Call_Kill();

  Call_Kill(const Call_Kill& from);

  inline Call_Kill& operator=(const Call_Kill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Kill& default_instance();

  void Swap(Call_Kill* other);

  // implements Message ----------------------------------------------

  Call_Kill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Kill& from);
  void MergeFrom(const Call_Kill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // optional .mesos.SlaveID slave_id = 2;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.KillPolicy kill_policy = 3;
  inline bool has_kill_policy() const;
  inline void clear_kill_policy();
  static const int kKillPolicyFieldNumber = 3;
  inline const ::mesos::KillPolicy& kill_policy() const;
  inline ::mesos::KillPolicy* mutable_kill_policy();
  inline ::mesos::KillPolicy* release_kill_policy();
  inline void set_allocated_kill_policy(::mesos::KillPolicy* kill_policy);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Kill)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_kill_policy();
  inline void clear_has_kill_policy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::KillPolicy* kill_policy_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Kill* default_instance_;
};
// -------------------------------------------------------------------

class Call_Shutdown : public ::google::protobuf::Message {
 public:
  Call_Shutdown();
  virtual ~Call_Shutdown();

  Call_Shutdown(const Call_Shutdown& from);

  inline Call_Shutdown& operator=(const Call_Shutdown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Shutdown& default_instance();

  void Swap(Call_Shutdown* other);

  // implements Message ----------------------------------------------

  Call_Shutdown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Shutdown& from);
  void MergeFrom(const Call_Shutdown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required .mesos.SlaveID slave_id = 2;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Shutdown)
 private:
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::ExecutorID* executor_id_;
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Shutdown* default_instance_;
};
// -------------------------------------------------------------------

class Call_Acknowledge : public ::google::protobuf::Message {
 public:
  Call_Acknowledge();
  virtual ~Call_Acknowledge();

  Call_Acknowledge(const Call_Acknowledge& from);

  inline Call_Acknowledge& operator=(const Call_Acknowledge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Acknowledge& default_instance();

  void Swap(Call_Acknowledge* other);

  // implements Message ----------------------------------------------

  Call_Acknowledge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Acknowledge& from);
  void MergeFrom(const Call_Acknowledge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required bytes uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Acknowledge)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::TaskID* task_id_;
  ::std::string* uuid_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Acknowledge* default_instance_;
};
// -------------------------------------------------------------------

class Call_Reconcile_Task : public ::google::protobuf::Message {
 public:
  Call_Reconcile_Task();
  virtual ~Call_Reconcile_Task();

  Call_Reconcile_Task(const Call_Reconcile_Task& from);

  inline Call_Reconcile_Task& operator=(const Call_Reconcile_Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Reconcile_Task& default_instance();

  void Swap(Call_Reconcile_Task* other);

  // implements Message ----------------------------------------------

  Call_Reconcile_Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Reconcile_Task& from);
  void MergeFrom(const Call_Reconcile_Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // optional .mesos.SlaveID slave_id = 2;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Reconcile.Task)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Reconcile_Task* default_instance_;
};
// -------------------------------------------------------------------

class Call_Reconcile : public ::google::protobuf::Message {
 public:
  Call_Reconcile();
  virtual ~Call_Reconcile();

  Call_Reconcile(const Call_Reconcile& from);

  inline Call_Reconcile& operator=(const Call_Reconcile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Reconcile& default_instance();

  void Swap(Call_Reconcile* other);

  // implements Message ----------------------------------------------

  Call_Reconcile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Reconcile& from);
  void MergeFrom(const Call_Reconcile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Call_Reconcile_Task Task;

  // accessors -------------------------------------------------------

  // repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 1;
  inline const ::mesos::scheduler::Call_Reconcile_Task& tasks(int index) const;
  inline ::mesos::scheduler::Call_Reconcile_Task* mutable_tasks(int index);
  inline ::mesos::scheduler::Call_Reconcile_Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Reconcile)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task > tasks_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Reconcile* default_instance_;
};
// -------------------------------------------------------------------

class Call_Message : public ::google::protobuf::Message {
 public:
  Call_Message();
  virtual ~Call_Message();

  Call_Message(const Call_Message& from);

  inline Call_Message& operator=(const Call_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Message& default_instance();

  void Swap(Call_Message* other);

  // implements Message ----------------------------------------------

  Call_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Message& from);
  void MergeFrom(const Call_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.ExecutorID executor_id = 2;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 2;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Message)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Message* default_instance_;
};
// -------------------------------------------------------------------

class Call_Request : public ::google::protobuf::Message {
 public:
  Call_Request();
  virtual ~Call_Request();

  Call_Request(const Call_Request& from);

  inline Call_Request& operator=(const Call_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Request& default_instance();

  void Swap(Call_Request* other);

  // implements Message ----------------------------------------------

  Call_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Request& from);
  void MergeFrom(const Call_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Request requests = 1;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 1;
  inline const ::mesos::Request& requests(int index) const;
  inline ::mesos::Request* mutable_requests(int index);
  inline ::mesos::Request* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
      mutable_requests();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Request)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Request > requests_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Request* default_instance_;
};
// -------------------------------------------------------------------

class Call_Suppress : public ::google::protobuf::Message {
 public:
  Call_Suppress();
  virtual ~Call_Suppress();

  Call_Suppress(const Call_Suppress& from);

  inline Call_Suppress& operator=(const Call_Suppress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call_Suppress& default_instance();

  void Swap(Call_Suppress* other);

  // implements Message ----------------------------------------------

  Call_Suppress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call_Suppress& from);
  void MergeFrom(const Call_Suppress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roles = 1;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 1;
  inline const ::std::string& roles(int index) const;
  inline ::std::string* mutable_roles(int index);
  inline void set_roles(int index, const ::std::string& value);
  inline void set_roles(int index, const char* value);
  inline void set_roles(int index, const char* value, size_t size);
  inline ::std::string* add_roles();
  inline void add_roles(const ::std::string& value);
  inline void add_roles(const char* value);
  inline void add_roles(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_roles();

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call.Suppress)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> roles_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call_Suppress* default_instance_;
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  void Swap(Call* other);

  // implements Message ----------------------------------------------

  Call* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Call_Subscribe Subscribe;
  typedef Call_Accept Accept;
  typedef Call_Decline Decline;
  typedef Call_AcceptInverseOffers AcceptInverseOffers;
  typedef Call_DeclineInverseOffers DeclineInverseOffers;
  typedef Call_Revive Revive;
  typedef Call_Kill Kill;
  typedef Call_Shutdown Shutdown;
  typedef Call_Acknowledge Acknowledge;
  typedef Call_Reconcile Reconcile;
  typedef Call_Message Message;
  typedef Call_Request Request;
  typedef Call_Suppress Suppress;

  typedef Call_Type Type;
  static const Type UNKNOWN = Call_Type_UNKNOWN;
  static const Type SUBSCRIBE = Call_Type_SUBSCRIBE;
  static const Type TEARDOWN = Call_Type_TEARDOWN;
  static const Type ACCEPT = Call_Type_ACCEPT;
  static const Type DECLINE = Call_Type_DECLINE;
  static const Type ACCEPT_INVERSE_OFFERS = Call_Type_ACCEPT_INVERSE_OFFERS;
  static const Type DECLINE_INVERSE_OFFERS = Call_Type_DECLINE_INVERSE_OFFERS;
  static const Type REVIVE = Call_Type_REVIVE;
  static const Type KILL = Call_Type_KILL;
  static const Type SHUTDOWN = Call_Type_SHUTDOWN;
  static const Type ACKNOWLEDGE = Call_Type_ACKNOWLEDGE;
  static const Type RECONCILE = Call_Type_RECONCILE;
  static const Type MESSAGE = Call_Type_MESSAGE;
  static const Type REQUEST = Call_Type_REQUEST;
  static const Type SUPPRESS = Call_Type_SUPPRESS;
  static inline bool Type_IsValid(int value) {
    return Call_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Call_Type_Type_MIN;
  static const Type Type_MAX =
    Call_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Call_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Call_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Call_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Call_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.scheduler.Call.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::scheduler::Call_Type type() const;
  inline void set_type(::mesos::scheduler::Call_Type value);

  // optional .mesos.scheduler.Call.Subscribe subscribe = 3;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 3;
  inline const ::mesos::scheduler::Call_Subscribe& subscribe() const;
  inline ::mesos::scheduler::Call_Subscribe* mutable_subscribe();
  inline ::mesos::scheduler::Call_Subscribe* release_subscribe();
  inline void set_allocated_subscribe(::mesos::scheduler::Call_Subscribe* subscribe);

  // optional .mesos.scheduler.Call.Accept accept = 4;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 4;
  inline const ::mesos::scheduler::Call_Accept& accept() const;
  inline ::mesos::scheduler::Call_Accept* mutable_accept();
  inline ::mesos::scheduler::Call_Accept* release_accept();
  inline void set_allocated_accept(::mesos::scheduler::Call_Accept* accept);

  // optional .mesos.scheduler.Call.Decline decline = 5;
  inline bool has_decline() const;
  inline void clear_decline();
  static const int kDeclineFieldNumber = 5;
  inline const ::mesos::scheduler::Call_Decline& decline() const;
  inline ::mesos::scheduler::Call_Decline* mutable_decline();
  inline ::mesos::scheduler::Call_Decline* release_decline();
  inline void set_allocated_decline(::mesos::scheduler::Call_Decline* decline);

  // optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
  inline bool has_accept_inverse_offers() const;
  inline void clear_accept_inverse_offers();
  static const int kAcceptInverseOffersFieldNumber = 13;
  inline const ::mesos::scheduler::Call_AcceptInverseOffers& accept_inverse_offers() const;
  inline ::mesos::scheduler::Call_AcceptInverseOffers* mutable_accept_inverse_offers();
  inline ::mesos::scheduler::Call_AcceptInverseOffers* release_accept_inverse_offers();
  inline void set_allocated_accept_inverse_offers(::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers);

  // optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
  inline bool has_decline_inverse_offers() const;
  inline void clear_decline_inverse_offers();
  static const int kDeclineInverseOffersFieldNumber = 14;
  inline const ::mesos::scheduler::Call_DeclineInverseOffers& decline_inverse_offers() const;
  inline ::mesos::scheduler::Call_DeclineInverseOffers* mutable_decline_inverse_offers();
  inline ::mesos::scheduler::Call_DeclineInverseOffers* release_decline_inverse_offers();
  inline void set_allocated_decline_inverse_offers(::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers);

  // optional .mesos.scheduler.Call.Revive revive = 15;
  inline bool has_revive() const;
  inline void clear_revive();
  static const int kReviveFieldNumber = 15;
  inline const ::mesos::scheduler::Call_Revive& revive() const;
  inline ::mesos::scheduler::Call_Revive* mutable_revive();
  inline ::mesos::scheduler::Call_Revive* release_revive();
  inline void set_allocated_revive(::mesos::scheduler::Call_Revive* revive);

  // optional .mesos.scheduler.Call.Kill kill = 6;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 6;
  inline const ::mesos::scheduler::Call_Kill& kill() const;
  inline ::mesos::scheduler::Call_Kill* mutable_kill();
  inline ::mesos::scheduler::Call_Kill* release_kill();
  inline void set_allocated_kill(::mesos::scheduler::Call_Kill* kill);

  // optional .mesos.scheduler.Call.Shutdown shutdown = 7;
  inline bool has_shutdown() const;
  inline void clear_shutdown();
  static const int kShutdownFieldNumber = 7;
  inline const ::mesos::scheduler::Call_Shutdown& shutdown() const;
  inline ::mesos::scheduler::Call_Shutdown* mutable_shutdown();
  inline ::mesos::scheduler::Call_Shutdown* release_shutdown();
  inline void set_allocated_shutdown(::mesos::scheduler::Call_Shutdown* shutdown);

  // optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
  inline bool has_acknowledge() const;
  inline void clear_acknowledge();
  static const int kAcknowledgeFieldNumber = 8;
  inline const ::mesos::scheduler::Call_Acknowledge& acknowledge() const;
  inline ::mesos::scheduler::Call_Acknowledge* mutable_acknowledge();
  inline ::mesos::scheduler::Call_Acknowledge* release_acknowledge();
  inline void set_allocated_acknowledge(::mesos::scheduler::Call_Acknowledge* acknowledge);

  // optional .mesos.scheduler.Call.Reconcile reconcile = 9;
  inline bool has_reconcile() const;
  inline void clear_reconcile();
  static const int kReconcileFieldNumber = 9;
  inline const ::mesos::scheduler::Call_Reconcile& reconcile() const;
  inline ::mesos::scheduler::Call_Reconcile* mutable_reconcile();
  inline ::mesos::scheduler::Call_Reconcile* release_reconcile();
  inline void set_allocated_reconcile(::mesos::scheduler::Call_Reconcile* reconcile);

  // optional .mesos.scheduler.Call.Message message = 10;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 10;
  inline const ::mesos::scheduler::Call_Message& message() const;
  inline ::mesos::scheduler::Call_Message* mutable_message();
  inline ::mesos::scheduler::Call_Message* release_message();
  inline void set_allocated_message(::mesos::scheduler::Call_Message* message);

  // optional .mesos.scheduler.Call.Request request = 11;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 11;
  inline const ::mesos::scheduler::Call_Request& request() const;
  inline ::mesos::scheduler::Call_Request* mutable_request();
  inline ::mesos::scheduler::Call_Request* release_request();
  inline void set_allocated_request(::mesos::scheduler::Call_Request* request);

  // optional .mesos.scheduler.Call.Suppress suppress = 16;
  inline bool has_suppress() const;
  inline void clear_suppress();
  static const int kSuppressFieldNumber = 16;
  inline const ::mesos::scheduler::Call_Suppress& suppress() const;
  inline ::mesos::scheduler::Call_Suppress* mutable_suppress();
  inline ::mesos::scheduler::Call_Suppress* release_suppress();
  inline void set_allocated_suppress(::mesos::scheduler::Call_Suppress* suppress);

  // @@protoc_insertion_point(class_scope:mesos.scheduler.Call)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_subscribe();
  inline void clear_has_subscribe();
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_decline();
  inline void clear_has_decline();
  inline void set_has_accept_inverse_offers();
  inline void clear_has_accept_inverse_offers();
  inline void set_has_decline_inverse_offers();
  inline void clear_has_decline_inverse_offers();
  inline void set_has_revive();
  inline void clear_has_revive();
  inline void set_has_kill();
  inline void clear_has_kill();
  inline void set_has_shutdown();
  inline void clear_has_shutdown();
  inline void set_has_acknowledge();
  inline void clear_has_acknowledge();
  inline void set_has_reconcile();
  inline void clear_has_reconcile();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_suppress();
  inline void clear_has_suppress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::scheduler::Call_Subscribe* subscribe_;
  ::mesos::scheduler::Call_Accept* accept_;
  ::mesos::scheduler::Call_Decline* decline_;
  ::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers_;
  ::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers_;
  ::mesos::scheduler::Call_Revive* revive_;
  ::mesos::scheduler::Call_Kill* kill_;
  ::mesos::scheduler::Call_Shutdown* shutdown_;
  ::mesos::scheduler::Call_Acknowledge* acknowledge_;
  ::mesos::scheduler::Call_Reconcile* reconcile_;
  ::mesos::scheduler::Call_Message* message_;
  ::mesos::scheduler::Call_Request* request_;
  ::mesos::scheduler::Call_Suppress* suppress_;
  int type_;
  friend void  protobuf_AddDesc_scheduler_2eproto();
  friend void protobuf_AssignDesc_scheduler_2eproto();
  friend void protobuf_ShutdownFile_scheduler_2eproto();

  void InitAsDefaultInstance();
  static Call* default_instance_;
};
// ===================================================================


// ===================================================================

// Event_Subscribed

// required .mesos.FrameworkID framework_id = 1;
inline bool Event_Subscribed::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Subscribed::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Subscribed::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Subscribed::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Event_Subscribed::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Subscribed.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Event_Subscribed::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Subscribed.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* Event_Subscribed::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Event_Subscribed::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Subscribed.framework_id)
}

// optional double heartbeat_interval_seconds = 2;
inline bool Event_Subscribed::has_heartbeat_interval_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Subscribed::set_has_heartbeat_interval_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Subscribed::clear_has_heartbeat_interval_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Subscribed::clear_heartbeat_interval_seconds() {
  heartbeat_interval_seconds_ = 0;
  clear_has_heartbeat_interval_seconds();
}
inline double Event_Subscribed::heartbeat_interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Subscribed.heartbeat_interval_seconds)
  return heartbeat_interval_seconds_;
}
inline void Event_Subscribed::set_heartbeat_interval_seconds(double value) {
  set_has_heartbeat_interval_seconds();
  heartbeat_interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Subscribed.heartbeat_interval_seconds)
}

// optional .mesos.MasterInfo master_info = 3;
inline bool Event_Subscribed::has_master_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Subscribed::set_has_master_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Subscribed::clear_has_master_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Subscribed::clear_master_info() {
  if (master_info_ != NULL) master_info_->::mesos::MasterInfo::Clear();
  clear_has_master_info();
}
inline const ::mesos::MasterInfo& Event_Subscribed::master_info() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Subscribed.master_info)
  return master_info_ != NULL ? *master_info_ : *default_instance_->master_info_;
}
inline ::mesos::MasterInfo* Event_Subscribed::mutable_master_info() {
  set_has_master_info();
  if (master_info_ == NULL) master_info_ = new ::mesos::MasterInfo;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Subscribed.master_info)
  return master_info_;
}
inline ::mesos::MasterInfo* Event_Subscribed::release_master_info() {
  clear_has_master_info();
  ::mesos::MasterInfo* temp = master_info_;
  master_info_ = NULL;
  return temp;
}
inline void Event_Subscribed::set_allocated_master_info(::mesos::MasterInfo* master_info) {
  delete master_info_;
  master_info_ = master_info;
  if (master_info) {
    set_has_master_info();
  } else {
    clear_has_master_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Subscribed.master_info)
}

// -------------------------------------------------------------------

// Event_Offers

// repeated .mesos.Offer offers = 1;
inline int Event_Offers::offers_size() const {
  return offers_.size();
}
inline void Event_Offers::clear_offers() {
  offers_.Clear();
}
inline const ::mesos::Offer& Event_Offers::offers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Offers.offers)
  return offers_.Get(index);
}
inline ::mesos::Offer* Event_Offers::mutable_offers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Offers.offers)
  return offers_.Mutable(index);
}
inline ::mesos::Offer* Event_Offers::add_offers() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Event.Offers.offers)
  return offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer >&
Event_Offers::offers() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Event.Offers.offers)
  return offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer >*
Event_Offers::mutable_offers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Event.Offers.offers)
  return &offers_;
}

// -------------------------------------------------------------------

// Event_InverseOffers

// repeated .mesos.InverseOffer inverse_offers = 1;
inline int Event_InverseOffers::inverse_offers_size() const {
  return inverse_offers_.size();
}
inline void Event_InverseOffers::clear_inverse_offers() {
  inverse_offers_.Clear();
}
inline const ::mesos::InverseOffer& Event_InverseOffers::inverse_offers(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_.Get(index);
}
inline ::mesos::InverseOffer* Event_InverseOffers::mutable_inverse_offers(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_.Mutable(index);
}
inline ::mesos::InverseOffer* Event_InverseOffers::add_inverse_offers() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >&
Event_InverseOffers::inverse_offers() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return inverse_offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::InverseOffer >*
Event_InverseOffers::mutable_inverse_offers() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Event.InverseOffers.inverse_offers)
  return &inverse_offers_;
}

// -------------------------------------------------------------------

// Event_Rescind

// required .mesos.OfferID offer_id = 1;
inline bool Event_Rescind::has_offer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Rescind::set_has_offer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Rescind::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Rescind::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& Event_Rescind::offer_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Rescind.offer_id)
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* Event_Rescind::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Rescind.offer_id)
  return offer_id_;
}
inline ::mesos::OfferID* Event_Rescind::release_offer_id() {
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void Event_Rescind::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Rescind.offer_id)
}

// -------------------------------------------------------------------

// Event_RescindInverseOffer

// required .mesos.OfferID inverse_offer_id = 1;
inline bool Event_RescindInverseOffer::has_inverse_offer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_RescindInverseOffer::set_has_inverse_offer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_RescindInverseOffer::clear_has_inverse_offer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_RescindInverseOffer::clear_inverse_offer_id() {
  if (inverse_offer_id_ != NULL) inverse_offer_id_->::mesos::OfferID::Clear();
  clear_has_inverse_offer_id();
}
inline const ::mesos::OfferID& Event_RescindInverseOffer::inverse_offer_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
  return inverse_offer_id_ != NULL ? *inverse_offer_id_ : *default_instance_->inverse_offer_id_;
}
inline ::mesos::OfferID* Event_RescindInverseOffer::mutable_inverse_offer_id() {
  set_has_inverse_offer_id();
  if (inverse_offer_id_ == NULL) inverse_offer_id_ = new ::mesos::OfferID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
  return inverse_offer_id_;
}
inline ::mesos::OfferID* Event_RescindInverseOffer::release_inverse_offer_id() {
  clear_has_inverse_offer_id();
  ::mesos::OfferID* temp = inverse_offer_id_;
  inverse_offer_id_ = NULL;
  return temp;
}
inline void Event_RescindInverseOffer::set_allocated_inverse_offer_id(::mesos::OfferID* inverse_offer_id) {
  delete inverse_offer_id_;
  inverse_offer_id_ = inverse_offer_id;
  if (inverse_offer_id) {
    set_has_inverse_offer_id();
  } else {
    clear_has_inverse_offer_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.RescindInverseOffer.inverse_offer_id)
}

// -------------------------------------------------------------------

// Event_Update

// required .mesos.TaskStatus status = 1;
inline bool Event_Update::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Update::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Update::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Update::clear_status() {
  if (status_ != NULL) status_->::mesos::TaskStatus::Clear();
  clear_has_status();
}
inline const ::mesos::TaskStatus& Event_Update::status() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Update.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::mesos::TaskStatus* Event_Update::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::mesos::TaskStatus;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Update.status)
  return status_;
}
inline ::mesos::TaskStatus* Event_Update::release_status() {
  clear_has_status();
  ::mesos::TaskStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Event_Update::set_allocated_status(::mesos::TaskStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Update.status)
}

// -------------------------------------------------------------------

// Event_Message

// required .mesos.SlaveID slave_id = 1;
inline bool Event_Message::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Message::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Message::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Message::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Event_Message::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Message.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Event_Message::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Message.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Event_Message::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Event_Message::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Message.slave_id)
}

// required .mesos.ExecutorID executor_id = 2;
inline bool Event_Message::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Message::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Message::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Message::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Event_Message::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Message.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Event_Message::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Message.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* Event_Message::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Event_Message::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Message.executor_id)
}

// required bytes data = 3;
inline bool Event_Message::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Message::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Message::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Event_Message::data() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Message.data)
  return *data_;
}
inline void Event_Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Message.data)
}
inline void Event_Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Event.Message.data)
}
inline void Event_Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Event.Message.data)
}
inline ::std::string* Event_Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Message.data)
  return data_;
}
inline ::std::string* Event_Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Event_Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Message.data)
}

// -------------------------------------------------------------------

// Event_Failure

// optional .mesos.SlaveID slave_id = 1;
inline bool Event_Failure::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Failure::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Failure::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Failure::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Event_Failure::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Failure.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Event_Failure::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Failure.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Event_Failure::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Event_Failure::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Failure.slave_id)
}

// optional .mesos.ExecutorID executor_id = 2;
inline bool Event_Failure::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event_Failure::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event_Failure::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event_Failure::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Event_Failure::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Failure.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Event_Failure::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Failure.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* Event_Failure::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Event_Failure::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Failure.executor_id)
}

// optional int32 status = 3;
inline bool Event_Failure::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event_Failure::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event_Failure::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event_Failure::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Event_Failure::status() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Failure.status)
  return status_;
}
inline void Event_Failure::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Failure.status)
}

// -------------------------------------------------------------------

// Event_Error

// required string message = 1;
inline bool Event_Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event_Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event_Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event_Error::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Event_Error::message() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.Error.message)
  return *message_;
}
inline void Event_Error::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.Error.message)
}
inline void Event_Error::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Event.Error.message)
}
inline void Event_Error::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Event.Error.message)
}
inline ::std::string* Event_Error::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.Error.message)
  return message_;
}
inline ::std::string* Event_Error::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Event_Error::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.Error.message)
}

// -------------------------------------------------------------------

// Event

// optional .mesos.scheduler.Event.Type type = 1;
inline bool Event::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::scheduler::Event_Type Event::type() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.type)
  return static_cast< ::mesos::scheduler::Event_Type >(type_);
}
inline void Event::set_type(::mesos::scheduler::Event_Type value) {
  assert(::mesos::scheduler::Event_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Event.type)
}

// optional .mesos.scheduler.Event.Subscribed subscribed = 2;
inline bool Event::has_subscribed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_subscribed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_subscribed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_subscribed() {
  if (subscribed_ != NULL) subscribed_->::mesos::scheduler::Event_Subscribed::Clear();
  clear_has_subscribed();
}
inline const ::mesos::scheduler::Event_Subscribed& Event::subscribed() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.subscribed)
  return subscribed_ != NULL ? *subscribed_ : *default_instance_->subscribed_;
}
inline ::mesos::scheduler::Event_Subscribed* Event::mutable_subscribed() {
  set_has_subscribed();
  if (subscribed_ == NULL) subscribed_ = new ::mesos::scheduler::Event_Subscribed;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.subscribed)
  return subscribed_;
}
inline ::mesos::scheduler::Event_Subscribed* Event::release_subscribed() {
  clear_has_subscribed();
  ::mesos::scheduler::Event_Subscribed* temp = subscribed_;
  subscribed_ = NULL;
  return temp;
}
inline void Event::set_allocated_subscribed(::mesos::scheduler::Event_Subscribed* subscribed) {
  delete subscribed_;
  subscribed_ = subscribed;
  if (subscribed) {
    set_has_subscribed();
  } else {
    clear_has_subscribed();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.subscribed)
}

// optional .mesos.scheduler.Event.Offers offers = 3;
inline bool Event::has_offers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_offers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_offers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_offers() {
  if (offers_ != NULL) offers_->::mesos::scheduler::Event_Offers::Clear();
  clear_has_offers();
}
inline const ::mesos::scheduler::Event_Offers& Event::offers() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.offers)
  return offers_ != NULL ? *offers_ : *default_instance_->offers_;
}
inline ::mesos::scheduler::Event_Offers* Event::mutable_offers() {
  set_has_offers();
  if (offers_ == NULL) offers_ = new ::mesos::scheduler::Event_Offers;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.offers)
  return offers_;
}
inline ::mesos::scheduler::Event_Offers* Event::release_offers() {
  clear_has_offers();
  ::mesos::scheduler::Event_Offers* temp = offers_;
  offers_ = NULL;
  return temp;
}
inline void Event::set_allocated_offers(::mesos::scheduler::Event_Offers* offers) {
  delete offers_;
  offers_ = offers;
  if (offers) {
    set_has_offers();
  } else {
    clear_has_offers();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.offers)
}

// optional .mesos.scheduler.Event.InverseOffers inverse_offers = 9;
inline bool Event::has_inverse_offers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_inverse_offers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_inverse_offers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_inverse_offers() {
  if (inverse_offers_ != NULL) inverse_offers_->::mesos::scheduler::Event_InverseOffers::Clear();
  clear_has_inverse_offers();
}
inline const ::mesos::scheduler::Event_InverseOffers& Event::inverse_offers() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.inverse_offers)
  return inverse_offers_ != NULL ? *inverse_offers_ : *default_instance_->inverse_offers_;
}
inline ::mesos::scheduler::Event_InverseOffers* Event::mutable_inverse_offers() {
  set_has_inverse_offers();
  if (inverse_offers_ == NULL) inverse_offers_ = new ::mesos::scheduler::Event_InverseOffers;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.inverse_offers)
  return inverse_offers_;
}
inline ::mesos::scheduler::Event_InverseOffers* Event::release_inverse_offers() {
  clear_has_inverse_offers();
  ::mesos::scheduler::Event_InverseOffers* temp = inverse_offers_;
  inverse_offers_ = NULL;
  return temp;
}
inline void Event::set_allocated_inverse_offers(::mesos::scheduler::Event_InverseOffers* inverse_offers) {
  delete inverse_offers_;
  inverse_offers_ = inverse_offers;
  if (inverse_offers) {
    set_has_inverse_offers();
  } else {
    clear_has_inverse_offers();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.inverse_offers)
}

// optional .mesos.scheduler.Event.Rescind rescind = 4;
inline bool Event::has_rescind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_rescind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_rescind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_rescind() {
  if (rescind_ != NULL) rescind_->::mesos::scheduler::Event_Rescind::Clear();
  clear_has_rescind();
}
inline const ::mesos::scheduler::Event_Rescind& Event::rescind() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.rescind)
  return rescind_ != NULL ? *rescind_ : *default_instance_->rescind_;
}
inline ::mesos::scheduler::Event_Rescind* Event::mutable_rescind() {
  set_has_rescind();
  if (rescind_ == NULL) rescind_ = new ::mesos::scheduler::Event_Rescind;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.rescind)
  return rescind_;
}
inline ::mesos::scheduler::Event_Rescind* Event::release_rescind() {
  clear_has_rescind();
  ::mesos::scheduler::Event_Rescind* temp = rescind_;
  rescind_ = NULL;
  return temp;
}
inline void Event::set_allocated_rescind(::mesos::scheduler::Event_Rescind* rescind) {
  delete rescind_;
  rescind_ = rescind;
  if (rescind) {
    set_has_rescind();
  } else {
    clear_has_rescind();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.rescind)
}

// optional .mesos.scheduler.Event.RescindInverseOffer rescind_inverse_offer = 10;
inline bool Event::has_rescind_inverse_offer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_rescind_inverse_offer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_rescind_inverse_offer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_rescind_inverse_offer() {
  if (rescind_inverse_offer_ != NULL) rescind_inverse_offer_->::mesos::scheduler::Event_RescindInverseOffer::Clear();
  clear_has_rescind_inverse_offer();
}
inline const ::mesos::scheduler::Event_RescindInverseOffer& Event::rescind_inverse_offer() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.rescind_inverse_offer)
  return rescind_inverse_offer_ != NULL ? *rescind_inverse_offer_ : *default_instance_->rescind_inverse_offer_;
}
inline ::mesos::scheduler::Event_RescindInverseOffer* Event::mutable_rescind_inverse_offer() {
  set_has_rescind_inverse_offer();
  if (rescind_inverse_offer_ == NULL) rescind_inverse_offer_ = new ::mesos::scheduler::Event_RescindInverseOffer;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.rescind_inverse_offer)
  return rescind_inverse_offer_;
}
inline ::mesos::scheduler::Event_RescindInverseOffer* Event::release_rescind_inverse_offer() {
  clear_has_rescind_inverse_offer();
  ::mesos::scheduler::Event_RescindInverseOffer* temp = rescind_inverse_offer_;
  rescind_inverse_offer_ = NULL;
  return temp;
}
inline void Event::set_allocated_rescind_inverse_offer(::mesos::scheduler::Event_RescindInverseOffer* rescind_inverse_offer) {
  delete rescind_inverse_offer_;
  rescind_inverse_offer_ = rescind_inverse_offer;
  if (rescind_inverse_offer) {
    set_has_rescind_inverse_offer();
  } else {
    clear_has_rescind_inverse_offer();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.rescind_inverse_offer)
}

// optional .mesos.scheduler.Event.Update update = 5;
inline bool Event::has_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_update() {
  if (update_ != NULL) update_->::mesos::scheduler::Event_Update::Clear();
  clear_has_update();
}
inline const ::mesos::scheduler::Event_Update& Event::update() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.update)
  return update_ != NULL ? *update_ : *default_instance_->update_;
}
inline ::mesos::scheduler::Event_Update* Event::mutable_update() {
  set_has_update();
  if (update_ == NULL) update_ = new ::mesos::scheduler::Event_Update;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.update)
  return update_;
}
inline ::mesos::scheduler::Event_Update* Event::release_update() {
  clear_has_update();
  ::mesos::scheduler::Event_Update* temp = update_;
  update_ = NULL;
  return temp;
}
inline void Event::set_allocated_update(::mesos::scheduler::Event_Update* update) {
  delete update_;
  update_ = update;
  if (update) {
    set_has_update();
  } else {
    clear_has_update();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.update)
}

// optional .mesos.scheduler.Event.Message message = 6;
inline bool Event::has_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Event::set_has_message() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Event::clear_has_message() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Event::clear_message() {
  if (message_ != NULL) message_->::mesos::scheduler::Event_Message::Clear();
  clear_has_message();
}
inline const ::mesos::scheduler::Event_Message& Event::message() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::mesos::scheduler::Event_Message* Event::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::mesos::scheduler::Event_Message;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.message)
  return message_;
}
inline ::mesos::scheduler::Event_Message* Event::release_message() {
  clear_has_message();
  ::mesos::scheduler::Event_Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline void Event::set_allocated_message(::mesos::scheduler::Event_Message* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.message)
}

// optional .mesos.scheduler.Event.Failure failure = 7;
inline bool Event::has_failure() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_failure() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_failure() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_failure() {
  if (failure_ != NULL) failure_->::mesos::scheduler::Event_Failure::Clear();
  clear_has_failure();
}
inline const ::mesos::scheduler::Event_Failure& Event::failure() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.failure)
  return failure_ != NULL ? *failure_ : *default_instance_->failure_;
}
inline ::mesos::scheduler::Event_Failure* Event::mutable_failure() {
  set_has_failure();
  if (failure_ == NULL) failure_ = new ::mesos::scheduler::Event_Failure;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.failure)
  return failure_;
}
inline ::mesos::scheduler::Event_Failure* Event::release_failure() {
  clear_has_failure();
  ::mesos::scheduler::Event_Failure* temp = failure_;
  failure_ = NULL;
  return temp;
}
inline void Event::set_allocated_failure(::mesos::scheduler::Event_Failure* failure) {
  delete failure_;
  failure_ = failure;
  if (failure) {
    set_has_failure();
  } else {
    clear_has_failure();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.failure)
}

// optional .mesos.scheduler.Event.Error error = 8;
inline bool Event::has_error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Event::set_has_error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Event::clear_has_error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Event::clear_error() {
  if (error_ != NULL) error_->::mesos::scheduler::Event_Error::Clear();
  clear_has_error();
}
inline const ::mesos::scheduler::Event_Error& Event::error() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Event.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::mesos::scheduler::Event_Error* Event::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::mesos::scheduler::Event_Error;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Event.error)
  return error_;
}
inline ::mesos::scheduler::Event_Error* Event::release_error() {
  clear_has_error();
  ::mesos::scheduler::Event_Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Event::set_allocated_error(::mesos::scheduler::Event_Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Event.error)
}

// -------------------------------------------------------------------

// Call_Subscribe

// required .mesos.FrameworkInfo framework_info = 1;
inline bool Call_Subscribe::has_framework_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Subscribe::set_has_framework_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Subscribe::clear_has_framework_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Subscribe::clear_framework_info() {
  if (framework_info_ != NULL) framework_info_->::mesos::FrameworkInfo::Clear();
  clear_has_framework_info();
}
inline const ::mesos::FrameworkInfo& Call_Subscribe::framework_info() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Subscribe.framework_info)
  return framework_info_ != NULL ? *framework_info_ : *default_instance_->framework_info_;
}
inline ::mesos::FrameworkInfo* Call_Subscribe::mutable_framework_info() {
  set_has_framework_info();
  if (framework_info_ == NULL) framework_info_ = new ::mesos::FrameworkInfo;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Subscribe.framework_info)
  return framework_info_;
}
inline ::mesos::FrameworkInfo* Call_Subscribe::release_framework_info() {
  clear_has_framework_info();
  ::mesos::FrameworkInfo* temp = framework_info_;
  framework_info_ = NULL;
  return temp;
}
inline void Call_Subscribe::set_allocated_framework_info(::mesos::FrameworkInfo* framework_info) {
  delete framework_info_;
  framework_info_ = framework_info;
  if (framework_info) {
    set_has_framework_info();
  } else {
    clear_has_framework_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Subscribe.framework_info)
}

// optional bool force = 2;
inline bool Call_Subscribe::has_force() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Subscribe::set_has_force() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Subscribe::clear_has_force() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Subscribe::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool Call_Subscribe::force() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Subscribe.force)
  return force_;
}
inline void Call_Subscribe::set_force(bool value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Subscribe.force)
}

// -------------------------------------------------------------------

// Call_Accept

// repeated .mesos.OfferID offer_ids = 1;
inline int Call_Accept::offer_ids_size() const {
  return offer_ids_.size();
}
inline void Call_Accept::clear_offer_ids() {
  offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_Accept::offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Accept::mutable_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Accept::add_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Accept::offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Accept.offer_ids)
  return offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Accept::mutable_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Accept.offer_ids)
  return &offer_ids_;
}

// repeated .mesos.Offer.Operation operations = 2;
inline int Call_Accept::operations_size() const {
  return operations_.size();
}
inline void Call_Accept::clear_operations() {
  operations_.Clear();
}
inline const ::mesos::Offer_Operation& Call_Accept::operations(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Accept.operations)
  return operations_.Get(index);
}
inline ::mesos::Offer_Operation* Call_Accept::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Accept.operations)
  return operations_.Mutable(index);
}
inline ::mesos::Offer_Operation* Call_Accept::add_operations() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Accept.operations)
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >&
Call_Accept::operations() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Accept.operations)
  return operations_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Offer_Operation >*
Call_Accept::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Accept.operations)
  return &operations_;
}

// optional .mesos.Filters filters = 3;
inline bool Call_Accept::has_filters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Accept::set_has_filters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Accept::clear_has_filters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Accept::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_Accept::filters() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Accept.filters)
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_Accept::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Accept.filters)
  return filters_;
}
inline ::mesos::Filters* Call_Accept::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_Accept::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Accept.filters)
}

// -------------------------------------------------------------------

// Call_Decline

// repeated .mesos.OfferID offer_ids = 1;
inline int Call_Decline::offer_ids_size() const {
  return offer_ids_.size();
}
inline void Call_Decline::clear_offer_ids() {
  offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_Decline::offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_Decline::mutable_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_Decline::add_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_Decline::offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Decline.offer_ids)
  return offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_Decline::mutable_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Decline.offer_ids)
  return &offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_Decline::has_filters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Decline::set_has_filters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Decline::clear_has_filters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Decline::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_Decline::filters() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Decline.filters)
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_Decline::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Decline.filters)
  return filters_;
}
inline ::mesos::Filters* Call_Decline::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_Decline::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Decline.filters)
}

// -------------------------------------------------------------------

// Call_AcceptInverseOffers

// repeated .mesos.OfferID inverse_offer_ids = 1;
inline int Call_AcceptInverseOffers::inverse_offer_ids_size() const {
  return inverse_offer_ids_.size();
}
inline void Call_AcceptInverseOffers::clear_inverse_offer_ids() {
  inverse_offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_AcceptInverseOffers::inverse_offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_AcceptInverseOffers::mutable_inverse_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_AcceptInverseOffers::add_inverse_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_AcceptInverseOffers::inverse_offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_AcceptInverseOffers::mutable_inverse_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.AcceptInverseOffers.inverse_offer_ids)
  return &inverse_offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_AcceptInverseOffers::has_filters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_AcceptInverseOffers::set_has_filters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_AcceptInverseOffers::clear_has_filters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_AcceptInverseOffers::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_AcceptInverseOffers::filters() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.AcceptInverseOffers.filters)
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_AcceptInverseOffers::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.AcceptInverseOffers.filters)
  return filters_;
}
inline ::mesos::Filters* Call_AcceptInverseOffers::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_AcceptInverseOffers::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.AcceptInverseOffers.filters)
}

// -------------------------------------------------------------------

// Call_DeclineInverseOffers

// repeated .mesos.OfferID inverse_offer_ids = 1;
inline int Call_DeclineInverseOffers::inverse_offer_ids_size() const {
  return inverse_offer_ids_.size();
}
inline void Call_DeclineInverseOffers::clear_inverse_offer_ids() {
  inverse_offer_ids_.Clear();
}
inline const ::mesos::OfferID& Call_DeclineInverseOffers::inverse_offer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Get(index);
}
inline ::mesos::OfferID* Call_DeclineInverseOffers::mutable_inverse_offer_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Mutable(index);
}
inline ::mesos::OfferID* Call_DeclineInverseOffers::add_inverse_offer_ids() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >&
Call_DeclineInverseOffers::inverse_offer_ids() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return inverse_offer_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::OfferID >*
Call_DeclineInverseOffers::mutable_inverse_offer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.DeclineInverseOffers.inverse_offer_ids)
  return &inverse_offer_ids_;
}

// optional .mesos.Filters filters = 2;
inline bool Call_DeclineInverseOffers::has_filters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_DeclineInverseOffers::set_has_filters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_DeclineInverseOffers::clear_has_filters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_DeclineInverseOffers::clear_filters() {
  if (filters_ != NULL) filters_->::mesos::Filters::Clear();
  clear_has_filters();
}
inline const ::mesos::Filters& Call_DeclineInverseOffers::filters() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.DeclineInverseOffers.filters)
  return filters_ != NULL ? *filters_ : *default_instance_->filters_;
}
inline ::mesos::Filters* Call_DeclineInverseOffers::mutable_filters() {
  set_has_filters();
  if (filters_ == NULL) filters_ = new ::mesos::Filters;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.DeclineInverseOffers.filters)
  return filters_;
}
inline ::mesos::Filters* Call_DeclineInverseOffers::release_filters() {
  clear_has_filters();
  ::mesos::Filters* temp = filters_;
  filters_ = NULL;
  return temp;
}
inline void Call_DeclineInverseOffers::set_allocated_filters(::mesos::Filters* filters) {
  delete filters_;
  filters_ = filters;
  if (filters) {
    set_has_filters();
  } else {
    clear_has_filters();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.DeclineInverseOffers.filters)
}

// -------------------------------------------------------------------

// Call_Revive

// repeated string roles = 1;
inline int Call_Revive::roles_size() const {
  return roles_.size();
}
inline void Call_Revive::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& Call_Revive::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Revive.roles)
  return roles_.Get(index);
}
inline ::std::string* Call_Revive::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Revive.roles)
  return roles_.Mutable(index);
}
inline void Call_Revive::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Revive.roles)
  roles_.Mutable(index)->assign(value);
}
inline void Call_Revive::set_roles(int index, const char* value) {
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Revive.roles)
}
inline void Call_Revive::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Revive.roles)
}
inline ::std::string* Call_Revive::add_roles() {
  return roles_.Add();
}
inline void Call_Revive::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Revive.roles)
}
inline void Call_Revive::add_roles(const char* value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.scheduler.Call.Revive.roles)
}
inline void Call_Revive::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.scheduler.Call.Revive.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Call_Revive::roles() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Revive.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Call_Revive::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Revive.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// Call_Kill

// required .mesos.TaskID task_id = 1;
inline bool Call_Kill::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Kill::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Kill::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Kill::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Call_Kill::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Kill.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Call_Kill::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Kill.task_id)
  return task_id_;
}
inline ::mesos::TaskID* Call_Kill::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Call_Kill::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Kill.task_id)
}

// optional .mesos.SlaveID slave_id = 2;
inline bool Call_Kill::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Kill::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Kill::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Kill::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Kill::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Kill.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Kill::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Kill.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Kill::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Kill::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Kill.slave_id)
}

// optional .mesos.KillPolicy kill_policy = 3;
inline bool Call_Kill::has_kill_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Kill::set_has_kill_policy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Kill::clear_has_kill_policy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Kill::clear_kill_policy() {
  if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
  clear_has_kill_policy();
}
inline const ::mesos::KillPolicy& Call_Kill::kill_policy() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Kill.kill_policy)
  return kill_policy_ != NULL ? *kill_policy_ : *default_instance_->kill_policy_;
}
inline ::mesos::KillPolicy* Call_Kill::mutable_kill_policy() {
  set_has_kill_policy();
  if (kill_policy_ == NULL) kill_policy_ = new ::mesos::KillPolicy;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Kill.kill_policy)
  return kill_policy_;
}
inline ::mesos::KillPolicy* Call_Kill::release_kill_policy() {
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  kill_policy_ = NULL;
  return temp;
}
inline void Call_Kill::set_allocated_kill_policy(::mesos::KillPolicy* kill_policy) {
  delete kill_policy_;
  kill_policy_ = kill_policy;
  if (kill_policy) {
    set_has_kill_policy();
  } else {
    clear_has_kill_policy();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Kill.kill_policy)
}

// -------------------------------------------------------------------

// Call_Shutdown

// required .mesos.ExecutorID executor_id = 1;
inline bool Call_Shutdown::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Shutdown::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Shutdown::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Shutdown::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Call_Shutdown::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Shutdown.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Call_Shutdown::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Shutdown.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* Call_Shutdown::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Call_Shutdown::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Shutdown.executor_id)
}

// required .mesos.SlaveID slave_id = 2;
inline bool Call_Shutdown::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Shutdown::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Shutdown::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Shutdown::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Shutdown::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Shutdown.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Shutdown::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Shutdown.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Shutdown::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Shutdown::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Shutdown.slave_id)
}

// -------------------------------------------------------------------

// Call_Acknowledge

// required .mesos.SlaveID slave_id = 1;
inline bool Call_Acknowledge::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Acknowledge::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Acknowledge::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Acknowledge::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Acknowledge::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Acknowledge.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Acknowledge::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Acknowledge.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Acknowledge::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Acknowledge::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Acknowledge.slave_id)
}

// required .mesos.TaskID task_id = 2;
inline bool Call_Acknowledge::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Acknowledge::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Acknowledge::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Acknowledge::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Call_Acknowledge::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Acknowledge.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Call_Acknowledge::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Acknowledge.task_id)
  return task_id_;
}
inline ::mesos::TaskID* Call_Acknowledge::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Call_Acknowledge::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Acknowledge.task_id)
}

// required bytes uuid = 3;
inline bool Call_Acknowledge::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Acknowledge::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Acknowledge::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Acknowledge::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Call_Acknowledge::uuid() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Acknowledge.uuid)
  return *uuid_;
}
inline void Call_Acknowledge::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Acknowledge.uuid)
}
inline void Call_Acknowledge::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Acknowledge.uuid)
}
inline void Call_Acknowledge::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Acknowledge.uuid)
}
inline ::std::string* Call_Acknowledge::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Acknowledge.uuid)
  return uuid_;
}
inline ::std::string* Call_Acknowledge::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Call_Acknowledge::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Acknowledge.uuid)
}

// -------------------------------------------------------------------

// Call_Reconcile_Task

// required .mesos.TaskID task_id = 1;
inline bool Call_Reconcile_Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Reconcile_Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Reconcile_Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Reconcile_Task::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& Call_Reconcile_Task::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Reconcile.Task.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* Call_Reconcile_Task::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Reconcile.Task.task_id)
  return task_id_;
}
inline ::mesos::TaskID* Call_Reconcile_Task::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void Call_Reconcile_Task::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Reconcile.Task.task_id)
}

// optional .mesos.SlaveID slave_id = 2;
inline bool Call_Reconcile_Task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Reconcile_Task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Reconcile_Task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Reconcile_Task::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Reconcile_Task::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Reconcile.Task.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Reconcile_Task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Reconcile.Task.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Reconcile_Task::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Reconcile_Task::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Reconcile.Task.slave_id)
}

// -------------------------------------------------------------------

// Call_Reconcile

// repeated .mesos.scheduler.Call.Reconcile.Task tasks = 1;
inline int Call_Reconcile::tasks_size() const {
  return tasks_.size();
}
inline void Call_Reconcile::clear_tasks() {
  tasks_.Clear();
}
inline const ::mesos::scheduler::Call_Reconcile_Task& Call_Reconcile::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_.Get(index);
}
inline ::mesos::scheduler::Call_Reconcile_Task* Call_Reconcile::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_.Mutable(index);
}
inline ::mesos::scheduler::Call_Reconcile_Task* Call_Reconcile::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >&
Call_Reconcile::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Reconcile.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::scheduler::Call_Reconcile_Task >*
Call_Reconcile::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Reconcile.tasks)
  return &tasks_;
}

// -------------------------------------------------------------------

// Call_Message

// required .mesos.SlaveID slave_id = 1;
inline bool Call_Message::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call_Message::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call_Message::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call_Message::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Call_Message::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Message.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Call_Message::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Message.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* Call_Message::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Call_Message::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Message.slave_id)
}

// required .mesos.ExecutorID executor_id = 2;
inline bool Call_Message::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call_Message::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call_Message::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call_Message::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& Call_Message::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Message.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* Call_Message::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Message.executor_id)
  return executor_id_;
}
inline ::mesos::ExecutorID* Call_Message::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void Call_Message::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Message.executor_id)
}

// required bytes data = 3;
inline bool Call_Message::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call_Message::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call_Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call_Message::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Call_Message::data() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Message.data)
  return *data_;
}
inline void Call_Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Message.data)
}
inline void Call_Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Message.data)
}
inline void Call_Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Message.data)
}
inline ::std::string* Call_Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Message.data)
  return data_;
}
inline ::std::string* Call_Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Call_Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.Message.data)
}

// -------------------------------------------------------------------

// Call_Request

// repeated .mesos.Request requests = 1;
inline int Call_Request::requests_size() const {
  return requests_.size();
}
inline void Call_Request::clear_requests() {
  requests_.Clear();
}
inline const ::mesos::Request& Call_Request::requests(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Request.requests)
  return requests_.Get(index);
}
inline ::mesos::Request* Call_Request::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Request.requests)
  return requests_.Mutable(index);
}
inline ::mesos::Request* Call_Request::add_requests() {
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Request.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Request >&
Call_Request::requests() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Request.requests)
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Request >*
Call_Request::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Request.requests)
  return &requests_;
}

// -------------------------------------------------------------------

// Call_Suppress

// repeated string roles = 1;
inline int Call_Suppress::roles_size() const {
  return roles_.size();
}
inline void Call_Suppress::clear_roles() {
  roles_.Clear();
}
inline const ::std::string& Call_Suppress::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.Suppress.roles)
  return roles_.Get(index);
}
inline ::std::string* Call_Suppress::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.Suppress.roles)
  return roles_.Mutable(index);
}
inline void Call_Suppress::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.Suppress.roles)
  roles_.Mutable(index)->assign(value);
}
inline void Call_Suppress::set_roles(int index, const char* value) {
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.scheduler.Call.Suppress.roles)
}
inline void Call_Suppress::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.scheduler.Call.Suppress.roles)
}
inline ::std::string* Call_Suppress::add_roles() {
  return roles_.Add();
}
inline void Call_Suppress::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.scheduler.Call.Suppress.roles)
}
inline void Call_Suppress::add_roles(const char* value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.scheduler.Call.Suppress.roles)
}
inline void Call_Suppress::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.scheduler.Call.Suppress.roles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Call_Suppress::roles() const {
  // @@protoc_insertion_point(field_list:mesos.scheduler.Call.Suppress.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Call_Suppress::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.scheduler.Call.Suppress.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// Call

// optional .mesos.FrameworkID framework_id = 1;
inline bool Call::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Call::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Call::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* Call::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Call::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.framework_id)
}

// optional .mesos.scheduler.Call.Type type = 2;
inline bool Call::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::scheduler::Call_Type Call::type() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.type)
  return static_cast< ::mesos::scheduler::Call_Type >(type_);
}
inline void Call::set_type(::mesos::scheduler::Call_Type value) {
  assert(::mesos::scheduler::Call_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.scheduler.Call.type)
}

// optional .mesos.scheduler.Call.Subscribe subscribe = 3;
inline bool Call::has_subscribe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Call::set_has_subscribe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Call::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Call::clear_subscribe() {
  if (subscribe_ != NULL) subscribe_->::mesos::scheduler::Call_Subscribe::Clear();
  clear_has_subscribe();
}
inline const ::mesos::scheduler::Call_Subscribe& Call::subscribe() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.subscribe)
  return subscribe_ != NULL ? *subscribe_ : *default_instance_->subscribe_;
}
inline ::mesos::scheduler::Call_Subscribe* Call::mutable_subscribe() {
  set_has_subscribe();
  if (subscribe_ == NULL) subscribe_ = new ::mesos::scheduler::Call_Subscribe;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.subscribe)
  return subscribe_;
}
inline ::mesos::scheduler::Call_Subscribe* Call::release_subscribe() {
  clear_has_subscribe();
  ::mesos::scheduler::Call_Subscribe* temp = subscribe_;
  subscribe_ = NULL;
  return temp;
}
inline void Call::set_allocated_subscribe(::mesos::scheduler::Call_Subscribe* subscribe) {
  delete subscribe_;
  subscribe_ = subscribe;
  if (subscribe) {
    set_has_subscribe();
  } else {
    clear_has_subscribe();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.subscribe)
}

// optional .mesos.scheduler.Call.Accept accept = 4;
inline bool Call::has_accept() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Call::set_has_accept() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Call::clear_has_accept() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Call::clear_accept() {
  if (accept_ != NULL) accept_->::mesos::scheduler::Call_Accept::Clear();
  clear_has_accept();
}
inline const ::mesos::scheduler::Call_Accept& Call::accept() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.accept)
  return accept_ != NULL ? *accept_ : *default_instance_->accept_;
}
inline ::mesos::scheduler::Call_Accept* Call::mutable_accept() {
  set_has_accept();
  if (accept_ == NULL) accept_ = new ::mesos::scheduler::Call_Accept;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.accept)
  return accept_;
}
inline ::mesos::scheduler::Call_Accept* Call::release_accept() {
  clear_has_accept();
  ::mesos::scheduler::Call_Accept* temp = accept_;
  accept_ = NULL;
  return temp;
}
inline void Call::set_allocated_accept(::mesos::scheduler::Call_Accept* accept) {
  delete accept_;
  accept_ = accept;
  if (accept) {
    set_has_accept();
  } else {
    clear_has_accept();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.accept)
}

// optional .mesos.scheduler.Call.Decline decline = 5;
inline bool Call::has_decline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Call::set_has_decline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Call::clear_has_decline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Call::clear_decline() {
  if (decline_ != NULL) decline_->::mesos::scheduler::Call_Decline::Clear();
  clear_has_decline();
}
inline const ::mesos::scheduler::Call_Decline& Call::decline() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.decline)
  return decline_ != NULL ? *decline_ : *default_instance_->decline_;
}
inline ::mesos::scheduler::Call_Decline* Call::mutable_decline() {
  set_has_decline();
  if (decline_ == NULL) decline_ = new ::mesos::scheduler::Call_Decline;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.decline)
  return decline_;
}
inline ::mesos::scheduler::Call_Decline* Call::release_decline() {
  clear_has_decline();
  ::mesos::scheduler::Call_Decline* temp = decline_;
  decline_ = NULL;
  return temp;
}
inline void Call::set_allocated_decline(::mesos::scheduler::Call_Decline* decline) {
  delete decline_;
  decline_ = decline;
  if (decline) {
    set_has_decline();
  } else {
    clear_has_decline();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.decline)
}

// optional .mesos.scheduler.Call.AcceptInverseOffers accept_inverse_offers = 13;
inline bool Call::has_accept_inverse_offers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Call::set_has_accept_inverse_offers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Call::clear_has_accept_inverse_offers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Call::clear_accept_inverse_offers() {
  if (accept_inverse_offers_ != NULL) accept_inverse_offers_->::mesos::scheduler::Call_AcceptInverseOffers::Clear();
  clear_has_accept_inverse_offers();
}
inline const ::mesos::scheduler::Call_AcceptInverseOffers& Call::accept_inverse_offers() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.accept_inverse_offers)
  return accept_inverse_offers_ != NULL ? *accept_inverse_offers_ : *default_instance_->accept_inverse_offers_;
}
inline ::mesos::scheduler::Call_AcceptInverseOffers* Call::mutable_accept_inverse_offers() {
  set_has_accept_inverse_offers();
  if (accept_inverse_offers_ == NULL) accept_inverse_offers_ = new ::mesos::scheduler::Call_AcceptInverseOffers;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.accept_inverse_offers)
  return accept_inverse_offers_;
}
inline ::mesos::scheduler::Call_AcceptInverseOffers* Call::release_accept_inverse_offers() {
  clear_has_accept_inverse_offers();
  ::mesos::scheduler::Call_AcceptInverseOffers* temp = accept_inverse_offers_;
  accept_inverse_offers_ = NULL;
  return temp;
}
inline void Call::set_allocated_accept_inverse_offers(::mesos::scheduler::Call_AcceptInverseOffers* accept_inverse_offers) {
  delete accept_inverse_offers_;
  accept_inverse_offers_ = accept_inverse_offers;
  if (accept_inverse_offers) {
    set_has_accept_inverse_offers();
  } else {
    clear_has_accept_inverse_offers();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.accept_inverse_offers)
}

// optional .mesos.scheduler.Call.DeclineInverseOffers decline_inverse_offers = 14;
inline bool Call::has_decline_inverse_offers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Call::set_has_decline_inverse_offers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Call::clear_has_decline_inverse_offers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Call::clear_decline_inverse_offers() {
  if (decline_inverse_offers_ != NULL) decline_inverse_offers_->::mesos::scheduler::Call_DeclineInverseOffers::Clear();
  clear_has_decline_inverse_offers();
}
inline const ::mesos::scheduler::Call_DeclineInverseOffers& Call::decline_inverse_offers() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.decline_inverse_offers)
  return decline_inverse_offers_ != NULL ? *decline_inverse_offers_ : *default_instance_->decline_inverse_offers_;
}
inline ::mesos::scheduler::Call_DeclineInverseOffers* Call::mutable_decline_inverse_offers() {
  set_has_decline_inverse_offers();
  if (decline_inverse_offers_ == NULL) decline_inverse_offers_ = new ::mesos::scheduler::Call_DeclineInverseOffers;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.decline_inverse_offers)
  return decline_inverse_offers_;
}
inline ::mesos::scheduler::Call_DeclineInverseOffers* Call::release_decline_inverse_offers() {
  clear_has_decline_inverse_offers();
  ::mesos::scheduler::Call_DeclineInverseOffers* temp = decline_inverse_offers_;
  decline_inverse_offers_ = NULL;
  return temp;
}
inline void Call::set_allocated_decline_inverse_offers(::mesos::scheduler::Call_DeclineInverseOffers* decline_inverse_offers) {
  delete decline_inverse_offers_;
  decline_inverse_offers_ = decline_inverse_offers;
  if (decline_inverse_offers) {
    set_has_decline_inverse_offers();
  } else {
    clear_has_decline_inverse_offers();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.decline_inverse_offers)
}

// optional .mesos.scheduler.Call.Revive revive = 15;
inline bool Call::has_revive() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Call::set_has_revive() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Call::clear_has_revive() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Call::clear_revive() {
  if (revive_ != NULL) revive_->::mesos::scheduler::Call_Revive::Clear();
  clear_has_revive();
}
inline const ::mesos::scheduler::Call_Revive& Call::revive() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.revive)
  return revive_ != NULL ? *revive_ : *default_instance_->revive_;
}
inline ::mesos::scheduler::Call_Revive* Call::mutable_revive() {
  set_has_revive();
  if (revive_ == NULL) revive_ = new ::mesos::scheduler::Call_Revive;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.revive)
  return revive_;
}
inline ::mesos::scheduler::Call_Revive* Call::release_revive() {
  clear_has_revive();
  ::mesos::scheduler::Call_Revive* temp = revive_;
  revive_ = NULL;
  return temp;
}
inline void Call::set_allocated_revive(::mesos::scheduler::Call_Revive* revive) {
  delete revive_;
  revive_ = revive;
  if (revive) {
    set_has_revive();
  } else {
    clear_has_revive();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.revive)
}

// optional .mesos.scheduler.Call.Kill kill = 6;
inline bool Call::has_kill() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Call::set_has_kill() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Call::clear_has_kill() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Call::clear_kill() {
  if (kill_ != NULL) kill_->::mesos::scheduler::Call_Kill::Clear();
  clear_has_kill();
}
inline const ::mesos::scheduler::Call_Kill& Call::kill() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.kill)
  return kill_ != NULL ? *kill_ : *default_instance_->kill_;
}
inline ::mesos::scheduler::Call_Kill* Call::mutable_kill() {
  set_has_kill();
  if (kill_ == NULL) kill_ = new ::mesos::scheduler::Call_Kill;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.kill)
  return kill_;
}
inline ::mesos::scheduler::Call_Kill* Call::release_kill() {
  clear_has_kill();
  ::mesos::scheduler::Call_Kill* temp = kill_;
  kill_ = NULL;
  return temp;
}
inline void Call::set_allocated_kill(::mesos::scheduler::Call_Kill* kill) {
  delete kill_;
  kill_ = kill;
  if (kill) {
    set_has_kill();
  } else {
    clear_has_kill();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.kill)
}

// optional .mesos.scheduler.Call.Shutdown shutdown = 7;
inline bool Call::has_shutdown() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Call::set_has_shutdown() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Call::clear_has_shutdown() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Call::clear_shutdown() {
  if (shutdown_ != NULL) shutdown_->::mesos::scheduler::Call_Shutdown::Clear();
  clear_has_shutdown();
}
inline const ::mesos::scheduler::Call_Shutdown& Call::shutdown() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.shutdown)
  return shutdown_ != NULL ? *shutdown_ : *default_instance_->shutdown_;
}
inline ::mesos::scheduler::Call_Shutdown* Call::mutable_shutdown() {
  set_has_shutdown();
  if (shutdown_ == NULL) shutdown_ = new ::mesos::scheduler::Call_Shutdown;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.shutdown)
  return shutdown_;
}
inline ::mesos::scheduler::Call_Shutdown* Call::release_shutdown() {
  clear_has_shutdown();
  ::mesos::scheduler::Call_Shutdown* temp = shutdown_;
  shutdown_ = NULL;
  return temp;
}
inline void Call::set_allocated_shutdown(::mesos::scheduler::Call_Shutdown* shutdown) {
  delete shutdown_;
  shutdown_ = shutdown;
  if (shutdown) {
    set_has_shutdown();
  } else {
    clear_has_shutdown();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.shutdown)
}

// optional .mesos.scheduler.Call.Acknowledge acknowledge = 8;
inline bool Call::has_acknowledge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Call::set_has_acknowledge() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Call::clear_has_acknowledge() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Call::clear_acknowledge() {
  if (acknowledge_ != NULL) acknowledge_->::mesos::scheduler::Call_Acknowledge::Clear();
  clear_has_acknowledge();
}
inline const ::mesos::scheduler::Call_Acknowledge& Call::acknowledge() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.acknowledge)
  return acknowledge_ != NULL ? *acknowledge_ : *default_instance_->acknowledge_;
}
inline ::mesos::scheduler::Call_Acknowledge* Call::mutable_acknowledge() {
  set_has_acknowledge();
  if (acknowledge_ == NULL) acknowledge_ = new ::mesos::scheduler::Call_Acknowledge;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.acknowledge)
  return acknowledge_;
}
inline ::mesos::scheduler::Call_Acknowledge* Call::release_acknowledge() {
  clear_has_acknowledge();
  ::mesos::scheduler::Call_Acknowledge* temp = acknowledge_;
  acknowledge_ = NULL;
  return temp;
}
inline void Call::set_allocated_acknowledge(::mesos::scheduler::Call_Acknowledge* acknowledge) {
  delete acknowledge_;
  acknowledge_ = acknowledge;
  if (acknowledge) {
    set_has_acknowledge();
  } else {
    clear_has_acknowledge();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.acknowledge)
}

// optional .mesos.scheduler.Call.Reconcile reconcile = 9;
inline bool Call::has_reconcile() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Call::set_has_reconcile() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Call::clear_has_reconcile() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Call::clear_reconcile() {
  if (reconcile_ != NULL) reconcile_->::mesos::scheduler::Call_Reconcile::Clear();
  clear_has_reconcile();
}
inline const ::mesos::scheduler::Call_Reconcile& Call::reconcile() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.reconcile)
  return reconcile_ != NULL ? *reconcile_ : *default_instance_->reconcile_;
}
inline ::mesos::scheduler::Call_Reconcile* Call::mutable_reconcile() {
  set_has_reconcile();
  if (reconcile_ == NULL) reconcile_ = new ::mesos::scheduler::Call_Reconcile;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.reconcile)
  return reconcile_;
}
inline ::mesos::scheduler::Call_Reconcile* Call::release_reconcile() {
  clear_has_reconcile();
  ::mesos::scheduler::Call_Reconcile* temp = reconcile_;
  reconcile_ = NULL;
  return temp;
}
inline void Call::set_allocated_reconcile(::mesos::scheduler::Call_Reconcile* reconcile) {
  delete reconcile_;
  reconcile_ = reconcile;
  if (reconcile) {
    set_has_reconcile();
  } else {
    clear_has_reconcile();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.reconcile)
}

// optional .mesos.scheduler.Call.Message message = 10;
inline bool Call::has_message() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Call::set_has_message() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Call::clear_has_message() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Call::clear_message() {
  if (message_ != NULL) message_->::mesos::scheduler::Call_Message::Clear();
  clear_has_message();
}
inline const ::mesos::scheduler::Call_Message& Call::message() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::mesos::scheduler::Call_Message* Call::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::mesos::scheduler::Call_Message;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.message)
  return message_;
}
inline ::mesos::scheduler::Call_Message* Call::release_message() {
  clear_has_message();
  ::mesos::scheduler::Call_Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline void Call::set_allocated_message(::mesos::scheduler::Call_Message* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.message)
}

// optional .mesos.scheduler.Call.Request request = 11;
inline bool Call::has_request() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Call::set_has_request() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Call::clear_has_request() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Call::clear_request() {
  if (request_ != NULL) request_->::mesos::scheduler::Call_Request::Clear();
  clear_has_request();
}
inline const ::mesos::scheduler::Call_Request& Call::request() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::mesos::scheduler::Call_Request* Call::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::mesos::scheduler::Call_Request;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.request)
  return request_;
}
inline ::mesos::scheduler::Call_Request* Call::release_request() {
  clear_has_request();
  ::mesos::scheduler::Call_Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Call::set_allocated_request(::mesos::scheduler::Call_Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.request)
}

// optional .mesos.scheduler.Call.Suppress suppress = 16;
inline bool Call::has_suppress() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Call::set_has_suppress() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Call::clear_has_suppress() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Call::clear_suppress() {
  if (suppress_ != NULL) suppress_->::mesos::scheduler::Call_Suppress::Clear();
  clear_has_suppress();
}
inline const ::mesos::scheduler::Call_Suppress& Call::suppress() const {
  // @@protoc_insertion_point(field_get:mesos.scheduler.Call.suppress)
  return suppress_ != NULL ? *suppress_ : *default_instance_->suppress_;
}
inline ::mesos::scheduler::Call_Suppress* Call::mutable_suppress() {
  set_has_suppress();
  if (suppress_ == NULL) suppress_ = new ::mesos::scheduler::Call_Suppress;
  // @@protoc_insertion_point(field_mutable:mesos.scheduler.Call.suppress)
  return suppress_;
}
inline ::mesos::scheduler::Call_Suppress* Call::release_suppress() {
  clear_has_suppress();
  ::mesos::scheduler::Call_Suppress* temp = suppress_;
  suppress_ = NULL;
  return temp;
}
inline void Call::set_allocated_suppress(::mesos::scheduler::Call_Suppress* suppress) {
  delete suppress_;
  suppress_ = suppress;
  if (suppress) {
    set_has_suppress();
  } else {
    clear_has_suppress();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.scheduler.Call.suppress)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace scheduler
}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mesos::scheduler::Event_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Event_Type>() {
  return ::mesos::scheduler::Event_Type_descriptor();
}
template <> struct is_proto_enum< ::mesos::scheduler::Call_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::scheduler::Call_Type>() {
  return ::mesos::scheduler::Call_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_scheduler_2eproto__INCLUDED
