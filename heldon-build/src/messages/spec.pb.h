// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spec.proto

#ifndef PROTOBUF_spec_2eproto__INCLUDED
#define PROTOBUF_spec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace appc {
namespace spec {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_spec_2eproto();
void protobuf_AssignDesc_spec_2eproto();
void protobuf_ShutdownFile_spec_2eproto();

class ImageManifest;
class ImageManifest_Label;
class ImageManifest_Environment;
class ImageManifest_App;
class ImageManifest_Annotation;
class ImageManifest_Dependency;

// ===================================================================

class ImageManifest_Label : public ::google::protobuf::Message {
 public:
  ImageManifest_Label();
  virtual ~ImageManifest_Label();

  ImageManifest_Label(const ImageManifest_Label& from);

  inline ImageManifest_Label& operator=(const ImageManifest_Label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Label& default_instance();

  void Swap(ImageManifest_Label* other);

  // implements Message ----------------------------------------------

  ImageManifest_Label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest_Label& from);
  void MergeFrom(const ImageManifest_Label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Label)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_spec_2eproto();
  friend void protobuf_AssignDesc_spec_2eproto();
  friend void protobuf_ShutdownFile_spec_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest_Label* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest_Environment : public ::google::protobuf::Message {
 public:
  ImageManifest_Environment();
  virtual ~ImageManifest_Environment();

  ImageManifest_Environment(const ImageManifest_Environment& from);

  inline ImageManifest_Environment& operator=(const ImageManifest_Environment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Environment& default_instance();

  void Swap(ImageManifest_Environment* other);

  // implements Message ----------------------------------------------

  ImageManifest_Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest_Environment& from);
  void MergeFrom(const ImageManifest_Environment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Environment)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_spec_2eproto();
  friend void protobuf_AssignDesc_spec_2eproto();
  friend void protobuf_ShutdownFile_spec_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest_Environment* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest_App : public ::google::protobuf::Message {
 public:
  ImageManifest_App();
  virtual ~ImageManifest_App();

  ImageManifest_App(const ImageManifest_App& from);

  inline ImageManifest_App& operator=(const ImageManifest_App& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_App& default_instance();

  void Swap(ImageManifest_App* other);

  // implements Message ----------------------------------------------

  ImageManifest_App* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest_App& from);
  void MergeFrom(const ImageManifest_App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string exec = 1;
  inline int exec_size() const;
  inline void clear_exec();
  static const int kExecFieldNumber = 1;
  inline const ::std::string& exec(int index) const;
  inline ::std::string* mutable_exec(int index);
  inline void set_exec(int index, const ::std::string& value);
  inline void set_exec(int index, const char* value);
  inline void set_exec(int index, const char* value, size_t size);
  inline ::std::string* add_exec();
  inline void add_exec(const ::std::string& value);
  inline void add_exec(const char* value);
  inline void add_exec(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exec() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exec();

  // optional string workingDirectory = 2;
  inline bool has_workingdirectory() const;
  inline void clear_workingdirectory();
  static const int kWorkingDirectoryFieldNumber = 2;
  inline const ::std::string& workingdirectory() const;
  inline void set_workingdirectory(const ::std::string& value);
  inline void set_workingdirectory(const char* value);
  inline void set_workingdirectory(const char* value, size_t size);
  inline ::std::string* mutable_workingdirectory();
  inline ::std::string* release_workingdirectory();
  inline void set_allocated_workingdirectory(::std::string* workingdirectory);

  // repeated .appc.spec.ImageManifest.Environment environment = 3;
  inline int environment_size() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 3;
  inline const ::appc::spec::ImageManifest_Environment& environment(int index) const;
  inline ::appc::spec::ImageManifest_Environment* mutable_environment(int index);
  inline ::appc::spec::ImageManifest_Environment* add_environment();
  inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >&
      environment() const;
  inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >*
      mutable_environment();

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.App)
 private:
  inline void set_has_workingdirectory();
  inline void clear_has_workingdirectory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exec_;
  ::std::string* workingdirectory_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment > environment_;
  friend void  protobuf_AddDesc_spec_2eproto();
  friend void protobuf_AssignDesc_spec_2eproto();
  friend void protobuf_ShutdownFile_spec_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest_App* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest_Annotation : public ::google::protobuf::Message {
 public:
  ImageManifest_Annotation();
  virtual ~ImageManifest_Annotation();

  ImageManifest_Annotation(const ImageManifest_Annotation& from);

  inline ImageManifest_Annotation& operator=(const ImageManifest_Annotation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Annotation& default_instance();

  void Swap(ImageManifest_Annotation* other);

  // implements Message ----------------------------------------------

  ImageManifest_Annotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest_Annotation& from);
  void MergeFrom(const ImageManifest_Annotation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Annotation)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_spec_2eproto();
  friend void protobuf_AssignDesc_spec_2eproto();
  friend void protobuf_ShutdownFile_spec_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest_Annotation* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest_Dependency : public ::google::protobuf::Message {
 public:
  ImageManifest_Dependency();
  virtual ~ImageManifest_Dependency();

  ImageManifest_Dependency(const ImageManifest_Dependency& from);

  inline ImageManifest_Dependency& operator=(const ImageManifest_Dependency& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Dependency& default_instance();

  void Swap(ImageManifest_Dependency* other);

  // implements Message ----------------------------------------------

  ImageManifest_Dependency* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest_Dependency& from);
  void MergeFrom(const ImageManifest_Dependency& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string imageName = 1;
  inline bool has_imagename() const;
  inline void clear_imagename();
  static const int kImageNameFieldNumber = 1;
  inline const ::std::string& imagename() const;
  inline void set_imagename(const ::std::string& value);
  inline void set_imagename(const char* value);
  inline void set_imagename(const char* value, size_t size);
  inline ::std::string* mutable_imagename();
  inline ::std::string* release_imagename();
  inline void set_allocated_imagename(::std::string* imagename);

  // optional string imageID = 2;
  inline bool has_imageid() const;
  inline void clear_imageid();
  static const int kImageIDFieldNumber = 2;
  inline const ::std::string& imageid() const;
  inline void set_imageid(const ::std::string& value);
  inline void set_imageid(const char* value);
  inline void set_imageid(const char* value, size_t size);
  inline ::std::string* mutable_imageid();
  inline ::std::string* release_imageid();
  inline void set_allocated_imageid(::std::string* imageid);

  // repeated .appc.spec.ImageManifest.Label labels = 3;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 3;
  inline const ::appc::spec::ImageManifest_Label& labels(int index) const;
  inline ::appc::spec::ImageManifest_Label* mutable_labels(int index);
  inline ::appc::spec::ImageManifest_Label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
      mutable_labels();

  // optional uint64 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest.Dependency)
 private:
  inline void set_has_imagename();
  inline void clear_has_imagename();
  inline void set_has_imageid();
  inline void clear_has_imageid();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* imagename_;
  ::std::string* imageid_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label > labels_;
  ::google::protobuf::uint64 size_;
  friend void  protobuf_AddDesc_spec_2eproto();
  friend void protobuf_AssignDesc_spec_2eproto();
  friend void protobuf_ShutdownFile_spec_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest_Dependency* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest : public ::google::protobuf::Message {
 public:
  ImageManifest();
  virtual ~ImageManifest();

  ImageManifest(const ImageManifest& from);

  inline ImageManifest& operator=(const ImageManifest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest& default_instance();

  void Swap(ImageManifest* other);

  // implements Message ----------------------------------------------

  ImageManifest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest& from);
  void MergeFrom(const ImageManifest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ImageManifest_Label Label;
  typedef ImageManifest_Environment Environment;
  typedef ImageManifest_App App;
  typedef ImageManifest_Annotation Annotation;
  typedef ImageManifest_Dependency Dependency;

  // accessors -------------------------------------------------------

  // required string acKind = 1;
  inline bool has_ackind() const;
  inline void clear_ackind();
  static const int kAcKindFieldNumber = 1;
  inline const ::std::string& ackind() const;
  inline void set_ackind(const ::std::string& value);
  inline void set_ackind(const char* value);
  inline void set_ackind(const char* value, size_t size);
  inline ::std::string* mutable_ackind();
  inline ::std::string* release_ackind();
  inline void set_allocated_ackind(::std::string* ackind);

  // required string acVersion = 2;
  inline bool has_acversion() const;
  inline void clear_acversion();
  static const int kAcVersionFieldNumber = 2;
  inline const ::std::string& acversion() const;
  inline void set_acversion(const ::std::string& value);
  inline void set_acversion(const char* value);
  inline void set_acversion(const char* value, size_t size);
  inline ::std::string* mutable_acversion();
  inline ::std::string* release_acversion();
  inline void set_allocated_acversion(::std::string* acversion);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .appc.spec.ImageManifest.Label labels = 4;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 4;
  inline const ::appc::spec::ImageManifest_Label& labels(int index) const;
  inline ::appc::spec::ImageManifest_Label* mutable_labels(int index);
  inline ::appc::spec::ImageManifest_Label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
      mutable_labels();

  // optional .appc.spec.ImageManifest.App app = 7;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 7;
  inline const ::appc::spec::ImageManifest_App& app() const;
  inline ::appc::spec::ImageManifest_App* mutable_app();
  inline ::appc::spec::ImageManifest_App* release_app();
  inline void set_allocated_app(::appc::spec::ImageManifest_App* app);

  // repeated .appc.spec.ImageManifest.Annotation annotations = 5;
  inline int annotations_size() const;
  inline void clear_annotations();
  static const int kAnnotationsFieldNumber = 5;
  inline const ::appc::spec::ImageManifest_Annotation& annotations(int index) const;
  inline ::appc::spec::ImageManifest_Annotation* mutable_annotations(int index);
  inline ::appc::spec::ImageManifest_Annotation* add_annotations();
  inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >&
      annotations() const;
  inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >*
      mutable_annotations();

  // repeated .appc.spec.ImageManifest.Dependency dependencies = 6;
  inline int dependencies_size() const;
  inline void clear_dependencies();
  static const int kDependenciesFieldNumber = 6;
  inline const ::appc::spec::ImageManifest_Dependency& dependencies(int index) const;
  inline ::appc::spec::ImageManifest_Dependency* mutable_dependencies(int index);
  inline ::appc::spec::ImageManifest_Dependency* add_dependencies();
  inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >&
      dependencies() const;
  inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >*
      mutable_dependencies();

  // @@protoc_insertion_point(class_scope:appc.spec.ImageManifest)
 private:
  inline void set_has_ackind();
  inline void clear_has_ackind();
  inline void set_has_acversion();
  inline void clear_has_acversion();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_app();
  inline void clear_has_app();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ackind_;
  ::std::string* acversion_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label > labels_;
  ::appc::spec::ImageManifest_App* app_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation > annotations_;
  ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency > dependencies_;
  friend void  protobuf_AddDesc_spec_2eproto();
  friend void protobuf_AssignDesc_spec_2eproto();
  friend void protobuf_ShutdownFile_spec_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest* default_instance_;
};
// ===================================================================


// ===================================================================

// ImageManifest_Label

// required string name = 1;
inline bool ImageManifest_Label::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Label::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Label::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Label::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImageManifest_Label::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Label.name)
  return *name_;
}
inline void ImageManifest_Label::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Label.name)
}
inline void ImageManifest_Label::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Label.name)
}
inline void ImageManifest_Label::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Label.name)
}
inline ::std::string* ImageManifest_Label::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Label.name)
  return name_;
}
inline ::std::string* ImageManifest_Label::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Label::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Label.name)
}

// required string value = 2;
inline bool ImageManifest_Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Label::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ImageManifest_Label::value() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Label.value)
  return *value_;
}
inline void ImageManifest_Label::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Label.value)
}
inline void ImageManifest_Label::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Label.value)
}
inline void ImageManifest_Label::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Label.value)
}
inline ::std::string* ImageManifest_Label::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Label.value)
  return value_;
}
inline ::std::string* ImageManifest_Label::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Label::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Label.value)
}

// -------------------------------------------------------------------

// ImageManifest_Environment

// required string name = 1;
inline bool ImageManifest_Environment::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Environment::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Environment::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Environment::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImageManifest_Environment::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Environment.name)
  return *name_;
}
inline void ImageManifest_Environment::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Environment.name)
}
inline void ImageManifest_Environment::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Environment.name)
}
inline void ImageManifest_Environment::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Environment.name)
}
inline ::std::string* ImageManifest_Environment::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Environment.name)
  return name_;
}
inline ::std::string* ImageManifest_Environment::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Environment::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Environment.name)
}

// required string value = 2;
inline bool ImageManifest_Environment::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Environment::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Environment::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Environment::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ImageManifest_Environment::value() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Environment.value)
  return *value_;
}
inline void ImageManifest_Environment::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Environment.value)
}
inline void ImageManifest_Environment::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Environment.value)
}
inline void ImageManifest_Environment::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Environment.value)
}
inline ::std::string* ImageManifest_Environment::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Environment.value)
  return value_;
}
inline ::std::string* ImageManifest_Environment::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Environment::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Environment.value)
}

// -------------------------------------------------------------------

// ImageManifest_App

// repeated string exec = 1;
inline int ImageManifest_App::exec_size() const {
  return exec_.size();
}
inline void ImageManifest_App::clear_exec() {
  exec_.Clear();
}
inline const ::std::string& ImageManifest_App::exec(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.App.exec)
  return exec_.Get(index);
}
inline ::std::string* ImageManifest_App::mutable_exec(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.App.exec)
  return exec_.Mutable(index);
}
inline void ImageManifest_App::set_exec(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.App.exec)
  exec_.Mutable(index)->assign(value);
}
inline void ImageManifest_App::set_exec(int index, const char* value) {
  exec_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.App.exec)
}
inline void ImageManifest_App::set_exec(int index, const char* value, size_t size) {
  exec_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.App.exec)
}
inline ::std::string* ImageManifest_App::add_exec() {
  return exec_.Add();
}
inline void ImageManifest_App::add_exec(const ::std::string& value) {
  exec_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.App.exec)
}
inline void ImageManifest_App::add_exec(const char* value) {
  exec_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:appc.spec.ImageManifest.App.exec)
}
inline void ImageManifest_App::add_exec(const char* value, size_t size) {
  exec_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:appc.spec.ImageManifest.App.exec)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_App::exec() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.App.exec)
  return exec_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_App::mutable_exec() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.App.exec)
  return &exec_;
}

// optional string workingDirectory = 2;
inline bool ImageManifest_App::has_workingdirectory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_App::set_has_workingdirectory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_App::clear_has_workingdirectory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_App::clear_workingdirectory() {
  if (workingdirectory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdirectory_->clear();
  }
  clear_has_workingdirectory();
}
inline const ::std::string& ImageManifest_App::workingdirectory() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.App.workingDirectory)
  return *workingdirectory_;
}
inline void ImageManifest_App::set_workingdirectory(const ::std::string& value) {
  set_has_workingdirectory();
  if (workingdirectory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdirectory_ = new ::std::string;
  }
  workingdirectory_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.App.workingDirectory)
}
inline void ImageManifest_App::set_workingdirectory(const char* value) {
  set_has_workingdirectory();
  if (workingdirectory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdirectory_ = new ::std::string;
  }
  workingdirectory_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.App.workingDirectory)
}
inline void ImageManifest_App::set_workingdirectory(const char* value, size_t size) {
  set_has_workingdirectory();
  if (workingdirectory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdirectory_ = new ::std::string;
  }
  workingdirectory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.App.workingDirectory)
}
inline ::std::string* ImageManifest_App::mutable_workingdirectory() {
  set_has_workingdirectory();
  if (workingdirectory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdirectory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.App.workingDirectory)
  return workingdirectory_;
}
inline ::std::string* ImageManifest_App::release_workingdirectory() {
  clear_has_workingdirectory();
  if (workingdirectory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workingdirectory_;
    workingdirectory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_App::set_allocated_workingdirectory(::std::string* workingdirectory) {
  if (workingdirectory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workingdirectory_;
  }
  if (workingdirectory) {
    set_has_workingdirectory();
    workingdirectory_ = workingdirectory;
  } else {
    clear_has_workingdirectory();
    workingdirectory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.App.workingDirectory)
}

// repeated .appc.spec.ImageManifest.Environment environment = 3;
inline int ImageManifest_App::environment_size() const {
  return environment_.size();
}
inline void ImageManifest_App::clear_environment() {
  environment_.Clear();
}
inline const ::appc::spec::ImageManifest_Environment& ImageManifest_App::environment(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.App.environment)
  return environment_.Get(index);
}
inline ::appc::spec::ImageManifest_Environment* ImageManifest_App::mutable_environment(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.App.environment)
  return environment_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Environment* ImageManifest_App::add_environment() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.App.environment)
  return environment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >&
ImageManifest_App::environment() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.App.environment)
  return environment_;
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Environment >*
ImageManifest_App::mutable_environment() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.App.environment)
  return &environment_;
}

// -------------------------------------------------------------------

// ImageManifest_Annotation

// required string name = 1;
inline bool ImageManifest_Annotation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Annotation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Annotation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Annotation::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImageManifest_Annotation::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Annotation.name)
  return *name_;
}
inline void ImageManifest_Annotation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Annotation.name)
}
inline void ImageManifest_Annotation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Annotation.name)
}
inline void ImageManifest_Annotation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Annotation.name)
}
inline ::std::string* ImageManifest_Annotation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Annotation.name)
  return name_;
}
inline ::std::string* ImageManifest_Annotation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Annotation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Annotation.name)
}

// required string value = 2;
inline bool ImageManifest_Annotation::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Annotation::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Annotation::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Annotation::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ImageManifest_Annotation::value() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Annotation.value)
  return *value_;
}
inline void ImageManifest_Annotation::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Annotation.value)
}
inline void ImageManifest_Annotation::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Annotation.value)
}
inline void ImageManifest_Annotation::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Annotation.value)
}
inline ::std::string* ImageManifest_Annotation::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Annotation.value)
  return value_;
}
inline ::std::string* ImageManifest_Annotation::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Annotation::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Annotation.value)
}

// -------------------------------------------------------------------

// ImageManifest_Dependency

// required string imageName = 1;
inline bool ImageManifest_Dependency::has_imagename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Dependency::set_has_imagename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Dependency::clear_has_imagename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Dependency::clear_imagename() {
  if (imagename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagename_->clear();
  }
  clear_has_imagename();
}
inline const ::std::string& ImageManifest_Dependency::imagename() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.imageName)
  return *imagename_;
}
inline void ImageManifest_Dependency::set_imagename(const ::std::string& value) {
  set_has_imagename();
  if (imagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagename_ = new ::std::string;
  }
  imagename_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Dependency.imageName)
}
inline void ImageManifest_Dependency::set_imagename(const char* value) {
  set_has_imagename();
  if (imagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagename_ = new ::std::string;
  }
  imagename_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Dependency.imageName)
}
inline void ImageManifest_Dependency::set_imagename(const char* value, size_t size) {
  set_has_imagename();
  if (imagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagename_ = new ::std::string;
  }
  imagename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Dependency.imageName)
}
inline ::std::string* ImageManifest_Dependency::mutable_imagename() {
  set_has_imagename();
  if (imagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Dependency.imageName)
  return imagename_;
}
inline ::std::string* ImageManifest_Dependency::release_imagename() {
  clear_has_imagename();
  if (imagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imagename_;
    imagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Dependency::set_allocated_imagename(::std::string* imagename) {
  if (imagename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imagename_;
  }
  if (imagename) {
    set_has_imagename();
    imagename_ = imagename;
  } else {
    clear_has_imagename();
    imagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Dependency.imageName)
}

// optional string imageID = 2;
inline bool ImageManifest_Dependency::has_imageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest_Dependency::set_has_imageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest_Dependency::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest_Dependency::clear_imageid() {
  if (imageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imageid_->clear();
  }
  clear_has_imageid();
}
inline const ::std::string& ImageManifest_Dependency::imageid() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.imageID)
  return *imageid_;
}
inline void ImageManifest_Dependency::set_imageid(const ::std::string& value) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Dependency.imageID)
}
inline void ImageManifest_Dependency::set_imageid(const char* value) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.Dependency.imageID)
}
inline void ImageManifest_Dependency::set_imageid(const char* value, size_t size) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.Dependency.imageID)
}
inline ::std::string* ImageManifest_Dependency::mutable_imageid() {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imageid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Dependency.imageID)
  return imageid_;
}
inline ::std::string* ImageManifest_Dependency::release_imageid() {
  clear_has_imageid();
  if (imageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imageid_;
    imageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Dependency::set_allocated_imageid(::std::string* imageid) {
  if (imageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imageid_;
  }
  if (imageid) {
    set_has_imageid();
    imageid_ = imageid;
  } else {
    clear_has_imageid();
    imageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.Dependency.imageID)
}

// repeated .appc.spec.ImageManifest.Label labels = 3;
inline int ImageManifest_Dependency::labels_size() const {
  return labels_.size();
}
inline void ImageManifest_Dependency::clear_labels() {
  labels_.Clear();
}
inline const ::appc::spec::ImageManifest_Label& ImageManifest_Dependency::labels(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.labels)
  return labels_.Get(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest_Dependency::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.Dependency.labels)
  return labels_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest_Dependency::add_labels() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.Dependency.labels)
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
ImageManifest_Dependency::labels() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.Dependency.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
ImageManifest_Dependency::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.Dependency.labels)
  return &labels_;
}

// optional uint64 size = 4;
inline bool ImageManifest_Dependency::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest_Dependency::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest_Dependency::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest_Dependency::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 ImageManifest_Dependency::size() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.Dependency.size)
  return size_;
}
inline void ImageManifest_Dependency::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.Dependency.size)
}

// -------------------------------------------------------------------

// ImageManifest

// required string acKind = 1;
inline bool ImageManifest::has_ackind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest::set_has_ackind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest::clear_has_ackind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest::clear_ackind() {
  if (ackind_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ackind_->clear();
  }
  clear_has_ackind();
}
inline const ::std::string& ImageManifest::ackind() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.acKind)
  return *ackind_;
}
inline void ImageManifest::set_ackind(const ::std::string& value) {
  set_has_ackind();
  if (ackind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ackind_ = new ::std::string;
  }
  ackind_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.acKind)
}
inline void ImageManifest::set_ackind(const char* value) {
  set_has_ackind();
  if (ackind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ackind_ = new ::std::string;
  }
  ackind_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.acKind)
}
inline void ImageManifest::set_ackind(const char* value, size_t size) {
  set_has_ackind();
  if (ackind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ackind_ = new ::std::string;
  }
  ackind_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.acKind)
}
inline ::std::string* ImageManifest::mutable_ackind() {
  set_has_ackind();
  if (ackind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ackind_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.acKind)
  return ackind_;
}
inline ::std::string* ImageManifest::release_ackind() {
  clear_has_ackind();
  if (ackind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ackind_;
    ackind_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_ackind(::std::string* ackind) {
  if (ackind_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ackind_;
  }
  if (ackind) {
    set_has_ackind();
    ackind_ = ackind;
  } else {
    clear_has_ackind();
    ackind_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.acKind)
}

// required string acVersion = 2;
inline bool ImageManifest::has_acversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest::set_has_acversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest::clear_has_acversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest::clear_acversion() {
  if (acversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acversion_->clear();
  }
  clear_has_acversion();
}
inline const ::std::string& ImageManifest::acversion() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.acVersion)
  return *acversion_;
}
inline void ImageManifest::set_acversion(const ::std::string& value) {
  set_has_acversion();
  if (acversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acversion_ = new ::std::string;
  }
  acversion_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.acVersion)
}
inline void ImageManifest::set_acversion(const char* value) {
  set_has_acversion();
  if (acversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acversion_ = new ::std::string;
  }
  acversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.acVersion)
}
inline void ImageManifest::set_acversion(const char* value, size_t size) {
  set_has_acversion();
  if (acversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acversion_ = new ::std::string;
  }
  acversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.acVersion)
}
inline ::std::string* ImageManifest::mutable_acversion() {
  set_has_acversion();
  if (acversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.acVersion)
  return acversion_;
}
inline ::std::string* ImageManifest::release_acversion() {
  clear_has_acversion();
  if (acversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = acversion_;
    acversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_acversion(::std::string* acversion) {
  if (acversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete acversion_;
  }
  if (acversion) {
    set_has_acversion();
    acversion_ = acversion;
  } else {
    clear_has_acversion();
    acversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.acVersion)
}

// required string name = 3;
inline bool ImageManifest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImageManifest::name() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.name)
  return *name_;
}
inline void ImageManifest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:appc.spec.ImageManifest.name)
}
inline void ImageManifest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:appc.spec.ImageManifest.name)
}
inline void ImageManifest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:appc.spec.ImageManifest.name)
}
inline ::std::string* ImageManifest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.name)
  return name_;
}
inline ::std::string* ImageManifest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.name)
}

// repeated .appc.spec.ImageManifest.Label labels = 4;
inline int ImageManifest::labels_size() const {
  return labels_.size();
}
inline void ImageManifest::clear_labels() {
  labels_.Clear();
}
inline const ::appc::spec::ImageManifest_Label& ImageManifest::labels(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.labels)
  return labels_.Get(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.labels)
  return labels_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Label* ImageManifest::add_labels() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.labels)
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >&
ImageManifest::labels() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Label >*
ImageManifest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.labels)
  return &labels_;
}

// optional .appc.spec.ImageManifest.App app = 7;
inline bool ImageManifest::has_app() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageManifest::set_has_app() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageManifest::clear_has_app() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageManifest::clear_app() {
  if (app_ != NULL) app_->::appc::spec::ImageManifest_App::Clear();
  clear_has_app();
}
inline const ::appc::spec::ImageManifest_App& ImageManifest::app() const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.app)
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::appc::spec::ImageManifest_App* ImageManifest::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::appc::spec::ImageManifest_App;
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.app)
  return app_;
}
inline ::appc::spec::ImageManifest_App* ImageManifest::release_app() {
  clear_has_app();
  ::appc::spec::ImageManifest_App* temp = app_;
  app_ = NULL;
  return temp;
}
inline void ImageManifest::set_allocated_app(::appc::spec::ImageManifest_App* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
  // @@protoc_insertion_point(field_set_allocated:appc.spec.ImageManifest.app)
}

// repeated .appc.spec.ImageManifest.Annotation annotations = 5;
inline int ImageManifest::annotations_size() const {
  return annotations_.size();
}
inline void ImageManifest::clear_annotations() {
  annotations_.Clear();
}
inline const ::appc::spec::ImageManifest_Annotation& ImageManifest::annotations(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.annotations)
  return annotations_.Get(index);
}
inline ::appc::spec::ImageManifest_Annotation* ImageManifest::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.annotations)
  return annotations_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Annotation* ImageManifest::add_annotations() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.annotations)
  return annotations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >&
ImageManifest::annotations() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.annotations)
  return annotations_;
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Annotation >*
ImageManifest::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.annotations)
  return &annotations_;
}

// repeated .appc.spec.ImageManifest.Dependency dependencies = 6;
inline int ImageManifest::dependencies_size() const {
  return dependencies_.size();
}
inline void ImageManifest::clear_dependencies() {
  dependencies_.Clear();
}
inline const ::appc::spec::ImageManifest_Dependency& ImageManifest::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:appc.spec.ImageManifest.dependencies)
  return dependencies_.Get(index);
}
inline ::appc::spec::ImageManifest_Dependency* ImageManifest::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:appc.spec.ImageManifest.dependencies)
  return dependencies_.Mutable(index);
}
inline ::appc::spec::ImageManifest_Dependency* ImageManifest::add_dependencies() {
  // @@protoc_insertion_point(field_add:appc.spec.ImageManifest.dependencies)
  return dependencies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >&
ImageManifest::dependencies() const {
  // @@protoc_insertion_point(field_list:appc.spec.ImageManifest.dependencies)
  return dependencies_;
}
inline ::google::protobuf::RepeatedPtrField< ::appc::spec::ImageManifest_Dependency >*
ImageManifest::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:appc.spec.ImageManifest.dependencies)
  return &dependencies_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace spec
}  // namespace appc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_spec_2eproto__INCLUDED
