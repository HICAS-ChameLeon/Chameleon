// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: super_master_related.proto

#ifndef PROTOBUF_super_5fmaster_5frelated_2eproto__INCLUDED
#define PROTOBUF_super_5fmaster_5frelated_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "hardware_resource.pb.h"
#include "runtime_resource.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

class ChameleonMasterINFO;
class Address;
class MasterRegisteredMessage;
class SlavesInfoControlledByMaster;
class MasterInfoControlledBySuperMaster;
class SuperMasterControlMessage;
class AcceptRegisteredMessage;
class SlaveInfo;
class OwnedSlavesMessage;
class TerminatingMasterMessage;
class AdministeredSlavesMessage;
class LaunchMasterMessage;

enum MasterRegisteredMessage_Status {
  MasterRegisteredMessage_Status_FIRST_REGISTERING = 0,
  MasterRegisteredMessage_Status_REREGISTERING = 1
};
bool MasterRegisteredMessage_Status_IsValid(int value);
const MasterRegisteredMessage_Status MasterRegisteredMessage_Status_Status_MIN = MasterRegisteredMessage_Status_FIRST_REGISTERING;
const MasterRegisteredMessage_Status MasterRegisteredMessage_Status_Status_MAX = MasterRegisteredMessage_Status_REREGISTERING;
const int MasterRegisteredMessage_Status_Status_ARRAYSIZE = MasterRegisteredMessage_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* MasterRegisteredMessage_Status_descriptor();
inline const ::std::string& MasterRegisteredMessage_Status_Name(MasterRegisteredMessage_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    MasterRegisteredMessage_Status_descriptor(), value);
}
inline bool MasterRegisteredMessage_Status_Parse(
    const ::std::string& name, MasterRegisteredMessage_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MasterRegisteredMessage_Status>(
    MasterRegisteredMessage_Status_descriptor(), name, value);
}
enum AcceptRegisteredMessage_Status {
  AcceptRegisteredMessage_Status_SUCCESS = 0,
  AcceptRegisteredMessage_Status_FAILURE = 1
};
bool AcceptRegisteredMessage_Status_IsValid(int value);
const AcceptRegisteredMessage_Status AcceptRegisteredMessage_Status_Status_MIN = AcceptRegisteredMessage_Status_SUCCESS;
const AcceptRegisteredMessage_Status AcceptRegisteredMessage_Status_Status_MAX = AcceptRegisteredMessage_Status_FAILURE;
const int AcceptRegisteredMessage_Status_Status_ARRAYSIZE = AcceptRegisteredMessage_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* AcceptRegisteredMessage_Status_descriptor();
inline const ::std::string& AcceptRegisteredMessage_Status_Name(AcceptRegisteredMessage_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    AcceptRegisteredMessage_Status_descriptor(), value);
}
inline bool AcceptRegisteredMessage_Status_Parse(
    const ::std::string& name, AcceptRegisteredMessage_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AcceptRegisteredMessage_Status>(
    AcceptRegisteredMessage_Status_descriptor(), name, value);
}
// ===================================================================

class ChameleonMasterINFO : public ::google::protobuf::Message {
 public:
  ChameleonMasterINFO();
  virtual ~ChameleonMasterINFO();

  ChameleonMasterINFO(const ChameleonMasterINFO& from);

  inline ChameleonMasterINFO& operator=(const ChameleonMasterINFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChameleonMasterINFO& default_instance();

  void Swap(ChameleonMasterINFO* other);

  // implements Message ----------------------------------------------

  ChameleonMasterINFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChameleonMasterINFO& from);
  void MergeFrom(const ChameleonMasterINFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string pid = 4;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 4;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .Address address = 7;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 7;
  inline const ::Address& address() const;
  inline ::Address* mutable_address();
  inline ::Address* release_address();
  inline void set_allocated_address(::Address* address);

  // @@protoc_insertion_point(class_scope:ChameleonMasterINFO)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* pid_;
  ::std::string* hostname_;
  ::std::string* version_;
  ::Address* address_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static ChameleonMasterINFO* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Address)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hostname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class MasterRegisteredMessage : public ::google::protobuf::Message {
 public:
  MasterRegisteredMessage();
  virtual ~MasterRegisteredMessage();

  MasterRegisteredMessage(const MasterRegisteredMessage& from);

  inline MasterRegisteredMessage& operator=(const MasterRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterRegisteredMessage& default_instance();

  void Swap(MasterRegisteredMessage* other);

  // implements Message ----------------------------------------------

  MasterRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterRegisteredMessage& from);
  void MergeFrom(const MasterRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MasterRegisteredMessage_Status Status;
  static const Status FIRST_REGISTERING = MasterRegisteredMessage_Status_FIRST_REGISTERING;
  static const Status REREGISTERING = MasterRegisteredMessage_Status_REREGISTERING;
  static inline bool Status_IsValid(int value) {
    return MasterRegisteredMessage_Status_IsValid(value);
  }
  static const Status Status_MIN =
    MasterRegisteredMessage_Status_Status_MIN;
  static const Status Status_MAX =
    MasterRegisteredMessage_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    MasterRegisteredMessage_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return MasterRegisteredMessage_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return MasterRegisteredMessage_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return MasterRegisteredMessage_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string master_id = 1;
  inline bool has_master_id() const;
  inline void clear_master_id();
  static const int kMasterIdFieldNumber = 1;
  inline const ::std::string& master_id() const;
  inline void set_master_id(const ::std::string& value);
  inline void set_master_id(const char* value);
  inline void set_master_id(const char* value, size_t size);
  inline ::std::string* mutable_master_id();
  inline ::std::string* release_master_id();
  inline void set_allocated_master_id(::std::string* master_id);

  // required string master_uuid = 2;
  inline bool has_master_uuid() const;
  inline void clear_master_uuid();
  static const int kMasterUuidFieldNumber = 2;
  inline const ::std::string& master_uuid() const;
  inline void set_master_uuid(const ::std::string& value);
  inline void set_master_uuid(const char* value);
  inline void set_master_uuid(const char* value, size_t size);
  inline ::std::string* mutable_master_uuid();
  inline ::std::string* release_master_uuid();
  inline void set_allocated_master_uuid(::std::string* master_uuid);

  // required .MasterRegisteredMessage.Status status = 3 [default = FIRST_REGISTERING];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::MasterRegisteredMessage_Status status() const;
  inline void set_status(::MasterRegisteredMessage_Status value);

  // @@protoc_insertion_point(class_scope:MasterRegisteredMessage)
 private:
  inline void set_has_master_id();
  inline void clear_has_master_id();
  inline void set_has_master_uuid();
  inline void clear_has_master_uuid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_id_;
  ::std::string* master_uuid_;
  int status_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static MasterRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class SlavesInfoControlledByMaster : public ::google::protobuf::Message {
 public:
  SlavesInfoControlledByMaster();
  virtual ~SlavesInfoControlledByMaster();

  SlavesInfoControlledByMaster(const SlavesInfoControlledByMaster& from);

  inline SlavesInfoControlledByMaster& operator=(const SlavesInfoControlledByMaster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlavesInfoControlledByMaster& default_instance();

  void Swap(SlavesInfoControlledByMaster* other);

  // implements Message ----------------------------------------------

  SlavesInfoControlledByMaster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlavesInfoControlledByMaster& from);
  void MergeFrom(const SlavesInfoControlledByMaster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required string port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  inline void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:SlavesInfoControlledByMaster)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* port_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static SlavesInfoControlledByMaster* default_instance_;
};
// -------------------------------------------------------------------

class MasterInfoControlledBySuperMaster : public ::google::protobuf::Message {
 public:
  MasterInfoControlledBySuperMaster();
  virtual ~MasterInfoControlledBySuperMaster();

  MasterInfoControlledBySuperMaster(const MasterInfoControlledBySuperMaster& from);

  inline MasterInfoControlledBySuperMaster& operator=(const MasterInfoControlledBySuperMaster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfoControlledBySuperMaster& default_instance();

  void Swap(MasterInfoControlledBySuperMaster* other);

  // implements Message ----------------------------------------------

  MasterInfoControlledBySuperMaster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterInfoControlledBySuperMaster& from);
  void MergeFrom(const MasterInfoControlledBySuperMaster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required string port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  inline void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:MasterInfoControlledBySuperMaster)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* port_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static MasterInfoControlledBySuperMaster* default_instance_;
};
// -------------------------------------------------------------------

class SuperMasterControlMessage : public ::google::protobuf::Message {
 public:
  SuperMasterControlMessage();
  virtual ~SuperMasterControlMessage();

  SuperMasterControlMessage(const SuperMasterControlMessage& from);

  inline SuperMasterControlMessage& operator=(const SuperMasterControlMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperMasterControlMessage& default_instance();

  void Swap(SuperMasterControlMessage* other);

  // implements Message ----------------------------------------------

  SuperMasterControlMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuperMasterControlMessage& from);
  void MergeFrom(const SuperMasterControlMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string super_master_id = 1;
  inline bool has_super_master_id() const;
  inline void clear_super_master_id();
  static const int kSuperMasterIdFieldNumber = 1;
  inline const ::std::string& super_master_id() const;
  inline void set_super_master_id(const ::std::string& value);
  inline void set_super_master_id(const char* value);
  inline void set_super_master_id(const char* value, size_t size);
  inline ::std::string* mutable_super_master_id();
  inline ::std::string* release_super_master_id();
  inline void set_allocated_super_master_id(::std::string* super_master_id);

  // optional string super_master_uuid = 2;
  inline bool has_super_master_uuid() const;
  inline void clear_super_master_uuid();
  static const int kSuperMasterUuidFieldNumber = 2;
  inline const ::std::string& super_master_uuid() const;
  inline void set_super_master_uuid(const ::std::string& value);
  inline void set_super_master_uuid(const char* value);
  inline void set_super_master_uuid(const char* value, size_t size);
  inline ::std::string* mutable_super_master_uuid();
  inline ::std::string* release_super_master_uuid();
  inline void set_allocated_super_master_uuid(::std::string* super_master_uuid);

  // required bool passive = 3;
  inline bool has_passive() const;
  inline void clear_passive();
  static const int kPassiveFieldNumber = 3;
  inline bool passive() const;
  inline void set_passive(bool value);

  // repeated .SlavesInfoControlledByMaster my_slaves = 4;
  inline int my_slaves_size() const;
  inline void clear_my_slaves();
  static const int kMySlavesFieldNumber = 4;
  inline const ::SlavesInfoControlledByMaster& my_slaves(int index) const;
  inline ::SlavesInfoControlledByMaster* mutable_my_slaves(int index);
  inline ::SlavesInfoControlledByMaster* add_my_slaves();
  inline const ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >&
      my_slaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >*
      mutable_my_slaves();

  // repeated .MasterInfoControlledBySuperMaster my_master = 5;
  inline int my_master_size() const;
  inline void clear_my_master();
  static const int kMyMasterFieldNumber = 5;
  inline const ::MasterInfoControlledBySuperMaster& my_master(int index) const;
  inline ::MasterInfoControlledBySuperMaster* mutable_my_master(int index);
  inline ::MasterInfoControlledBySuperMaster* add_my_master();
  inline const ::google::protobuf::RepeatedPtrField< ::MasterInfoControlledBySuperMaster >&
      my_master() const;
  inline ::google::protobuf::RepeatedPtrField< ::MasterInfoControlledBySuperMaster >*
      mutable_my_master();

  // @@protoc_insertion_point(class_scope:SuperMasterControlMessage)
 private:
  inline void set_has_super_master_id();
  inline void clear_has_super_master_id();
  inline void set_has_super_master_uuid();
  inline void clear_has_super_master_uuid();
  inline void set_has_passive();
  inline void clear_has_passive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* super_master_id_;
  ::std::string* super_master_uuid_;
  ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster > my_slaves_;
  ::google::protobuf::RepeatedPtrField< ::MasterInfoControlledBySuperMaster > my_master_;
  bool passive_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static SuperMasterControlMessage* default_instance_;
};
// -------------------------------------------------------------------

class AcceptRegisteredMessage : public ::google::protobuf::Message {
 public:
  AcceptRegisteredMessage();
  virtual ~AcceptRegisteredMessage();

  AcceptRegisteredMessage(const AcceptRegisteredMessage& from);

  inline AcceptRegisteredMessage& operator=(const AcceptRegisteredMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptRegisteredMessage& default_instance();

  void Swap(AcceptRegisteredMessage* other);

  // implements Message ----------------------------------------------

  AcceptRegisteredMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcceptRegisteredMessage& from);
  void MergeFrom(const AcceptRegisteredMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AcceptRegisteredMessage_Status Status;
  static const Status SUCCESS = AcceptRegisteredMessage_Status_SUCCESS;
  static const Status FAILURE = AcceptRegisteredMessage_Status_FAILURE;
  static inline bool Status_IsValid(int value) {
    return AcceptRegisteredMessage_Status_IsValid(value);
  }
  static const Status Status_MIN =
    AcceptRegisteredMessage_Status_Status_MIN;
  static const Status Status_MAX =
    AcceptRegisteredMessage_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    AcceptRegisteredMessage_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return AcceptRegisteredMessage_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return AcceptRegisteredMessage_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return AcceptRegisteredMessage_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string master_id = 1;
  inline bool has_master_id() const;
  inline void clear_master_id();
  static const int kMasterIdFieldNumber = 1;
  inline const ::std::string& master_id() const;
  inline void set_master_id(const ::std::string& value);
  inline void set_master_id(const char* value);
  inline void set_master_id(const char* value, size_t size);
  inline ::std::string* mutable_master_id();
  inline ::std::string* release_master_id();
  inline void set_allocated_master_id(::std::string* master_id);

  // required .AcceptRegisteredMessage.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::AcceptRegisteredMessage_Status status() const;
  inline void set_status(::AcceptRegisteredMessage_Status value);

  // @@protoc_insertion_point(class_scope:AcceptRegisteredMessage)
 private:
  inline void set_has_master_id();
  inline void clear_has_master_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_id_;
  int status_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static AcceptRegisteredMessage* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();

  SlaveInfo(const SlaveInfo& from);

  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();

  void Swap(SlaveInfo* other);

  // implements Message ----------------------------------------------

  SlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HardwareResourcesMessage hardware_resources = 1;
  inline bool has_hardware_resources() const;
  inline void clear_hardware_resources();
  static const int kHardwareResourcesFieldNumber = 1;
  inline const ::HardwareResourcesMessage& hardware_resources() const;
  inline ::HardwareResourcesMessage* mutable_hardware_resources();
  inline ::HardwareResourcesMessage* release_hardware_resources();
  inline void set_allocated_hardware_resources(::HardwareResourcesMessage* hardware_resources);

  // required .RuntimeResourcesMessage runtime_resources = 2;
  inline bool has_runtime_resources() const;
  inline void clear_runtime_resources();
  static const int kRuntimeResourcesFieldNumber = 2;
  inline const ::RuntimeResourcesMessage& runtime_resources() const;
  inline ::RuntimeResourcesMessage* mutable_runtime_resources();
  inline ::RuntimeResourcesMessage* release_runtime_resources();
  inline void set_allocated_runtime_resources(::RuntimeResourcesMessage* runtime_resources);

  // @@protoc_insertion_point(class_scope:SlaveInfo)
 private:
  inline void set_has_hardware_resources();
  inline void clear_has_hardware_resources();
  inline void set_has_runtime_resources();
  inline void clear_has_runtime_resources();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::HardwareResourcesMessage* hardware_resources_;
  ::RuntimeResourcesMessage* runtime_resources_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static SlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class OwnedSlavesMessage : public ::google::protobuf::Message {
 public:
  OwnedSlavesMessage();
  virtual ~OwnedSlavesMessage();

  OwnedSlavesMessage(const OwnedSlavesMessage& from);

  inline OwnedSlavesMessage& operator=(const OwnedSlavesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnedSlavesMessage& default_instance();

  void Swap(OwnedSlavesMessage* other);

  // implements Message ----------------------------------------------

  OwnedSlavesMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnedSlavesMessage& from);
  void MergeFrom(const OwnedSlavesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SlaveInfo slave_infos = 1;
  inline int slave_infos_size() const;
  inline void clear_slave_infos();
  static const int kSlaveInfosFieldNumber = 1;
  inline const ::SlaveInfo& slave_infos(int index) const;
  inline ::SlaveInfo* mutable_slave_infos(int index);
  inline ::SlaveInfo* add_slave_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::SlaveInfo >&
      slave_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlaveInfo >*
      mutable_slave_infos();

  // required uint32 quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OwnedSlavesMessage)
 private:
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SlaveInfo > slave_infos_;
  ::google::protobuf::uint32 quantity_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static OwnedSlavesMessage* default_instance_;
};
// -------------------------------------------------------------------

class TerminatingMasterMessage : public ::google::protobuf::Message {
 public:
  TerminatingMasterMessage();
  virtual ~TerminatingMasterMessage();

  TerminatingMasterMessage(const TerminatingMasterMessage& from);

  inline TerminatingMasterMessage& operator=(const TerminatingMasterMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TerminatingMasterMessage& default_instance();

  void Swap(TerminatingMasterMessage* other);

  // implements Message ----------------------------------------------

  TerminatingMasterMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TerminatingMasterMessage& from);
  void MergeFrom(const TerminatingMasterMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string master_id = 1;
  inline bool has_master_id() const;
  inline void clear_master_id();
  static const int kMasterIdFieldNumber = 1;
  inline const ::std::string& master_id() const;
  inline void set_master_id(const ::std::string& value);
  inline void set_master_id(const char* value);
  inline void set_master_id(const char* value, size_t size);
  inline ::std::string* mutable_master_id();
  inline ::std::string* release_master_id();
  inline void set_allocated_master_id(::std::string* master_id);

  // @@protoc_insertion_point(class_scope:TerminatingMasterMessage)
 private:
  inline void set_has_master_id();
  inline void clear_has_master_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_id_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static TerminatingMasterMessage* default_instance_;
};
// -------------------------------------------------------------------

class AdministeredSlavesMessage : public ::google::protobuf::Message {
 public:
  AdministeredSlavesMessage();
  virtual ~AdministeredSlavesMessage();

  AdministeredSlavesMessage(const AdministeredSlavesMessage& from);

  inline AdministeredSlavesMessage& operator=(const AdministeredSlavesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdministeredSlavesMessage& default_instance();

  void Swap(AdministeredSlavesMessage* other);

  // implements Message ----------------------------------------------

  AdministeredSlavesMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdministeredSlavesMessage& from);
  void MergeFrom(const AdministeredSlavesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string master_id = 1;
  inline bool has_master_id() const;
  inline void clear_master_id();
  static const int kMasterIdFieldNumber = 1;
  inline const ::std::string& master_id() const;
  inline void set_master_id(const ::std::string& value);
  inline void set_master_id(const char* value);
  inline void set_master_id(const char* value, size_t size);
  inline ::std::string* mutable_master_id();
  inline ::std::string* release_master_id();
  inline void set_allocated_master_id(::std::string* master_id);

  // required string master_uuid = 2;
  inline bool has_master_uuid() const;
  inline void clear_master_uuid();
  static const int kMasterUuidFieldNumber = 2;
  inline const ::std::string& master_uuid() const;
  inline void set_master_uuid(const ::std::string& value);
  inline void set_master_uuid(const char* value);
  inline void set_master_uuid(const char* value, size_t size);
  inline ::std::string* mutable_master_uuid();
  inline ::std::string* release_master_uuid();
  inline void set_allocated_master_uuid(::std::string* master_uuid);

  // required string super_master_uuid = 3;
  inline bool has_super_master_uuid() const;
  inline void clear_super_master_uuid();
  static const int kSuperMasterUuidFieldNumber = 3;
  inline const ::std::string& super_master_uuid() const;
  inline void set_super_master_uuid(const ::std::string& value);
  inline void set_super_master_uuid(const char* value);
  inline void set_super_master_uuid(const char* value, size_t size);
  inline ::std::string* mutable_super_master_uuid();
  inline ::std::string* release_super_master_uuid();
  inline void set_allocated_super_master_uuid(::std::string* super_master_uuid);

  // repeated .SlavesInfoControlledByMaster my_slaves = 4;
  inline int my_slaves_size() const;
  inline void clear_my_slaves();
  static const int kMySlavesFieldNumber = 4;
  inline const ::SlavesInfoControlledByMaster& my_slaves(int index) const;
  inline ::SlavesInfoControlledByMaster* mutable_my_slaves(int index);
  inline ::SlavesInfoControlledByMaster* add_my_slaves();
  inline const ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >&
      my_slaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >*
      mutable_my_slaves();

  // @@protoc_insertion_point(class_scope:AdministeredSlavesMessage)
 private:
  inline void set_has_master_id();
  inline void clear_has_master_id();
  inline void set_has_master_uuid();
  inline void clear_has_master_uuid();
  inline void set_has_super_master_uuid();
  inline void clear_has_super_master_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_id_;
  ::std::string* master_uuid_;
  ::std::string* super_master_uuid_;
  ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster > my_slaves_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static AdministeredSlavesMessage* default_instance_;
};
// -------------------------------------------------------------------

class LaunchMasterMessage : public ::google::protobuf::Message {
 public:
  LaunchMasterMessage();
  virtual ~LaunchMasterMessage();

  LaunchMasterMessage(const LaunchMasterMessage& from);

  inline LaunchMasterMessage& operator=(const LaunchMasterMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaunchMasterMessage& default_instance();

  void Swap(LaunchMasterMessage* other);

  // implements Message ----------------------------------------------

  LaunchMasterMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaunchMasterMessage& from);
  void MergeFrom(const LaunchMasterMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  inline void set_allocated_port(::std::string* port);

  // required string master_path = 2;
  inline bool has_master_path() const;
  inline void clear_master_path();
  static const int kMasterPathFieldNumber = 2;
  inline const ::std::string& master_path() const;
  inline void set_master_path(const ::std::string& value);
  inline void set_master_path(const char* value);
  inline void set_master_path(const char* value, size_t size);
  inline ::std::string* mutable_master_path();
  inline ::std::string* release_master_path();
  inline void set_allocated_master_path(::std::string* master_path);

  // required string webui_path = 3;
  inline bool has_webui_path() const;
  inline void clear_webui_path();
  static const int kWebuiPathFieldNumber = 3;
  inline const ::std::string& webui_path() const;
  inline void set_webui_path(const ::std::string& value);
  inline void set_webui_path(const char* value);
  inline void set_webui_path(const char* value, size_t size);
  inline ::std::string* mutable_webui_path();
  inline ::std::string* release_webui_path();
  inline void set_allocated_webui_path(::std::string* webui_path);

  // required bool is_fault_tolerance = 4;
  inline bool has_is_fault_tolerance() const;
  inline void clear_is_fault_tolerance();
  static const int kIsFaultToleranceFieldNumber = 4;
  inline bool is_fault_tolerance() const;
  inline void set_is_fault_tolerance(bool value);

  // @@protoc_insertion_point(class_scope:LaunchMasterMessage)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_master_path();
  inline void clear_has_master_path();
  inline void set_has_webui_path();
  inline void clear_has_webui_path();
  inline void set_has_is_fault_tolerance();
  inline void clear_has_is_fault_tolerance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* port_;
  ::std::string* master_path_;
  ::std::string* webui_path_;
  bool is_fault_tolerance_;
  friend void  protobuf_AddDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_AssignDesc_super_5fmaster_5frelated_2eproto();
  friend void protobuf_ShutdownFile_super_5fmaster_5frelated_2eproto();

  void InitAsDefaultInstance();
  static LaunchMasterMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ChameleonMasterINFO

// required string id = 1;
inline bool ChameleonMasterINFO::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChameleonMasterINFO::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChameleonMasterINFO::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChameleonMasterINFO::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ChameleonMasterINFO::id() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.id)
  return *id_;
}
inline void ChameleonMasterINFO::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:ChameleonMasterINFO.id)
}
inline void ChameleonMasterINFO::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChameleonMasterINFO.id)
}
inline void ChameleonMasterINFO::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChameleonMasterINFO.id)
}
inline ::std::string* ChameleonMasterINFO::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChameleonMasterINFO.id)
  return id_;
}
inline ::std::string* ChameleonMasterINFO::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChameleonMasterINFO::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChameleonMasterINFO.id)
}

// required uint32 ip = 2;
inline bool ChameleonMasterINFO::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChameleonMasterINFO::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChameleonMasterINFO::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChameleonMasterINFO::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 ChameleonMasterINFO::ip() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.ip)
  return ip_;
}
inline void ChameleonMasterINFO::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:ChameleonMasterINFO.ip)
}

// required uint32 port = 3;
inline bool ChameleonMasterINFO::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChameleonMasterINFO::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChameleonMasterINFO::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChameleonMasterINFO::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ChameleonMasterINFO::port() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.port)
  return port_;
}
inline void ChameleonMasterINFO::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:ChameleonMasterINFO.port)
}

// optional string pid = 4;
inline bool ChameleonMasterINFO::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChameleonMasterINFO::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChameleonMasterINFO::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChameleonMasterINFO::clear_pid() {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& ChameleonMasterINFO::pid() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.pid)
  return *pid_;
}
inline void ChameleonMasterINFO::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
  // @@protoc_insertion_point(field_set:ChameleonMasterINFO.pid)
}
inline void ChameleonMasterINFO::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChameleonMasterINFO.pid)
}
inline void ChameleonMasterINFO::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChameleonMasterINFO.pid)
}
inline ::std::string* ChameleonMasterINFO::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChameleonMasterINFO.pid)
  return pid_;
}
inline ::std::string* ChameleonMasterINFO::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChameleonMasterINFO::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChameleonMasterINFO.pid)
}

// optional string hostname = 5;
inline bool ChameleonMasterINFO::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChameleonMasterINFO::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChameleonMasterINFO::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChameleonMasterINFO::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ChameleonMasterINFO::hostname() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.hostname)
  return *hostname_;
}
inline void ChameleonMasterINFO::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:ChameleonMasterINFO.hostname)
}
inline void ChameleonMasterINFO::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChameleonMasterINFO.hostname)
}
inline void ChameleonMasterINFO::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChameleonMasterINFO.hostname)
}
inline ::std::string* ChameleonMasterINFO::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChameleonMasterINFO.hostname)
  return hostname_;
}
inline ::std::string* ChameleonMasterINFO::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChameleonMasterINFO::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChameleonMasterINFO.hostname)
}

// optional string version = 6;
inline bool ChameleonMasterINFO::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChameleonMasterINFO::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChameleonMasterINFO::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChameleonMasterINFO::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ChameleonMasterINFO::version() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.version)
  return *version_;
}
inline void ChameleonMasterINFO::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:ChameleonMasterINFO.version)
}
inline void ChameleonMasterINFO::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChameleonMasterINFO.version)
}
inline void ChameleonMasterINFO::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChameleonMasterINFO.version)
}
inline ::std::string* ChameleonMasterINFO::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChameleonMasterINFO.version)
  return version_;
}
inline ::std::string* ChameleonMasterINFO::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChameleonMasterINFO::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChameleonMasterINFO.version)
}

// optional .Address address = 7;
inline bool ChameleonMasterINFO::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChameleonMasterINFO::set_has_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChameleonMasterINFO::clear_has_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChameleonMasterINFO::clear_address() {
  if (address_ != NULL) address_->::Address::Clear();
  clear_has_address();
}
inline const ::Address& ChameleonMasterINFO::address() const {
  // @@protoc_insertion_point(field_get:ChameleonMasterINFO.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::Address* ChameleonMasterINFO::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::Address;
  // @@protoc_insertion_point(field_mutable:ChameleonMasterINFO.address)
  return address_;
}
inline ::Address* ChameleonMasterINFO::release_address() {
  clear_has_address();
  ::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void ChameleonMasterINFO::set_allocated_address(::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:ChameleonMasterINFO.address)
}

// -------------------------------------------------------------------

// Address

// optional string hostname = 1;
inline bool Address::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Address::hostname() const {
  // @@protoc_insertion_point(field_get:Address.hostname)
  return *hostname_;
}
inline void Address::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:Address.hostname)
}
inline void Address::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Address.hostname)
}
inline void Address::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Address.hostname)
}
inline ::std::string* Address::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Address.hostname)
  return hostname_;
}
inline ::std::string* Address::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Address::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Address.hostname)
}

// optional string ip = 2;
inline bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Address::ip() const {
  // @@protoc_insertion_point(field_get:Address.ip)
  return *ip_;
}
inline void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:Address.ip)
}
inline void Address::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:Address.ip)
}
inline void Address::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Address.ip)
}
inline ::std::string* Address::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Address.ip)
  return ip_;
}
inline ::std::string* Address::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Address::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Address.ip)
}

// required int32 port = 3;
inline bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:Address.port)
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Address.port)
}

// -------------------------------------------------------------------

// MasterRegisteredMessage

// required string master_id = 1;
inline bool MasterRegisteredMessage::has_master_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterRegisteredMessage::set_has_master_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterRegisteredMessage::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterRegisteredMessage::clear_master_id() {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_->clear();
  }
  clear_has_master_id();
}
inline const ::std::string& MasterRegisteredMessage::master_id() const {
  // @@protoc_insertion_point(field_get:MasterRegisteredMessage.master_id)
  return *master_id_;
}
inline void MasterRegisteredMessage::set_master_id(const ::std::string& value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set:MasterRegisteredMessage.master_id)
}
inline void MasterRegisteredMessage::set_master_id(const char* value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:MasterRegisteredMessage.master_id)
}
inline void MasterRegisteredMessage::set_master_id(const char* value, size_t size) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MasterRegisteredMessage.master_id)
}
inline ::std::string* MasterRegisteredMessage::mutable_master_id() {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MasterRegisteredMessage.master_id)
  return master_id_;
}
inline ::std::string* MasterRegisteredMessage::release_master_id() {
  clear_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_id_;
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterRegisteredMessage::set_allocated_master_id(::std::string* master_id) {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_id_;
  }
  if (master_id) {
    set_has_master_id();
    master_id_ = master_id;
  } else {
    clear_has_master_id();
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MasterRegisteredMessage.master_id)
}

// required string master_uuid = 2;
inline bool MasterRegisteredMessage::has_master_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterRegisteredMessage::set_has_master_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterRegisteredMessage::clear_has_master_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterRegisteredMessage::clear_master_uuid() {
  if (master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_->clear();
  }
  clear_has_master_uuid();
}
inline const ::std::string& MasterRegisteredMessage::master_uuid() const {
  // @@protoc_insertion_point(field_get:MasterRegisteredMessage.master_uuid)
  return *master_uuid_;
}
inline void MasterRegisteredMessage::set_master_uuid(const ::std::string& value) {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:MasterRegisteredMessage.master_uuid)
}
inline void MasterRegisteredMessage::set_master_uuid(const char* value) {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:MasterRegisteredMessage.master_uuid)
}
inline void MasterRegisteredMessage::set_master_uuid(const char* value, size_t size) {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  master_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MasterRegisteredMessage.master_uuid)
}
inline ::std::string* MasterRegisteredMessage::mutable_master_uuid() {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MasterRegisteredMessage.master_uuid)
  return master_uuid_;
}
inline ::std::string* MasterRegisteredMessage::release_master_uuid() {
  clear_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_uuid_;
    master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterRegisteredMessage::set_allocated_master_uuid(::std::string* master_uuid) {
  if (master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_uuid_;
  }
  if (master_uuid) {
    set_has_master_uuid();
    master_uuid_ = master_uuid;
  } else {
    clear_has_master_uuid();
    master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MasterRegisteredMessage.master_uuid)
}

// required .MasterRegisteredMessage.Status status = 3 [default = FIRST_REGISTERING];
inline bool MasterRegisteredMessage::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterRegisteredMessage::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterRegisteredMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterRegisteredMessage::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::MasterRegisteredMessage_Status MasterRegisteredMessage::status() const {
  // @@protoc_insertion_point(field_get:MasterRegisteredMessage.status)
  return static_cast< ::MasterRegisteredMessage_Status >(status_);
}
inline void MasterRegisteredMessage::set_status(::MasterRegisteredMessage_Status value) {
  assert(::MasterRegisteredMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MasterRegisteredMessage.status)
}

// -------------------------------------------------------------------

// SlavesInfoControlledByMaster

// required string ip = 1;
inline bool SlavesInfoControlledByMaster::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlavesInfoControlledByMaster::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlavesInfoControlledByMaster::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlavesInfoControlledByMaster::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& SlavesInfoControlledByMaster::ip() const {
  // @@protoc_insertion_point(field_get:SlavesInfoControlledByMaster.ip)
  return *ip_;
}
inline void SlavesInfoControlledByMaster::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:SlavesInfoControlledByMaster.ip)
}
inline void SlavesInfoControlledByMaster::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:SlavesInfoControlledByMaster.ip)
}
inline void SlavesInfoControlledByMaster::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SlavesInfoControlledByMaster.ip)
}
inline ::std::string* SlavesInfoControlledByMaster::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SlavesInfoControlledByMaster.ip)
  return ip_;
}
inline ::std::string* SlavesInfoControlledByMaster::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlavesInfoControlledByMaster::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SlavesInfoControlledByMaster.ip)
}

// required string port = 2;
inline bool SlavesInfoControlledByMaster::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlavesInfoControlledByMaster::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlavesInfoControlledByMaster::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlavesInfoControlledByMaster::clear_port() {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& SlavesInfoControlledByMaster::port() const {
  // @@protoc_insertion_point(field_get:SlavesInfoControlledByMaster.port)
  return *port_;
}
inline void SlavesInfoControlledByMaster::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set:SlavesInfoControlledByMaster.port)
}
inline void SlavesInfoControlledByMaster::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set_char:SlavesInfoControlledByMaster.port)
}
inline void SlavesInfoControlledByMaster::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SlavesInfoControlledByMaster.port)
}
inline ::std::string* SlavesInfoControlledByMaster::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SlavesInfoControlledByMaster.port)
  return port_;
}
inline ::std::string* SlavesInfoControlledByMaster::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlavesInfoControlledByMaster::set_allocated_port(::std::string* port) {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete port_;
  }
  if (port) {
    set_has_port();
    port_ = port;
  } else {
    clear_has_port();
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SlavesInfoControlledByMaster.port)
}

// -------------------------------------------------------------------

// MasterInfoControlledBySuperMaster

// required string ip = 1;
inline bool MasterInfoControlledBySuperMaster::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfoControlledBySuperMaster::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfoControlledBySuperMaster::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfoControlledBySuperMaster::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& MasterInfoControlledBySuperMaster::ip() const {
  // @@protoc_insertion_point(field_get:MasterInfoControlledBySuperMaster.ip)
  return *ip_;
}
inline void MasterInfoControlledBySuperMaster::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:MasterInfoControlledBySuperMaster.ip)
}
inline void MasterInfoControlledBySuperMaster::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:MasterInfoControlledBySuperMaster.ip)
}
inline void MasterInfoControlledBySuperMaster::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MasterInfoControlledBySuperMaster.ip)
}
inline ::std::string* MasterInfoControlledBySuperMaster::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MasterInfoControlledBySuperMaster.ip)
  return ip_;
}
inline ::std::string* MasterInfoControlledBySuperMaster::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterInfoControlledBySuperMaster::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MasterInfoControlledBySuperMaster.ip)
}

// required string port = 2;
inline bool MasterInfoControlledBySuperMaster::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterInfoControlledBySuperMaster::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterInfoControlledBySuperMaster::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterInfoControlledBySuperMaster::clear_port() {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& MasterInfoControlledBySuperMaster::port() const {
  // @@protoc_insertion_point(field_get:MasterInfoControlledBySuperMaster.port)
  return *port_;
}
inline void MasterInfoControlledBySuperMaster::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set:MasterInfoControlledBySuperMaster.port)
}
inline void MasterInfoControlledBySuperMaster::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set_char:MasterInfoControlledBySuperMaster.port)
}
inline void MasterInfoControlledBySuperMaster::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MasterInfoControlledBySuperMaster.port)
}
inline ::std::string* MasterInfoControlledBySuperMaster::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MasterInfoControlledBySuperMaster.port)
  return port_;
}
inline ::std::string* MasterInfoControlledBySuperMaster::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterInfoControlledBySuperMaster::set_allocated_port(::std::string* port) {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete port_;
  }
  if (port) {
    set_has_port();
    port_ = port;
  } else {
    clear_has_port();
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MasterInfoControlledBySuperMaster.port)
}

// -------------------------------------------------------------------

// SuperMasterControlMessage

// required string super_master_id = 1;
inline bool SuperMasterControlMessage::has_super_master_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuperMasterControlMessage::set_has_super_master_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuperMasterControlMessage::clear_has_super_master_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuperMasterControlMessage::clear_super_master_id() {
  if (super_master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_id_->clear();
  }
  clear_has_super_master_id();
}
inline const ::std::string& SuperMasterControlMessage::super_master_id() const {
  // @@protoc_insertion_point(field_get:SuperMasterControlMessage.super_master_id)
  return *super_master_id_;
}
inline void SuperMasterControlMessage::set_super_master_id(const ::std::string& value) {
  set_has_super_master_id();
  if (super_master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_id_ = new ::std::string;
  }
  super_master_id_->assign(value);
  // @@protoc_insertion_point(field_set:SuperMasterControlMessage.super_master_id)
}
inline void SuperMasterControlMessage::set_super_master_id(const char* value) {
  set_has_super_master_id();
  if (super_master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_id_ = new ::std::string;
  }
  super_master_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:SuperMasterControlMessage.super_master_id)
}
inline void SuperMasterControlMessage::set_super_master_id(const char* value, size_t size) {
  set_has_super_master_id();
  if (super_master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_id_ = new ::std::string;
  }
  super_master_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SuperMasterControlMessage.super_master_id)
}
inline ::std::string* SuperMasterControlMessage::mutable_super_master_id() {
  set_has_super_master_id();
  if (super_master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SuperMasterControlMessage.super_master_id)
  return super_master_id_;
}
inline ::std::string* SuperMasterControlMessage::release_super_master_id() {
  clear_has_super_master_id();
  if (super_master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = super_master_id_;
    super_master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SuperMasterControlMessage::set_allocated_super_master_id(::std::string* super_master_id) {
  if (super_master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete super_master_id_;
  }
  if (super_master_id) {
    set_has_super_master_id();
    super_master_id_ = super_master_id;
  } else {
    clear_has_super_master_id();
    super_master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SuperMasterControlMessage.super_master_id)
}

// optional string super_master_uuid = 2;
inline bool SuperMasterControlMessage::has_super_master_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuperMasterControlMessage::set_has_super_master_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuperMasterControlMessage::clear_has_super_master_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuperMasterControlMessage::clear_super_master_uuid() {
  if (super_master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_->clear();
  }
  clear_has_super_master_uuid();
}
inline const ::std::string& SuperMasterControlMessage::super_master_uuid() const {
  // @@protoc_insertion_point(field_get:SuperMasterControlMessage.super_master_uuid)
  return *super_master_uuid_;
}
inline void SuperMasterControlMessage::set_super_master_uuid(const ::std::string& value) {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  super_master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:SuperMasterControlMessage.super_master_uuid)
}
inline void SuperMasterControlMessage::set_super_master_uuid(const char* value) {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  super_master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:SuperMasterControlMessage.super_master_uuid)
}
inline void SuperMasterControlMessage::set_super_master_uuid(const char* value, size_t size) {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  super_master_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SuperMasterControlMessage.super_master_uuid)
}
inline ::std::string* SuperMasterControlMessage::mutable_super_master_uuid() {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SuperMasterControlMessage.super_master_uuid)
  return super_master_uuid_;
}
inline ::std::string* SuperMasterControlMessage::release_super_master_uuid() {
  clear_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = super_master_uuid_;
    super_master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SuperMasterControlMessage::set_allocated_super_master_uuid(::std::string* super_master_uuid) {
  if (super_master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete super_master_uuid_;
  }
  if (super_master_uuid) {
    set_has_super_master_uuid();
    super_master_uuid_ = super_master_uuid;
  } else {
    clear_has_super_master_uuid();
    super_master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SuperMasterControlMessage.super_master_uuid)
}

// required bool passive = 3;
inline bool SuperMasterControlMessage::has_passive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuperMasterControlMessage::set_has_passive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuperMasterControlMessage::clear_has_passive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuperMasterControlMessage::clear_passive() {
  passive_ = false;
  clear_has_passive();
}
inline bool SuperMasterControlMessage::passive() const {
  // @@protoc_insertion_point(field_get:SuperMasterControlMessage.passive)
  return passive_;
}
inline void SuperMasterControlMessage::set_passive(bool value) {
  set_has_passive();
  passive_ = value;
  // @@protoc_insertion_point(field_set:SuperMasterControlMessage.passive)
}

// repeated .SlavesInfoControlledByMaster my_slaves = 4;
inline int SuperMasterControlMessage::my_slaves_size() const {
  return my_slaves_.size();
}
inline void SuperMasterControlMessage::clear_my_slaves() {
  my_slaves_.Clear();
}
inline const ::SlavesInfoControlledByMaster& SuperMasterControlMessage::my_slaves(int index) const {
  // @@protoc_insertion_point(field_get:SuperMasterControlMessage.my_slaves)
  return my_slaves_.Get(index);
}
inline ::SlavesInfoControlledByMaster* SuperMasterControlMessage::mutable_my_slaves(int index) {
  // @@protoc_insertion_point(field_mutable:SuperMasterControlMessage.my_slaves)
  return my_slaves_.Mutable(index);
}
inline ::SlavesInfoControlledByMaster* SuperMasterControlMessage::add_my_slaves() {
  // @@protoc_insertion_point(field_add:SuperMasterControlMessage.my_slaves)
  return my_slaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >&
SuperMasterControlMessage::my_slaves() const {
  // @@protoc_insertion_point(field_list:SuperMasterControlMessage.my_slaves)
  return my_slaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >*
SuperMasterControlMessage::mutable_my_slaves() {
  // @@protoc_insertion_point(field_mutable_list:SuperMasterControlMessage.my_slaves)
  return &my_slaves_;
}

// repeated .MasterInfoControlledBySuperMaster my_master = 5;
inline int SuperMasterControlMessage::my_master_size() const {
  return my_master_.size();
}
inline void SuperMasterControlMessage::clear_my_master() {
  my_master_.Clear();
}
inline const ::MasterInfoControlledBySuperMaster& SuperMasterControlMessage::my_master(int index) const {
  // @@protoc_insertion_point(field_get:SuperMasterControlMessage.my_master)
  return my_master_.Get(index);
}
inline ::MasterInfoControlledBySuperMaster* SuperMasterControlMessage::mutable_my_master(int index) {
  // @@protoc_insertion_point(field_mutable:SuperMasterControlMessage.my_master)
  return my_master_.Mutable(index);
}
inline ::MasterInfoControlledBySuperMaster* SuperMasterControlMessage::add_my_master() {
  // @@protoc_insertion_point(field_add:SuperMasterControlMessage.my_master)
  return my_master_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MasterInfoControlledBySuperMaster >&
SuperMasterControlMessage::my_master() const {
  // @@protoc_insertion_point(field_list:SuperMasterControlMessage.my_master)
  return my_master_;
}
inline ::google::protobuf::RepeatedPtrField< ::MasterInfoControlledBySuperMaster >*
SuperMasterControlMessage::mutable_my_master() {
  // @@protoc_insertion_point(field_mutable_list:SuperMasterControlMessage.my_master)
  return &my_master_;
}

// -------------------------------------------------------------------

// AcceptRegisteredMessage

// required string master_id = 1;
inline bool AcceptRegisteredMessage::has_master_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptRegisteredMessage::set_has_master_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptRegisteredMessage::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptRegisteredMessage::clear_master_id() {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_->clear();
  }
  clear_has_master_id();
}
inline const ::std::string& AcceptRegisteredMessage::master_id() const {
  // @@protoc_insertion_point(field_get:AcceptRegisteredMessage.master_id)
  return *master_id_;
}
inline void AcceptRegisteredMessage::set_master_id(const ::std::string& value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set:AcceptRegisteredMessage.master_id)
}
inline void AcceptRegisteredMessage::set_master_id(const char* value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:AcceptRegisteredMessage.master_id)
}
inline void AcceptRegisteredMessage::set_master_id(const char* value, size_t size) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AcceptRegisteredMessage.master_id)
}
inline ::std::string* AcceptRegisteredMessage::mutable_master_id() {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AcceptRegisteredMessage.master_id)
  return master_id_;
}
inline ::std::string* AcceptRegisteredMessage::release_master_id() {
  clear_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_id_;
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AcceptRegisteredMessage::set_allocated_master_id(::std::string* master_id) {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_id_;
  }
  if (master_id) {
    set_has_master_id();
    master_id_ = master_id;
  } else {
    clear_has_master_id();
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AcceptRegisteredMessage.master_id)
}

// required .AcceptRegisteredMessage.Status status = 2;
inline bool AcceptRegisteredMessage::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptRegisteredMessage::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptRegisteredMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptRegisteredMessage::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::AcceptRegisteredMessage_Status AcceptRegisteredMessage::status() const {
  // @@protoc_insertion_point(field_get:AcceptRegisteredMessage.status)
  return static_cast< ::AcceptRegisteredMessage_Status >(status_);
}
inline void AcceptRegisteredMessage::set_status(::AcceptRegisteredMessage_Status value) {
  assert(::AcceptRegisteredMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:AcceptRegisteredMessage.status)
}

// -------------------------------------------------------------------

// SlaveInfo

// required .HardwareResourcesMessage hardware_resources = 1;
inline bool SlaveInfo::has_hardware_resources() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo::set_has_hardware_resources() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo::clear_has_hardware_resources() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo::clear_hardware_resources() {
  if (hardware_resources_ != NULL) hardware_resources_->::HardwareResourcesMessage::Clear();
  clear_has_hardware_resources();
}
inline const ::HardwareResourcesMessage& SlaveInfo::hardware_resources() const {
  // @@protoc_insertion_point(field_get:SlaveInfo.hardware_resources)
  return hardware_resources_ != NULL ? *hardware_resources_ : *default_instance_->hardware_resources_;
}
inline ::HardwareResourcesMessage* SlaveInfo::mutable_hardware_resources() {
  set_has_hardware_resources();
  if (hardware_resources_ == NULL) hardware_resources_ = new ::HardwareResourcesMessage;
  // @@protoc_insertion_point(field_mutable:SlaveInfo.hardware_resources)
  return hardware_resources_;
}
inline ::HardwareResourcesMessage* SlaveInfo::release_hardware_resources() {
  clear_has_hardware_resources();
  ::HardwareResourcesMessage* temp = hardware_resources_;
  hardware_resources_ = NULL;
  return temp;
}
inline void SlaveInfo::set_allocated_hardware_resources(::HardwareResourcesMessage* hardware_resources) {
  delete hardware_resources_;
  hardware_resources_ = hardware_resources;
  if (hardware_resources) {
    set_has_hardware_resources();
  } else {
    clear_has_hardware_resources();
  }
  // @@protoc_insertion_point(field_set_allocated:SlaveInfo.hardware_resources)
}

// required .RuntimeResourcesMessage runtime_resources = 2;
inline bool SlaveInfo::has_runtime_resources() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveInfo::set_has_runtime_resources() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveInfo::clear_has_runtime_resources() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveInfo::clear_runtime_resources() {
  if (runtime_resources_ != NULL) runtime_resources_->::RuntimeResourcesMessage::Clear();
  clear_has_runtime_resources();
}
inline const ::RuntimeResourcesMessage& SlaveInfo::runtime_resources() const {
  // @@protoc_insertion_point(field_get:SlaveInfo.runtime_resources)
  return runtime_resources_ != NULL ? *runtime_resources_ : *default_instance_->runtime_resources_;
}
inline ::RuntimeResourcesMessage* SlaveInfo::mutable_runtime_resources() {
  set_has_runtime_resources();
  if (runtime_resources_ == NULL) runtime_resources_ = new ::RuntimeResourcesMessage;
  // @@protoc_insertion_point(field_mutable:SlaveInfo.runtime_resources)
  return runtime_resources_;
}
inline ::RuntimeResourcesMessage* SlaveInfo::release_runtime_resources() {
  clear_has_runtime_resources();
  ::RuntimeResourcesMessage* temp = runtime_resources_;
  runtime_resources_ = NULL;
  return temp;
}
inline void SlaveInfo::set_allocated_runtime_resources(::RuntimeResourcesMessage* runtime_resources) {
  delete runtime_resources_;
  runtime_resources_ = runtime_resources;
  if (runtime_resources) {
    set_has_runtime_resources();
  } else {
    clear_has_runtime_resources();
  }
  // @@protoc_insertion_point(field_set_allocated:SlaveInfo.runtime_resources)
}

// -------------------------------------------------------------------

// OwnedSlavesMessage

// repeated .SlaveInfo slave_infos = 1;
inline int OwnedSlavesMessage::slave_infos_size() const {
  return slave_infos_.size();
}
inline void OwnedSlavesMessage::clear_slave_infos() {
  slave_infos_.Clear();
}
inline const ::SlaveInfo& OwnedSlavesMessage::slave_infos(int index) const {
  // @@protoc_insertion_point(field_get:OwnedSlavesMessage.slave_infos)
  return slave_infos_.Get(index);
}
inline ::SlaveInfo* OwnedSlavesMessage::mutable_slave_infos(int index) {
  // @@protoc_insertion_point(field_mutable:OwnedSlavesMessage.slave_infos)
  return slave_infos_.Mutable(index);
}
inline ::SlaveInfo* OwnedSlavesMessage::add_slave_infos() {
  // @@protoc_insertion_point(field_add:OwnedSlavesMessage.slave_infos)
  return slave_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlaveInfo >&
OwnedSlavesMessage::slave_infos() const {
  // @@protoc_insertion_point(field_list:OwnedSlavesMessage.slave_infos)
  return slave_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlaveInfo >*
OwnedSlavesMessage::mutable_slave_infos() {
  // @@protoc_insertion_point(field_mutable_list:OwnedSlavesMessage.slave_infos)
  return &slave_infos_;
}

// required uint32 quantity = 2;
inline bool OwnedSlavesMessage::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OwnedSlavesMessage::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OwnedSlavesMessage::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OwnedSlavesMessage::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 OwnedSlavesMessage::quantity() const {
  // @@protoc_insertion_point(field_get:OwnedSlavesMessage.quantity)
  return quantity_;
}
inline void OwnedSlavesMessage::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:OwnedSlavesMessage.quantity)
}

// -------------------------------------------------------------------

// TerminatingMasterMessage

// required string master_id = 1;
inline bool TerminatingMasterMessage::has_master_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TerminatingMasterMessage::set_has_master_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TerminatingMasterMessage::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TerminatingMasterMessage::clear_master_id() {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_->clear();
  }
  clear_has_master_id();
}
inline const ::std::string& TerminatingMasterMessage::master_id() const {
  // @@protoc_insertion_point(field_get:TerminatingMasterMessage.master_id)
  return *master_id_;
}
inline void TerminatingMasterMessage::set_master_id(const ::std::string& value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set:TerminatingMasterMessage.master_id)
}
inline void TerminatingMasterMessage::set_master_id(const char* value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:TerminatingMasterMessage.master_id)
}
inline void TerminatingMasterMessage::set_master_id(const char* value, size_t size) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TerminatingMasterMessage.master_id)
}
inline ::std::string* TerminatingMasterMessage::mutable_master_id() {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TerminatingMasterMessage.master_id)
  return master_id_;
}
inline ::std::string* TerminatingMasterMessage::release_master_id() {
  clear_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_id_;
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TerminatingMasterMessage::set_allocated_master_id(::std::string* master_id) {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_id_;
  }
  if (master_id) {
    set_has_master_id();
    master_id_ = master_id;
  } else {
    clear_has_master_id();
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TerminatingMasterMessage.master_id)
}

// -------------------------------------------------------------------

// AdministeredSlavesMessage

// required string master_id = 1;
inline bool AdministeredSlavesMessage::has_master_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdministeredSlavesMessage::set_has_master_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdministeredSlavesMessage::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdministeredSlavesMessage::clear_master_id() {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_->clear();
  }
  clear_has_master_id();
}
inline const ::std::string& AdministeredSlavesMessage::master_id() const {
  // @@protoc_insertion_point(field_get:AdministeredSlavesMessage.master_id)
  return *master_id_;
}
inline void AdministeredSlavesMessage::set_master_id(const ::std::string& value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set:AdministeredSlavesMessage.master_id)
}
inline void AdministeredSlavesMessage::set_master_id(const char* value) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:AdministeredSlavesMessage.master_id)
}
inline void AdministeredSlavesMessage::set_master_id(const char* value, size_t size) {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  master_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AdministeredSlavesMessage.master_id)
}
inline ::std::string* AdministeredSlavesMessage::mutable_master_id() {
  set_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AdministeredSlavesMessage.master_id)
  return master_id_;
}
inline ::std::string* AdministeredSlavesMessage::release_master_id() {
  clear_has_master_id();
  if (master_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_id_;
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdministeredSlavesMessage::set_allocated_master_id(::std::string* master_id) {
  if (master_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_id_;
  }
  if (master_id) {
    set_has_master_id();
    master_id_ = master_id;
  } else {
    clear_has_master_id();
    master_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AdministeredSlavesMessage.master_id)
}

// required string master_uuid = 2;
inline bool AdministeredSlavesMessage::has_master_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdministeredSlavesMessage::set_has_master_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdministeredSlavesMessage::clear_has_master_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdministeredSlavesMessage::clear_master_uuid() {
  if (master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_->clear();
  }
  clear_has_master_uuid();
}
inline const ::std::string& AdministeredSlavesMessage::master_uuid() const {
  // @@protoc_insertion_point(field_get:AdministeredSlavesMessage.master_uuid)
  return *master_uuid_;
}
inline void AdministeredSlavesMessage::set_master_uuid(const ::std::string& value) {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:AdministeredSlavesMessage.master_uuid)
}
inline void AdministeredSlavesMessage::set_master_uuid(const char* value) {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AdministeredSlavesMessage.master_uuid)
}
inline void AdministeredSlavesMessage::set_master_uuid(const char* value, size_t size) {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  master_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AdministeredSlavesMessage.master_uuid)
}
inline ::std::string* AdministeredSlavesMessage::mutable_master_uuid() {
  set_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AdministeredSlavesMessage.master_uuid)
  return master_uuid_;
}
inline ::std::string* AdministeredSlavesMessage::release_master_uuid() {
  clear_has_master_uuid();
  if (master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_uuid_;
    master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdministeredSlavesMessage::set_allocated_master_uuid(::std::string* master_uuid) {
  if (master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_uuid_;
  }
  if (master_uuid) {
    set_has_master_uuid();
    master_uuid_ = master_uuid;
  } else {
    clear_has_master_uuid();
    master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AdministeredSlavesMessage.master_uuid)
}

// required string super_master_uuid = 3;
inline bool AdministeredSlavesMessage::has_super_master_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdministeredSlavesMessage::set_has_super_master_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdministeredSlavesMessage::clear_has_super_master_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdministeredSlavesMessage::clear_super_master_uuid() {
  if (super_master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_->clear();
  }
  clear_has_super_master_uuid();
}
inline const ::std::string& AdministeredSlavesMessage::super_master_uuid() const {
  // @@protoc_insertion_point(field_get:AdministeredSlavesMessage.super_master_uuid)
  return *super_master_uuid_;
}
inline void AdministeredSlavesMessage::set_super_master_uuid(const ::std::string& value) {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  super_master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:AdministeredSlavesMessage.super_master_uuid)
}
inline void AdministeredSlavesMessage::set_super_master_uuid(const char* value) {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  super_master_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AdministeredSlavesMessage.super_master_uuid)
}
inline void AdministeredSlavesMessage::set_super_master_uuid(const char* value, size_t size) {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  super_master_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AdministeredSlavesMessage.super_master_uuid)
}
inline ::std::string* AdministeredSlavesMessage::mutable_super_master_uuid() {
  set_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    super_master_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AdministeredSlavesMessage.super_master_uuid)
  return super_master_uuid_;
}
inline ::std::string* AdministeredSlavesMessage::release_super_master_uuid() {
  clear_has_super_master_uuid();
  if (super_master_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = super_master_uuid_;
    super_master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdministeredSlavesMessage::set_allocated_super_master_uuid(::std::string* super_master_uuid) {
  if (super_master_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete super_master_uuid_;
  }
  if (super_master_uuid) {
    set_has_super_master_uuid();
    super_master_uuid_ = super_master_uuid;
  } else {
    clear_has_super_master_uuid();
    super_master_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AdministeredSlavesMessage.super_master_uuid)
}

// repeated .SlavesInfoControlledByMaster my_slaves = 4;
inline int AdministeredSlavesMessage::my_slaves_size() const {
  return my_slaves_.size();
}
inline void AdministeredSlavesMessage::clear_my_slaves() {
  my_slaves_.Clear();
}
inline const ::SlavesInfoControlledByMaster& AdministeredSlavesMessage::my_slaves(int index) const {
  // @@protoc_insertion_point(field_get:AdministeredSlavesMessage.my_slaves)
  return my_slaves_.Get(index);
}
inline ::SlavesInfoControlledByMaster* AdministeredSlavesMessage::mutable_my_slaves(int index) {
  // @@protoc_insertion_point(field_mutable:AdministeredSlavesMessage.my_slaves)
  return my_slaves_.Mutable(index);
}
inline ::SlavesInfoControlledByMaster* AdministeredSlavesMessage::add_my_slaves() {
  // @@protoc_insertion_point(field_add:AdministeredSlavesMessage.my_slaves)
  return my_slaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >&
AdministeredSlavesMessage::my_slaves() const {
  // @@protoc_insertion_point(field_list:AdministeredSlavesMessage.my_slaves)
  return my_slaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlavesInfoControlledByMaster >*
AdministeredSlavesMessage::mutable_my_slaves() {
  // @@protoc_insertion_point(field_mutable_list:AdministeredSlavesMessage.my_slaves)
  return &my_slaves_;
}

// -------------------------------------------------------------------

// LaunchMasterMessage

// required string port = 1;
inline bool LaunchMasterMessage::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaunchMasterMessage::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaunchMasterMessage::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaunchMasterMessage::clear_port() {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& LaunchMasterMessage::port() const {
  // @@protoc_insertion_point(field_get:LaunchMasterMessage.port)
  return *port_;
}
inline void LaunchMasterMessage::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set:LaunchMasterMessage.port)
}
inline void LaunchMasterMessage::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(value);
  // @@protoc_insertion_point(field_set_char:LaunchMasterMessage.port)
}
inline void LaunchMasterMessage::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LaunchMasterMessage.port)
}
inline ::std::string* LaunchMasterMessage::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LaunchMasterMessage.port)
  return port_;
}
inline ::std::string* LaunchMasterMessage::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LaunchMasterMessage::set_allocated_port(::std::string* port) {
  if (port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete port_;
  }
  if (port) {
    set_has_port();
    port_ = port;
  } else {
    clear_has_port();
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LaunchMasterMessage.port)
}

// required string master_path = 2;
inline bool LaunchMasterMessage::has_master_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaunchMasterMessage::set_has_master_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaunchMasterMessage::clear_has_master_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaunchMasterMessage::clear_master_path() {
  if (master_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_path_->clear();
  }
  clear_has_master_path();
}
inline const ::std::string& LaunchMasterMessage::master_path() const {
  // @@protoc_insertion_point(field_get:LaunchMasterMessage.master_path)
  return *master_path_;
}
inline void LaunchMasterMessage::set_master_path(const ::std::string& value) {
  set_has_master_path();
  if (master_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_path_ = new ::std::string;
  }
  master_path_->assign(value);
  // @@protoc_insertion_point(field_set:LaunchMasterMessage.master_path)
}
inline void LaunchMasterMessage::set_master_path(const char* value) {
  set_has_master_path();
  if (master_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_path_ = new ::std::string;
  }
  master_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:LaunchMasterMessage.master_path)
}
inline void LaunchMasterMessage::set_master_path(const char* value, size_t size) {
  set_has_master_path();
  if (master_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_path_ = new ::std::string;
  }
  master_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LaunchMasterMessage.master_path)
}
inline ::std::string* LaunchMasterMessage::mutable_master_path() {
  set_has_master_path();
  if (master_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LaunchMasterMessage.master_path)
  return master_path_;
}
inline ::std::string* LaunchMasterMessage::release_master_path() {
  clear_has_master_path();
  if (master_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_path_;
    master_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LaunchMasterMessage::set_allocated_master_path(::std::string* master_path) {
  if (master_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_path_;
  }
  if (master_path) {
    set_has_master_path();
    master_path_ = master_path;
  } else {
    clear_has_master_path();
    master_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LaunchMasterMessage.master_path)
}

// required string webui_path = 3;
inline bool LaunchMasterMessage::has_webui_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaunchMasterMessage::set_has_webui_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaunchMasterMessage::clear_has_webui_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaunchMasterMessage::clear_webui_path() {
  if (webui_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_path_->clear();
  }
  clear_has_webui_path();
}
inline const ::std::string& LaunchMasterMessage::webui_path() const {
  // @@protoc_insertion_point(field_get:LaunchMasterMessage.webui_path)
  return *webui_path_;
}
inline void LaunchMasterMessage::set_webui_path(const ::std::string& value) {
  set_has_webui_path();
  if (webui_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_path_ = new ::std::string;
  }
  webui_path_->assign(value);
  // @@protoc_insertion_point(field_set:LaunchMasterMessage.webui_path)
}
inline void LaunchMasterMessage::set_webui_path(const char* value) {
  set_has_webui_path();
  if (webui_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_path_ = new ::std::string;
  }
  webui_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:LaunchMasterMessage.webui_path)
}
inline void LaunchMasterMessage::set_webui_path(const char* value, size_t size) {
  set_has_webui_path();
  if (webui_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_path_ = new ::std::string;
  }
  webui_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LaunchMasterMessage.webui_path)
}
inline ::std::string* LaunchMasterMessage::mutable_webui_path() {
  set_has_webui_path();
  if (webui_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    webui_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LaunchMasterMessage.webui_path)
  return webui_path_;
}
inline ::std::string* LaunchMasterMessage::release_webui_path() {
  clear_has_webui_path();
  if (webui_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = webui_path_;
    webui_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LaunchMasterMessage::set_allocated_webui_path(::std::string* webui_path) {
  if (webui_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete webui_path_;
  }
  if (webui_path) {
    set_has_webui_path();
    webui_path_ = webui_path;
  } else {
    clear_has_webui_path();
    webui_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LaunchMasterMessage.webui_path)
}

// required bool is_fault_tolerance = 4;
inline bool LaunchMasterMessage::has_is_fault_tolerance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaunchMasterMessage::set_has_is_fault_tolerance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaunchMasterMessage::clear_has_is_fault_tolerance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaunchMasterMessage::clear_is_fault_tolerance() {
  is_fault_tolerance_ = false;
  clear_has_is_fault_tolerance();
}
inline bool LaunchMasterMessage::is_fault_tolerance() const {
  // @@protoc_insertion_point(field_get:LaunchMasterMessage.is_fault_tolerance)
  return is_fault_tolerance_;
}
inline void LaunchMasterMessage::set_is_fault_tolerance(bool value) {
  set_has_is_fault_tolerance();
  is_fault_tolerance_ = value;
  // @@protoc_insertion_point(field_set:LaunchMasterMessage.is_fault_tolerance)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MasterRegisteredMessage_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MasterRegisteredMessage_Status>() {
  return ::MasterRegisteredMessage_Status_descriptor();
}
template <> struct is_proto_enum< ::AcceptRegisteredMessage_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AcceptRegisteredMessage_Status>() {
  return ::AcceptRegisteredMessage_Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_super_5fmaster_5frelated_2eproto__INCLUDED
