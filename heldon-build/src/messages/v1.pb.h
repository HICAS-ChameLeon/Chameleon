// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v1.proto

#ifndef PROTOBUF_v1_2eproto__INCLUDED
#define PROTOBUF_v1_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace docker {
namespace spec {
namespace v1 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_v1_2eproto();
void protobuf_AssignDesc_v1_2eproto();
void protobuf_ShutdownFile_v1_2eproto();

class Label;
class ImageManifest;
class ImageManifest_Config;

// ===================================================================

class Label : public ::google::protobuf::Message {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();

  void Swap(Label* other);

  // implements Message ----------------------------------------------

  Label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:docker.spec.v1.Label)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_v1_2eproto();
  friend void protobuf_AssignDesc_v1_2eproto();
  friend void protobuf_ShutdownFile_v1_2eproto();

  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest_Config : public ::google::protobuf::Message {
 public:
  ImageManifest_Config();
  virtual ~ImageManifest_Config();

  ImageManifest_Config(const ImageManifest_Config& from);

  inline ImageManifest_Config& operator=(const ImageManifest_Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest_Config& default_instance();

  void Swap(ImageManifest_Config* other);

  // implements Message ----------------------------------------------

  ImageManifest_Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest_Config& from);
  void MergeFrom(const ImageManifest_Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // repeated string Entrypoint = 2;
  inline int entrypoint_size() const;
  inline void clear_entrypoint();
  static const int kEntrypointFieldNumber = 2;
  inline const ::std::string& entrypoint(int index) const;
  inline ::std::string* mutable_entrypoint(int index);
  inline void set_entrypoint(int index, const ::std::string& value);
  inline void set_entrypoint(int index, const char* value);
  inline void set_entrypoint(int index, const char* value, size_t size);
  inline ::std::string* add_entrypoint();
  inline void add_entrypoint(const ::std::string& value);
  inline void add_entrypoint(const char* value);
  inline void add_entrypoint(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& entrypoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entrypoint();

  // repeated string Env = 3;
  inline int env_size() const;
  inline void clear_env();
  static const int kEnvFieldNumber = 3;
  inline const ::std::string& env(int index) const;
  inline ::std::string* mutable_env(int index);
  inline void set_env(int index, const ::std::string& value);
  inline void set_env(int index, const char* value);
  inline void set_env(int index, const char* value, size_t size);
  inline ::std::string* add_env();
  inline void add_env(const ::std::string& value);
  inline void add_env(const char* value);
  inline void add_env(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& env() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_env();

  // optional string User = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // repeated string Cmd = 5;
  inline int cmd_size() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 5;
  inline const ::std::string& cmd(int index) const;
  inline ::std::string* mutable_cmd(int index);
  inline void set_cmd(int index, const ::std::string& value);
  inline void set_cmd(int index, const char* value);
  inline void set_cmd(int index, const char* value, size_t size);
  inline ::std::string* add_cmd();
  inline void add_cmd(const ::std::string& value);
  inline void add_cmd(const char* value);
  inline void add_cmd(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd();

  // optional string WorkingDir = 6;
  inline bool has_workingdir() const;
  inline void clear_workingdir();
  static const int kWorkingDirFieldNumber = 6;
  inline const ::std::string& workingdir() const;
  inline void set_workingdir(const ::std::string& value);
  inline void set_workingdir(const char* value);
  inline void set_workingdir(const char* value, size_t size);
  inline ::std::string* mutable_workingdir();
  inline ::std::string* release_workingdir();
  inline void set_allocated_workingdir(::std::string* workingdir);

  // optional string Image = 8;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 8;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // repeated .docker.spec.v1.Label labels = 9;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 9;
  inline const ::docker::spec::v1::Label& labels(int index) const;
  inline ::docker::spec::v1::Label* mutable_labels(int index);
  inline ::docker::spec::v1::Label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::docker::spec::v1::Label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::docker::spec::v1::Label >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:docker.spec.v1.ImageManifest.Config)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_workingdir();
  inline void clear_has_workingdir();
  inline void set_has_image();
  inline void clear_has_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entrypoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> env_;
  ::std::string* user_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_;
  ::std::string* workingdir_;
  ::std::string* image_;
  ::google::protobuf::RepeatedPtrField< ::docker::spec::v1::Label > labels_;
  friend void  protobuf_AddDesc_v1_2eproto();
  friend void protobuf_AssignDesc_v1_2eproto();
  friend void protobuf_ShutdownFile_v1_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest_Config* default_instance_;
};
// -------------------------------------------------------------------

class ImageManifest : public ::google::protobuf::Message {
 public:
  ImageManifest();
  virtual ~ImageManifest();

  ImageManifest(const ImageManifest& from);

  inline ImageManifest& operator=(const ImageManifest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageManifest& default_instance();

  void Swap(ImageManifest* other);

  // implements Message ----------------------------------------------

  ImageManifest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageManifest& from);
  void MergeFrom(const ImageManifest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ImageManifest_Config Config;

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline const ::std::string& parent() const;
  inline void set_parent(const ::std::string& value);
  inline void set_parent(const char* value);
  inline void set_parent(const char* value, size_t size);
  inline ::std::string* mutable_parent();
  inline ::std::string* release_parent();
  inline void set_allocated_parent(::std::string* parent);

  // optional string comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional string created = 4;
  inline bool has_created() const;
  inline void clear_created();
  static const int kCreatedFieldNumber = 4;
  inline const ::std::string& created() const;
  inline void set_created(const ::std::string& value);
  inline void set_created(const char* value);
  inline void set_created(const char* value, size_t size);
  inline ::std::string* mutable_created();
  inline ::std::string* release_created();
  inline void set_allocated_created(::std::string* created);

  // optional string container = 5;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 5;
  inline const ::std::string& container() const;
  inline void set_container(const ::std::string& value);
  inline void set_container(const char* value);
  inline void set_container(const char* value, size_t size);
  inline ::std::string* mutable_container();
  inline ::std::string* release_container();
  inline void set_allocated_container(::std::string* container);

  // optional .docker.spec.v1.ImageManifest.Config container_config = 6;
  inline bool has_container_config() const;
  inline void clear_container_config();
  static const int kContainerConfigFieldNumber = 6;
  inline const ::docker::spec::v1::ImageManifest_Config& container_config() const;
  inline ::docker::spec::v1::ImageManifest_Config* mutable_container_config();
  inline ::docker::spec::v1::ImageManifest_Config* release_container_config();
  inline void set_allocated_container_config(::docker::spec::v1::ImageManifest_Config* container_config);

  // optional string docker_version = 7;
  inline bool has_docker_version() const;
  inline void clear_docker_version();
  static const int kDockerVersionFieldNumber = 7;
  inline const ::std::string& docker_version() const;
  inline void set_docker_version(const ::std::string& value);
  inline void set_docker_version(const char* value);
  inline void set_docker_version(const char* value, size_t size);
  inline ::std::string* mutable_docker_version();
  inline ::std::string* release_docker_version();
  inline void set_allocated_docker_version(::std::string* docker_version);

  // optional string author = 8;
  inline bool has_author() const;
  inline void clear_author();
  static const int kAuthorFieldNumber = 8;
  inline const ::std::string& author() const;
  inline void set_author(const ::std::string& value);
  inline void set_author(const char* value);
  inline void set_author(const char* value, size_t size);
  inline ::std::string* mutable_author();
  inline ::std::string* release_author();
  inline void set_allocated_author(::std::string* author);

  // optional .docker.spec.v1.ImageManifest.Config config = 9;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 9;
  inline const ::docker::spec::v1::ImageManifest_Config& config() const;
  inline ::docker::spec::v1::ImageManifest_Config* mutable_config();
  inline ::docker::spec::v1::ImageManifest_Config* release_config();
  inline void set_allocated_config(::docker::spec::v1::ImageManifest_Config* config);

  // optional string architecture = 10;
  inline bool has_architecture() const;
  inline void clear_architecture();
  static const int kArchitectureFieldNumber = 10;
  inline const ::std::string& architecture() const;
  inline void set_architecture(const ::std::string& value);
  inline void set_architecture(const char* value);
  inline void set_architecture(const char* value, size_t size);
  inline ::std::string* mutable_architecture();
  inline ::std::string* release_architecture();
  inline void set_allocated_architecture(::std::string* architecture);

  // optional string os = 11;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 11;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional uint32 Size = 12;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 12;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:docker.spec.v1.ImageManifest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_created();
  inline void clear_has_created();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_container_config();
  inline void clear_has_container_config();
  inline void set_has_docker_version();
  inline void clear_has_docker_version();
  inline void set_has_author();
  inline void clear_has_author();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_architecture();
  inline void clear_has_architecture();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* parent_;
  ::std::string* comment_;
  ::std::string* created_;
  ::std::string* container_;
  ::docker::spec::v1::ImageManifest_Config* container_config_;
  ::std::string* docker_version_;
  ::std::string* author_;
  ::docker::spec::v1::ImageManifest_Config* config_;
  ::std::string* architecture_;
  ::std::string* os_;
  ::google::protobuf::uint32 size_;
  friend void  protobuf_AddDesc_v1_2eproto();
  friend void protobuf_AssignDesc_v1_2eproto();
  friend void protobuf_ShutdownFile_v1_2eproto();

  void InitAsDefaultInstance();
  static ImageManifest* default_instance_;
};
// ===================================================================


// ===================================================================

// Label

// optional string key = 1;
inline bool Label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Label::key() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.Label.key)
  return *key_;
}
inline void Label::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.Label.key)
}
inline void Label::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.Label.key)
}
inline void Label::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.Label.key)
}
inline ::std::string* Label::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.Label.key)
  return key_;
}
inline ::std::string* Label::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Label::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.Label.key)
}

// optional string value = 2;
inline bool Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Label::value() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.Label.value)
  return *value_;
}
inline void Label::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.Label.value)
}
inline void Label::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.Label.value)
}
inline void Label::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.Label.value)
}
inline ::std::string* Label::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.Label.value)
  return value_;
}
inline ::std::string* Label::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Label::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.Label.value)
}

// -------------------------------------------------------------------

// ImageManifest_Config

// optional string Hostname = 1;
inline bool ImageManifest_Config::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest_Config::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest_Config::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest_Config::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ImageManifest_Config::hostname() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Hostname)
  return *hostname_;
}
inline void ImageManifest_Config::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Hostname)
}
inline void ImageManifest_Config::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Hostname)
}
inline void ImageManifest_Config::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Hostname)
}
inline ::std::string* ImageManifest_Config::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Hostname)
  return hostname_;
}
inline ::std::string* ImageManifest_Config::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Config::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.Hostname)
}

// repeated string Entrypoint = 2;
inline int ImageManifest_Config::entrypoint_size() const {
  return entrypoint_.size();
}
inline void ImageManifest_Config::clear_entrypoint() {
  entrypoint_.Clear();
}
inline const ::std::string& ImageManifest_Config::entrypoint(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_.Get(index);
}
inline ::std::string* ImageManifest_Config::mutable_entrypoint(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_.Mutable(index);
}
inline void ImageManifest_Config::set_entrypoint(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Entrypoint)
  entrypoint_.Mutable(index)->assign(value);
}
inline void ImageManifest_Config::set_entrypoint(int index, const char* value) {
  entrypoint_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline void ImageManifest_Config::set_entrypoint(int index, const char* value, size_t size) {
  entrypoint_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline ::std::string* ImageManifest_Config::add_entrypoint() {
  return entrypoint_.Add();
}
inline void ImageManifest_Config::add_entrypoint(const ::std::string& value) {
  entrypoint_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline void ImageManifest_Config::add_entrypoint(const char* value) {
  entrypoint_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline void ImageManifest_Config::add_entrypoint(const char* value, size_t size) {
  entrypoint_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:docker.spec.v1.ImageManifest.Config.Entrypoint)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_Config::entrypoint() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return entrypoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_Config::mutable_entrypoint() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.Entrypoint)
  return &entrypoint_;
}

// repeated string Env = 3;
inline int ImageManifest_Config::env_size() const {
  return env_.size();
}
inline void ImageManifest_Config::clear_env() {
  env_.Clear();
}
inline const ::std::string& ImageManifest_Config::env(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Env)
  return env_.Get(index);
}
inline ::std::string* ImageManifest_Config::mutable_env(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Env)
  return env_.Mutable(index);
}
inline void ImageManifest_Config::set_env(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Env)
  env_.Mutable(index)->assign(value);
}
inline void ImageManifest_Config::set_env(int index, const char* value) {
  env_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Env)
}
inline void ImageManifest_Config::set_env(int index, const char* value, size_t size) {
  env_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Env)
}
inline ::std::string* ImageManifest_Config::add_env() {
  return env_.Add();
}
inline void ImageManifest_Config::add_env(const ::std::string& value) {
  env_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Env)
}
inline void ImageManifest_Config::add_env(const char* value) {
  env_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:docker.spec.v1.ImageManifest.Config.Env)
}
inline void ImageManifest_Config::add_env(const char* value, size_t size) {
  env_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:docker.spec.v1.ImageManifest.Config.Env)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_Config::env() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.Env)
  return env_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_Config::mutable_env() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.Env)
  return &env_;
}

// optional string User = 4;
inline bool ImageManifest_Config::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest_Config::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest_Config::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest_Config::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& ImageManifest_Config::user() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.User)
  return *user_;
}
inline void ImageManifest_Config::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.User)
}
inline void ImageManifest_Config::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.User)
}
inline void ImageManifest_Config::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.User)
}
inline ::std::string* ImageManifest_Config::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.User)
  return user_;
}
inline ::std::string* ImageManifest_Config::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Config::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.User)
}

// repeated string Cmd = 5;
inline int ImageManifest_Config::cmd_size() const {
  return cmd_.size();
}
inline void ImageManifest_Config::clear_cmd() {
  cmd_.Clear();
}
inline const ::std::string& ImageManifest_Config::cmd(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_.Get(index);
}
inline ::std::string* ImageManifest_Config::mutable_cmd(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_.Mutable(index);
}
inline void ImageManifest_Config::set_cmd(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Cmd)
  cmd_.Mutable(index)->assign(value);
}
inline void ImageManifest_Config::set_cmd(int index, const char* value) {
  cmd_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline void ImageManifest_Config::set_cmd(int index, const char* value, size_t size) {
  cmd_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline ::std::string* ImageManifest_Config::add_cmd() {
  return cmd_.Add();
}
inline void ImageManifest_Config::add_cmd(const ::std::string& value) {
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline void ImageManifest_Config::add_cmd(const char* value) {
  cmd_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline void ImageManifest_Config::add_cmd(const char* value, size_t size) {
  cmd_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:docker.spec.v1.ImageManifest.Config.Cmd)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageManifest_Config::cmd() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.Cmd)
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageManifest_Config::mutable_cmd() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.Cmd)
  return &cmd_;
}

// optional string WorkingDir = 6;
inline bool ImageManifest_Config::has_workingdir() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageManifest_Config::set_has_workingdir() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageManifest_Config::clear_has_workingdir() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageManifest_Config::clear_workingdir() {
  if (workingdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdir_->clear();
  }
  clear_has_workingdir();
}
inline const ::std::string& ImageManifest_Config::workingdir() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.WorkingDir)
  return *workingdir_;
}
inline void ImageManifest_Config::set_workingdir(const ::std::string& value) {
  set_has_workingdir();
  if (workingdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdir_ = new ::std::string;
  }
  workingdir_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
inline void ImageManifest_Config::set_workingdir(const char* value) {
  set_has_workingdir();
  if (workingdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdir_ = new ::std::string;
  }
  workingdir_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
inline void ImageManifest_Config::set_workingdir(const char* value, size_t size) {
  set_has_workingdir();
  if (workingdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdir_ = new ::std::string;
  }
  workingdir_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.WorkingDir)
}
inline ::std::string* ImageManifest_Config::mutable_workingdir() {
  set_has_workingdir();
  if (workingdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workingdir_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.WorkingDir)
  return workingdir_;
}
inline ::std::string* ImageManifest_Config::release_workingdir() {
  clear_has_workingdir();
  if (workingdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workingdir_;
    workingdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Config::set_allocated_workingdir(::std::string* workingdir) {
  if (workingdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workingdir_;
  }
  if (workingdir) {
    set_has_workingdir();
    workingdir_ = workingdir;
  } else {
    clear_has_workingdir();
    workingdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.WorkingDir)
}

// optional string Image = 8;
inline bool ImageManifest_Config::has_image() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageManifest_Config::set_has_image() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageManifest_Config::clear_has_image() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageManifest_Config::clear_image() {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& ImageManifest_Config::image() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.Image)
  return *image_;
}
inline void ImageManifest_Config::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Config.Image)
}
inline void ImageManifest_Config::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.Config.Image)
}
inline void ImageManifest_Config::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.Config.Image)
}
inline ::std::string* ImageManifest_Config::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.Image)
  return image_;
}
inline ::std::string* ImageManifest_Config::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest_Config::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.Config.Image)
}

// repeated .docker.spec.v1.Label labels = 9;
inline int ImageManifest_Config::labels_size() const {
  return labels_.size();
}
inline void ImageManifest_Config::clear_labels() {
  labels_.Clear();
}
inline const ::docker::spec::v1::Label& ImageManifest_Config::labels(int index) const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Config.labels)
  return labels_.Get(index);
}
inline ::docker::spec::v1::Label* ImageManifest_Config::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.Config.labels)
  return labels_.Mutable(index);
}
inline ::docker::spec::v1::Label* ImageManifest_Config::add_labels() {
  // @@protoc_insertion_point(field_add:docker.spec.v1.ImageManifest.Config.labels)
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::docker::spec::v1::Label >&
ImageManifest_Config::labels() const {
  // @@protoc_insertion_point(field_list:docker.spec.v1.ImageManifest.Config.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::docker::spec::v1::Label >*
ImageManifest_Config::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:docker.spec.v1.ImageManifest.Config.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// ImageManifest

// optional string id = 1;
inline bool ImageManifest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageManifest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageManifest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageManifest::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ImageManifest::id() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.id)
  return *id_;
}
inline void ImageManifest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.id)
}
inline void ImageManifest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.id)
}
inline void ImageManifest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.id)
}
inline ::std::string* ImageManifest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.id)
  return id_;
}
inline ::std::string* ImageManifest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.id)
}

// optional string parent = 2;
inline bool ImageManifest::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageManifest::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageManifest::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageManifest::clear_parent() {
  if (parent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_->clear();
  }
  clear_has_parent();
}
inline const ::std::string& ImageManifest::parent() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.parent)
  return *parent_;
}
inline void ImageManifest::set_parent(const ::std::string& value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.parent)
}
inline void ImageManifest::set_parent(const char* value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.parent)
}
inline void ImageManifest::set_parent(const char* value, size_t size) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  parent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.parent)
}
inline ::std::string* ImageManifest::mutable_parent() {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.parent)
  return parent_;
}
inline ::std::string* ImageManifest::release_parent() {
  clear_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parent_;
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_parent(::std::string* parent) {
  if (parent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parent_;
  }
  if (parent) {
    set_has_parent();
    parent_ = parent;
  } else {
    clear_has_parent();
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.parent)
}

// optional string comment = 3;
inline bool ImageManifest::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageManifest::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageManifest::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageManifest::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ImageManifest::comment() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.comment)
  return *comment_;
}
inline void ImageManifest::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.comment)
}
inline void ImageManifest::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.comment)
}
inline void ImageManifest::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.comment)
}
inline ::std::string* ImageManifest::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.comment)
  return comment_;
}
inline ::std::string* ImageManifest::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.comment)
}

// optional string created = 4;
inline bool ImageManifest::has_created() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageManifest::set_has_created() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageManifest::clear_has_created() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageManifest::clear_created() {
  if (created_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_->clear();
  }
  clear_has_created();
}
inline const ::std::string& ImageManifest::created() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.created)
  return *created_;
}
inline void ImageManifest::set_created(const ::std::string& value) {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  created_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.created)
}
inline void ImageManifest::set_created(const char* value) {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  created_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.created)
}
inline void ImageManifest::set_created(const char* value, size_t size) {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  created_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.created)
}
inline ::std::string* ImageManifest::mutable_created() {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.created)
  return created_;
}
inline ::std::string* ImageManifest::release_created() {
  clear_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = created_;
    created_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_created(::std::string* created) {
  if (created_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete created_;
  }
  if (created) {
    set_has_created();
    created_ = created;
  } else {
    clear_has_created();
    created_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.created)
}

// optional string container = 5;
inline bool ImageManifest::has_container() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageManifest::set_has_container() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageManifest::clear_has_container() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageManifest::clear_container() {
  if (container_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_->clear();
  }
  clear_has_container();
}
inline const ::std::string& ImageManifest::container() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.container)
  return *container_;
}
inline void ImageManifest::set_container(const ::std::string& value) {
  set_has_container();
  if (container_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_ = new ::std::string;
  }
  container_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.container)
}
inline void ImageManifest::set_container(const char* value) {
  set_has_container();
  if (container_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_ = new ::std::string;
  }
  container_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.container)
}
inline void ImageManifest::set_container(const char* value, size_t size) {
  set_has_container();
  if (container_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_ = new ::std::string;
  }
  container_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.container)
}
inline ::std::string* ImageManifest::mutable_container() {
  set_has_container();
  if (container_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    container_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.container)
  return container_;
}
inline ::std::string* ImageManifest::release_container() {
  clear_has_container();
  if (container_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = container_;
    container_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_container(::std::string* container) {
  if (container_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete container_;
  }
  if (container) {
    set_has_container();
    container_ = container;
  } else {
    clear_has_container();
    container_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.container)
}

// optional .docker.spec.v1.ImageManifest.Config container_config = 6;
inline bool ImageManifest::has_container_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageManifest::set_has_container_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageManifest::clear_has_container_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageManifest::clear_container_config() {
  if (container_config_ != NULL) container_config_->::docker::spec::v1::ImageManifest_Config::Clear();
  clear_has_container_config();
}
inline const ::docker::spec::v1::ImageManifest_Config& ImageManifest::container_config() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.container_config)
  return container_config_ != NULL ? *container_config_ : *default_instance_->container_config_;
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::mutable_container_config() {
  set_has_container_config();
  if (container_config_ == NULL) container_config_ = new ::docker::spec::v1::ImageManifest_Config;
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.container_config)
  return container_config_;
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::release_container_config() {
  clear_has_container_config();
  ::docker::spec::v1::ImageManifest_Config* temp = container_config_;
  container_config_ = NULL;
  return temp;
}
inline void ImageManifest::set_allocated_container_config(::docker::spec::v1::ImageManifest_Config* container_config) {
  delete container_config_;
  container_config_ = container_config;
  if (container_config) {
    set_has_container_config();
  } else {
    clear_has_container_config();
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.container_config)
}

// optional string docker_version = 7;
inline bool ImageManifest::has_docker_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageManifest::set_has_docker_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageManifest::clear_has_docker_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageManifest::clear_docker_version() {
  if (docker_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docker_version_->clear();
  }
  clear_has_docker_version();
}
inline const ::std::string& ImageManifest::docker_version() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.docker_version)
  return *docker_version_;
}
inline void ImageManifest::set_docker_version(const ::std::string& value) {
  set_has_docker_version();
  if (docker_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docker_version_ = new ::std::string;
  }
  docker_version_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.docker_version)
}
inline void ImageManifest::set_docker_version(const char* value) {
  set_has_docker_version();
  if (docker_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docker_version_ = new ::std::string;
  }
  docker_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.docker_version)
}
inline void ImageManifest::set_docker_version(const char* value, size_t size) {
  set_has_docker_version();
  if (docker_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docker_version_ = new ::std::string;
  }
  docker_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.docker_version)
}
inline ::std::string* ImageManifest::mutable_docker_version() {
  set_has_docker_version();
  if (docker_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docker_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.docker_version)
  return docker_version_;
}
inline ::std::string* ImageManifest::release_docker_version() {
  clear_has_docker_version();
  if (docker_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = docker_version_;
    docker_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_docker_version(::std::string* docker_version) {
  if (docker_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete docker_version_;
  }
  if (docker_version) {
    set_has_docker_version();
    docker_version_ = docker_version;
  } else {
    clear_has_docker_version();
    docker_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.docker_version)
}

// optional string author = 8;
inline bool ImageManifest::has_author() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageManifest::set_has_author() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageManifest::clear_has_author() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageManifest::clear_author() {
  if (author_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_->clear();
  }
  clear_has_author();
}
inline const ::std::string& ImageManifest::author() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.author)
  return *author_;
}
inline void ImageManifest::set_author(const ::std::string& value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.author)
}
inline void ImageManifest::set_author(const char* value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.author)
}
inline void ImageManifest::set_author(const char* value, size_t size) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.author)
}
inline ::std::string* ImageManifest::mutable_author() {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.author)
  return author_;
}
inline ::std::string* ImageManifest::release_author() {
  clear_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = author_;
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_author(::std::string* author) {
  if (author_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete author_;
  }
  if (author) {
    set_has_author();
    author_ = author;
  } else {
    clear_has_author();
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.author)
}

// optional .docker.spec.v1.ImageManifest.Config config = 9;
inline bool ImageManifest::has_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageManifest::set_has_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageManifest::clear_has_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageManifest::clear_config() {
  if (config_ != NULL) config_->::docker::spec::v1::ImageManifest_Config::Clear();
  clear_has_config();
}
inline const ::docker::spec::v1::ImageManifest_Config& ImageManifest::config() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::docker::spec::v1::ImageManifest_Config;
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.config)
  return config_;
}
inline ::docker::spec::v1::ImageManifest_Config* ImageManifest::release_config() {
  clear_has_config();
  ::docker::spec::v1::ImageManifest_Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void ImageManifest::set_allocated_config(::docker::spec::v1::ImageManifest_Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.config)
}

// optional string architecture = 10;
inline bool ImageManifest::has_architecture() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageManifest::set_has_architecture() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageManifest::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageManifest::clear_architecture() {
  if (architecture_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    architecture_->clear();
  }
  clear_has_architecture();
}
inline const ::std::string& ImageManifest::architecture() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.architecture)
  return *architecture_;
}
inline void ImageManifest::set_architecture(const ::std::string& value) {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    architecture_ = new ::std::string;
  }
  architecture_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.architecture)
}
inline void ImageManifest::set_architecture(const char* value) {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    architecture_ = new ::std::string;
  }
  architecture_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.architecture)
}
inline void ImageManifest::set_architecture(const char* value, size_t size) {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    architecture_ = new ::std::string;
  }
  architecture_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.architecture)
}
inline ::std::string* ImageManifest::mutable_architecture() {
  set_has_architecture();
  if (architecture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    architecture_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.architecture)
  return architecture_;
}
inline ::std::string* ImageManifest::release_architecture() {
  clear_has_architecture();
  if (architecture_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = architecture_;
    architecture_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_architecture(::std::string* architecture) {
  if (architecture_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete architecture_;
  }
  if (architecture) {
    set_has_architecture();
    architecture_ = architecture;
  } else {
    clear_has_architecture();
    architecture_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.architecture)
}

// optional string os = 11;
inline bool ImageManifest::has_os() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageManifest::set_has_os() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageManifest::clear_has_os() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageManifest::clear_os() {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& ImageManifest::os() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.os)
  return *os_;
}
inline void ImageManifest::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.os)
}
inline void ImageManifest::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set_char:docker.spec.v1.ImageManifest.os)
}
inline void ImageManifest::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:docker.spec.v1.ImageManifest.os)
}
inline ::std::string* ImageManifest::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:docker.spec.v1.ImageManifest.os)
  return os_;
}
inline ::std::string* ImageManifest::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageManifest::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:docker.spec.v1.ImageManifest.os)
}

// optional uint32 Size = 12;
inline bool ImageManifest::has_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageManifest::set_has_size() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageManifest::clear_has_size() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageManifest::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 ImageManifest::size() const {
  // @@protoc_insertion_point(field_get:docker.spec.v1.ImageManifest.Size)
  return size_;
}
inline void ImageManifest::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:docker.spec.v1.ImageManifest.Size)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace spec
}  // namespace docker

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_v1_2eproto__INCLUDED
